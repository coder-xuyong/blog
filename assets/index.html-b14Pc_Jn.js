import{_ as t,c as n,b as a,o as r}from"./app-jHLa_8Nm.js";const i={};function o(l,e){return r(),n("div",null,e[0]||(e[0]=[a('<h1 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h1><h2 id="什么是堆" tabindex="-1"><a class="header-anchor" href="#什么是堆"><span>什么是堆？</span></a></h2><p>堆（Heap）是一个可以被看成近似完全二叉树的数组。</p><ul><li><strong>堆是一个完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</strong>。</li></ul><p>堆可以分为大顶堆和小顶堆。</p><ul><li><p>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“<strong>大顶堆</strong>”。</p></li><li><p>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“<strong>小顶堆</strong>”。</p></li></ul><h2 id="如何实现堆" tabindex="-1"><a class="header-anchor" href="#如何实现堆"><span>如何实现堆</span></a></h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220311112542.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>堆常见的操作：</p><ul><li>HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $$O(n)$$。</li><li>HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $$O(log N)$$</li><li>HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $$O(log N)$$。</li><li>HEAPSORT：借由 HEAPFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为$$ O(N log N)$$，空间复杂度为 $$O(1)$$。</li></ul><h2 id="堆的应用场景" tabindex="-1"><a class="header-anchor" href="#堆的应用场景"><span>堆的应用场景</span></a></h2><h3 id="求-top-n" tabindex="-1"><a class="header-anchor" href="#求-top-n"><span>求 TOP N</span></a></h3><p>堆结构的一个常见应用是建立优先队列（Priority Queue）。</p><p>求 Top K 的问题抽象成两类。一类是针对静态数据集合；另一类是针对动态数据集合</p><h3 id="优先级队列" tabindex="-1"><a class="header-anchor" href="#优先级队列"><span>优先级队列</span></a></h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>堆和优先级队列非常相似：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><blockquote><p>参考：Java 的 <code>PriorityQueue</code> 类</p></blockquote><h3 id="求中位数" tabindex="-1"><a class="header-anchor" href="#求中位数"><span>求中位数</span></a></h3>',20)]))}const s=t(i,[["render",o],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/pages/99ac45/","title":"堆","lang":"zh-CN","frontmatter":{"title":"堆","date":"2015-03-09T16:01:27.000Z","order":2,"categories":["数据结构和算法","树"],"tags":["数据结构","树","二叉树","堆"],"permalink":"/pages/99ac45/","description":"堆 什么是堆？ 堆（Heap）是一个可以被看成近似完全二叉树的数组。 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 堆可以分为大顶堆和小顶堆。 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。 对于每个节点的值...","head":[["meta",{"property":"og:url","content":"https://coder-xuyong.github.io/blog/pages/99ac45/"}],["meta",{"property":"og:site_name","content":"coder-xuyong"}],["meta",{"property":"og:title","content":"堆"}],["meta",{"property":"og:description","content":"堆 什么是堆？ 堆（Heap）是一个可以被看成近似完全二叉树的数组。 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 堆可以分为大顶堆和小顶堆。 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。 对于每个节点的值..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/snap/20220311112542.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-10T02:14:26.000Z"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"树"}],["meta",{"property":"article:tag","content":"二叉树"}],["meta",{"property":"article:tag","content":"堆"}],["meta",{"property":"article:published_time","content":"2015-03-09T16:01:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-10T02:14:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220311112542.jpg\\"],\\"datePublished\\":\\"2015-03-09T16:01:27.000Z\\",\\"dateModified\\":\\"2025-06-10T02:14:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuyong\\",\\"url\\":\\"https://github.com/coder-xuyong\\"}]}"]]},"headers":[{"level":2,"title":"什么是堆？","slug":"什么是堆","link":"#什么是堆","children":[]},{"level":2,"title":"如何实现堆","slug":"如何实现堆","link":"#如何实现堆","children":[]},{"level":2,"title":"堆的应用场景","slug":"堆的应用场景","link":"#堆的应用场景","children":[{"level":3,"title":"求 TOP N","slug":"求-top-n","link":"#求-top-n","children":[]},{"level":3,"title":"优先级队列","slug":"优先级队列","link":"#优先级队列","children":[]},{"level":3,"title":"求中位数","slug":"求中位数","link":"#求中位数","children":[]}]}],"git":{"createdTime":1749521666000,"updatedTime":1749521666000,"contributors":[{"name":"XuYong","username":"XuYong","email":"1299461580@qq.com","commits":1,"url":"https://github.com/XuYong"}]},"readingTime":{"minutes":2.04,"words":613},"filePathRelative":"posts/11.数据结构和算法/02.树/02.堆.md","localizedDate":"2015年3月9日","excerpt":"\\n<h2>什么是堆？</h2>\\n<p>堆（Heap）是一个可以被看成近似完全二叉树的数组。</p>\\n<ul>\\n<li><strong>堆是一个完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>\\n<li><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</strong>。</li>\\n</ul>\\n<p>堆可以分为大顶堆和小顶堆。</p>\\n<ul>\\n<li>\\n<p>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“<strong>大顶堆</strong>”。</p>\\n</li>\\n<li>\\n<p>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“<strong>小顶堆</strong>”。</p>\\n</li>\\n</ul>","autoDesc":true}');export{s as comp,c as data};
