import{_ as t,c as r,b as a,o as n}from"./app-D4aAnUWn.js";const i={};function o(s,e){return n(),r("div",null,e[0]||(e[0]=[a('<h1 id="读写分离基本原理" tabindex="-1"><a class="header-anchor" href="#读写分离基本原理"><span>读写分离基本原理</span></a></h1><p><strong>读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作</strong>。</p><h2 id="_1-为何要读写分离" tabindex="-1"><a class="header-anchor" href="#_1-为何要读写分离"><span>1. 为何要读写分离</span></a></h2><ul><li><strong>有效减少锁竞争</strong> - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。</li><li><strong>提高查询吞吐量</strong> - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</li><li><strong>提升数据库可用性</strong> - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</li></ul><h2 id="_2-读写分离的原理" tabindex="-1"><a class="header-anchor" href="#_2-读写分离的原理"><span>2. 读写分离的原理</span></a></h2><p>读写分离的实现是根据 SQL 语义分析，将读操作和写操作分别路由至主库与从库。</p><figure><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png" alt="读写分离" tabindex="0" loading="lazy"><figcaption>读写分离</figcaption></figure><p>读写分离的基本实现是：</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave-proxy.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li><li>数据库主机负责读写操作，从机只负责读操作。</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了全量数据。</li><li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li><li>主机会记录请求的二进制日志，然后推送给从库，从库解析并执行日志中的请求，完成主从复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。</li></ul><h2 id="_3-读写分离的问题" tabindex="-1"><a class="header-anchor" href="#_3-读写分离的问题"><span>3. 读写分离的问题</span></a></h2><p>读写分离存在两个问题：<strong>数据一致性</strong>和<strong>分发机制</strong>。</p><h3 id="_3-1-数据一致性" tabindex="-1"><a class="header-anchor" href="#_3-1-数据一致性"><span>3.1. 数据一致性</span></a></h3><p>读写分离产生了主库与从库之间的数据一致性的问题。</p><figure><img src="https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png" alt="数据分片 + 读写分离" tabindex="0" loading="lazy"><figcaption>数据分片 + 读写分离</figcaption></figure><h3 id="_3-2-分发机制" tabindex="-1"><a class="header-anchor" href="#_3-2-分发机制"><span>3.2. 分发机制</span></a></h3><p>数据库读写分离后，一个 SQL 请求具体分发到哪个数据库节点？一般有两种分发方式：客户端分发和中间件代理分发。</p><p>客户端分发，是基于程序代码，自行控制数据分发到哪个数据库节点。更细一点来说，一般程序中建立多个数据库的连接，根据一定的算法，选择合适的连接去发起 SQL 请求。这种方式也被称为客户端中间件，代表有：jdbc-sharding。</p><p>中间件代理分发，指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。代表有：Mycat。</p><h2 id="_4-参考资料" tabindex="-1"><a class="header-anchor" href="#_4-参考资料"><span>4. 参考资料</span></a></h2><ul><li><a href="https://time.geekbang.org/column/intro/100046801" target="_blank" rel="noopener noreferrer">后端存储实战课</a></li><li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener noreferrer">ShardingSphere 官方文档</a></li></ul>',21)]))}const p=t(i,[["render",o],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/pages/3faf18/","title":"读写分离基本原理","lang":"zh-CN","frontmatter":{"title":"读写分离基本原理","date":"2022-04-14T11:36:23.000Z","order":2,"categories":["分布式","分布式存储"],"tags":["分布式","数据调度","读写分离"],"permalink":"/pages/3faf18/","description":"读写分离基本原理 读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。 1. 为何要读写分离 有效减少锁竞争 - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。 提高查询吞吐量 - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数...","head":[["meta",{"property":"og:url","content":"https://coder-xuyong.github.io/blog/pages/3faf18/"}],["meta",{"property":"og:site_name","content":"coder-xuyong"}],["meta",{"property":"og:title","content":"读写分离基本原理"}],["meta",{"property":"og:description","content":"读写分离基本原理 读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。 1. 为何要读写分离 有效减少锁竞争 - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。 提高查询吞吐量 - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-10T02:14:26.000Z"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"数据调度"}],["meta",{"property":"article:tag","content":"读写分离"}],["meta",{"property":"article:published_time","content":"2022-04-14T11:36:23.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-10T02:14:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"读写分离基本原理\\",\\"image\\":[\\"https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave-proxy.png\\",\\"https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png\\"],\\"datePublished\\":\\"2022-04-14T11:36:23.000Z\\",\\"dateModified\\":\\"2025-06-10T02:14:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuyong\\",\\"url\\":\\"https://github.com/coder-xuyong\\"}]}"]]},"headers":[{"level":2,"title":"1. 为何要读写分离","slug":"_1-为何要读写分离","link":"#_1-为何要读写分离","children":[]},{"level":2,"title":"2. 读写分离的原理","slug":"_2-读写分离的原理","link":"#_2-读写分离的原理","children":[]},{"level":2,"title":"3. 读写分离的问题","slug":"_3-读写分离的问题","link":"#_3-读写分离的问题","children":[{"level":3,"title":"3.1. 数据一致性","slug":"_3-1-数据一致性","link":"#_3-1-数据一致性","children":[]},{"level":3,"title":"3.2. 分发机制","slug":"_3-2-分发机制","link":"#_3-2-分发机制","children":[]}]},{"level":2,"title":"4. 参考资料","slug":"_4-参考资料","link":"#_4-参考资料","children":[]}],"git":{"createdTime":1749521666000,"updatedTime":1749521666000,"contributors":[{"name":"XuYong","username":"XuYong","email":"1299461580@qq.com","commits":1,"url":"https://github.com/XuYong"}]},"readingTime":{"minutes":2.94,"words":883},"filePathRelative":"posts/15.分布式/22.分布式存储/02.读写分离.md","localizedDate":"2022年4月14日","excerpt":"\\n<p><strong>读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作</strong>。</p>\\n<h2>1. 为何要读写分离</h2>\\n<ul>\\n<li><strong>有效减少锁竞争</strong> - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。</li>\\n<li><strong>提高查询吞吐量</strong> - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</li>\\n<li><strong>提升数据库可用性</strong> - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</li>\\n</ul>","autoDesc":true}');export{p as comp,g as data};
