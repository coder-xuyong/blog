"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3629],{6262:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,t]of a)n[e]=t;return n}},3666:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>r,data:()=>c});var t=n(641);const s={},r=(0,n(6262).A)(s,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,[a[0]||(a[0]=(0,t.Lk)("p",null,"java 基本类型、String、关键字等内容介绍",-1)),(0,t.Q3)(" more "),a[1]||(a[1]=(0,t.Fv)('<h2 id="_1-java基本数据类型" tabindex="-1"><a class="header-anchor" href="#_1-java基本数据类型"><span>1. Java基本数据类型</span></a></h2><h3 id="_1-1-数据类型分类" tabindex="-1"><a class="header-anchor" href="#_1-1-数据类型分类"><span>1.1 数据类型分类</span></a></h3><p>Java基本数据类型分为四类：整数类型、浮点类型、字符类型和布尔类型。</p><h4 id="_1-1-1-整数类型" tabindex="-1"><a class="header-anchor" href="#_1-1-1-整数类型"><span>1.1.1 整数类型</span></a></h4><ul><li><strong>byte</strong>：占用 1 个字节（8 位），取值范围是 -128 到 127，常用于处理底层字节流数据、节省内存空间的场景，例如在一些小型嵌入式设备程序中对传感器数据的初步存储。</li><li><strong>short</strong>：占 2 个字节（16 位），范围为 -32768 到 32767，在特定的对内存要求稍高但数值范围有限的运算场景使用，如早期一些简单游戏的计分系统。</li><li><strong>int</strong>：整型是最常用的，占 4 个字节（32 位），取值范围 -2147483648 到 2147483647，广泛应用于日常编程中的整数运算，像循环计数器、数组下标等。</li><li><strong>long</strong>：长整型，占 8 个字节（64 位），范围为 -9223372036854775808 到 9223372036854775807，当需要处理较大整数，比如系统时间戳（以毫秒为单位）、大数据量统计中的计数时会用到，定义长整型字面量时要在数字后加 <code>L</code> 或 <code>l</code>，建议用 <code>L</code> 以避免混淆。</li></ul><h4 id="_1-1-2-浮点类型" tabindex="-1"><a class="header-anchor" href="#_1-1-2-浮点类型"><span>1.1.2 浮点类型</span></a></h4><ul><li>重要提醒：浮点数由于二进制存储机制，存在精度问题，绝对不能直接用于精确的金额计算，金融领域通常采用 <code>BigDecimal</code> 类来确保金额的精准。</li><li><strong>float</strong>：单精度浮点型，占 4 个字节（32 位），能表示大约 7 位有效数字，常用于科学计算中对精度要求不特别高的近似值场景，定义字面量时需在数字后加 <code>F</code> 或 <code>f</code>，因为 Java 默认小数是 <code>double</code> 型。</li><li><strong>double</strong>：双精度浮点型，占 8 个字节（64 位），约有 15 位有效数字，在高精度科学实验数据存储、图形图像渲染等对精度要求较高的场景常用，是 Java 默认的浮点数据类型。</li></ul><h4 id="_1-1-3-字符类型" tabindex="-1"><a class="header-anchor" href="#_1-1-3-字符类型"><span>1.1.3 字符类型</span></a></h4><ul><li><strong>char</strong>：字符型，占 2 个字节（16 位），用于存储单个字符，字符在 Java 中用单引号括起来，如 <code>&#39;A&#39;</code>、<code>&#39;9&#39;</code>、<code>&#39;$&#39;</code> 等，本质上存储的是字符对应的 Unicode 编码值，这使得 Java 能够处理世界上大部分的字符。</li></ul><h4 id="_1-1-4-布尔类型" tabindex="-1"><a class="header-anchor" href="#_1-1-4-布尔类型"><span>1.1.4 布尔类型</span></a></h4><ul><li><strong>boolean</strong>：布尔型，占 1 位（实际编译后占用空间因虚拟机实现而异，一般至少 1 字节），只有两个取值 <code>true</code> 和 <code>false</code>，主要用于条件判断、逻辑控制，是 <code>if</code> 语句、<code>while</code> 循环等条件表达式的基础。</li></ul><h3 id="_1-2-自动拆装箱机制" tabindex="-1"><a class="header-anchor" href="#_1-2-自动拆装箱机制"><span>1.2 自动拆装箱机制</span></a></h3><h4 id="_1-2-1-装箱-boxing" tabindex="-1"><a class="header-anchor" href="#_1-2-1-装箱-boxing"><span>1.2.1 装箱（Boxing）</span></a></h4><p>自动将基本数据类型转换为对应的包装类对象。例如，<code>Integer numObj = 10;</code>，这里编译器自动把 <code>int</code> 值 10 包装成 <code>Integer</code> 对象，以便在需要对象的场景（如集合存储）使用。但需要注意，装箱过程会创建新的对象，如果频繁进行装箱操作，会带来一定的性能开销。</p><h4 id="_1-2-2-拆箱-unboxing" tabindex="-1"><a class="header-anchor" href="#_1-2-2-拆箱-unboxing"><span>1.2.2 拆箱（Unboxing）</span></a></h4><p>与装箱相反，是自动把包装类对象还原为基本数据类型。比如，<code>Integer numObj = new Integer(20); int num = numObj;</code>，在赋值时编译器将 <code>Integer</code> 对象拆解获取 <code>int</code> 值，用于数值运算等操作。同样，过度拆箱也可能影响性能，尤其是在循环等频繁操作场景。</p><h2 id="_2-string类型" tabindex="-1"><a class="header-anchor" href="#_2-string类型"><span>2. String类型</span></a></h2><h3 id="_2-1-常用方法" tabindex="-1"><a class="header-anchor" href="#_2-1-常用方法"><span>2.1 常用方法</span></a></h3><h4 id="_2-1-1-连接操作" tabindex="-1"><a class="header-anchor" href="#_2-1-1-连接操作"><span>2.1.1 连接操作</span></a></h4><p>可以使用 <code>+</code> 运算符实现字符串连接。例如，<code>String firstName = &quot;John&quot;; String lastName = &quot;Doe&quot;; String fullName = firstName + &quot; &quot; + lastName;</code>，不过在编译器内部，对于较长的连接链，会优化为使用 <code>StringBuilder</code> 来避免频繁创建新的 <code>String</code> 对象，以提高性能。</p><h4 id="_2-1-2-获取长度" tabindex="-1"><a class="header-anchor" href="#_2-1-2-获取长度"><span>2.1.2 获取长度</span></a></h4><p>调用 <code>length()</code> 方法来获取字符串的长度，这与数组的 <code>length</code> 属性有所不同。例如，<code>String message = &quot;Hello&quot;; int len = message.length();</code>，通过该方法可以得到字符串中字符的个数。</p><h4 id="_2-1-3-字符索引访问" tabindex="-1"><a class="header-anchor" href="#_2-1-3-字符索引访问"><span>2.1.3 字符索引访问</span></a></h4><p>使用 <code>charAt(int index)</code> 方法按索引获取字符，索引从 0 开始。如 <code>String word = &quot;Java&quot;; char c = word.charAt(1);</code>，这里可以取到字符 <code>a</code>，需要注意的是，如果索引越界，会抛出 <code>IndexOutOfBoundsException</code>。</p><h4 id="_2-1-4-子串截取" tabindex="-1"><a class="header-anchor" href="#_2-1-4-子串截取"><span>2.1.4 子串截取</span></a></h4><p>依靠 <code>substring(int start, int end)</code> 方法，其中 <code>start</code> 索引对应的字符包含在内，<code>end</code> 索引对应的字符不包含在内。例如，<code>String text = &quot;Hello Java&quot;; String sub = text.substring(0, 5);</code>，可以得到子串 “Hello”。</p><h3 id="_2-2-技巧" tabindex="-1"><a class="header-anchor" href="#_2-2-技巧"><span>2.2 技巧</span></a></h3><h4 id="_2-2-1-字符串比较" tabindex="-1"><a class="header-anchor" href="#_2-2-1-字符串比较"><span>2.2.1 字符串比较</span></a></h4><p>要避免使用 <code>==</code> 来判断字符串内容是否相等，而应该使用 <code>equals()</code> 方法。因为 <code>==</code> 比较的是引用地址，而 <code>equals</code> 方法在 <code>String</code> 类中被重写，能够比较字符序列是否一致。例如，<code>String s1 = &quot;hello&quot;; String s2 = new String(&quot;hello&quot;); s1.equals(s2)</code> 的结果为 <code>true</code>，但 <code>s1 == s2</code> 的结果为 <code>false</code>。</p><h4 id="_2-2-3-空字符串判断" tabindex="-1"><a class="header-anchor" href="#_2-2-3-空字符串判断"><span>2.2.3 空字符串判断</span></a></h4><p>可以结合使用 <code>isEmpty()</code> 和 <code>length() == 0</code> 方法来判断空字符串。<code>isEmpty()</code> 方法简洁直观，<code>length() == 0</code> 方法通用性强。例如，<code>String str = &quot;&quot;; str.isEmpty();</code> 和 <code>str.length() == 0</code> 都能确认字符串为空。</p><h3 id="_2-3-字符串池、class常量池、运行时常量池概念" tabindex="-1"><a class="header-anchor" href="#_2-3-字符串池、class常量池、运行时常量池概念"><span>2.3 字符串池、Class常量池、运行时常量池概念</span></a></h3><h4 id="_2-3-1-字符串池" tabindex="-1"><a class="header-anchor" href="#_2-3-1-字符串池"><span>2.3.1 字符串池</span></a></h4><p>字符串池是堆内存的一部分，它存放 Java 程序中直接使用双引号括起的字符串字面量。当创建相同字面量的字符串时，会直接从池中获取引用，这样可以节省内存。例如，<code>String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; s1 == s2</code> 的结果为 <code>true</code>，因为它们指向的是字符串池中的同一个对象。</p><h4 id="_2-3-2-class常量池" tabindex="-1"><a class="header-anchor" href="#_2-3-2-class常量池"><span>2.3.2 Class常量池</span></a></h4><p>位于方法区，是类文件结构的一部分，它存放编译期生成的各种常量，包括字符串常量、基本类型常量等，为类的加载和运行提供基础数据支持。</p><h4 id="_2-3-3-运行时常量池" tabindex="-1"><a class="header-anchor" href="#_2-3-3-运行时常量池"><span>2.3.3 运行时常量池</span></a></h4><p>是方法区的动态扩展，在类加载后，运行期间可以将新的常量放入其中。它包含从 Class常量池解析来的常量以及通过动态生成的，如 <code>String.intern()</code> 处理后的字符串，用于高效访问常量。</p><h3 id="_2-4-intern方法" tabindex="-1"><a class="header-anchor" href="#_2-4-intern方法"><span>2.4 intern方法</span></a></h3><p>调用 <code>intern()</code> 方法能够将字符串对象添加到字符串池（如果池中没有相同的字符串），并返回池内对应字符串的引用。例如，<code>String s1 = new String(&quot;hello&quot;).intern(); String s2 = &quot;hello&quot;; s1 == s2</code> 的结果为 <code>true</code>，这是通过 <code>intern()</code> 方法强制实现了字符串实例的共享。</p><h3 id="_2-5-string长度限制" tabindex="-1"><a class="header-anchor" href="#_2-5-string长度限制"><span>2.5 String长度限制</span></a></h3><p>在 Java 中，<code>String</code> 理论上长度受限于内存大小，但在实际操作中有一些约束。在编译期，常量字符串的长度受到编译器的限制（通常为几千字节）；在运行时，创建 <code>String</code> 对象受到堆内存分配以及虚拟机实现的限制，对于超长字符串的处理需要谨慎规划内存。</p><h2 id="_3-java关键字" tabindex="-1"><a class="header-anchor" href="#_3-java关键字"><span>3. Java关键字</span></a></h2><h3 id="_3-1-访问控制关键字" tabindex="-1"><a class="header-anchor" href="#_3-1-访问控制关键字"><span>3.1 访问控制关键字</span></a></h3><h4 id="_3-1-1-public" tabindex="-1"><a class="header-anchor" href="#_3-1-1-public"><span>3.1.1 public</span></a></h4><p>赋予最宽泛的访问权限，修饰的类、成员可以被任何其他类访问，无论是同包还是跨包，这有助于代码的复用和模块之间的协同工作，促进大型项目的开发。</p><h4 id="_3-1-2-private" tabindex="-1"><a class="header-anchor" href="#_3-1-2-private"><span>3.1.2 private</span></a></h4><p>实施最严格的保密措施，修饰的成员（变量、方法）只能在所属类的内部可见，外部类无法直接访问，这是实现类封装的关键，能够有效地保护类的内部实现细节，防止外部的非法篡改。</p><h4 id="_3-1-3-protected" tabindex="-1"><a class="header-anchor" href="#_3-1-3-protected"><span>3.1.3 protected</span></a></h4><p>介于 public 和 private 之间，修饰的成员在同包内的类以及子类中可以访问，这种访问权限搭建了继承的桥梁，既允许子类继承和拓展父类的功能，又适度地隔离了外界对父类的直接访问，维护了类层次结构的稳定性。</p><h4 id="_3-1-4-default-无显式关键字" tabindex="-1"><a class="header-anchor" href="#_3-1-4-default-无显式关键字"><span>3.1.4 default（无显式关键字）</span></a></h4><p>当类、成员没有显式地使用访问控制关键字时，默认采用包访问权限，即同包内的类可以相互访问，这种默认设置有助于维持包内的代码凝聚性，同时对外保持一定的封闭性。</p><h3 id="_3-2-类、接口、抽象相关关键字" tabindex="-1"><a class="header-anchor" href="#_3-2-类、接口、抽象相关关键字"><span>3.2 类、接口、抽象相关关键字</span></a></h3><h4 id="_3-1-1-class" tabindex="-1"><a class="header-anchor" href="#_3-1-1-class"><span>3.1.1 class</span></a></h4><p>是定义类的标志性关键字，通过它可以勾勒出对象的蓝图，在类中定义属性和方法，类是 Java 编程世界的基石，承载着程序的主要逻辑和数据结构。</p><h4 id="_3-1-2-interface" tabindex="-1"><a class="header-anchor" href="#_3-1-2-interface"><span>3.1.2 interface</span></a></h4><p>用于绘制规范的蓝图，它规定了一组方法签名以及常量，但不包含具体的实现细节。接口使得不同的类可以遵循相同的规范，实现多态性，在松耦合的模块关联中发挥着重要作用。</p><h4 id="_3-1-3-abstract" tabindex="-1"><a class="header-anchor" href="#_3-1-3-abstract"><span>3.1.3 abstract</span></a></h4><p>可以用来定义抽象类和抽象方法。抽象类为子类提供了一个框架，它可以包含抽象方法，这些抽象方法需要子类去具体实现，通过这种方式规划了继承体系的发展方向，引导子类按照预定的设计进行拓展。</p><h3 id="_3-3-修饰符关键字" tabindex="-1"><a class="header-anchor" href="#_3-3-修饰符关键字"><span>3.3 修饰符关键字</span></a></h3><h4 id="_3-3-1-final" tabindex="-1"><a class="header-anchor" href="#_3-3-1-final"><span>3.3.1 final</span></a></h4><p>具有“最终确定”的含义，当修饰类时，该类不可被继承；修饰方法时，方法不可被重写；修饰变量时，变量成为常量，其值不能再被改变。使用 final 关键字可以保障代码的稳定性，确保数据在特定阶段后保持恒定。</p><h4 id="_3-3-2-static" tabindex="-1"><a class="header-anchor" href="#_3-3-2-static"><span>3.3.2 static</span></a></h4><p>赋予成员静态的特性，当 static 修饰变量或方法时，它们归属于类本身，而不是类的某个实例，因此可以直接通过类名进行访问，无需创建实例对象。静态成员常用于工具类、共享资源等场景，需要注意的是，静态方法不能直接访问非静态成员，因为非静态成员依赖于具体的实例。</p><h4 id="_3-3-3-synchronized" tabindex="-1"><a class="header-anchor" href="#_3-3-3-synchronized"><span>3.3.3 synchronized</span></a></h4><p>在多线程编程中充当“保镖”的角色，当修饰方法或代码块时，它能够确保在同一时刻只有一个线程能够进入被修饰的区域，从而保护共享资源，防止多个线程并发访问时产生冲突，保证程序的正确性和稳定性。</p><h3 id="_3-4-流程控制关键字" tabindex="-1"><a class="header-anchor" href="#_3-4-流程控制关键字"><span>3.4 流程控制关键字</span></a></h3><h4 id="_3-4-1-if、else" tabindex="-1"><a class="header-anchor" href="#_3-4-1-if、else"><span>3.4.1 if、else</span></a></h4><p>是最基础的条件分支语句，if 语句用于根据给定的条件判断程序的走向，如果条件成立，则执行相应的代码块；else 语句则在 if 条件不成立时提供备用的执行路径，它们可以灵活组合，应对各种各样复杂的程序逻辑。</p><h4 id="_3-4-2-switch、case、default" tabindex="-1"><a class="header-anchor" href="#_3-4-2-switch、case、default"><span>3.4.2 switch、case、default</span></a></h4><p>是多分支的快捷方式，switch 语句根据一个表达式的值来选择执行多个分支中的一个，case 用来标记每个可能的分支情况，当表达式的值与某个 case 后的常量匹配时，就执行对应的代码块；如果没有匹配的 case，则执行 default 分支，这种结构在处理定值的多分支情况时非常高效。</p><h4 id="_3-4-3-while、do-while" tabindex="-1"><a class="header-anchor" href="#_3-4-3-while、do-while"><span>3.4.3 while、do - while</span></a></h4><p>都是循环语句，while 循环先判断条件是否成立，成立则执行循环体，然后再次判断条件，如此反复，直到条件不成立；do - while 循环则先执行一次循环体，然后再判断条件，若条件成立则继续循环，它们适用于不同的循环场景，根据具体需求选择使用。</p><h4 id="_3-4-4-for" tabindex="-1"><a class="header-anchor" href="#_3-4-4-for"><span>3.4.4 for</span></a></h4><p>是一种功能强大的万能循环语句，它将循环的初始化、条件判断、循环体执行以及迭代操作集成在一起，在遍历数组、集合等数据结构以及进行简单的计数循环时都非常方便，能够大大提高编程效率。</p><h3 id="_3-5-异常处理关键字" tabindex="-1"><a class="header-anchor" href="#_3-5-异常处理关键字"><span>3.5 异常处理关键字</span></a></h3><h4 id="_3-5-1-try、catch、finally" tabindex="-1"><a class="header-anchor" href="#_3-5-1-try、catch、finally"><span>3.5.1 try、catch、finally</span></a></h4><p>构成了异常处理的铁三角，try 语句块用于包围可能出现异常的代码；catch 语句块紧跟其后，用于捕获并处理特定类型的异常，多个 catch 块可以针对不同类型的异常进行分类处理；finally 语句块无论是否发生异常，都会被执行，它通常用于保证资源的释放和清理工作，确保程序的稳健性。</p><h4 id="_3-5-2-throw" tabindex="-1"><a class="header-anchor" href="#_3-5-2-throw"><span>3.5.2 throw</span></a></h4><p>用于手动抛出异常，当程序在运行过程中遇到某些不符合预期的情况时，可以使用 throw 语句抛出一个异常对象，将错误信息传递给调用者，促使调用者采取相应的措施来处理问题。</p><h4 id="_3-5-2-throws" tabindex="-1"><a class="header-anchor" href="#_3-5-2-throws"><span>3.5.2 throws</span></a></h4><p>是在方法声明中使用的关键字，用于声明该方法可能抛出的异常类型，这样做可以提醒调用者在调用该方法时需要注意防范相应的异常，实现异常处理的协同。</p><h3 id="_3-6-其他重要关键字" tabindex="-1"><a class="header-anchor" href="#_3-6-其他重要关键字"><span>3.6 其他重要关键字</span></a></h3><h4 id="_3-6-1-this" tabindex="-1"><a class="header-anchor" href="#_3-6-1-this"><span>3.6.1 this</span></a></h4><p>在类内部充当“自我指代”的角色，用于区分同名的成员变量和局部变量，还可以在构造函数中调用其他构造函数，实现构造函数的复用，它聚焦于当前对象的操作，使代码更加清晰。</p><h4 id="_3-6-2-super" tabindex="-1"><a class="header-anchor" href="#_3-6-2-super"><span>3.6.2 super</span></a></h4><p>在子类中用于“追溯祖先”，可以访问父类的成员变量和方法，还可以调用父类的构造函数，这对于维护继承体系的正统性非常重要，确保子类在拓展功能的同时，不会丢失父类的核心特性。</p><h4 id="_3-6-3-new" tabindex="-1"><a class="header-anchor" href="#_3-6-3-new"><span>3.6.3 new</span></a></h4><p>是创建对象的“魔法棒”，使用 new 关键字可以在堆内存中开辟空间，调用对象的构造函数进行初始化，赋予对象生命，使其能够参与到程序的运行中。</p><h4 id="_3-6-4-null" tabindex="-1"><a class="header-anchor" href="#_3-6-4-null"><span>3.6.4 null</span></a></h4><p>代表空引用，它在 Java 中是一个特殊的值，就像一把双刃剑，如果使用不当，很容易引发空指针异常，所以在编程过程中，对于可能为 null 的引用要格外小心，谨慎处理。</p>',91))])}]]),c=JSON.parse('{"path":"/posts/java/basic/object-oriented/3.java-basic.html","title":"java 基础知识","lang":"zh-CN","frontmatter":{"title":"java 基础知识","icon":"pen-to-square","cover":"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png","date":"2024-12-27T00:00:00.000Z","lastUpdated":true,"order":1,"category":["java"],"tag":["java-basic"],"description":"java 基本类型、String、关键字等内容介绍","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/java/basic/object-oriented/3.java-basic.html"}],["meta",{"property":"og:site_name","content":"coder-xuyong"}],["meta",{"property":"og:title","content":"java 基础知识"}],["meta",{"property":"og:description","content":"java 基本类型、String、关键字等内容介绍"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T08:06:56.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png"}],["meta",{"name":"twitter:image:alt","content":"java 基础知识"}],["meta",{"property":"article:tag","content":"java-basic"}],["meta",{"property":"article:published_time","content":"2024-12-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T08:06:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java 基础知识\\",\\"image\\":[\\"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png\\"],\\"datePublished\\":\\"2024-12-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-27T08:06:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuyong\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. Java基本数据类型","slug":"_1-java基本数据类型","link":"#_1-java基本数据类型","children":[{"level":3,"title":"1.1 数据类型分类","slug":"_1-1-数据类型分类","link":"#_1-1-数据类型分类","children":[]},{"level":3,"title":"1.2 自动拆装箱机制","slug":"_1-2-自动拆装箱机制","link":"#_1-2-自动拆装箱机制","children":[]}]},{"level":2,"title":"2. String类型","slug":"_2-string类型","link":"#_2-string类型","children":[{"level":3,"title":"2.1 常用方法","slug":"_2-1-常用方法","link":"#_2-1-常用方法","children":[]},{"level":3,"title":"2.2 技巧","slug":"_2-2-技巧","link":"#_2-2-技巧","children":[]},{"level":3,"title":"2.3 字符串池、Class常量池、运行时常量池概念","slug":"_2-3-字符串池、class常量池、运行时常量池概念","link":"#_2-3-字符串池、class常量池、运行时常量池概念","children":[]},{"level":3,"title":"2.4 intern方法","slug":"_2-4-intern方法","link":"#_2-4-intern方法","children":[]},{"level":3,"title":"2.5 String长度限制","slug":"_2-5-string长度限制","link":"#_2-5-string长度限制","children":[]}]},{"level":2,"title":"3. Java关键字","slug":"_3-java关键字","link":"#_3-java关键字","children":[{"level":3,"title":"3.1 访问控制关键字","slug":"_3-1-访问控制关键字","link":"#_3-1-访问控制关键字","children":[]},{"level":3,"title":"3.2 类、接口、抽象相关关键字","slug":"_3-2-类、接口、抽象相关关键字","link":"#_3-2-类、接口、抽象相关关键字","children":[]},{"level":3,"title":"3.3 修饰符关键字","slug":"_3-3-修饰符关键字","link":"#_3-3-修饰符关键字","children":[]},{"level":3,"title":"3.4 流程控制关键字","slug":"_3-4-流程控制关键字","link":"#_3-4-流程控制关键字","children":[]},{"level":3,"title":"3.5 异常处理关键字","slug":"_3-5-异常处理关键字","link":"#_3-5-异常处理关键字","children":[]},{"level":3,"title":"3.6 其他重要关键字","slug":"_3-6-其他重要关键字","link":"#_3-6-其他重要关键字","children":[]}]}],"git":{"createdTime":1735286816000,"updatedTime":1735286816000,"contributors":[{"name":"XuYong","username":"XuYong","email":"55010058+coder-xuyong@users.noreply.github.com","commits":1,"url":"https://github.com/XuYong"}]},"readingTime":{"minutes":11.75,"words":3526},"filePathRelative":"posts/java/basic/object-oriented/3.java-basic.md","localizedDate":"2024年12月27日","excerpt":"<p>java 基本类型、String、关键字等内容介绍</p>\\n","autoDesc":true}')}}]);