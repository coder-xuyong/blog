"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3524],{61709:(n,e,t)=>{t.d(e,{l:()=>i});const i={category:{"/":{path:"/category/",map:{使用指南:{path:"/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",indexes:[0]},linux:{path:"/category/linux/",indexes:[1,2]},idea:{path:"/category/idea/",indexes:[3]},mysql:{path:"/category/mysql/",indexes:[4,5,6,7,8,9,10,11,12]},java:{path:"/category/java/",indexes:[13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]},network:{path:"/category/network/",indexes:[74]},redis:{path:"/category/redis/",indexes:[75,76,77]},windows:{path:"/category/windows/",indexes:[78,79]},dependence:{path:"/category/dependence/",indexes:[80,81,82,83,84]},spring:{path:"/category/spring/",indexes:[85]},python:{path:"/category/python/",indexes:[86]},Java:{path:"/category/java/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},框架:{path:"/category/%E6%A1%86%E6%9E%B6/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring:{path:"/category/spring/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring综合:{path:"/category/spring%E7%BB%BC%E5%90%88/",indexes:[118,119,120,126,140]},Spring核心:{path:"/category/spring%E6%A0%B8%E5%BF%83/",indexes:[94,95,96,97,98,99,100,101,102,103,104,105,106,107,112,113,115,116,117,123,124,128,130,134]},Spring数据:{path:"/category/spring%E6%95%B0%E6%8D%AE/",indexes:[92,93,108,110,131,132,133,137,139,146]},SpringWeb:{path:"/category/springweb/",indexes:[87,88,89,90,91,121,135,142]},SpringIO:{path:"/category/springio/",indexes:[109,127,129,136]},Spring集成:{path:"/category/spring%E9%9B%86%E6%88%90/",indexes:[125,143,144,145]},Spring安全:{path:"/category/spring%E5%AE%89%E5%85%A8/",indexes:[114]},Spring其他:{path:"/category/spring%E5%85%B6%E4%BB%96/",indexes:[111,122,138,141]}}}},tag:{"/":{path:"/tag/",map:{页面配置:{path:"/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",indexes:[0]},使用指南:{path:"/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",indexes:[0,3]},linux:{path:"/tag/linux/",indexes:[1,2]},tomcat:{path:"/tag/tomcat/",indexes:[2,32]},shell:{path:"/tag/shell/",indexes:[78,79,2,29]},sql:{path:"/tag/sql/",indexes:[4,5,6,7,8,9,10,11,12]},bug:{path:"/tag/bug/",indexes:[23,25]},internet:{path:"/tag/internet/",indexes:[74]},java:{path:"/tag/java/",indexes:[80,75,76,77,29,81,82,83,84,85,30,31]},spring:{path:"/tag/spring/",indexes:[75,76,77,29,81,82,83,84,85,30,31]},springboot:{path:"/tag/springboot/",indexes:[75,76,77,29,81,82,83,84,85,30,31]},redis:{path:"/tag/redis/",indexes:[75,76,77]},script:{path:"/tag/script/",indexes:[78,79]},"java-basic":{path:"/tag/java-basic/",indexes:[13,14,15,16,17,18,24,26,27,28,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]},logback:{path:"/tag/logback/",indexes:[81]},maven:{path:"/tag/maven/",indexes:[82]},mybatis:{path:"/tag/mybatis/",indexes:[83]},netty:{path:"/tag/netty/",indexes:[19,20,21,22,84]},nio:{path:"/tag/nio/",indexes:[19]},javaweb:{path:"/tag/javaweb/",indexes:[32,33,34]},http:{path:"/tag/http/",indexes:[32]},servlet:{path:"/tag/servlet/",indexes:[32]},Request:{path:"/tag/request/",indexes:[33]},Response:{path:"/tag/response/",indexes:[33]},jdbc:{path:"/tag/jdbc/",indexes:[34]},djgango:{path:"/tag/djgango/",indexes:[86]},Java:{path:"/tag/java/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},框架:{path:"/tag/%E6%A1%86%E6%9E%B6/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring:{path:"/tag/spring/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},SpringBoot:{path:"/tag/springboot/",indexes:[92,93,108,109,110,111,113,114,118,119,120,121,122,124,125,127,128,129,131,132,133,134,135,136,137,138,139,146]},面试:{path:"/tag/%E9%9D%A2%E8%AF%95/",indexes:[140]},Bean:{path:"/tag/bean/",indexes:[104,105,106,112]},BeanDefinition:{path:"/tag/beandefinition/",indexes:[112]},IOC:{path:"/tag/ioc/",indexes:[107,115,116,117]},依赖查找:{path:"/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",indexes:[116]},依赖注入:{path:"/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",indexes:[107,117]},AOP:{path:"/tag/aop/",indexes:[123]},Resource:{path:"/tag/resource/",indexes:[130]},数据绑定:{path:"/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",indexes:[101]},数据库:{path:"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",indexes:[110,146]},DataSource:{path:"/tag/datasource/",indexes:[146]},JDBC:{path:"/tag/jdbc/",indexes:[132]},JdbcTemplate:{path:"/tag/jdbctemplate/",indexes:[132]},事务:{path:"/tag/%E4%BA%8B%E5%8A%A1/",indexes:[108]},JPA:{path:"/tag/jpa/",indexes:[133]},MyBatis:{path:"/tag/mybatis/",indexes:[131]},PageHelper:{path:"/tag/pagehelper/",indexes:[131]},Mapper:{path:"/tag/mapper/",indexes:[131]},Redis:{path:"/tag/redis/",indexes:[93]},MongoDB:{path:"/tag/mongodb/",indexes:[139]},Elasticsearch:{path:"/tag/elasticsearch/",indexes:[137]},Web:{path:"/tag/web/",indexes:[87,88,89,90,91,121,135,142]},Controller:{path:"/tag/controller/",indexes:[89]},DispatcherServlet:{path:"/tag/dispatcherservlet/",indexes:[91]},Filter:{path:"/tag/filter/",indexes:[90]},CORS:{path:"/tag/cors/",indexes:[88]},View:{path:"/tag/view/",indexes:[87]},异步:{path:"/tag/%E5%BC%82%E6%AD%A5/",indexes:[129]},JSON:{path:"/tag/json/",indexes:[136]},邮件:{path:"/tag/%E9%82%AE%E4%BB%B6/",indexes:[127]},IO:{path:"/tag/io/",indexes:[109]},集成:{path:"/tag/%E9%9B%86%E6%88%90/",indexes:[125,143,144,145]},缓存:{path:"/tag/%E7%BC%93%E5%AD%98/",indexes:[143]},调度器:{path:"/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",indexes:[144]},Dubbo:{path:"/tag/dubbo/",indexes:[145]},安全:{path:"/tag/%E5%AE%89%E5%85%A8/",indexes:[114]}}}}}},94776:(n,e,t)=>{t.d(e,{M:()=>i});const i=["/posts/markdown.html","/posts/linux/linux.html","/posts/linux/linuxWork.html","/posts/idea/idea.html","/posts/mysql/DDL.html","/posts/mysql/DML_DQL.html","/posts/mysql/mysqlBug.html","/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html","/posts/mysql/mysql%E5%AE%89%E8%A3%85.html","/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html","/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html","/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html","/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html","/posts/java/basic/3.java-basic.html","/posts/java/basic/4.collection.html","/posts/java/basic/2.three-features.html","/posts/java/basic/1.object-oriented-programming.html","/posts/java/basic/comparator.html","/posts/java/basic/regularExpression.html","/posts/java/netty/Netty01-nio.html","/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html","/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html","/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html","/posts/network/ftp.html","/posts/java/basic/ioStream.html","/posts/java/bug/bug.html","/posts/java/basic/jottings.html","/posts/java/basic/java8Stream.html","/posts/java/basic/multithreading.html","/posts/windows/workcondition.html","/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html","/posts/java/springboot/workcondition.html","/posts/java/web/HTTP_Tomcat_Servlet.html","/posts/java/web/Request_Response.html","/posts/java/web/jdbc.html","/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html","/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html","/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html","/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html","/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html","/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html","/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html","/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html","/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html","/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html","/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html","/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html","/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html","/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html","/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html","/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html","/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html","/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html","/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html","/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html","/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html","/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html","/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html","/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html","/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html","/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html","/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html","/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html","/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html","/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html","/posts/network/internet.html","/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html","/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html","/posts/redis/redisBUG.html","/posts/shell/shellWork.html","/posts/shell/shell.html","/posts/java/dependence/docx4j.html","/posts/java/dependence/log.html","/posts/java/dependence/maven.html","/posts/java/dependence/mybatis.html","/posts/java/dependence/netty.html","/posts/java/spring/spring.html","/posts/python/django/djangoWork.html","/pages/251e31/","/pages/1d2954/","/pages/5d002f/","/pages/4a164d/","/pages/20287b/","/pages/191cdb/","/pages/65e4a2/","/pages/1f743f/","/pages/ad472e/","/pages/03d838/","/pages/b6556f/","/pages/cca414/","/pages/175cbd/","/pages/6662dc/","/pages/267b4c/","/pages/fe6aad/","/pages/b5b8ad/","/pages/55f315/","/pages/4ab176/","/pages/8289f5/","/pages/a5f257/","/pages/128c54/","/pages/56581b/","/pages/b912d1/","/pages/c013cc/","/pages/68097d/","/pages/950e4d/","/pages/568352/","/pages/915530/","/pages/9a6f6b/","/pages/f61a1c/","/pages/430f53/","/pages/dbf521/","/pages/9e0b67/","/pages/e2586a/","/pages/6bb8c1/","/pages/53aedb/","/pages/5e7c20/","/pages/d6025b/","/pages/9d3091/","/pages/2586f1/","/pages/cb598e/","/pages/92add2/","/pages/a1549f/","/pages/88219e/","/pages/cf19fd/","/pages/a03d7b/","/pages/0fb992/","/pages/ad0516/","/pages/676725/","/pages/fac14c/","/pages/bac2ce/","/pages/db2a41/","/pages/db33b0/","/pages/752c6a/","/pages/65351b/","/pages/a311cb/","/pages/a187f0/","/pages/274fd7/","/pages/1b774c/","/intro.html"]},53781:(n,e,t)=>{t.d(e,{U:()=>i});const i={article:{"/":{path:"/article/",indexes:[0,13,14,15,16,3,147,17,18,80,19,20,21,22,86,78,23,74,79,24,25,26,27,28,1,2,4,5,6,7,8,9,10,11,12,75,76,77,29,81,82,83,84,85,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]}},star:{"/":{path:"/star/",indexes:[0,147]}},timeline:{"/":{path:"/timeline/",indexes:[13,14,15,16,0,3,147,17,18,80,19,20,21,22,86,78,23,74,79,24,25,26,27,28,1,2,4,5,6,7,8,9,10,11,12,75,76,77,29,81,82,83,84,85,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]}}}},88965:(n,e,t)=>{t.d(e,{B:()=>H});var i={};t.r(i);var a={};t.r(a);var r={};t.r(r);var s={};t.r(s),t.d(s,{default:()=>h});var o={};t.r(o),t.d(o,{default:()=>S});var l={};t.r(l);var c={};t.r(c),t.d(c,{default:()=>j});var p={};t.r(p),t.d(p,{default:()=>N});var d={};t.r(d),t.d(d,{default:()=>U});var g=t(33349),u=t(11781),m=t(19212);const h={enhance:({app:n})=>{n.component("CodeTabs",u.S),n.component("Tabs",m.t)}};var b=t(58031),v=t(83027);const S={enhance:({app:n})=>{n.component("CodeDemo",b.A),n.component("MdDemo",v.A)}};var f=t(38913),y=t(80355),E=t(80457),B=t(6990),w=t(42402),A=t(97786),k=t(79403),x=t(70596),C=t(38831);const j={enhance:({app:n})=>{(0,w.L4)("FontIcon")||n.component("FontIcon",k.A),(0,w.L4)("Badge")||n.component("Badge",x.A),(0,w.L4)("VPCard")||n.component("VPCard",C.A)},setup:()=>{(0,A.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/brands.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,A.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/solid.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,A.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/fontawesome.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}})},rootComponents:[]};var T=t(26358),D=t(23827),I=t(31599),L=t(22614),F=t(75054),R=t(80783),P=t(38465),M=t(20641),O=t(77107),_=t(79920);(0,P.M_)((n=>{const e=n.t,t=!1!==n.I,i=n.i;return t?{title:e,content:i?()=>[(0,M.h)(R.GB,{icon:i}),e]:null,order:n.O,index:n.I}:null}));const N={enhance:({app:n,router:e})=>{const{scrollBehavior:t}=e.options;e.options.scrollBehavior=async(...n)=>(await R.lE.wait(),t(...n)),(0,R.fk)(n),n.component("HopeIcon",R.GB),n.component("BloggerInfo",O.tI),n.component("SocialMedias",O.rS),n.component("GlobalEncrypt",_.J),n.component("LocalEncrypt",_.n)},setup:()=>{(0,R.PV)(),(0,R.i$)(),(0,O.su)()},layouts:{Layout:R.PE,NotFound:R.Mk,BlogCategory:O.Pn,BlogHome:O.qX,BlogType:O.z7,Timeline:O.Kf}};var J=t(8278),q=t(61428);const U=(0,J.re)({setup(){(0,q.H)(new Date("2024-12-18"),{"/":"已运行 :day 天 :hour 小时 :minute 分钟 :second 秒"},!0)}}),H=[i,a,r,g,s,o,l,r,f,y,E,B,c,T,D,I,L,F,p,d].map((n=>n.default)).filter(Boolean)},68164:(n,e,t)=>{t.d(e,{J:()=>a,c:()=>i});const i=JSON.parse('{"/posts/mysql/DML&DQL.html":"/posts/mysql/DML_DQL.html","/posts/java/web/HTTP&Tomcat&Servlet.html":"/posts/java/web/HTTP_Tomcat_Servlet.html","/posts/java/web/Request&Response.html":"/posts/java/web/Request_Response.html","/posts/java/basic/11-%E9%9B%86%E5%90%88&%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList&%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html":"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html","/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static&%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html":"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html","/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81&%E5%8C%85&final&%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6&%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html":"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html","/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB&%E6%8E%A5%E5%8F%A3&%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html":"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html","/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B&Set&%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html":"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html","/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map&%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0&%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html":"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html","/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0&doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0&%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html":"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html":"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html","/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8&File&%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8&File&%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html":"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html","/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html":"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html","/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html":"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html","/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html":"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html":"/pages/9d3091/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html":"/pages/430f53/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html":"/pages/dbf521/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html":"/pages/db33b0/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/":"/pages/9e0b67/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html":"/pages/68097d/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html":"/pages/915530/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html":"/pages/9a6f6b/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html":"/pages/f61a1c/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html":"/pages/a5f257/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html":"/pages/8289f5/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html":"/pages/4ab176/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html":"/pages/55f315/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/09.Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html":"/pages/ad472e/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html":"/pages/53aedb/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html":"/pages/a1549f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html":"/pages/fe6aad/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html":"/pages/267b4c/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html":"/pages/6662dc/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html":"/pages/1f743f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html":"/pages/cca414/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html":"/pages/b5b8ad/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html":"/pages/175cbd/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html":"/pages/b6556f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/29.SpringEnvironment%E6%8A%BD%E8%B1%A1.html":"/pages/03d838/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html":"/pages/950e4d/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html":"/pages/0fb992/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html":"/pages/cb598e/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/":"/pages/5e7c20/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html":"/pages/1b774c/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html":"/pages/cf19fd/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html":"/pages/128c54/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html":"/pages/a03d7b/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html":"/pages/88219e/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/20.SpringData%E7%BB%BC%E5%90%88.html":"/pages/191cdb/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html":"/pages/65e4a2/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html":"/pages/db2a41/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html":"/pages/fac14c/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/":"/pages/b912d1/","/posts/java/spring/03-SpringWeb/01.SpringWeb%E7%BB%BC%E8%BF%B0.html":"/pages/65351b/","/posts/java/spring/03-SpringWeb/02.SpringWeb%E5%BA%94%E7%94%A8.html":"/pages/5d002f/","/posts/java/spring/03-SpringWeb/03.DispatcherServlet.html":"/pages/20287b/","/posts/java/spring/03-SpringWeb/04.Spring%E8%BF%87%E6%BB%A4%E5%99%A8.html":"/pages/4a164d/","/posts/java/spring/03-SpringWeb/05.Spring%E8%B7%A8%E5%9F%9F.html":"/pages/1d2954/","/posts/java/spring/03-SpringWeb/06.Spring%E8%A7%86%E5%9B%BE.html":"/pages/251e31/","/posts/java/spring/03-SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html":"/pages/ad0516/","/posts/java/spring/03-SpringWeb/":"/pages/e2586a/","/posts/java/spring/04-SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html":"/pages/92add2/","/posts/java/spring/04-SpringIO/02.SpringBoot%E4%B9%8BJson.html":"/pages/676725/","/posts/java/spring/04-SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html":"/pages/2586f1/","/posts/java/spring/04-SpringIO/":"/pages/56581b/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html":"/pages/a311cb/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html":"/pages/a187f0/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html":"/pages/274fd7/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/":"/pages/d6025b/","/posts/java/spring/10-Spring%E5%AE%89%E5%85%A8/01.SpringBoot%E4%B9%8B%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html":"/pages/568352/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html":"/pages/752c6a/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html":"/pages/bac2ce/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html":"/pages/c013cc/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/":"/pages/6bb8c1/"}'),a=Object.fromEntries([["/",{loader:()=>t.e(4470).then(t.bind(t,62744)),meta:{t:"主页",i:"home"}}],["/intro.html",{loader:()=>t.e(1531).then(t.bind(t,6924)),meta:{d:1734619579e3,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/e699d7e2413ed5dfb384ee48c2b872d3_5181262111088024686.png",e:"\n<p>重生之我在提瓦特大陆当牛马</p>\n",r:{minutes:.09,words:26},t:"介绍页",i:"circle-info",y:"a"}}],["/demo/",{loader:()=>t.e(3320).then(t.bind(t,85351)),meta:{t:"主要功能与配置演示",i:"laptop-code"}}],["/demo/disable.html",{loader:()=>t.e(2756).then(t.bind(t,24139)),meta:{t:"布局与功能禁用",i:"gears",O:4}}],["/demo/encrypt.html",{loader:()=>t.e(2581).then(t.bind(t,71314)),meta:{t:"密码加密的文章",i:"lock"}}],["/demo/layout.html",{loader:()=>t.e(6216).then(t.bind(t,74087)),meta:{t:"布局",i:"object-group",O:2}}],["/demo/markdown.html",{loader:()=>t.e(8711).then(t.bind(t,36175)),meta:{t:"Markdown 展示",i:"fab fa-markdown",O:2}}],["/demo/page.html",{loader:()=>t.e(645).then(t.bind(t,95397)),meta:{t:"页面配置使用说明",i:"file",O:3}}],["/posts/markdown.html",{loader:()=>t.e(1629).then(t.bind(t,49531)),meta:{a:"xuyong",d:17347392e5,l:"2024年12月21日",c:["使用指南"],g:["页面配置","使用指南"],u:!0,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/fdcbc9ef8859b7077d92ae38d925e15e_7767077963502328666.png",e:"<p><code>more</code> 注释之前的内容被视为文章摘要。</p>\n",r:{minutes:2.02,words:606},t:"页面配置使用说明",i:"file",O:3,y:"a"}}],["/posts/linux/linux.html",{loader:()=>t.e(4261).then(t.bind(t,15628)),meta:{d:16855776e5,l:"2023年6月1日",c:["linux"],g:["linux"],e:"<p>linux 命令集</p>\n",r:{minutes:29.18,words:8754},t:"linux 命令集",i:"pen-to-square",y:"a"}}],["/posts/linux/linuxWork.html",{loader:()=>t.e(4292).then(t.bind(t,60195)),meta:{d:16855776e5,l:"2023年6月1日",c:["linux"],g:["linux","tomcat","shell"],e:"<p>在工作中遇到的有关Linux的问题</p>\n",r:{minutes:2.81,words:842},t:"在工作中遇到的有关Linux的问题",i:"pen-to-square",y:"a"}}],["/posts/idea/idea.html",{loader:()=>t.e(8565).then(t.bind(t,18830)),meta:{a:"xuyong",d:17347392e5,l:"2024年12月21日",c:["idea"],g:["使用指南"],u:!1,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/07/04/d063646e97392638e07da24ce6b8c3cb_3567507076955258130.png",e:"<p>记录 idea 使用过程中遇到的问题</p>\n",r:{minutes:.98,words:294},t:"idea 使用方便记录",i:"file",y:"a"}}],["/posts/mysql/DDL.html",{loader:()=>t.e(779).then(t.bind(t,35486)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DDL常用命令，操作数据库和表结构</p>\n",r:{minutes:1.88,words:564},t:"DDL常用命令，操作数据库和表结构",i:"pen-to-square",y:"a"}}],["/posts/mysql/DML_DQL.html",{loader:()=>t.e(532).then(t.bind(t,29099)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DML和DQL常用命令，操作表数据</p>\n",r:{minutes:1.84,words:551},t:"DML和DQL常用命令，操作表数据",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysqlBug.html",{loader:()=>t.e(2755).then(t.bind(t,57114)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql使用中遇到的问题记录</p>\n",r:{minutes:.53,words:160},t:"mysql使用中遇到的问题记录",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html",{loader:()=>t.e(7219).then(t.bind(t,59e3)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DDL常用命令，操作数据库和表结构</p>\n",r:{minutes:2.33,words:698},t:"mysql 存储过程",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E5%AE%89%E8%A3%85.html",{loader:()=>t.e(2851).then(t.bind(t,74326)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql 安装指南</p>\n",r:{minutes:.96,words:287},t:"mysql 安装",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html",{loader:()=>t.e(8122).then(t.bind(t,72388)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql 数据格式</p>\n",r:{minutes:1.36,words:409},t:"mysql 数据格式",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html",{loader:()=>t.e(9610).then(t.bind(t,88366)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql约束</p>\n",r:{minutes:7.92,words:2376},t:"mysql约束",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html",{loader:()=>t.e(8587).then(t.bind(t,33636)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql自定义函数</p>\n",r:{minutes:3.32,words:996},t:"mysql自定义函数",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html",{loader:()=>t.e(5558).then(t.bind(t,32454)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>触发器</p>\n",r:{minutes:.74,words:221},t:"触发器",i:"pen-to-square",y:"a"}}],["/posts/network/ftp.html",{loader:()=>t.e(9434).then(t.bind(t,48704)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["bug"],e:"<p>ftp 的一些基础内容</p>\n",r:{minutes:1.6,words:481},t:"ftp",i:"pen-to-square",y:"a"}}],["/posts/network/internet.html",{loader:()=>t.e(638).then(t.bind(t,30020)),meta:{d:16859232e5,l:"2023年6月5日",c:["network"],g:["internet"],e:"<p>计算机网络学习笔记</p>\n",r:{minutes:14.73,words:4418},t:"计算机网络",i:"pen-to-square",y:"a"}}],["/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html",{loader:()=>t.e(6059).then(t.bind(t,17549)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 学习笔记之实战篇</p>\n",r:{minutes:47.09,words:14126},t:"redis 学习笔记之实战篇",i:"pen-to-square",y:"a"}}],["/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",{loader:()=>t.e(9793).then(t.bind(t,61419)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 学习笔记之快速入门</p>\n",r:{minutes:16.98,words:5093},t:"redis 学习笔记之快速入门",i:"pen-to-square",y:"a"}}],["/posts/redis/redisBUG.html",{loader:()=>t.e(5183).then(t.bind(t,69299)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 使用过程中的bug记录</p>\n",r:{minutes:1.42,words:427},t:"redis 使用过程中的bug记录",i:"pen-to-square",y:"a"}}],["/posts/shell/shell.html",{loader:()=>t.e(1669).then(t.bind(t,73730)),meta:{d:16859232e5,l:"2023年6月5日",c:["windows"],g:["script","shell"],e:"<p>入门 shell 脚本的基础知识</p>\n",r:{minutes:34.53,words:10358},t:"shell 基础知识",i:"pen-to-square",y:"a"}}],["/posts/shell/shellWork.html",{loader:()=>t.e(8628).then(t.bind(t,81709)),meta:{d:17155584e5,l:"2024年5月13日",c:["windows"],g:["script","shell"],e:"<p>工作中遇到有关 shell 脚本的情景和处理记录</p>\n",r:{minutes:.69,words:208},t:"工作中遇到的 shell",i:"pen-to-square",y:"a"}}],["/posts/windows/workcondition.html",{loader:()=>t.e(486).then(t.bind(t,75994)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot","shell"],e:"<p>Windows 工作中遇到的问题</p>\n",r:{minutes:2.66,words:797},t:"Windows 工作中遇到的问题",i:"pen-to-square",y:"a"}}],["/posts/java/basic/1.object-oriented-programming.html",{loader:()=>t.e(6233).then(t.bind(t,92717)),meta:{d:1734912e6,l:"2024年12月23日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png",e:"<p>java 面向对象基本信息介绍</p>\n",r:{minutes:10.38,words:3115},t:"什么是面向对象编程",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/2.three-features.html",{loader:()=>t.e(1088).then(t.bind(t,66658)),meta:{d:17349984e5,l:"2024年12月24日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2023/02/06/df329c62acad08953832134777166e57_5667154156652123154.png",e:"<p>java 封装、继承、多态介绍</p>\n",r:{minutes:10.28,words:3083},t:"面向对象的三大基本特征",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/3.java-basic.html",{loader:()=>t.e(7462).then(t.bind(t,41909)),meta:{d:17352576e5,l:"2024年12月27日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png",e:"<p>java 基本类型、String、关键字等内容介绍</p>\n",r:{minutes:6.86,words:2059},t:"java 基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/basic/4.collection.html",{loader:()=>t.e(8653).then(t.bind(t,96534)),meta:{d:17352576e5,l:"2024年12月27日",c:["java"],g:["java-basic"],v:"https://uploadstatic.mihoyo.com/contentweb/20200312/2020031219451784892.png",e:"<p>java 集合相关内容</p>\n",r:{minutes:6.87,words:2060},t:"java 集合",i:"pen-to-square",y:"a"}}],["/posts/java/basic/comparator.html",{loader:()=>t.e(7352).then(t.bind(t,89030)),meta:{d:17343936e5,l:"2024年12月17日",c:["java"],g:["java-basic"],e:"<p>Comparator 的一些基本使用</p>\n",r:{minutes:2.57,words:770},t:"comparator 基本使用",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/ioStream.html",{loader:()=>t.e(1816).then(t.bind(t,87982)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["java-basic"],e:"<p>IO 流的一些基本使用，后续记得完善</p>\n",r:{minutes:.25,words:76},t:"io 流的基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/basic/java8Stream.html",{loader:()=>t.e(8810).then(t.bind(t,93838)),meta:{d:16857504e5,l:"2023年6月3日",c:["java"],g:["java-basic"],e:"<p>java8 stream 梳理</p>\n",r:{minutes:17.43,words:5228},t:"java8 stream",i:"pen-to-square",y:"a"}}],["/posts/java/basic/jottings.html",{loader:()=>t.e(2222).then(t.bind(t,65432)),meta:{d:16858368e5,l:"2023年6月4日",c:["java"],g:["java-basic"],e:"<p>java 零碎知识点记录</p>\n",r:{minutes:2.55,words:764},t:"java 零碎知识点",i:"pen-to-square",y:"a"}}],["/posts/java/basic/multithreading.html",{loader:()=>t.e(5763).then(t.bind(t,98773)),meta:{d:1685664e6,l:"2023年6月2日",c:["java"],g:["java-basic"],e:"<p>多线程基础</p>\n",r:{minutes:13.31,words:3993},t:"多线程基础",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/regularExpression.html",{loader:()=>t.e(3512).then(t.bind(t,68589)),meta:{d:17343936e5,l:"2024年12月17日",c:["java"],g:["java-basic"],e:"<p>java 正则表达式的基础使用</p>\n",r:{minutes:5.53,words:1658},t:"java 使用正则表达式",i:"pen-to-square",y:"a"}}],["/posts/java/bug/bug.html",{loader:()=>t.e(1796).then(t.bind(t,75441)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["bug"],e:"<p>记录遇见的 Java 相关疑难杂症的 bug</p>\n",r:{minutes:.3,words:89},t:"java bug 合集",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/docx4j.html",{loader:()=>t.e(4337).then(t.bind(t,45574)),meta:{d:17343936e5,l:"2024年12月17日",c:["dependence"],g:["java"],e:"<p>docx4j 的一些基本使用</p>\n",r:{minutes:4.43,words:1330},t:"docx4j 基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/log.html",{loader:()=>t.e(7119).then(t.bind(t,34513)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","logback"],e:"<p>Java 有关log的第三方依赖的使用</p>\n",r:{minutes:5.86,words:1758},t:"Java 有关log的第三方依赖的使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/maven.html",{loader:()=>t.e(6574).then(t.bind(t,40565)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","maven"],e:"<p>maven的基本使用</p>\n",r:{minutes:9.77,words:2931},t:"有关maven的使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/mybatis.html",{loader:()=>t.e(5304).then(t.bind(t,55831)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","mybatis"],e:"<p>mybatis 的基本使用</p>\n",r:{minutes:21.93,words:6580},t:"mybatis 的基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/netty.html",{loader:()=>t.e(2709).then(t.bind(t,93595)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","netty"],e:"<p>netty 学习</p>\n",r:{minutes:1.15,words:344},t:"netty 学习",i:"pen-to-square",y:"a"}}],["/posts/java/netty/Netty01-nio.html",{loader:()=>t.e(1100).then(t.bind(t,65497)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty","nio"],e:"<p>non-blocking io 非阻塞 IO</p>\n",r:{minutes:32.01,words:9603},t:"NIO 基础",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html",{loader:()=>t.e(2022).then(t.bind(t,70471)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>Netty 入门</p>\n",r:{minutes:30.61,words:9183},t:"Netty 入门",i:"pen-to-square",O:2,y:"a"}}],["/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html",{loader:()=>t.e(4051).then(t.bind(t,49242)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>Netty 进阶</p>\n",r:{minutes:29.55,words:8865},t:"Netty 进阶",i:"pen-to-square",O:3,y:"a"}}],["/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html",{loader:()=>t.e(3222).then(t.bind(t,98228)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>优化与源码</p>\n",r:{minutes:21.53,words:6459},t:"优化与源码",i:"pen-to-square",O:4,y:"a"}}],["/posts/java/spring/spring.html",{loader:()=>t.e(3516).then(t.bind(t,6634)),meta:{d:16855776e5,l:"2023年6月1日",c:["spring"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:8.54,words:2562},t:"spring 学习笔记",i:"pen-to-square",y:"a"}}],["/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html",{loader:()=>t.e(3117).then(t.bind(t,64728)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:.73,words:219},t:"spring面试题",i:"pen-to-square",y:"a"}}],["/posts/java/springboot/workcondition.html",{loader:()=>t.e(5227).then(t.bind(t,57119)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:20.72,words:6215},t:"springboot 工作中遇到的问题",i:"pen-to-square",y:"a"}}],["/posts/java/web/HTTP_Tomcat_Servlet.html",{loader:()=>t.e(3821).then(t.bind(t,14485)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","http","tomcat","servlet"],e:"<p>HTTP tomcat Servlet 基础知识</p>\n",r:{minutes:38.71,words:11612},t:"HTTP tomcat Servlet 基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/web/Request_Response.html",{loader:()=>t.e(9861).then(t.bind(t,8994)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","Request","Response"],e:"<p>Request&amp;Response 基础知识</p>\n",r:{minutes:39.2,words:11761},t:"Request&Response 的基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/web/jdbc.html",{loader:()=>t.e(57).then(t.bind(t,4634)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","jdbc"],e:"<p>jdbc 基础使用</p>\n",r:{minutes:21.81,words:6543},t:"jdbc 的基本使用",i:"pen-to-square",y:"a"}}],["/posts/python/django/djangoWork.html",{loader:()=>t.e(6855).then(t.bind(t,12215)),meta:{d:17169408e5,l:"2024年5月29日",c:["python"],g:["djgango"],e:"<p>在工作中遇到了 django  框架，记录一些使用过程中遇到的问题</p>\n",r:{minutes:2.18,words:655},t:"django 使用过程中发生的问题",i:"pen-to-square",y:"a"}}],["/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",{loader:()=>t.e(1664).then(t.bind(t,82832)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Java入门介绍，编写hello world</p>\n",r:{minutes:10.55,words:3165},t:"Java入门",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",{loader:()=>t.e(8906).then(t.bind(t,61025)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Java基础概念学习</p>\n",r:{minutes:22.64,words:6791},t:"Java基础概念",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(4417).then(t.bind(t,26525)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>运算符和表达式记录</p>\n",r:{minutes:14.82,words:4447},t:"运算符和表达式",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",{loader:()=>t.e(5404).then(t.bind(t,75772)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>流程控制语句</p>\n",r:{minutes:12.62,words:3785},t:"流程控制语句",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html",{loader:()=>t.e(2741).then(t.bind(t,56605)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>循环高级</p>\n",r:{minutes:6.78,words:2034},t:"循环高级",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",{loader:()=>t.e(1255).then(t.bind(t,5725)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>数组</p>\n",r:{minutes:11.52,words:3455},t:"数组",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html",{loader:()=>t.e(3266).then(t.bind(t,54768)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>方法概述</p>\n",r:{minutes:12.48,words:3745},t:"方法概述",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(843).then(t.bind(t,33838)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>综合练习</p>\n",r:{minutes:14.22,words:4267},t:"综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",{loader:()=>t.e(4867).then(t.bind(t,75470)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>类和对象</p>\n",r:{minutes:9.69,words:2908},t:"类和对象",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(1524).then(t.bind(t,9313)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>扩展：键盘录入笔记</p>\n",r:{minutes:3.97,words:1192},t:"扩展：键盘录入笔记",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(3870).then(t.bind(t,75761)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>面向对象综合训练综合练习</p>\n",r:{minutes:18.04,words:5413},t:"面向对象综合训练综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html",{loader:()=>t.e(8238).then(t.bind(t,73913)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常用API</p>\n",r:{minutes:15.69,words:4708},t:"常用API",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html",{loader:()=>t.e(689).then(t.bind(t,95292)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>ArrayList&amp;学生管理系统</p>\n",r:{minutes:10.94,words:3283},t:"ArrayList&学生管理系统",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html",{loader:()=>t.e(3336).then(t.bind(t,16982)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>面向对象进阶部分学习方法</p>\n",r:{minutes:24.27,words:7282},t:"面向对象进阶部分学习方法",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(9537).then(t.bind(t,78744)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>多态</p>\n",r:{minutes:15.02,words:4507},t:"多态",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(9094).then(t.bind(t,46259)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>抽象类</p>\n",r:{minutes:18.32,words:5497},t:"抽象类",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html",{loader:()=>t.e(8373).then(t.bind(t,25099)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>day16-面向对象综合练习（上）</p>\n",r:{minutes:13.04,words:3913},t:"day16-面向对象综合练习（上）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html",{loader:()=>t.e(2077).then(t.bind(t,35599)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>day16-面向对象综合练习（下）</p>\n",r:{minutes:19.75,words:5925},t:"day16-面向对象综合练习（下）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html",{loader:()=>t.e(6636).then(t.bind(t,27933)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常见API，对象克隆</p>\n",r:{minutes:39.65,words:11896},t:"常见API，对象克隆",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",{loader:()=>t.e(1361).then(t.bind(t,23839)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>正则表达式</p>\n",r:{minutes:22.4,words:6719},t:"正则表达式",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html",{loader:()=>t.e(743).then(t.bind(t,41897)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常用API</p>\n",r:{minutes:23.9,words:7169},t:"常用API",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html",{loader:()=>t.e(7848).then(t.bind(t,15853)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常见的七种查找算法：</p>\n",r:{minutes:19.57,words:5871},t:"常见的七种查找算法",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html",{loader:()=>t.e(9740).then(t.bind(t,93939)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Collection集合</p>\n",r:{minutes:11.8,words:3539},t:"Collection集合",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html",{loader:()=>t.e(7509).then(t.bind(t,78110)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>泛型</p>\n",r:{minutes:11.69,words:3508},t:"泛型",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html",{loader:()=>t.e(1264).then(t.bind(t,34831)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Map集合</p>\n",r:{minutes:6.37,words:1910},t:"Map集合",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(9920).then(t.bind(t,77626)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>可变参数&amp;综合练习</p>\n",r:{minutes:10.91,words:3273},t:"可变参数&综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html",{loader:()=>t.e(2790).then(t.bind(t,55364)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>stream流和方法引用</p>\n",r:{minutes:17.44,words:5233},t:"stream流和方法引用",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html",{loader:()=>t.e(7343).then(t.bind(t,42136)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO(异常&amp;File&amp;综合案例）</p>\n",r:{minutes:21.44,words:6431},t:"IO(异常&File&综合案例）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html",{loader:()=>t.e(9227).then(t.bind(t,72275)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO流（字节流&amp;字符流）</p>\n",r:{minutes:21.1,words:6330},t:"IO流（字节流&字符流）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html",{loader:()=>t.e(7078).then(t.bind(t,94095)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO流（其他流）</p>\n",r:{minutes:23.73,words:7120},t:"IO流（其他流）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html",{loader:()=>t.e(7378).then(t.bind(t,27970)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>实现多线程</p>\n",r:{minutes:20.83,words:6249},t:"实现多线程",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html",{loader:()=>t.e(2613).then(t.bind(t,29737)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>线程池</p>\n",r:{minutes:34.15,words:10245},t:"线程池",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html",{loader:()=>t.e(2193).then(t.bind(t,71946)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>网络编程入门</p>\n",r:{minutes:22.51,words:6753},t:"网络编程入门",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",{loader:()=>t.e(9484).then(t.bind(t,28492)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>反射&amp;动态代理</p>\n",r:{minutes:19.3,words:5791},t:"反射&动态代理",i:"pen-to-square",O:1,y:"a"}}],["/pages/9d3091/",{loader:()=>t.e(6026).then(t.bind(t,26057)),meta:{d:1574419562e3,l:"2019年11月22日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring"],e:"\n<h2>Spring Framework 简介</h2>\n<p>Spring Framework 是最受欢迎的企业级 Java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。</p>\n<p>当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。</p>\n<p>Spring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>\n<p>Spring Framework 设计理念如下：</p>",r:{minutes:9.58,words:2875},t:"Spring Framework 综述",y:"a"}}],["/pages/430f53/",{loader:()=>t.e(1909).then(t.bind(t,63511)),meta:{d:1597215686e3,l:"2020年8月12日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:"\n<blockquote>\n<ol>\n<li>预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章</li>\n<li>说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。</li>\n</ol>\n</blockquote>",r:{minutes:37.48,words:11245},t:"SpringBoot 知识图谱",y:"a"}}],["/pages/dbf521/",{loader:()=>t.e(4264).then(t.bind(t,66576)),meta:{d:1597215686e3,l:"2020年8月12日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:'\n<p>SpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。</p>\n<figure><img src="https:////upload-images.jianshu.io/upload_images/6430208-ebcb376f96103703.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',r:{minutes:6.26,words:1878},t:"SpringBoot 基本原理",y:"a"}}],["/pages/db33b0/",{loader:()=>t.e(9084).then(t.bind(t,26763)),meta:{d:1533231212e3,l:"2018年8月2日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","面试"],e:"\n<h2>综合篇</h2>\n<h3>不同版本的 Spring Framework 有哪些主要功能？</h3>\n<table>\n<thead>\n<tr>\n<th>Version</th>\n<th>Feature</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring 2.5</td>\n<td>发布于 2007 年。这是第一个支持注解的版本。</td>\n</tr>\n<tr>\n<td>Spring 3.0</td>\n<td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td>\n</tr>\n<tr>\n<td>Spring 4.0</td>\n<td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td>\n</tr>\n</tbody>\n</table>",r:{minutes:20.87,words:6260},t:"Spring 面试",y:"a"}}],["/pages/9e0b67/",{loader:()=>t.e(9797).then(t.bind(t,50729)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html" target="_blank">Spring 概述</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html" target="_blank">SpringBoot 知识图谱</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html" target="_blank">SpringBoot 基本原理</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html" target="_blank">Spring 面试</a></li>\n</ul>',r:{minutes:.48,words:144},t:"Spring 综述",y:"a"}}],["/pages/68097d/",{loader:()=>t.e(1804).then(t.bind(t,39763)),meta:{d:1639163742e3,l:"2021年12月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean","BeanDefinition"],e:"\n<p>在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。<strong>Bean 是由 Spring IoC 容器实例化、装配和管理的对象</strong>。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</p>\n<h2>Spring Bean 定义</h2>\n<h3>BeanDefinition</h3>\n<p>Spring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——<code>BeanDefinition</code> 对象。</p>\n<p><strong><code>BeanDefinition</code> 是 Spring 中定义 Bean 的配置元信息接口</strong>，它包含：</p>",r:{minutes:7.16,words:2147},t:"Spring Bean",y:"a"}}],["/pages/915530/",{loader:()=>t.e(4441).then(t.bind(t,52957)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC"],e:"\n<h2>IoC 简介</h2>\n<h3>IoC 是什么</h3>\n<p><strong>IoC</strong> 即<strong>控制反转</strong>（Inversion of Control，缩写为 IoC）。IoC 又称为<strong>依赖倒置原则</strong>（设计模式六大原则之一），它的要点在于：<strong>程序要依赖于抽象接口，不要依赖于具体实现</strong>。它的作用就是<strong>用于降低代码间的耦合度</strong>。</p>\n<p>IoC 的实现方式有两种：</p>\n<ul>\n<li><strong>依赖注入</strong>（Dependency Injection，简称 DI）：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li><strong>依赖查找</strong>（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。</li>\n</ul>",r:{minutes:23.88,words:7165},t:"Spring IoC",y:"a"}}],["/pages/9a6f6b/",{loader:()=>t.e(6724).then(t.bind(t,90468)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖查找"],e:"\n<p><strong>依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现</strong>。</p>\n<p>IoC 依赖查找大致可以分为以下几类：</p>\n<ul>\n<li>根据 Bean 名称查找</li>\n<li>根据 Bean 类型查找</li>\n<li>根据 Bean 名称 + 类型查找</li>\n<li>根据 Java 注解查找</li>\n</ul>\n<p>此外，根据查找的 Bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 API。</p>\n<h2>单一类型依赖查找</h2>\n<p>单一类型依赖查找接口- <code>BeanFactory</code></p>",r:{minutes:3.05,words:915},t:"Spring 依赖查找",y:"a"}}],["/pages/f61a1c/",{loader:()=>t.e(832).then(t.bind(t,72411)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖注入"],e:"\n<p>DI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API。</p>\n<p>依赖注入 (Dependency Injection，简称 DI) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。</p>\n<p>使用 DI，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。</p>",r:{minutes:9.77,words:2931},t:"Spring 依赖注入",y:"a"}}],["/pages/a5f257/",{loader:()=>t.e(9136).then(t.bind(t,33121)),meta:{d:1671568431e3,l:"2022年12月20日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖注入"],e:'\n<h2>依赖查找的来源</h2>\n<p>查找来源</p>\n<table>\n<thead>\n<tr>\n<th>来源</th>\n<th>配置元数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring BeanDefinition</td>\n<td><code>&lt;bean id ="user" class="xxx.xxx.User"&gt;</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>@Bean public User user() {...}</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>BeanDefinitionBuilder</code></td>\n</tr>\n<tr>\n<td>单例对象</td>\n<td>API 实现</td>\n</tr>\n</tbody>\n</table>',r:{minutes:2.33,words:698},t:"Spring IoC 依赖来源",y:"a"}}],["/pages/8289f5/",{loader:()=>t.e(9070).then(t.bind(t,63019)),meta:{d:167162292e4,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring Bean 作用域</h2>\n<table>\n<thead>\n<tr>\n<th>来源</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>singleton</td>\n<td>默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>原型作用域，每次依赖查找和依赖注入生成新 Bean 对象</td>\n</tr>\n<tr>\n<td>request</td>\n<td>将 Spring Bean 存储在 ServletRequest 上下文中</td>\n</tr>\n<tr>\n<td>session</td>\n<td>将 Spring Bean 存储在 HttpSession 中</td>\n</tr>\n<tr>\n<td>application</td>\n<td>将 Spring Bean 存储在 ServletContext 中</td>\n</tr>\n</tbody>\n</table>",r:{minutes:1.34,words:403},t:"Spring Bean 作用域",y:"a"}}],["/pages/4ab176/",{loader:()=>t.e(6149).then(t.bind(t,73057)),meta:{d:1671650761e3,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring Bean 元信息配置阶段</h2>\n<p>BeanDefinition 配置</p>\n<ul>\n<li>面向资源\n<ul>\n<li>XML 配置</li>\n<li>Properties 资源配置</li>\n</ul>\n</li>\n<li>面向注解</li>\n<li>面向 API</li>\n</ul>\n<h2>Spring Bean 元信息解析阶段</h2>\n<ul>\n<li>面向资源 BeanDefinition 解析\n<ul>\n<li>BeanDefinitionReader</li>\n<li>XML 解析器 - BeanDefinitionParser</li>\n</ul>\n</li>\n<li>面向注解 BeanDefinition 解析\n<ul>\n<li>AnnotatedBeanDefinitionReader</li>\n</ul>\n</li>\n</ul>",r:{minutes:2.62,words:787},t:"Spring Bean 生命周期",y:"a"}}],["/pages/55f315/",{loader:()=>t.e(7249).then(t.bind(t,98693)),meta:{d:1671652188e3,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring 配置元信息</h2>\n<ul>\n<li>Spring Bean 配置元信息 - BeanDefinition</li>\n<li>Spring Bean 属性元信息 - PropertyValues</li>\n<li>Spring 容器配置元信息</li>\n<li>Spring 外部化配置元信息 - PropertySource</li>\n<li>Spring Profile 元信息 - @Profile</li>\n</ul>\n<h2>Spring Bean 配置元信息</h2>\n<p>Bean 配置元信息 - BeanDefinition</p>\n<ul>\n<li>GenericBeanDefinition：通用型 BeanDefinition</li>\n<li>RootBeanDefinition：无 Parent 的 BeanDefinition 或者合并后 BeanDefinition</li>\n<li>AnnotatedBeanDefinition：注解标注的 BeanDefinition</li>\n</ul>",r:{minutes:5.73,words:1719},t:"Spring 配置元数据",y:"a"}}],["/pages/ad472e/",{loader:()=>t.e(2075).then(t.bind(t,93739)),meta:{d:1671789489e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 应用上下文启动准备阶段</h2>\n<p>AbstractApplicationContext#prepareRefresh() 方法</p>\n<ul>\n<li>启动时间 - startupDate</li>\n<li>状态标识 - closed(false)、active(true)</li>\n<li>初始化 PropertySources - initPropertySources()</li>\n<li>检验 Environment 中必须属性</li>\n<li>初始化事件监听器集合</li>\n<li>初始化早期 Spring 事件集合</li>\n</ul>\n<h2>BeanFactory 创建阶段</h2>",r:{minutes:2.77,words:831},t:"Spring 应用上下文生命周期",y:"a"}}],["/pages/53aedb/",{loader:()=>t.e(4882).then(t.bind(t,60915)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","AOP"],e:"\n<h2>AOP 概念</h2>\n<h3>什么是 AOP</h3>\n<p>AOP(Aspect-Oriented Programming，即 <strong>面向切面编程</strong>)与 OOP( Object-Oriented Programming，面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角。</p>\n<p>在 OOP 中，我们以类(class)作为我们的基本单元，而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>\n<h3>术语</h3>\n<h4>Aspect(切面)</h4>\n<p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>\nAOP 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p>",r:{minutes:13.7,words:4109},t:"Spring AOP",y:"a"}}],["/pages/a1549f/",{loader:()=>t.e(2754).then(t.bind(t,74134)),meta:{d:1567626401e3,l:"2019年9月4日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Resource"],e:'\n<blockquote>\n<p>Version 6.0.3</p>\n</blockquote>\n<h2>Resource 接口</h2>\n<p>相对标准 URL 访问机制，Spring 的 <code>org.springframework.core.io.Resource</code> 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Resource</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> InputStreamSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> exists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isReadable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isOpen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    URL</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getURL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    URI</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getURI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    File</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ReadableByteChannel</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> readableChannel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> contentLength</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> lastModified</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    Resource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> createRelative</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> relativePath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getFilename</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getDescription</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:7.56,words:2269},t:"Spring 资源管理",y:"a"}}],["/pages/fe6aad/",{loader:()=>t.e(8555).then(t.bind(t,1332)),meta:{d:1671730948e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<p>Java API 规范(<code>JSR303</code>)定义了<code>Bean</code>校验的标准<code>validation-api</code>，但没有提供实现。<code>hibernate validation</code>是对这个规范的实现，并增加了校验注解如<code>@Email</code>、<code>@Length</code>等。<code>Spring Validation</code>是对<code>hibernate validation</code>的二次封装，用于支持<code>spring mvc</code>参数自动校验。</p>",r:{minutes:8.99,words:2696},t:"Spring 校验",y:"a"}}],["/pages/267b4c/",{loader:()=>t.e(6462).then(t.bind(t,34730)),meta:{d:1671737217e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","数据绑定"],e:'\n<p><strong>Spring 数据绑定(Data Binding)的作用是将用户的输入动态绑定到 JavaBean</strong>。换句话说，Spring 数据绑定机制是将属性值设置到目标对象中。</p>\n<p>在 Spring 中，数据绑定功能主要由 <code>DataBinder</code> 类实现。此外，<code>BeanWrapper</code> 也具有类似的功能，但 <code>DataBinder</code> 额外支持字段验证、字段格式化和绑定结果分析。</p>\n<figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230111150930.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',r:{minutes:3.22,words:967},t:"Spring 数据绑定",y:"a"}}],["/pages/6662dc/",{loader:()=>t.e(551).then(t.bind(t,15861)),meta:{d:1671738239e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 类型转换的实现</h2>\n<ul>\n<li>基于 JavaBeans 接口的类型转换实现\n<ul>\n<li>基于 java.beans.PropertyEditor 接口扩展</li>\n</ul>\n</li>\n<li>Spring 3.0+ 通用类型转换实现</li>\n</ul>\n<h2>使用场景</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>基于 JavaBeans 接口的类型转换实现</th>\n<th>Spring 3.0+ 通用类型转换实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据绑定</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>BeanWrapper</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Bean 属性类型转换</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>外部化属性类型转换</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>",r:{minutes:3.49,words:1047},t:"Spring 类型转换",y:"a"}}],["/pages/1f743f/",{loader:()=>t.e(4407).then(t.bind(t,93191)),meta:{d:1673555206e3,l:"2023年1月12日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:'\n<h2>参考资料</h2>\n<ul>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener noreferrer">Spring 官方文档之 Core Technologies</a></li>\n<li><a href="https://time.geekbang.org/course/intro/265" target="_blank" rel="noopener noreferrer">《小马哥讲 Spring 核心编程思想》</a></li>\n</ul>',r:{minutes:.22,words:66},t:"Spring EL 表达式",y:"a"}}],["/pages/cca414/",{loader:()=>t.e(6768).then(t.bind(t,12330)),meta:{d:1671741062e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Java 事件/监听器编程模型</h2>\n<p>设计模式 - 观察者模式扩展</p>\n<ul>\n<li>可观者对象（消息发送者） - java.util.Observable</li>\n<li>观察者 - java.util.Observer</li>\n</ul>\n<p>标准化接口</p>\n<ul>\n<li>事件对象 - java.util.EventObject</li>\n<li>事件监听器 - java.util.EventListener</li>\n</ul>\n<h2>面向接口的事件/监听器设计模式</h2>\n<p>事件/监听器场景举例</p>\n<table>\n<thead>\n<tr>\n<th>Java 技术规范</th>\n<th>事件接口</th>\n<th>监听器接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JavaBeans</td>\n<td>java.beans.PropertyChangeEvent</td>\n<td>java.beans.PropertyChangeListener</td>\n</tr>\n<tr>\n<td>Java AWT</td>\n<td>java.awt.event.MouseEvent</td>\n<td>java.awt.event.MouseListener</td>\n</tr>\n<tr>\n<td>Java Swing</td>\n<td>javax.swing.event.MenuEvent</td>\n<td>javax.swing.event.MenuListener</td>\n</tr>\n<tr>\n<td>Java Preference</td>\n<td>java.util.prefs.PreferenceChangeEvent</td>\n<td>java.util.prefs.PreferenceChangeListener</td>\n</tr>\n</tbody>\n</table>",r:{minutes:3.98,words:1194},t:"Spring 事件",y:"a"}}],["/pages/b5b8ad/",{loader:()=>t.e(7504).then(t.bind(t,32390)),meta:{d:1671709494e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 国际化使用场景</h2>\n<ul>\n<li>普通国际化文案</li>\n<li>Bean Validation 校验国际化文案</li>\n<li>Web 站点页面渲染</li>\n<li>Web MVC 错误消息提示</li>\n</ul>\n<h2>Spring 国际化接口</h2>\n<ul>\n<li>核心接口：<code>org.springframework.context.MessageSource</code></li>\n<li>主要概念\n<ul>\n<li>文案模板编码（code）</li>\n<li>文案模板参数（args）</li>\n<li>区域（Locale）</li>\n</ul>\n</li>\n</ul>",r:{minutes:1.69,words:507},t:"Spring 国际化",y:"a"}}],["/pages/175cbd/",{loader:()=>t.e(4736).then(t.bind(t,78724)),meta:{d:1671739912e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Java 泛型基础</h2>\n<p>泛型类型</p>\n<ul>\n<li>泛型类型是在类型上参数化的泛型类或接口</li>\n</ul>\n<p>泛型使用场景</p>\n<ul>\n<li>编译时强类型检查</li>\n<li>避免类型强转</li>\n<li>实现通用算法</li>\n</ul>\n<p>泛型类型擦写</p>\n<ul>\n<li>泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会<br>\n为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n<ul>\n<li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为<br>\n“Object”。因此，生成的字节码只包含普通类、接口和方法</li>\n<li>必要时插入类型转换以保持类型安全</li>\n<li>生成桥方法以保留扩展泛型类型中的多态性</li>\n</ul>\n</li>\n</ul>",r:{minutes:2.53,words:758},t:"Spring 泛型处理",y:"a"}}],["/pages/b6556f/",{loader:()=>t.e(6492).then(t.bind(t,37939)),meta:{d:1671786495e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 注解驱动编程发展历程</h2>\n<ul>\n<li>注解驱动启蒙时代：Spring Framework 1.x</li>\n<li>注解驱动过渡时代：Spring Framework 2.x</li>\n<li>注解驱动黄金时代：Spring Framework 3.x</li>\n<li>注解驱动完善时代：Spring Framework 4.x</li>\n<li>注解驱动当下时代：Spring Framework 5.x</li>\n</ul>\n<h2>Spring 核心注解场景分类</h2>\n<p>Spring 模式注解</p>\n<table>\n<thead>\n<tr>\n<th>Spring 注解</th>\n<th>场景说明</th>\n<th>起始版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Repository</td>\n<td>数据仓储模式注解</td>\n<td>2.0</td>\n</tr>\n<tr>\n<td>@Component</td>\n<td>通用组件模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Service</td>\n<td>服务模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Controller</td>\n<td>Web 控制器模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Configuration</td>\n<td>配置类模式注解</td>\n<td>3.0</td>\n</tr>\n</tbody>\n</table>",r:{minutes:2.48,words:745},t:"Spring 注解",y:"a"}}],["/pages/03d838/",{loader:()=>t.e(1592).then(t.bind(t,6554)),meta:{d:1671787664e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>理解 Spring Environment 抽象</h2>\n<p>统一的 Spring 配置属性管理</p>\n<p>Spring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）</p>\n<p>条件化 Spring Bean 装配管理</p>\n<p>通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean</p>\n<h2>Spring Environment 接口使用场景</h2>",r:{minutes:2.28,words:684},t:"Spring Environment 抽象",y:"a"}}],["/pages/950e4d/",{loader:()=>t.e(7887).then(t.bind(t,339)),meta:{d:1639160546e3,l:"2021年12月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>Spring Boot 简介</h2>\n<p>Spring Boot 可以让使用者非常方便的创建 Spring 应用。</p>\n<p>Spring Boot 的目标是：</p>\n<ul>\n<li>为所有 Spring 开发者提供更快且可广泛访问的入门体验。</li>\n<li>开箱即用</li>\n<li>提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）</li>\n<li>完全不需要代码生成，也不需要 XML 配置。</li>\n</ul>\n<h2>Spring Boot 系统要求</h2>\n<p>Spring Boot 的构建工具要求：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">Build Tool</th>\n<th style="text-align:left">Version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">Maven</td>\n<td style="text-align:left">3.5+</td>\n</tr>\n<tr>\n<td style="text-align:left">Gradle</td>\n<td style="text-align:left">6.8.x, 6.9.x, and 7.x</td>\n</tr>\n</tbody>\n</table>',r:{minutes:7.74,words:2321},t:"SpringBoot 之快速入门",y:"a"}}],["/pages/0fb992/",{loader:()=>t.e(7882).then(t.bind(t,33833)),meta:{d:1547121354e3,l:"2019年1月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>加载 property 顺序</h2>\n<p>Spring Boot 加载 property 顺序如下：</p>\n<ol>\n<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-globalsettings" target="_blank" rel="noopener noreferrer">Devtools 全局配置</a> (当 devtools 被激活 <code>~/.spring-boot-devtools.properties</code>).</li>\n<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener noreferrer">测试环境中的 <code>@TestPropertySource</code> 注解配置</a></li>\n<li>测试环境中的属性 <code>properties</code>：<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener noreferrer"><code>@SpringBootTest</code></a> 和 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener noreferrer">测试注解</a>.</li>\n<li>命令行参数</li>\n<li><code>SPRING_APPLICATION_JSON</code> 属性</li>\n<li><code>ServletConfig</code> 初始化参数</li>\n<li><code>ServletContext</code> 初始化参数</li>\n<li>JNDI attributes from 通过 <code>java:comp/env</code> 配置的 JNDI 属性</li>\n<li>Java 系统属性 (<code>System.getProperties()</code>)</li>\n<li>操作系统环境比那里</li>\n<li><code>RandomValuePropertySource</code> 加载 <code>random.*</code> 形式的属性</li>\n<li>jar 包外的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 配置</li>\n<li>jar 包内的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 配置</li>\n<li>jar 包外的 <code>application.properties</code> 或 <code>application.yml</code> 配置</li>\n<li>jar 包内的 <code>application.properties</code> 或 <code>application.yml</code> 配置</li>\n<li><code>@PropertySource</code> 绑定的配置</li>\n<li>默认属性 (通过 <code>SpringApplication.setDefaultProperties</code> 指定)</li>\n</ol>',r:{minutes:4.9,words:1470},t:"SpringBoot 之属性加载详解",y:"a"}}],["/pages/cb598e/",{loader:()=>t.e(9886).then(t.bind(t,73723)),meta:{d:1574088901e3,l:"2019年11月18日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:"\n<blockquote>\n<p>一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。</p>\n<p>关键词： <code>@Profile</code>、<code>spring.profiles.active</code></p>\n</blockquote>\n<h2>区分环境的配置</h2>\n<h3>properties 配置</h3>\n<p>假设，一个应用的工作环境有：dev、test、prod</p>\n<p>那么，我们可以添加 4 个配置文件：</p>\n<ul>\n<li><code>applcation.properties</code> - 公共配置</li>\n<li><code>application-dev.properties</code> - 开发环境配置</li>\n<li><code>application-test.properties</code> - 测试环境配置</li>\n<li><code>application-prod.properties</code> - 生产环境配置</li>\n</ul>",r:{minutes:1.92,words:575},t:"SpringBoot 之 Profile",y:"a"}}],["/pages/5e7c20/",{loader:()=>t.e(2508).then(t.bind(t,19115)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<blockquote>\n<p>章节主要针对：Spring &amp; Spring Boot 框架的核心技术。如；Spring Bean、IoC、依赖查找、依赖注入、AOP、数据绑定、资源管理等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html" target="_blank">Spring Bean</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html" target="_blank">Spring IoC</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html" target="_blank">Spring 依赖查找</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html" target="_blank">Spring 依赖注入</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html" target="_blank">Spring IoC 依赖来源</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html" target="_blank">Spring Bean 作用域</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" target="_blank">Spring Bean 生命周期</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html" target="_blank">Spring 配置元数据</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html" target="_blank">Spring AOP</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html" target="_blank">Spring 资源管理</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html" target="_blank">Spring 校验</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html" target="_blank">Spring 数据绑定</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html" target="_blank">Spring 类型转换</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html" target="_blank">Spring EL 表达式</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html" target="_blank">Spring 事件</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html" target="_blank">Spring 国际化</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html" target="_blank">Spring 泛型处理</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html" target="_blank">Spring 注解</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" target="_blank">SpringBoot 教程之快速入门</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html" target="_blank">SpringBoot 之属性加载</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html" target="_blank">SpringBoot 之 Profile</a></li>\n</ul>',r:{minutes:1.15,words:344},t:"Spring 核心",y:"a"}}],["/pages/1b774c/",{loader:()=>t.e(7106).then(t.bind(t,49977)),meta:{d:1508491675e3,l:"2017年10月20日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","数据库","DataSource"],e:'\n<blockquote>\n<p>本文基于 Spring Boot 2.7.3 版本。</p>\n</blockquote>\n<h2>Spring Boot 数据源基本配置</h2>\n<p>Spring Boot 提供了一系列 <code>spring.datasource.*</code> 配置来控制 <code>DataSource</code> 的配置。用户可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中指定数据源配置。这些配置项维护在 <a href="https://github.com/spring-projects/spring-boot/tree/v2.7.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java" target="_blank" rel="noopener noreferrer"><code>DataSourceProperties</code></a> 。</p>',r:{minutes:10.39,words:3117},t:"Spring 之数据源",y:"a"}}],["/pages/cf19fd/",{loader:()=>t.e(6435).then(t.bind(t,55490)),meta:{d:1550500435e3,l:"2019年2月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","JDBC","JdbcTemplate"],e:"\n<p>JDBC 是 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。</p>\n<h2>JDBC 入门示例</h2>\n<p>JDBC 的工作步骤大致如下：</p>\n<ol>\n<li>创建实体类。</li>\n<li>声明数据库读写接口的 DAO 接口。定义 DAO 的好处在于对于数据层上层的业务，调用 DAO 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。</li>\n<li>创建一个 DAO 接口的实现类，使用 Spring 的 JDBC 模板去实现接口。</li>\n<li>最后，定义一个 DAO 接口的实现类的 JavaBean，并将数据源注入进去。</li>\n</ol>",r:{minutes:9.71,words:2912},t:"Spring 之 JDBC",y:"a"}}],["/pages/128c54/",{loader:()=>t.e(9881).then(t.bind(t,57365)),meta:{d:1663832809e3,l:"2022年9月22日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","事务"],e:"\n<p>Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 <code>@Transactional</code> 注解，即可一键开启方法的事务性配置。</p>\n<h2>理解事务</h2>\n<p>在软件开发领域，全有或全无的操作被称为<strong>事务（transaction）</strong>。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：<strong>全局事务</strong>或<strong>本地事务</strong>，两者都有很大的局限性。</p>",r:{minutes:43.32,words:12995},t:"Spring 之事务",y:"a"}}],["/pages/a03d7b/",{loader:()=>t.e(4429).then(t.bind(t,62350)),meta:{d:1550500435e3,l:"2019年2月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","JPA"],e:'\n<p>JPA 为对象关系映射提供了一种基于 POJO 的持久化模型。</p>\n<ul>\n<li>简化数据持久化代码的开发</li>\n<li>为 Java 社区屏蔽不同持久化 API 的差异</li>\n</ul>\n<h2>快速入门</h2>\n<p>（1）在 pom.xml 中引入依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-data-jpa&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:10.65,words:3196},t:"Spring 之 JPA",y:"a"}}],["/pages/88219e/",{loader:()=>t.e(6405).then(t.bind(t,28065)),meta:{d:1557421765e3,l:"2019年5月9日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","MyBatis","PageHelper","Mapper"],e:'\n<p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener noreferrer">Mybatis 官网</a> 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<h2>快速入门</h2>\n<p>要使用 MyBatis， 只需将 <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener noreferrer">mybatis-x.x.x.jar</a> 文件置于类路径（classpath）中即可。</p>',r:{minutes:11.95,words:3586},t:"Spring 集成 Mybatis",y:"a"}}],["/pages/191cdb/",{loader:()=>t.e(8742).then(t.bind(t,51291)),meta:{d:1675847435e3,l:"2023年2月8日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot"],e:"\n<p>Spring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。</p>\n<h2>核心概念</h2>\n<p>Repository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。<code>CrudRepository</code> 和 <code>ListCrudRepository</code> 接口为被管理的实体类提供复杂的 CRUD 功能。<code>ListCrudRepository</code> 提供等效方法，但它们返回 <code>List</code>，而 <code>CrudRepository</code> 方法返回 <code>Iterable</code>。</p>",r:{minutes:6.76,words:2028},t:"Spring Data 综合",y:"a"}}],["/pages/65e4a2/",{loader:()=>t.e(97).then(t.bind(t,28752)),meta:{d:1675198482e3,l:"2023年1月31日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","Redis"],e:'\n<h2>简介</h2>\n<p><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。</p>\n<p>在 Spring 中，<a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener noreferrer">spring-data-redis</a> 项目对访问 <a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> 进行了 API 封装，提供了便捷的访问方式。 <a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener noreferrer">spring-data-redis</a></p>',r:{minutes:2.58,words:773},t:"Spring 访问 Redis",y:"a"}}],["/pages/db2a41/",{loader:()=>t.e(6258).then(t.bind(t,697)),meta:{d:1544894976e3,l:"2018年12月15日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","MongoDB"],e:'\n<h2>简介</h2>\n<p><a href="https://www.mongodb.org/" target="_blank" rel="noopener noreferrer">MongoDB</a> 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>\n<p>在 Spring 中，<a href="https://github.com/spring-projects/spring-data-mongodb" target="_blank" rel="noopener noreferrer">spring-data-mongodb</a> 项目对访问 <a href="https://www.mongodb.org/" target="_blank" rel="noopener noreferrer">MongoDB</a> 进行了 API 封装，提供了便捷的访问方式。 Spring Data MongoDB 的核心是一个以 POJO 为中心的模型，用于与 MongoDB <code>DBCollection</code> 交互并轻松编写 <code>Repository</code> 样式的数据访问层。</p>',r:{minutes:2.73,words:819},t:"Spring 访问 MongoDB",y:"a"}}],["/pages/fac14c/",{loader:()=>t.e(9638).then(t.bind(t,56481)),meta:{d:1545746796e3,l:"2018年12月25日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","Elasticsearch"],e:'\n<h2>简介</h2>\n<p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer">Elasticsearch</a> 是一个开源的、分布式的搜索和分析引擎。</p>\n<h3>通过 REST 客户端连接 Elasticsearch</h3>\n<p>如果在 classpath 路径下存在 <code>org.elasticsearch.client:elasticsearch-rest-client</code> jar 包，Spring Boot 会自动配置并注册一个 <code>RestClient</code> Bean，它的默认访问路径为：<code>localhost:9200</code>。</p>',r:{minutes:2.36,words:709},t:"Spring 访问 Elasticsearch",y:"a"}}],["/pages/b912d1/",{loader:()=>t.e(7143).then(t.bind(t,90665)),meta:{d:1663499136e3,l:"2022年9月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","数据库"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html" target="_blank">Spring 之数据源</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html" target="_blank">Spring 之 JDBC</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html" target="_blank">Spring 之事务</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html" target="_blank">Spring 之 JPA</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html" target="_blank">Spring 集成 Mybatis</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html" target="_blank">Spring 访问 Redis</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html" target="_blank">Spring 访问 MongoDB</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html" target="_blank">Spring 访问 Elasticsearch</a></li>\n</ul>',r:{minutes:2.09,words:628},t:"Spring 数据篇",y:"a"}}],["/pages/65351b/",{loader:()=>t.e(5372).then(t.bind(t,12372)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web"],e:'\n<h2>快速入门</h2>\n<p>下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。</p>\n<p>（1）<code>pom.xml</code> 中引入依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-web&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.42,words:727},t:"Spring Web 综述",y:"a"}}],["/pages/5d002f/",{loader:()=>t.e(3379).then(t.bind(t,49189)),meta:{d:1676402482e3,l:"2023年2月14日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","Controller"],e:'\n<p>Spring MVC 提供了一种基于注解的编程模型，<code>@Controller</code> 和 <code>@RestController</code> 组件使用注解来表达请求映射、请求输入、异常处理等。注解控制器具有灵活的方法签名，并且不必扩展基类或实现特定接口。以下示例显示了一个由注解定义的控制器：</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">Controller</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> HelloController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">GetMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"/hello"</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> handle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Model</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> model</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B">        model</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">addAttribute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"message"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"Hello World!"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> "index"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:23.03,words:6909},t:"Spring Web 应用",y:"a"}}],["/pages/20287b/",{loader:()=>t.e(1259).then(t.bind(t,65465)),meta:{d:1676282272e3,l:"2023年2月13日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","DispatcherServlet"],e:'\n<h2>简介</h2>\n<p><code>DispatcherServlet</code> 是 Spring MVC 框架的核心组件，负责将<strong>客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果</strong>。</p>\n<h3>DispatcherServlet 工作原理</h3>\n<h4>DispatcherServlet 工作流程</h4>\n<p><code>DispatcherServlet</code> 的工作流程大致如下图所示：</p>\n<figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',r:{minutes:25.97,words:7791},t:"Spring MVC 之 DispatcherServlet",y:"a"}}],["/pages/4a164d/",{loader:()=>t.e(5842).then(t.bind(t,89148)),meta:{d:1676396649e3,l:"2023年2月14日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","Filter"],e:'\n<p><code>spring-web</code> 模块提供了一些有用的 Filter：</p>\n<ul>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-http-put" target="_blank" rel="noopener noreferrer">Form Data</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-forwarded-headers" target="_blank" rel="noopener noreferrer">Forwarded Headers</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-shallow-etag" target="_blank" rel="noopener noreferrer">Shallow ETag</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-cors" target="_blank" rel="noopener noreferrer">CORS</a></li>\n</ul>',r:{minutes:3.26,words:979},t:"Spring MVC 之过滤器",y:"a"}}],["/pages/1d2954/",{loader:()=>t.e(1987).then(t.bind(t,70579)),meta:{d:1676579606e3,l:"2023年2月16日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","CORS"],e:'\n<p>Spring MVC 支持跨域处理（CORS）。</p>\n<h2>简介</h2>\n<p>出于安全原因，浏览器禁止对当前源之外的资源进行 AJAX 调用。例如，可以在一个选项卡中使用您的银行帐户，而在另一个选项卡中使用 <a href="http://evil.com" target="_blank" rel="noopener noreferrer">evil.com</a>。来自 <a href="http://evil.com" target="_blank" rel="noopener noreferrer">evil.com</a> 的脚本不应该能够使用您的凭据向您的银行 API 发出 AJAX 请求——例如从您的账户中取款！</p>',r:{minutes:4.7,words:1409},t:"Spring MVC 之跨域",y:"a"}}],["/pages/251e31/",{loader:()=>t.e(8345).then(t.bind(t,35580)),meta:{d:1676632885e3,l:"2023年2月17日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","View"],e:'\n<p>Spring MVC 中视图技术的使用是可插拔的。无论决定使用 Thymeleaf、Groovy 等模板引擎、JSP 还是其他技术，都可以通过配置来更改。</p>\n<p>Spring MVC 的视图位于该应用程序的内部信任边界内。 视图可以访问应用程序上下文的所有 bean。 因此，不建议在模板可由外部源编辑的应用程序中使用 Spring MVC 的模板支持，因为这可能会产生安全隐患。</p>\n<h2>Thymeleaf</h2>\n<p><a href="https://www.thymeleaf.org/" target="_blank" rel="noopener noreferrer">Thymeleaf</a> 是一个现代服务器端 Java 模板引擎，它强调自然的 HTML 模板，可以通过双击在浏览器中预览，而无需运行服务器，这对于 UI 模板的独立工作（例如，由设计师）非常有帮助。</p>',r:{minutes:19.63,words:5888},t:"Spring MVC 之视图技术",y:"a"}}],["/pages/ad0516/",{loader:()=>t.e(3599).then(t.bind(t,42854)),meta:{d:1546967974e3,l:"2019年1月8日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","SpringBoot","Web"],e:"\n<blockquote>\n<p>EasyUI 是一个简单的用户界面组件的集合。由于 EasyUI 已经封装好大部分 UI 基本功能，能帮用户减少大量的 js 和 css 代码。所以，EasyUI 非常适合用于开发简单的系统或原型系统。</p>\n<p>本文示例使用技术点：</p>\n<ul>\n<li>Spring Boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa</li>\n<li>EasyUI：按需加载，并没有引入所有的 EasyUI 特性</li>\n<li>数据库：为了测试方便，使用 H2</li>\n</ul>\n</blockquote>",r:{minutes:4.71,words:1413},t:"SpringBoot 之应用 EasyUI",y:"a"}}],["/pages/e2586a/",{loader:()=>t.e(6929).then(t.bind(t,80247)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","SpringBoot","Web"],e:'\n<blockquote>\n<p>章节主要针对：Spring 在 web 领域的应用。如：Spring MVC、WebSocket 等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/01.SpringWeb%E7%BB%BC%E8%BF%B0.html" target="_blank">SpringWeb 综述</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/02.SpringWeb%E5%BA%94%E7%94%A8.html" target="_blank">SpringWeb 应用</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/03.DispatcherServlet.html" target="_blank">DispatcherServlet</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/04.Spring%E8%BF%87%E6%BB%A4%E5%99%A8.html" target="_blank">Spring 过滤器</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/05.Spring%E8%B7%A8%E5%9F%9F.html" target="_blank">Spring 跨域</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/06.Spring%E8%A7%86%E5%9B%BE.html" target="_blank">Spring 视图</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html" target="_blank">SpringBoot 之应用 EasyUI</a></li>\n</ul>',r:{minutes:.6,words:179},t:"Spring Web",y:"a"}}],["/pages/92add2/",{loader:()=>t.e(8610).then(t.bind(t,82199)),meta:{d:1574088901e3,l:"2019年11月18日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","异步"],e:'\n<h2><code>@EnableAsync</code> 注解</h2>\n<p>要使用 <code>@Async</code>，首先需要使用 <code>@EnableAsync</code> 注解开启 Spring Boot 中的异步特性。</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">Configuration</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">EnableAsync</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3,words:899},t:"spring-boot-async",y:"a"}}],["/pages/676725/",{loader:()=>t.e(8323).then(t.bind(t,35749)),meta:{d:1546208656e3,l:"2018年12月30日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","JSON"],e:"\n<h2>简介</h2>\n<h3>Spring Boot 支持的 Json 库</h3>\n<p>Spring Boot 支持三种 Json 库：</p>\n<ul>\n<li>Gson</li>\n<li>Jackson</li>\n<li>JSON-B</li>\n</ul>\n<p><strong>Jackson 是 Spring Boot 官方推荐的默认库。</strong></p>\n<p>Spring Boot 提供了 Jackson 的自动配置，Jackson 是 <code>spring-boot-starter-json</code> 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。</p>",r:{minutes:5.75,words:1726},t:"SpringBoot 之集成 Json",y:"a"}}],["/pages/2586f1/",{loader:()=>t.e(3568).then(t.bind(t,67723)),meta:{d:1574263244e3,l:"2019年11月20日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","邮件"],e:'\n<h2>简介</h2>\n<p>Spring Boot 收发邮件最简便方式是通过 <code>spring-boot-starter-mail</code>。</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-mail&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.96,words:889},t:"SpringBoot 之发送邮件",y:"a"}}],["/pages/56581b/",{loader:()=>t.e(83).then(t.bind(t,32110)),meta:{d:166350084e4,l:"2022年9月18日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","IO"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/04-SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html" target="_blank">SpringBoot 之异步请求</a></li>\n<li><a href="/blog/posts/java/spring/04-SpringIO/02.SpringBoot%E4%B9%8BJson.html" target="_blank">SpringBoot 之 Json</a></li>\n<li><a href="/blog/posts/java/spring/04-SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html" target="_blank">SpringBoot 之邮件</a></li>\n</ul>',r:{minutes:.46,words:139},t:"Spring IO",y:"a"}}],["/pages/a311cb/",{loader:()=>t.e(7289).then(t.bind(t,87073)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","缓存"],e:'\n<blockquote>\n<p>Spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。</p>\n</blockquote>\n<h2>缓存接口</h2>\n<p>Spring 的缓存 API 以注解方式提供。</p>\n<h3>开启注解</h3>\n<p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。<br>\n你有两个选择：<br>\n(1) 在 xml 中声明<br>\n像上一节 spring-ehcache.xml 中的做法一样，使用<code>&lt;cache:annotation-driven/&gt;</code></p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">cache:annotation-driven</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> cache-manager</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"cacheManager"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">/&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div>',r:{minutes:4.08,words:1223},t:"Spring集成缓存",y:"a"}}],["/pages/a187f0/",{loader:()=>t.e(3591).then(t.bind(t,634)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","调度器"],e:'\n<h2>概述</h2>\n<p>如果想在 Spring 中使用任务调度功能，除了集成调度框架 Quartz 这种方式，也可以使用 Spring 自己的调度任务框架。<br>\n使用 Spring 的调度框架，优点是：支持注解<code>@Scheduler</code>，可以省去大量的配置。</p>\n<h2>实时触发调度任务</h2>\n<h3>TaskScheduler 接口</h3>\n<p>Spring3 引入了<code>TaskScheduler</code>接口，这个接口定义了调度任务的抽象方法。<br>\nTaskScheduler 接口的声明：</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> TaskScheduler</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> schedule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Trigger</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> trigger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> schedule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleAtFixedRate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> period</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleAtFixedRate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> period</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleWithFixedDelay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> delay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleWithFixedDelay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> delay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:6.67,words:2002},t:"Spring 集成调度器",y:"a"}}],["/pages/274fd7/",{loader:()=>t.e(4334).then(t.bind(t,83988)),meta:{d:1509125441e3,l:"2017年10月27日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","Dubbo"],e:'\n<h2>ZooKeeper</h2>\n<p>ZooKeeper 可以作为 Dubbo 的注册中心。</p>\n<p>Dubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。</p>\n<p><strong>安装</strong></p>\n<p>在 <a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener noreferrer">ZooKeeper 发布中心</a> 选择需要的版本，下载后解压到本地。</p>',r:{minutes:3.64,words:1091},t:"Spring集成Dubbo",y:"a"}}],["/pages/d6025b/",{loader:()=>t.e(8049).then(t.bind(t,79442)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","SpringBoot","集成"],e:'\n<blockquote>\n<p>章节主要针对：Spring 与第三方框架、库集成。如：Cache、Scheduling、JMS、JMX 等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html" target="_blank">Spring 集成缓存中间件</a></li>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html" target="_blank">Spring 集成定时任务中间件</a></li>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html" target="_blank">Spring 集成 Dubbo</a></li>\n</ul>',r:{minutes:.59,words:177},t:"Spring 集成",y:"a"}}],["/pages/568352/",{loader:()=>t.e(2871).then(t.bind(t,15712)),meta:{d:1620930116e3,l:"2021年5月13日",c:["Java","框架","Spring","Spring安全"],g:["Java","框架","Spring","SpringBoot","安全"],e:'\n<h2>QuickStart</h2>\n<p>（1）添加依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-web&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-security&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:.46,words:138},t:"SpringBoot 之安全快速入门",y:"a"}}],["/pages/752c6a/",{loader:()=>t.e(8768).then(t.bind(t,38339)),meta:{d:1513350632e3,l:"2017年12月15日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring"],e:"\n<h2>前言</h2>\n<p>最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 JDK8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。</p>\n<p>总之，这是个费劲的活啊。</p>\n<p>本文小结一下升级 Spring4 的连锁问题。</p>\n<h2>为什么升级 spring4</h2>\n<p>升级 Spring4 的原因是：Spring 4 以前的版本不兼容 JDK8。当你的项目同时使用 Spring3 和 JDK8，如果代码中有使用 JDK8 字节码或 Lambada 表达式，那么会出问题。</p>",r:{minutes:7.37,words:2210},t:"Spring 4 升级踩雷指南",y:"a"}}],["/pages/bac2ce/",{loader:()=>t.e(8242).then(t.bind(t,12395)),meta:{d:1545434564e3,l:"2018年12月21日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>简介</h2>\n<p>Spring Boot 启动时默认会显示以下 LOGO：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  .   ____          _            __ _ _</span></span>\n<span class="line"><span> /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</span></span>\n<span class="line"><span>( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\</span></span>\n<span class="line"><span> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span></span>\n<span class="line"><span>  \'  |____| .__|_| |_|_| |_\\__, | / / / /</span></span>\n<span class="line"><span> =========|_|==============|___/=/_/_/_/</span></span>\n<span class="line"><span> :: Spring Boot ::        (v2.1.1.RELEASE)</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.42,words:727},t:"SpringBoot 之 banner 定制",y:"a"}}],["/pages/c013cc/",{loader:()=>t.e(6251).then(t.bind(t,41863)),meta:{d:1655239882e3,l:"2022年6月14日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener noreferrer"><code>spring-boot-actuator</code></a> 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 <code>spring-boot-starter-actuator</code> 依赖。</p>\n<p>如果是 Maven 项目，添加以下依赖：</p>',r:{minutes:9.96,words:2988},t:"SpringBoot Actuator 快速入门",y:"a"}}],["/pages/6bb8c1/",{loader:()=>t.e(8288).then(t.bind(t,86304)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html" target="_blank">Spring4 升级</a></li>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html" target="_blank">SpringBoot 之 banner</a></li>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html" target="_blank">SpringBoot 之 Actuator</a></li>\n</ul>',r:{minutes:.44,words:133},t:"Spring 其他",y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html",{loader:()=>t.e(8805).then(t.bind(t,47631)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>日志</p>\n",r:{minutes:1.91,words:573},t:"日志",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",{loader:()=>t.e(4198).then(t.bind(t,72581)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>类加载器</p>\n",r:{minutes:4.07,words:1220},t:"类加载器",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html",{loader:()=>t.e(6679).then(t.bind(t,54101)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>xml</p>\n",r:{minutes:9.68,words:2905},t:"xml",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",{loader:()=>t.e(1148).then(t.bind(t,77365)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>单元测试Junit</p>\n",r:{minutes:4.05,words:1216},t:"单元测试Junit",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html",{loader:()=>t.e(5825).then(t.bind(t,12741)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>注解</p>\n",r:{minutes:3.29,words:988},t:"注解",i:"pen-to-square",O:1,y:"a"}}],["/404.html",{loader:()=>t.e(7490).then(t.bind(t,81489)),meta:{t:""}}],["/posts/",{loader:()=>t.e(8666).then(t.bind(t,18063)),meta:{t:"Posts"}}],["/posts/linux/",{loader:()=>t.e(1343).then(t.bind(t,29772)),meta:{t:"Linux"}}],["/posts/idea/",{loader:()=>t.e(9824).then(t.bind(t,21838)),meta:{t:"Idea"}}],["/posts/mysql/",{loader:()=>t.e(3191).then(t.bind(t,25626)),meta:{t:"Mysql"}}],["/posts/network/",{loader:()=>t.e(183).then(t.bind(t,45998)),meta:{t:"Network"}}],["/posts/redis/",{loader:()=>t.e(2110).then(t.bind(t,58243)),meta:{t:"Redis"}}],["/posts/shell/",{loader:()=>t.e(5443).then(t.bind(t,95748)),meta:{t:"Shell"}}],["/posts/windows/",{loader:()=>t.e(2912).then(t.bind(t,72190)),meta:{t:"Windows"}}],["/posts/java/basic/",{loader:()=>t.e(3086).then(t.bind(t,33465)),meta:{t:"Basic"}}],["/posts/java/",{loader:()=>t.e(4895).then(t.bind(t,31919)),meta:{t:"Java"}}],["/posts/java/bug/",{loader:()=>t.e(5489).then(t.bind(t,89461)),meta:{t:"Bug"}}],["/posts/java/dependence/",{loader:()=>t.e(1133).then(t.bind(t,28682)),meta:{t:"Dependence"}}],["/posts/java/netty/",{loader:()=>t.e(584).then(t.bind(t,21103)),meta:{t:"Netty"}}],["/posts/java/spring/",{loader:()=>t.e(9385).then(t.bind(t,85793)),meta:{t:"Spring"}}],["/posts/java/springboot/",{loader:()=>t.e(861).then(t.bind(t,29432)),meta:{t:"Springboot"}}],["/posts/java/web/",{loader:()=>t.e(8458).then(t.bind(t,83749)),meta:{t:"Web"}}],["/posts/python/django/",{loader:()=>t.e(3521).then(t.bind(t,12691)),meta:{t:"Django"}}],["/posts/python/",{loader:()=>t.e(1285).then(t.bind(t,65169)),meta:{t:"Python"}}],["/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/",{loader:()=>t.e(6350).then(t.bind(t,731)),meta:{t:"01 Java入门"}}],["/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/",{loader:()=>t.e(451).then(t.bind(t,84459)),meta:{t:"02 Java基础概念"}}],["/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/",{loader:()=>t.e(4970).then(t.bind(t,36991)),meta:{t:"03 Java运算符"}}],["/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/",{loader:()=>t.e(7060).then(t.bind(t,75751)),meta:{t:"04 判断和循环"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/",{loader:()=>t.e(9143).then(t.bind(t,20219)),meta:{t:"05 循环高级和数组"}}],["/posts/java/basic/06-%E6%96%B9%E6%B3%95/",{loader:()=>t.e(9794).then(t.bind(t,39713)),meta:{t:"06 方法"}}],["/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/",{loader:()=>t.e(5622).then(t.bind(t,267)),meta:{t:"07 综合练习"}}],["/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",{loader:()=>t.e(5345).then(t.bind(t,66304)),meta:{t:"08 面向对象"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/",{loader:()=>t.e(6752).then(t.bind(t,36934)),meta:{t:"09 面向对象综合训练"}}],["/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/",{loader:()=>t.e(6658).then(t.bind(t,9578)),meta:{t:"10 字符串"}}],["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",{loader:()=>t.e(3113).then(t.bind(t,24305)),meta:{t:"11 集合 学生管理系统"}}],["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/",{loader:()=>t.e(3992).then(t.bind(t,20591)),meta:{t:"13 面向对象进阶（static 继承）"}}],["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/",{loader:()=>t.e(7694).then(t.bind(t,26475)),meta:{t:"14 面向对象进阶（多态 包 Final 权限修饰符 代码块）"}}],["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/",{loader:()=>t.e(5522).then(t.bind(t,56902)),meta:{t:"15 面向对象进阶（抽象类 接口 内部类）"}}],["/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/",{loader:()=>t.e(7048).then(t.bind(t,62421)),meta:{t:"16 面向对象综合练习（上）"}}],["/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/",{loader:()=>t.e(122).then(t.bind(t,71342)),meta:{t:"17 面向对象综合练习（下）"}}],["/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/",{loader:()=>t.e(1340).then(t.bind(t,83657)),meta:{t:"18 API（常见 API，对象克隆）"}}],["/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/",{loader:()=>t.e(250).then(t.bind(t,43069)),meta:{t:"19 API（正则表达式）"}}],["/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",{loader:()=>t.e(1239).then(t.bind(t,68503)),meta:{t:"20 API（时间，包装类，练习）"}}],["/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",{loader:()=>t.e(5710).then(t.bind(t,30001)),meta:{t:"21 API（算法，lambda，练习）"}}],["/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/",{loader:()=>t.e(637).then(t.bind(t,56887)),meta:{t:"22 集合（ List集合）"}}],["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/",{loader:()=>t.e(4377).then(t.bind(t,20898)),meta:{t:"23 集合（泛型 Set 数据结构）"}}],["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/",{loader:()=>t.e(9283).then(t.bind(t,60465)),meta:{t:"24 集合（ Map 可变参数 集合工具类）"}}],["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/",{loader:()=>t.e(6905).then(t.bind(t,7784)),meta:{t:"25 阶段项目（综合练习 Doudizhu游戏）"}}],["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/",{loader:()=>t.e(5746).then(t.bind(t,97715)),meta:{t:"26 集合（ Stream流 方法引用）"}}],["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/",{loader:()=>t.e(5437).then(t.bind(t,46019)),meta:{t:"27 IO(异常 File 综合案例）"}}],["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/",{loader:()=>t.e(1158).then(t.bind(t,62624)),meta:{t:"28 IO（字节流 字符流）"}}],["/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/",{loader:()=>t.e(8613).then(t.bind(t,12925)),meta:{t:"29 IO（其他流）"}}],["/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/",{loader:()=>t.e(1181).then(t.bind(t,3318)),meta:{t:"30 多线程"}}],["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/",{loader:()=>t.e(1843).then(t.bind(t,63030)),meta:{t:"31 多线程 Juc"}}],["/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",{loader:()=>t.e(4787).then(t.bind(t,97379)),meta:{t:"32 网络编程"}}],["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/",{loader:()=>t.e(524).then(t.bind(t,56350)),meta:{t:"33 基础加强（反射，动态代理）"}}],["/pages/",{loader:()=>t.e(3713).then(t.bind(t,80510)),meta:{t:"Pages"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/",{loader:()=>t.e(8295).then(t.bind(t,26139)),meta:{t:"01 Log日志"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/",{loader:()=>t.e(7870).then(t.bind(t,44715)),meta:{t:"34 基础加强（日志，类加载器，单元测试，xml，注解）"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",{loader:()=>t.e(8990).then(t.bind(t,69814)),meta:{t:"02 类加载器"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/",{loader:()=>t.e(4726).then(t.bind(t,42302)),meta:{t:"03 Xml"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",{loader:()=>t.e(754).then(t.bind(t,34689)),meta:{t:"04 单元测试"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/",{loader:()=>t.e(4854).then(t.bind(t,12472)),meta:{t:"05 注解"}}],["/category/",{loader:()=>t.e(3583).then(t.bind(t,3233)),meta:{t:"分类",I:!1}}],["/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>t.e(4021).then(t.bind(t,37062)),meta:{t:"使用指南 分类",I:!1}}],["/category/linux/",{loader:()=>t.e(8654).then(t.bind(t,70332)),meta:{t:"linux 分类",I:!1}}],["/category/idea/",{loader:()=>t.e(739).then(t.bind(t,64336)),meta:{t:"idea 分类",I:!1}}],["/category/mysql/",{loader:()=>t.e(1006).then(t.bind(t,37667)),meta:{t:"mysql 分类",I:!1}}],["/category/java/",{loader:()=>t.e(8236).then(t.bind(t,1730)),meta:{t:"java 分类",I:!1}}],["/category/network/",{loader:()=>t.e(150).then(t.bind(t,3942)),meta:{t:"network 分类",I:!1}}],["/category/redis/",{loader:()=>t.e(7).then(t.bind(t,21902)),meta:{t:"redis 分类",I:!1}}],["/category/windows/",{loader:()=>t.e(433).then(t.bind(t,93729)),meta:{t:"windows 分类",I:!1}}],["/category/dependence/",{loader:()=>t.e(7053).then(t.bind(t,32087)),meta:{t:"dependence 分类",I:!1}}],["/category/spring/",{loader:()=>t.e(9097).then(t.bind(t,97494)),meta:{t:"spring 分类",I:!1}}],["/category/python/",{loader:()=>t.e(1034).then(t.bind(t,99983)),meta:{t:"python 分类",I:!1}}],["/category/java/",{loader:()=>t.e(8236).then(t.bind(t,1730)),meta:{t:"Java 分类",I:!1}}],["/category/%E6%A1%86%E6%9E%B6/",{loader:()=>t.e(168).then(t.bind(t,18056)),meta:{t:"框架 分类",I:!1}}],["/category/spring/",{loader:()=>t.e(9097).then(t.bind(t,97494)),meta:{t:"Spring 分类",I:!1}}],["/category/spring%E7%BB%BC%E5%90%88/",{loader:()=>t.e(797).then(t.bind(t,48482)),meta:{t:"Spring综合 分类",I:!1}}],["/category/spring%E6%A0%B8%E5%BF%83/",{loader:()=>t.e(5164).then(t.bind(t,2936)),meta:{t:"Spring核心 分类",I:!1}}],["/category/spring%E6%95%B0%E6%8D%AE/",{loader:()=>t.e(6815).then(t.bind(t,33068)),meta:{t:"Spring数据 分类",I:!1}}],["/category/springweb/",{loader:()=>t.e(6729).then(t.bind(t,81638)),meta:{t:"SpringWeb 分类",I:!1}}],["/category/springio/",{loader:()=>t.e(7345).then(t.bind(t,50976)),meta:{t:"SpringIO 分类",I:!1}}],["/category/spring%E9%9B%86%E6%88%90/",{loader:()=>t.e(7975).then(t.bind(t,61837)),meta:{t:"Spring集成 分类",I:!1}}],["/category/spring%E5%AE%89%E5%85%A8/",{loader:()=>t.e(3912).then(t.bind(t,25392)),meta:{t:"Spring安全 分类",I:!1}}],["/category/spring%E5%85%B6%E4%BB%96/",{loader:()=>t.e(769).then(t.bind(t,71118)),meta:{t:"Spring其他 分类",I:!1}}],["/tag/",{loader:()=>t.e(1797).then(t.bind(t,60951)),meta:{t:"标签",I:!1}}],["/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",{loader:()=>t.e(602).then(t.bind(t,99462)),meta:{t:"标签: 页面配置",I:!1}}],["/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>t.e(1431).then(t.bind(t,8210)),meta:{t:"标签: 使用指南",I:!1}}],["/tag/linux/",{loader:()=>t.e(4316).then(t.bind(t,45922)),meta:{t:"标签: linux",I:!1}}],["/tag/tomcat/",{loader:()=>t.e(1986).then(t.bind(t,75925)),meta:{t:"标签: tomcat",I:!1}}],["/tag/shell/",{loader:()=>t.e(472).then(t.bind(t,42614)),meta:{t:"标签: shell",I:!1}}],["/tag/sql/",{loader:()=>t.e(5374).then(t.bind(t,60071)),meta:{t:"标签: sql",I:!1}}],["/tag/bug/",{loader:()=>t.e(6504).then(t.bind(t,12914)),meta:{t:"标签: bug",I:!1}}],["/tag/internet/",{loader:()=>t.e(9375).then(t.bind(t,74062)),meta:{t:"标签: internet",I:!1}}],["/tag/java/",{loader:()=>t.e(7869).then(t.bind(t,53691)),meta:{t:"标签: java",I:!1}}],["/tag/spring/",{loader:()=>t.e(6847).then(t.bind(t,40551)),meta:{t:"标签: spring",I:!1}}],["/tag/springboot/",{loader:()=>t.e(1159).then(t.bind(t,73821)),meta:{t:"标签: springboot",I:!1}}],["/tag/redis/",{loader:()=>t.e(8857).then(t.bind(t,41774)),meta:{t:"标签: redis",I:!1}}],["/tag/script/",{loader:()=>t.e(9969).then(t.bind(t,80696)),meta:{t:"标签: script",I:!1}}],["/tag/java-basic/",{loader:()=>t.e(4101).then(t.bind(t,23337)),meta:{t:"标签: java-basic",I:!1}}],["/tag/logback/",{loader:()=>t.e(2931).then(t.bind(t,93858)),meta:{t:"标签: logback",I:!1}}],["/tag/maven/",{loader:()=>t.e(9405).then(t.bind(t,88321)),meta:{t:"标签: maven",I:!1}}],["/tag/mybatis/",{loader:()=>t.e(3223).then(t.bind(t,95115)),meta:{t:"标签: mybatis",I:!1}}],["/tag/netty/",{loader:()=>t.e(70).then(t.bind(t,21707)),meta:{t:"标签: netty",I:!1}}],["/tag/nio/",{loader:()=>t.e(7936).then(t.bind(t,27565)),meta:{t:"标签: nio",I:!1}}],["/tag/javaweb/",{loader:()=>t.e(4172).then(t.bind(t,64741)),meta:{t:"标签: javaweb",I:!1}}],["/tag/http/",{loader:()=>t.e(4226).then(t.bind(t,83428)),meta:{t:"标签: http",I:!1}}],["/tag/servlet/",{loader:()=>t.e(6611).then(t.bind(t,32189)),meta:{t:"标签: servlet",I:!1}}],["/tag/request/",{loader:()=>t.e(7435).then(t.bind(t,78061)),meta:{t:"标签: Request",I:!1}}],["/tag/response/",{loader:()=>t.e(3301).then(t.bind(t,11006)),meta:{t:"标签: Response",I:!1}}],["/tag/jdbc/",{loader:()=>t.e(2703).then(t.bind(t,28650)),meta:{t:"标签: jdbc",I:!1}}],["/tag/djgango/",{loader:()=>t.e(8048).then(t.bind(t,9529)),meta:{t:"标签: djgango",I:!1}}],["/tag/java/",{loader:()=>t.e(7869).then(t.bind(t,53691)),meta:{t:"标签: Java",I:!1}}],["/tag/%E6%A1%86%E6%9E%B6/",{loader:()=>t.e(6606).then(t.bind(t,6807)),meta:{t:"标签: 框架",I:!1}}],["/tag/spring/",{loader:()=>t.e(6847).then(t.bind(t,40551)),meta:{t:"标签: Spring",I:!1}}],["/tag/springboot/",{loader:()=>t.e(1159).then(t.bind(t,73821)),meta:{t:"标签: SpringBoot",I:!1}}],["/tag/%E9%9D%A2%E8%AF%95/",{loader:()=>t.e(243).then(t.bind(t,856)),meta:{t:"标签: 面试",I:!1}}],["/tag/bean/",{loader:()=>t.e(9976).then(t.bind(t,22343)),meta:{t:"标签: Bean",I:!1}}],["/tag/beandefinition/",{loader:()=>t.e(8865).then(t.bind(t,5839)),meta:{t:"标签: BeanDefinition",I:!1}}],["/tag/ioc/",{loader:()=>t.e(5551).then(t.bind(t,67005)),meta:{t:"标签: IOC",I:!1}}],["/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",{loader:()=>t.e(2422).then(t.bind(t,83770)),meta:{t:"标签: 依赖查找",I:!1}}],["/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",{loader:()=>t.e(6).then(t.bind(t,96461)),meta:{t:"标签: 依赖注入",I:!1}}],["/tag/aop/",{loader:()=>t.e(6830).then(t.bind(t,85731)),meta:{t:"标签: AOP",I:!1}}],["/tag/resource/",{loader:()=>t.e(4742).then(t.bind(t,81272)),meta:{t:"标签: Resource",I:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",{loader:()=>t.e(8507).then(t.bind(t,16797)),meta:{t:"标签: 数据绑定",I:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",{loader:()=>t.e(4817).then(t.bind(t,12875)),meta:{t:"标签: 数据库",I:!1}}],["/tag/datasource/",{loader:()=>t.e(23).then(t.bind(t,36861)),meta:{t:"标签: DataSource",I:!1}}],["/tag/jdbc/",{loader:()=>t.e(2703).then(t.bind(t,28650)),meta:{t:"标签: JDBC",I:!1}}],["/tag/jdbctemplate/",{loader:()=>t.e(6809).then(t.bind(t,62927)),meta:{t:"标签: JdbcTemplate",I:!1}}],["/tag/%E4%BA%8B%E5%8A%A1/",{loader:()=>t.e(5426).then(t.bind(t,33347)),meta:{t:"标签: 事务",I:!1}}],["/tag/jpa/",{loader:()=>t.e(7419).then(t.bind(t,52266)),meta:{t:"标签: JPA",I:!1}}],["/tag/mybatis/",{loader:()=>t.e(3223).then(t.bind(t,95115)),meta:{t:"标签: MyBatis",I:!1}}],["/tag/pagehelper/",{loader:()=>t.e(8285).then(t.bind(t,22160)),meta:{t:"标签: PageHelper",I:!1}}],["/tag/mapper/",{loader:()=>t.e(1943).then(t.bind(t,26230)),meta:{t:"标签: Mapper",I:!1}}],["/tag/redis/",{loader:()=>t.e(8857).then(t.bind(t,41774)),meta:{t:"标签: Redis",I:!1}}],["/tag/mongodb/",{loader:()=>t.e(9416).then(t.bind(t,75579)),meta:{t:"标签: MongoDB",I:!1}}],["/tag/elasticsearch/",{loader:()=>t.e(8361).then(t.bind(t,37511)),meta:{t:"标签: Elasticsearch",I:!1}}],["/tag/web/",{loader:()=>t.e(2660).then(t.bind(t,57940)),meta:{t:"标签: Web",I:!1}}],["/tag/controller/",{loader:()=>t.e(7010).then(t.bind(t,55167)),meta:{t:"标签: Controller",I:!1}}],["/tag/dispatcherservlet/",{loader:()=>t.e(7212).then(t.bind(t,19670)),meta:{t:"标签: DispatcherServlet",I:!1}}],["/tag/filter/",{loader:()=>t.e(8088).then(t.bind(t,50466)),meta:{t:"标签: Filter",I:!1}}],["/tag/cors/",{loader:()=>t.e(2707).then(t.bind(t,74776)),meta:{t:"标签: CORS",I:!1}}],["/tag/view/",{loader:()=>t.e(8632).then(t.bind(t,20409)),meta:{t:"标签: View",I:!1}}],["/tag/%E5%BC%82%E6%AD%A5/",{loader:()=>t.e(6339).then(t.bind(t,28527)),meta:{t:"标签: 异步",I:!1}}],["/tag/json/",{loader:()=>t.e(40).then(t.bind(t,28229)),meta:{t:"标签: JSON",I:!1}}],["/tag/%E9%82%AE%E4%BB%B6/",{loader:()=>t.e(214).then(t.bind(t,40234)),meta:{t:"标签: 邮件",I:!1}}],["/tag/io/",{loader:()=>t.e(4086).then(t.bind(t,90795)),meta:{t:"标签: IO",I:!1}}],["/tag/%E9%9B%86%E6%88%90/",{loader:()=>t.e(9236).then(t.bind(t,6607)),meta:{t:"标签: 集成",I:!1}}],["/tag/%E7%BC%93%E5%AD%98/",{loader:()=>t.e(6822).then(t.bind(t,1694)),meta:{t:"标签: 缓存",I:!1}}],["/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",{loader:()=>t.e(7765).then(t.bind(t,55302)),meta:{t:"标签: 调度器",I:!1}}],["/tag/dubbo/",{loader:()=>t.e(4894).then(t.bind(t,65853)),meta:{t:"标签: Dubbo",I:!1}}],["/tag/%E5%AE%89%E5%85%A8/",{loader:()=>t.e(6123).then(t.bind(t,64610)),meta:{t:"标签: 安全",I:!1}}],["/article/",{loader:()=>t.e(7511).then(t.bind(t,2772)),meta:{t:"文章",I:!1}}],["/star/",{loader:()=>t.e(7199).then(t.bind(t,70353)),meta:{t:"星标",I:!1}}],["/timeline/",{loader:()=>t.e(5464).then(t.bind(t,14695)),meta:{t:"时间轴",I:!1}}]])},35124:(n,e,t)=>{t.d(e,{o:()=>i});const i=[{title:"主页",headers:[],path:"/",pathLocale:"/",extraFields:"---\nhome: true\nlayout: BlogHome\nicon: home\ntitle: 主页\n# heroImage: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/fdcbc9ef8859b7077d92ae38d925e15e_7767077963502328666.png\nheroText: coder-xuyong\nheroFullScreen: false # banner 是否全屏\n#bgImage: /assets/images/banner.jpg\nbgImage: https://ys.mihoyo.com/main/_nuxt/img/poster.47f71d4.jpg\ntagline: 心有所向 日复一日 必有精进✨\n\n\nprojects:\n  - icon: project\n    name: blog\n    desc: 日常记录知识点的个人博客\n    link: https://github.com/coder-xuyong/blog\n\n  # - icon: link\n  #   name: 链接名称\n  #   desc: 链接详细描述\n  #   link: https://链接地址\n\n  # - icon: book\n  #   name: 书籍名称\n  #   desc: 书籍详细描述\n  #   link: https://你的书籍链接\n\n  - icon: article\n    name: 无须服务器，搭建一个在线blog\n    desc: 使用 GitHub pages + vuepress 搭建静态blog\n    link: https://github.com/coder-xuyong/blog/blob/main/README.md\n\n  # - icon: friend\n  #   name: 伙伴名称\n  #   desc: 伙伴详细介绍\n  #   link: https://你的伙伴链接\n\n  # - icon: https://theme-hope-assets.vuejs.press/logo.svg\n  #   name: 自定义项目\n  #   desc: 自定义详细介绍\n  #   link: https://你的自定义链接\n\nfooter: 我虽无意逐鹿 却知苍生苦楚\n---\n\n\x3c!-- 这是一个博客主页的案例。\n\n要使用此布局，你应该在页面前端设置 `layout: BlogHome` 和 `home: true`。\n\n相关配置文档请见 [博客主页](https://theme-hope.vuejs.press/zh/guide/blog/home.html)。 --\x3e\n"},{title:"介绍页",headers:[],path:"/intro.html",pathLocale:"/",extraFields:"---\nicon: circle-info\ncover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/e699d7e2413ed5dfb384ee48c2b872d3_5181262111088024686.png\n# sticky: true\nstar: true\n---\n\n# 介绍页\n\n重生之我在提瓦特大陆当牛马\n"},{title:"主要功能与配置演示",headers:[],path:"/demo/",pathLocale:"/",extraFields:"---\ntitle: 主要功能与配置演示\nindex: false\nicon: laptop-code\ncategory:\n  - 使用指南\n# 文章不显示\narticle: false\n---\n\n<Catalog />\n"},{title:"布局与功能禁用",headers:[],path:"/demo/disable.html",pathLocale:"/",extraFields:"---\ntitle: 布局与功能禁用\nicon: gears\norder: 4\ncategory:\n  - 使用指南\ntag:\n  - 禁用\n\n# 文章不显示\narticle: false\n\nnavbar: false\nsidebar: false\n\nbreadcrumb: false\npageInfo: false\ncontributors: false\neditLink: false\nlastUpdated: false\nprev: false\nnext: false\ncomment: false\nfooter: false\n\nbacktotop: false\n---\n\n你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\n\n\x3c!-- more --\x3e\n\n本页面就是一个示例，禁用了如下功能:\n\n- 导航栏\n- 侧边栏\n- 路径导航\n- 页面信息\n- 贡献者\n- 编辑此页链接\n- 更新时间\n- 上一篇/下一篇 链接\n- 评论\n- 页脚\n- 返回顶部按钮\n"},{title:"布局",headers:[],path:"/demo/layout.html",pathLocale:"/",extraFields:"---\ntitle: 布局\nicon: object-group\norder: 2\ncategory:\n  - 指南\ntag:\n  - 布局\n# 文章不显示\narticle: false\n---\n\n布局包括:\n\n- [导航栏](https://theme-hope.vuejs.press/zh/guide/layout/navbar.html)\n- [侧边栏](https://theme-hope.vuejs.press/zh/guide/layout/sidebar.html)\n- [页脚](https://theme-hope.vuejs.press/zh/guide/layout/footer.html)\n\n同时每个页面包含:\n\n- [路径导航](https://theme-hope.vuejs.press/zh/guide/layout/breadcrumb.html)\n- [标题和页面信息](https://theme-hope.vuejs.press/zh/guide/feature/page-info.html)\n- [TOC (文章标题列表)](https://theme-hope.vuejs.press/zh/guide/layout/page.html#标题列表)\n- [贡献者、更新时间等页面元信息](https://theme-hope.vuejs.press/guide/feature/meta.html)\n- [评论](https://theme-hope.vuejs.press/zh/guide/feature/comment.html)\n\n主题也带有以下元素:\n\n- [夜间模式按钮](https://theme-hope.vuejs.press/zh/guide/interface/darkmode.html)\n- [返回顶部按钮](https://theme-hope.vuejs.press/guide/interface/others.html#返回顶部按钮)\n- [打印按钮](https://theme-hope.vuejs.press/guide/interface/others.html#打印按钮)\n\n你可以在主题选项和页面的 frontmatter 中自定义它们。\n"},{title:"Markdown 展示",headers:[{level:2,title:"Markdown 介绍",slug:"markdown-介绍",link:"#markdown-介绍",children:[]},{level:2,title:"Markdown 配置",slug:"markdown-配置",link:"#markdown-配置",children:[]},{level:2,title:"Markdown 扩展",slug:"markdown-扩展",link:"#markdown-扩展",children:[{level:3,title:"VuePress 扩展",slug:"vuepress-扩展",link:"#vuepress-扩展",children:[]},{level:3,title:"主题扩展",slug:"主题扩展",link:"#主题扩展",children:[]},{level:3,title:"图片增强",slug:"图片增强",link:"#图片增强",children:[]}]}],path:"/demo/markdown.html",pathLocale:"/",extraFields:'---\ntitle: Markdown 展示\nicon: fab fa-markdown\norder: 2\ncategory:\n  - 使用指南\ntag:\n  - Markdown\n# 文章不显示\narticle: false\n---\n\nVuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\n\n你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\n\n\x3c!-- more --\x3e\n\n## Markdown 介绍\n\n如果你是一个新手，还不会编写 Markdown，请先阅读 [Markdown 介绍](https://theme-hope.vuejs.press/zh/cookbook/markdown/) 和 [Markdown 演示](https://theme-hope.vuejs.press/zh/cookbook/markdown/demo.html)。\n\n## Markdown 配置\n\nVuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\n\n::: important Frontmatter\n\nFrontmatter 是 VuePress 中很重要的一个概念，请阅读 [Frontmatter 介绍](https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#front-matter) 了解详情。\n\n:::\n\n## Markdown 扩展\n\nVuePress 会使用 [markdown-it](https://github.com/markdown-it/markdown-it) 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 [语法扩展](https://github.com/markdown-it/markdown-it#syntax-extensions) 。\n\n### VuePress 扩展\n\n为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\n\n关于这些扩展，请阅读 [VuePress 中的 Markdown 扩展](https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html)。\n\n### 主题扩展\n\n通过 VuePress 插件，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\n\n#### 选项卡\n\n::: tabs#fruit\n\n@tab apple\n\nApple\n\n@tab banana\n\nBanana\n\n@tab orange\n\nOrange\n\n:::\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/content/tabs.html)\n\n#### 脚注\n\n此文字有脚注[^first].\n\n[^first]: 这是脚注内容\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/content/footnote.html)\n\n#### 导入文件\n\n\x3c!-- @include: ./README.md{11-17} --\x3e\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/content/include.html)\n\n#### TeX 语法\n\n$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/grammar/math.html)\n\n#### 任务列表\n\n- [x] 计划 1\n- [ ] 计划 2\n\n[查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/grammar/tasklist.html)\n\n### 图片增强\n\n支持为图片设置颜色模式和大小。\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/grammar/image.html)\n\n#### 上下角标\n\n19^th^ H~2~O\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/sup-sub.html)\n\n#### 组件\n\n```component VPCard\ntitle: Mr.Hope\ndesc: Where there is light, there is hope\nlogo: https://mister-hope.com/logo.svg\nlink: https://mister-hope.com\nbackground: rgba(253, 230, 138, 0.15)\n```\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/component/grammar.html)\n\n#### 提示容器\n\n::: v-pre\n\n安全的在 Markdown 中使用 {{ variable }}。\n\n:::\n\n::: info 自定义标题\n\n信息容器，包含 `代码` 与 [链接](#提示容器)。\n\n```js\nconst a = 1;\n```\n\n:::\n\n::: tip 自定义标题\n\n提示容器\n\n:::\n\n::: warning 自定义标题\n\n警告容器\n\n:::\n\n::: caution 自定义标题\n\n危险容器\n\n:::\n\n::: details 自定义标题\n\n详情容器\n\n:::\n\n- [GitHub 警示](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/alert.html)\n- [提示框](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/hint.html)\n\n#### 自定义对齐\n\n::: center\n\n我是居中的\n\n:::\n\n::: right\n\n我在右对齐\n\n:::\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/align.html)\n\n#### 属性支持\n\n一个拥有 ID 的 **单词**{#word}。\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/attrs.html)\n\n#### 标记\n\n你可以标记 ==重要的内容== 。\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/mark.html)\n\n#### 剧透\n\nVuePress Theme Hope !!十分强大!!.\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/spoiler.html)\n\n#### 样式化\n\n向 Mr.Hope 捐赠一杯咖啡。 _Recommended_\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/stylize/stylize.html)\n\n#### 图表\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/chartjs.html" width="100%" height="450"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/chart/chartjs.html)\n\n#### ECharts\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/echarts.html" width="100%" height="800"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/chart/echarts.html)\n\n#### 流程图\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/flowchart.html" width="100%" height="450"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/chart/flowchart.html)\n\n#### MarkMap\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/markmap.html" width="100%" height="380"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/chart/markmap.html)\n\n#### Mermaid\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/mermaid.html" width="100%" height="620"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/chart/mermaid.html)\n\n#### PlantUML\n\n@startuml\nAlice -> Bob: 认证请求\n\nalt 成功情况\n\n    Bob -> Alice: 认证接受\n\nelse 某种失败情况\n\n    Bob -> Alice: 认证失败\n    group 我自己的标签\n    Alice -> Log : 开始记录攻击日志\n        loop 1000次\n            Alice -> Bob: DNS 攻击\n        end\n    Alice -> Log : 结束记录攻击日志\n    end\n\nelse 另一种失败\n\n    Bob -> Alice: 请重复\n\nend\n@enduml\n\n- [View Detail](https://theme-hope.vuejs.press/zh/guide/markdown/chart/plantuml.html)\n\n#### 代码块\n\n::: code-tabs\n\n@tab pnpm\n\n```bash\npnpm add -D vuepress-theme-hope\n```\n\n@tab yarn\n\n```bash\nyarn add -D vuepress-theme-hope\n```\n\n@tab:active npm\n\n```bash\nnpm i -D vuepress-theme-hope\n```\n\n:::\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/code-tabs.html)\n\n#### 代码演示\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/code-demo.html" width="100%" height="450"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/demo.html)\n\n#### 交互演示\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/playground.html" width="100%" height="480"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/playground.html)\n\n#### Kotlin 交互演示\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/kotlin-playground.html" width="100%" height="220"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/kotlin-playground.html)\n\n#### Sandpack 交互演示\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/sandpack.html" width="100%" height="380"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/sandpack.html)\n\n#### Vue 交互演示\n\n<iframe src="https://plugin-md-enhance-demo.vuejs.press/snippet/vue-playground.html" width="100%" height="380"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/code/vue-playground.html)\n\n#### 幻灯片\n\n<iframe src="https://ecosystem.vuejs.press/zh/plugins/markdown/revealjs/demo.html" width="100%" height="420"/>\n\n- [查看详情](https://theme-hope.vuejs.press/zh/guide/markdown/content/revealjs.html)\n'},{title:"页面配置使用说明",headers:[{level:2,title:"页面标题",slug:"页面标题",link:"#页面标题",children:[]},{level:2,title:"页面信息",slug:"页面信息",link:"#页面信息",children:[]},{level:2,title:"页面内容",slug:"页面内容",link:"#页面内容",children:[]},{level:2,title:"组件",slug:"组件",link:"#组件",children:[]},{level:2,title:"表格",slug:"表格",link:"#表格",children:[]}],path:"/demo/page.html",pathLocale:"/",extraFields:"---\n# 这是文章的标题\ntitle: 页面配置使用说明\n# 你可以自定义封面图片\ncover: /assets/images/blogs/page1.png\n# 这是页面的图标\nicon: file\n# 这是侧边栏的顺序\norder: 3\n# 设置作者\nauthor: xuyong\n# 设置写作时间\ndate: 2024-12-21\n# 一个页面可以有多个分类\ncategory:\n  - 使用指南\n# 一个页面可以有多个标签\ntag:\n  - 页面配置\n  - 使用指南\n# 此页面会在文章列表置顶\nsticky: false\n# 此页面会出现在星标文章中\nstar: false\n# 你可以自定义页脚\nfooter: 这是测试显示的页脚\n# 你可以自定义版权信息\ncopyright: 无版权\n# 文章不显示\narticle: false\n---\n\n`more` 注释之前的内容被视为文章摘要。\n\n\x3c!-- more --\x3e\n\n## 页面标题\n\nThe first H1 title in Markdown will be regarded as page title.\n\nMarkdown 中的第一个 H1 标题会被视为页面标题。\n\n你可以在 Markdown 的 Frontmatter 中设置页面标题。\n\n```md\n---\ntitle: 页面标题\n---\n```\n\n## 页面信息\n\n你可以在 Markdown 的 Frontmatter 中设置页面信息。\n\n- 作者设置为 Ms.Hope。\n- 写作日期为 2020 年 1 月 1 日\n- 分类为 “使用指南”\n- 标签为 “页面配置” 和 “使用指南”\n\n## 页面内容\n\n你可以自由在这里书写你的 Markdown。\n\n::: tip 图片引入\n\n- 你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\n- 对于 `.vuepress/public` 文件夹的图片，请使用绝对链接 `/` 进行引用。\n\n:::\n\n## 组件\n\n每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\n\n{{ 1 + 1 }}\n\n\x3c!-- markdownlint-disable MD033 --\x3e\n\n<ul>\n  <li v-for=\"i in 3\">{{ i }}</li>\n</ul>\n\n\x3c!-- markdownlint-enable MD033 --\x3e\n\n你也可以创建并引入你自己的组件。\n\n<MyComponent />\n\n<script setup>\nimport { defineComponent, h, ref } from 'vue';\n\nconst MyComponent = defineComponent({\n  setup() {\n    const input = ref('Hello world!');\n    const onInput = (e) => {\n      input.value = e.target.value;\n    };\n\n    return () => [\n      h('p', [\n        h('span','输入: '),\n        h('input', {\n          value: input.value,\n          onInput,\n        }),\n      ]),\n      h('p', [h('span','输出: '), input.value]),\n    ];\n  },\n});\n<\/script>\n\n---\n\n主题包含一些有用的组件。这里是一些例子:\n\n- 文字结尾应该有深蓝色的 徽章文字 徽章。 <Badge text=\"徽章文字\" color=\"#242378\" />\n\n- 一个卡片:\n\n  ```component VPCard\n  title: Mr.Hope\n  desc: Where there is light, there is hope\n  logo: https://mister-hope.com/logo.svg\n  link: https://mister-hope.com\n  background: rgba(253, 230, 138, 0.15)\n  ```\n## 表格\n|     居中      |         右对齐 | 左对齐         |\n| :-----------: | -------------: | :------------- |\n| 居中使用`:-:` | 右对齐使用`-:` | 左对齐使用`:-` |\n|       b       |      aaaaaaaaa | aaaa           |\n|       c       |           aaaa | a              |"},{title:"页面配置使用说明",headers:[{level:2,title:"组件引用实例",slug:"组件引用实例",link:"#组件引用实例",children:[]},{level:2,title:"页面标题",slug:"页面标题",link:"#页面标题",children:[]},{level:2,title:"页面信息",slug:"页面信息",link:"#页面信息",children:[]},{level:2,title:"页面内容",slug:"页面内容",link:"#页面内容",children:[]},{level:2,title:"组件",slug:"组件",link:"#组件",children:[]},{level:2,title:"表格",slug:"表格",link:"#表格",children:[]}],path:"/posts/markdown.html",pathLocale:"/",extraFields:"---\n# 这是文章的标题\ntitle: 页面配置使用说明\n# 你可以自定义封面图片\ncover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/fdcbc9ef8859b7077d92ae38d925e15e_7767077963502328666.png\n# 这是页面的图标\nicon: file\n# 这是侧边栏的顺序\norder: 3\n# 设置作者\nauthor: xuyong\n# 设置写作时间\ndate: 2024-12-21\n# 提交GitHub 自动生成\nlastUpdated: true\n# 一个页面可以有多个分类\ncategory:\n  - 使用指南\n# 一个页面可以有多个标签\ntag:\n  - 页面配置\n  - 使用指南\n# 此页面会在文章列表置顶\nsticky: true\n# 此页面会出现在星标文章中\nstar: true\n# 你可以自定义页脚\nfooter: 这是测试显示的页脚\n# 你可以自定义版权信息\ncopyright: 无版权\n---\n\n`more` 注释之前的内容被视为文章摘要。\n\n\x3c!-- more --\x3e\n\n## 组件引用实例\n\n很奇怪，在其他地方有效果，在这里没有效果\n<DemoComponent />\n\n<script setup>\nimport DemoComponent from \"@DemoComponent\";\n<\/script>\n\n\n## 页面标题\n\nThe first H1 title in Markdown will be regarded as page title.\n\nMarkdown 中的第一个 H1 标题会被视为页面标题。\n\n你可以在 Markdown 的 Frontmatter 中设置页面标题。\n\n```md\n---\ntitle: 页面标题\n---\n```\n\n## 页面信息\n\n你可以在 Markdown 的 Frontmatter 中设置页面信息。\n\n- 作者设置为 Ms.Hope。\n- 写作日期为 2020 年 1 月 1 日\n- 分类为 “使用指南”\n- 标签为 “页面配置” 和 “使用指南”\n\n## 页面内容\n\n你可以自由在这里书写你的 Markdown。\n\n::: tip 图片引入\n\n- 你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\n- 对于 `.vuepress/public` 文件夹的图片，请使用绝对链接 `/` 进行引用。\n\n:::\n\n## 组件\n\n每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\n\n{{ 1 + 1 }}\n\n\x3c!-- markdownlint-disable MD033 --\x3e\n\n<ul>\n  <li v-for=\"i in 3\">{{ i }}</li>\n</ul>\n\n\x3c!-- markdownlint-enable MD033 --\x3e\n\n你也可以创建并引入你自己的组件。\n\n<MyComponent />\n\n<script setup>\nimport { defineComponent, h, ref } from 'vue';\n\nconst MyComponent = defineComponent({\n  setup() {\n    const input = ref('Hello world!');\n    const onInput = (e) => {\n      input.value = e.target.value;\n    };\n\n    return () => [\n      h('p', [\n        h('span','输入: '),\n        h('input', {\n          value: input.value,\n          onInput,\n        }),\n      ]),\n      h('p', [h('span','输出: '), input.value]),\n    ];\n  },\n});\n<\/script>\n\n---\n\n主题包含一些有用的组件。这里是一些例子:\n\n- 文字结尾应该有深蓝色的 徽章文字 徽章。 <Badge text=\"徽章文字\" color=\"#242378\" />\n\n- 一个卡片:\n\n  ```component VPCard\n  title: Mr.Hope\n  desc: Where there is light, there is hope\n  logo: https://mister-hope.com/logo.svg\n  link: https://mister-hope.com\n  background: rgba(253, 230, 138, 0.15)\n  ```\n## 表格\n|     居中      |         右对齐 | 左对齐         |\n| :-----------: | -------------: | :------------- |\n| 居中使用`:-:` | 右对齐使用`-:` | 左对齐使用`:-` |\n|       b       |      aaaaaaaaa | aaaa           |\n|       c       |           aaaa | a              |\n"},{title:"linux 命令集",headers:[{level:2,title:"1.基本命令",slug:"_1-基本命令",link:"#_1-基本命令",children:[]},{level:2,title:"2.关机",slug:"_2-关机",link:"#_2-关机",children:[]},{level:2,title:"3.文件和目录",slug:"_3-文件和目录",link:"#_3-文件和目录",children:[]},{level:2,title:"4.文件搜索",slug:"_4-文件搜索",link:"#_4-文件搜索",children:[]},{level:2,title:"5.挂载一个文件系统",slug:"_5-挂载一个文件系统",link:"#_5-挂载一个文件系统",children:[]},{level:2,title:"6.磁盘空间",slug:"_6-磁盘空间",link:"#_6-磁盘空间",children:[]},{level:2,title:"7.用户和群组",slug:"_7-用户和群组",link:"#_7-用户和群组",children:[]},{level:2,title:"8.文件的权限，使用“+”设置权限，使用“-”用于取消",slug:"_8-文件的权限-使用-设置权限-使用-用于取消",link:"#_8-文件的权限-使用-设置权限-使用-用于取消",children:[]},{level:2,title:"9.文件的特殊属性",slug:"_9-文件的特殊属性",link:"#_9-文件的特殊属性",children:[]},{level:2,title:"10.打包和压缩文件",slug:"_10-打包和压缩文件",link:"#_10-打包和压缩文件",children:[]},{level:2,title:"11.RPM 包",slug:"_11-rpm-包",link:"#_11-rpm-包",children:[]},{level:2,title:"12.YUM 软件包升级器",slug:"_12-yum-软件包升级器",link:"#_12-yum-软件包升级器",children:[]},{level:2,title:"13.deb 包",slug:"_13-deb-包",link:"#_13-deb-包",children:[]},{level:2,title:"14.查看文件内容",slug:"_14-查看文件内容",link:"#_14-查看文件内容",children:[]},{level:2,title:"15.文本处理",slug:"_15-文本处理",link:"#_15-文本处理",children:[]},{level:2,title:"16.字符设置和文件格式转换",slug:"_16-字符设置和文件格式转换",link:"#_16-字符设置和文件格式转换",children:[]},{level:2,title:"17.文件系统分析",slug:"_17-文件系统分析",link:"#_17-文件系统分析",children:[]},{level:2,title:"18.初始化一个文件系统",slug:"_18-初始化一个文件系统",link:"#_18-初始化一个文件系统",children:[]},{level:2,title:"19. SWAP文件系统",slug:"_19-swap文件系统",link:"#_19-swap文件系统",children:[]},{level:2,title:"20.备份",slug:"_20-备份",link:"#_20-备份",children:[]},{level:2,title:"21.光盘",slug:"_21-光盘",link:"#_21-光盘",children:[]},{level:2,title:"22.网络（以太网和WIFI无线）",slug:"_22-网络-以太网和wifi无线",link:"#_22-网络-以太网和wifi无线",children:[]},{level:2,title:"23.列出目录内容",slug:"_23-列出目录内容",link:"#_23-列出目录内容",children:[]},{level:2,title:"24.查看文件的类型",slug:"_24-查看文件的类型",link:"#_24-查看文件的类型",children:[]},{level:2,title:"25.复制文件目录",slug:"_25-复制文件目录",link:"#_25-复制文件目录",children:[]},{level:2,title:"26.系统常用命令",slug:"_26-系统常用命令",link:"#_26-系统常用命令",children:[]},{level:2,title:"27.VIM",slug:"_27-vim",link:"#_27-vim",children:[]},{level:2,title:"28.Windows 连接Linux",slug:"_28-windows-连接linux",link:"#_28-windows-连接linux",children:[]}],path:"/posts/linux/linux.html",pathLocale:"/",extraFields:"---\ntitle: linux 命令集\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - linux\ntag:\n  - linux\n---\n\n\nlinux 命令集\n\n\x3c!-- more --\x3e\n\n## 1.基本命令\n\n```shell\nps -ef | grep Name 查找进程\nkill Name 结束进程\nuname -m 显示机器的处理器架构\nuname -r 显示正在使用的内核版本\ndmidecode -q 显示硬件系统部件\n(SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性\nhdparm -tT /dev/sda 在磁盘上执行测试性读取操作系统信息\narch 显示机器的处理器架构\nuname -m 显示机器的处理器架构\nuname -r 显示正在使用的内核版本\ndmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)\nhdparm -i /dev/hda 罗列一个磁盘的架构特性\nhdparm -tT /dev/sda 在磁盘上执行测试性读取操作\ncat /proc/cpuinfo 显示CPU info的信息\ncat /proc/interrupts 显示中断\ncat /proc/meminfo 校验内存使用\ncat /proc/swaps 显示哪些swap被使用\ncat /proc/version 显示内核的版本\ncat /proc/net/dev 显示网络适配器及统计\ncat /proc/mounts 显示已加载的文件系统\nlspci -tv 罗列 PCI 设备\nlsusb -tv 显示 USB 设备\ndate 显示系统日期\ncal 2007 显示2007年的日历表\ndate 041217002007.00 设置日期和时间 - 月日时分年.秒\nclock -w 将时间修改保存到 BIOS\n```\n\n\n\n## 2.关机\n\n```shell\nshutdown -h now 关闭系统(1)\ninit 0 关闭系统(2)\ntelinit 0 关闭系统(3)\nshutdown -h hours:minutes & 按预定时间关闭系统\nshutdown -c 取消按预定时间关闭系统\nshutdown -r now 重启(1)\nreboot 重启(2)\nlogout 注销\n```\n\n\n\n\n## 3.文件和目录\n\n```shell\ncd /home 进入 '/ home' 目录'\ncd .. 返回上一级目录\ncd ../.. 返回上两级目录\ncd 进入个人的主目录\ncd ~user1 进入个人的主目录\ncd - 返回上次所在的目录\npwd 显示工作路径\nls 查看目录中的文件\nls -F 查看目录中的文件\nls -l 显示文件和目录的详细资料\nls -a 显示隐藏文件\nls *[0-9]* 显示包含数字的文件名和目录名\ntree 显示文件和目录由根目录开始的树形结构(1)\nlstree 显示文件和目录由根目录开始的树形结构(2)\nmkdir dir1 创建一个叫做 'dir1' 的目录'\nmkdir dir1 dir2 同时创建两个目录\nmkdir -p /tmp/dir1/dir2 创建一个目录树\nrm -f file1 删除一个叫做 'file1' 的文件'\nrmdir dir1 删除一个叫做 'dir1' 的目录'\nrm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容\nrm -rf dir1 dir2 同时删除两个目录及它们的内容\nmv dir1 new_dir 重命名/移动 一个目录\ncp file1 file2 复制一个文件\ncp dir/* . 复制一个目录下的所有文件到当前工作目录\ncp -a /tmp/dir1 . 复制一个目录到当前工作目录\ncp -a dir1 dir2 复制一个目录\nln -s file1 lnk1 创建一个指向文件或目录的软链接\nln file1 lnk1 创建一个指向文件或目录的物理链接\ntouch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)\nfile file1 outputs the mime type of the file as text\niconv -l 列出已知的编码\niconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.\nfind . -maxdepth 1 -name *.jpg -print -exec convert \"{}\" -resize 80x60 \"thumbs/{}\" \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)\n```\n\n## 4.文件搜索\n\n```shell\nfind / -name file1 从 '/' 开始进入根文件系统搜索文件和目录\nfind / -user user1 搜索属于用户 'user1' 的文件和目录\nfind /home/user1 -name \\*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件\nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件\nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件\nfind / -name \\*.rpm -exec chmod 755 '{}' \\; 搜索以 '.rpm' 结尾的文件并定义其权限\nfind / -xdev -name \\*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备\nlocate \\*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令\nwhereis halt 显示一个二进制文件、源码或man的位置\nwhich halt 显示一个二进制文件或可执行文件的完整路径\n```\n\n\n\n## 5.挂载一个文件系统\n\n```shell\nmount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在\numount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出\nfuser -km /mnt/hda2 当设备繁忙时强制卸载\numount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用\nmount /dev/fd0 /mnt/floppy 挂载一个软盘\nmount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom\nmount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件\nmount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统\nmount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享\n```\n\n\n\n## 6.磁盘空间\n\n```shell\ndf -h 显示已经挂载的分区列表\nls -lSr |more 以尺寸大小排列文件和目录\ndu -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'\ndu -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小\nrpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)\ndpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)\n```\n\n\n\n\n## 7.用户和群组\n\n```shell\ngroupadd group_name 创建一个新用户组\ngroupdel group_name 删除一个用户组\ngroupmod -n new_group_name old_group_name 重命名一个用户组\nuseradd -c \"Name Surname \" -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 \"admin\" 用户组的用户\nuseradd user1 创建一个新用户\nuserdel -r user1 删除一个用户 ( '-r' 排除主目录)\nusermod -c \"User FTP\" -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性\npasswd 修改口令\npasswd user1 修改一个用户的口令 (只允许root执行)\nchage -E 2005-12-31 user1 设置用户口令的失效期限\npwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户\ngrpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组\nnewgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组\n```\n\n\n\n\n\n\n\n## 8.文件的权限，使用“+”设置权限，使用“-”用于取消\n\n```shell\nls -lh 显示权限\nls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示\nchmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限\nchmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限\nchown user1 file1 改变一个文件的所有人属性\nchown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性\nchgrp group1 file1 改变文件的群组\nchown user1:group1 file1 改变一个文件的所有人和群组属性\nfind / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件\nchmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限\nchmod u-s /bin/file1 禁用一个二进制文件的 SUID位\nchmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的\nchmod g-s /home/public 禁用一个目录的 SGID 位\nchmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件\nchmod o-t /home/public 禁用一个目录的 STIKY 位\nchmod +x 文件路径 为所有者、所属组和其他用户添加执行的权限\nchmod -x 文件路径 为所有者、所属组和其他用户删除执行的权限\nchmod u+x 文件路径 为所有者添加执行的权限\nchmod g+x 文件路径 为所属组添加执行的权限\nchmod o+x 文件路径 为其他用户添加执行的权限\nchmod ug+x 文件路径 为所有者、所属组添加执行的权限\nchmod =wx 文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限\nchmod ug=wx 文件路径 为所有者、所属组添加写、执行的权限，取消读权限\n```\n\n\n\n## 9.文件的特殊属性\n\n* 使用 “+” 设置权限，使用 “-” 用于取消\n\n```shell\nchattr +a file1 只允许以追加方式读写文件\nchattr +c file1 允许这个文件能被内核自动压缩/解压\nchattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件\nchattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接\nchattr +s file1 允许一个文件被安全地删除\nchattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\nchattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件\nlsattr 显示特殊的属性\n```\n\n\n\n## 10.打包和压缩文件\n\n```shell\nbunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件\nbzip2 file1 压缩一个叫做 'file1' 的文件\ngunzip file1.gz 解压一个叫做 'file1.gz'的文件\ngzip file1 压缩一个叫做 'file1'的文件\ngzip -9 file1 最大程度压缩\nrar a file1.rar test_file 创建一个叫做 'file1.rar' 的包\nrar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'\nrar x file1.rar 解压rar包\nunrar x file1.rar 解压rar包\ntar -cvf archive.tar file1 创建一个非压缩的 tarball\ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件\ntar -tf archive.tar 显示一个包中的内容\ntar -xvf archive.tar 释放一个包\ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下\ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包\ntar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包\ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包\ntar -xvfz archive.tar.gz 解压一个gzip格式的压缩包\nzip file1.zip file1 创建一个zip格式的压缩包\nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包\nunzip file1.zip 解压一个zip格式压缩包\n```\n\n\n\n## 11.RPM 包\n\n```shell\nrpm -ivh package.rpm 安装一个rpm包\nrpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告\nrpm -U package.rpm 更新一个rpm包但不改变其配置文件\nrpm -F package.rpm 更新一个确定已经安装的rpm包\nrpm -e package_name.rpm 删除一个rpm包\nrpm -qa 显示系统中所有已经安装的rpm包\nrpm -qa | grep httpd 显示所有名称中包含 \"httpd\" 字样的rpm包\nrpm -qi package_name 获取一个已安装包的特殊信息\nrpm -qg \"System Environment/Daemons\" 显示一个组件的rpm包\nrpm -ql package_name 显示一个已经安装的rpm包提供的文件列表\nrpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表\nrpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表\nrpm -q package_name --whatprovides 显示一个rpm包所占的体积\nrpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l\nrpm -q package_name --changelog 显示一个rpm包的修改历史\nrpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供\nrpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表\nrpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书\nrpm --checksig package.rpm 确认一个rpm包的完整性\nrpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性\nrpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间\nrpm -Va 检查系统中所有已安装的rpm包- 小心使用\nrpm -Vp package.rpm 确认一个rpm包还未安装\nrpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件\nrpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包\nrpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包\n```\n\n\n\n\n\n\n\n## 12.YUM 软件包升级器\n\n```shell\nyum install package_name 下载并安装一个rpm包\nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系\nyum update package_name.rpm 更新当前系统中所有安装的rpm包\nyum update package_name 更新一个rpm包\nyum remove package_name 删除一个rpm包\nyum list 列出当前系统中安装的所有包\nyum search package_name 在rpm仓库中搜寻软件包\nyum clean packages 清理rpm缓存删除下载的包\nyum clean headers 删除所有头文件\nyum clean all 删除所有缓存的包和头文件\n```\n\n\n\n## 13.deb 包\n\n```shell\ndpkg -i package.deb 安装/更新一个 deb 包\ndpkg -r package_name 从系统删除一个 deb 包\ndpkg -l 显示系统中所有已经安装的 deb 包\ndpkg -l | grep httpd 显示所有名称中包含 \"httpd\" 字样的deb包\ndpkg -s package_name 获得已经安装在系统中一个特殊包的信息\ndpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表\ndpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表\ndpkg -S /bin/ping 确认所给的文件由哪个deb包提供\nAPT 软件工具 (Debian, Ubuntu 以及类似系统)\napt-get install package_name 安装/更新一个 deb 包\napt-cdrom install package_name 从光盘安装/更新一个 deb 包\napt-get update 升级列表中的软件包\napt-get upgrade 升级所有已安装的软件\napt-get remove package_name 从系统删除一个deb包\napt-get check 确认依赖的软件仓库正确\napt-get clean 从下载的软件包中清理缓存\napt-cache search searched-package 返回包含所要搜索字符串的软件包名称\n```\n\n\n\n## 14.查看文件内容\n\n```shell\ncat file1 从第一个字节开始正向查看文件的内容\ntac file1 从最后一行开始反向查看一个文件的内容\nmore file1 查看一个长文件的内容\nless file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作\nhead -2 file1 查看一个文件的前两行\ntail -2 file1 查看一个文件的最后两行\ntail -f /var/log/messages 实时查看被添加到一个文件中的内容\n```\n\n\n\n## 15.文本处理\n\n```shell\ncat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT\ncat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中\ncat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中\ngrep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词\"Aug\"\ngrep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇\ngrep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行\ngrep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\"\nsed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\"\nsed '/^$/d' example.txt 从example.txt文件中删除所有空白行\nsed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行\necho 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容\nsed -e '1d' result.txt 从文件example.txt 中排除第一行\nsed -n '/stringa1/p' 查看只包含词汇 \"string1\"的行\nsed -e 's/ *$//' example.txt 删除每一行最后的空白字符\nsed -e 's/stringa1//g' example.txt 从文档中只删除词汇 \"string1\" 并保留剩余全部\nsed -n '1,5p;5q' example.txt 查看从第一行到第5行内容\nsed -n '5p;5q' example.txt 查看第5行\nsed -e 's/00*/0/g' example.txt 用单个零替换多个零\ncat -n file1 标示文件的行数\ncat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行\necho a b c | awk '{print $1}' 查看一行第一栏\necho a b c | awk '{print $1,$3}' 查看一行的第一和第三栏\npaste file1 file2 合并两个文件或两栏的内容\npaste -d '+' file1 file2 合并两个文件或两栏的内容，中间用\"+\"区分\nsort file1 file2 排序两个文件的内容\nsort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)\nsort file1 file2 | uniq -u 删除交集，留下其他的行\nsort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)\ncomm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容\ncomm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容\ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分\n```\n\n\n\n\n## 16.字符设置和文件格式转换\n\n```shell\ndos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX\nunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS\nrecode ..HTML < page.txt > page.html 将一个文本文件转换成html\nrecode -l | more 显示所有允许的转换格式\n```\n\n\n\n\n\n\n## 17.文件系统分析\n\n```shell\nbadblocks -v /dev/hda1 检查磁盘hda1上的坏磁块\nfsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性\nfsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性\ne2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性\ne2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性\nfsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性\nfsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性\nfsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性\ndosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性\n```\n\n\n\n## 18.初始化一个文件系统\n\n```shell\nmkfs /dev/hda1 在hda1分区创建一个文件系统\nmke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统\nmke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统\nmkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统\nfdformat -n /dev/fd0 格式化一个软盘\nmkswap /dev/hda3 创建一个swap文件系统\n```\n\n## 19. SWAP文件系统\n\n```shell\nmkswap /dev/hda3 创建一个swap文件系统\nswapon /dev/hda3 启用一个新的swap文件系统\nswapon /dev/hda2 /dev/hdb3 启用两个swap分区\n```\n\n## 20.备份\n\n```shell\ndump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份\ndump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份\nrestore -if /tmp/home0.bak 还原一个交互式备份\nrsync -rogpav --delete /home /tmp 同步两边的目录\nrsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync\nrsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录\nrsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录\ndd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作\ndd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件\ntar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作\n( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p' 通过ssh在远程目录中复制一个目录内容\n( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' 通过ssh在远程目录中复制一个本地目录\ntar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接\nfind /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录\nfind /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包\ndd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作\ndd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容\n```\n\n\n\n## 21.光盘\n\n```shell\ncdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容\nmkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件\nmkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件\nmkisofs -J -allow-leading-dots -R -V \"Label CD\" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件\ncdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件\ngzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件\nmount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件\ncd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中\ncd-paranoia -- \"-3\" 从一个CD光盘转录音轨到 wav 文件中（参数-3）\ncdrecord --scanbus 扫描总线以识别scsi通道\ndd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD\n```\n\n\n\n## 22.网络（以太网和WIFI无线）\n\n```shell\nifconfig eth0 显示一个以太网卡的配置\nifup eth0 启用一个 'eth0' 网络设备\nifdown eth0 禁用一个 'eth0' 网络设备\nifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址\nifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)\ndhclient eth0 以dhcp模式启用 'eth0'\nroute -n show routing table\nroute add -net 0/0 gw IP_Gateway configura default gateway\nroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'\nroute del 0/0 gw IP_gateway remove static route\necho \"1\" > /proc/sys/net/ipv4/ip_forward activate ip routing\nhostname show hostname of system\nhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)\nip link show show link status of all interfaces\nmii-tool eth0 show link status of 'eth0'\nethtool eth0 show statistics of network card 'eth0'\nnetstat -tup show all active network connections and their PID\nnetstat -tupl show all network services listening on the system and their PID\ntcpdump tcp port 80 show all HTTP traffic\niwlist scan show wireless networks\niwconfig eth1 show configuration of a wireless network card\nhostname show hostname\nhost www.example.com lookup hostname to resolve name to ip address and viceversa\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa\nwhois www.example.com lookup on Whois database\n```\n\n\n\n## 23.列出目录内容\n\n```\nls -a：显示所有文件（包括隐藏文件）；\nls -l：显示详细信息；\nls -R：递归显示子目录结构；\nls -ld：显示目录和链接信息；\nctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；\nLinux中以.开头的文件是隐藏文件；\npwd:显示当前目录\n```\n\n## 24.查看文件的类型\n\nfile:查看文件的类型\n\n## 25.复制文件目录\n\n1、cp：复制文件和目录 cp源文件（文件夹）目标文件（文件夹）。\n\n常用参数：-r:递归复制整个目录树；-v：显示详细信息；\n复制文件夹时要在cp命令后面加一个-r参数：\n如：cp -r 源文件夹  目标文件夹。\n\n2、touch+文件名：当文件不存在的时候，创建相应的文件；当文件存在的时候，修改文件的创建时间。\n\n功能：生成一个空文件或修改文件的存取/修改的时间记录值；\ntouch * ：将当前下的文件时间修改为系统的当前时间；\ntouch –d 20040210 test：将test文件的日期改为20040210；\ntouch abc：若abc文件存在，则修改为系统的当前时间；若不存在，则生成一个为当前时间的空文件。\n\n3、mv 文件 目标目录：移动或重命名文件或目录（如果指定文件名，则可以重命名文件）。可以将文件及目录移到另一目录下，或更改文件及目录的名称。\n\n格式为：mv [参数]<源文件或目录> <目标文件或目录>\nmva.txt ../：将a.txt文件移动上层目录\nmv a.txt b.txt：将a.txt改名为b.txt\nmvdir2 ../：将dir2目录上移一层\n\n4、rm：删除文件\n\n常用参数：-i：交互式   -r：递归的删除包括目录中的所有内容。\n5、mkdir +文件夹名称：创建文件夹\n\n6、rm -r +文件夹名称：删除文件夹（空文件夹和非空文件夹都可删除）；\n\nrmdir 文件夹名称：删除文件夹（只能删除空文件夹）。\n\n7、mkdir  -p dir1/dir2 ：在当前目录下创建dir1目录，并在dir1目录下创建dir2目录， 也就是连续创建两个目录（dir1/和dir1/dir2）。\n\n8、rmdir –p dir1/dir2：删除dir1下的dir2目录，若dir1目录为空也删除它。\n\n9、rm * ：删除当前目录下的所有文件\n\n10、-f参数：强迫删除文件 rm –f  *.txt：强迫删除所有以后缀名为txt文件。\n\n11、-i参数：删除文件时询问\n\nrm　–i  * ：删除当前目录下的所有文件会有如下提示：\nrm:backup:is a directory　　　 遇到目录会略过\nrm: remove ‘myfiles.txt’ ? Y\n删除文件时会询问，可按Y或N键表示允许或拒绝删除文件。\n12、-r参数：递归删除（连子目录一同删除，这是一个相当常用的参数）。\n\nrm  -r test ：删除test目录（含test目录下所有文件和子目录）；\nrm  -r  *：删除所有文件（含当前目录所有文件、所有子目录和子目录下的文件） 一般在删除目录时r和f一起用，避免麻烦；\nrm  -rf test ：强行删除、不加询问。\n13、grep：功能：在文件中搜索匹配的字符并进行输出。\n\n格式：grep[参数] <要找的字串> <要寻找字 串的源文件>\ngreplinux test.txt：搜索test.txt文件中字符串linux并输出。\n14、ln命令\n\n功能：在文件和目录之间建立链接\n格式：ln [参数] <源文件或目录> <目标文件或目录>\n链接分“软链接”和“硬链接”\n1.软链接:\nln–s /usr/share/do  doc ：创建一个链接文件doc，并指向目录/usr/share/do\n2.硬链接:\nln  /usr/share/test  hard：创建一个硬链接文件hard，这时对于test文件对应 的存储区域来说，又多了一个文件指向它。\n\n## 26.系统常用命令\n\n1、显示命令\n\ndate:查看或设置当前系统的时间：格式化显示时间：+%Y--%m--%d；\ndate -s:设置当前系统的时间；\nhwclock(clock)：显示硬件时钟时间(需要管理员权限)；\ncal：查看日历；\n格式cal [参数] 月年；\ncal：显示当月的日历   cal4 2004 ：显示2004年4月的日历；\ncal- y 2003：显示2003年的日历；\nuptime：查看系统运行时间。\n2、输出查看命令\n\necho：显示输入的内容  追加文件echo \"liuyazhuang\" >> liuyazhuang.txt\ncat：显示文件内容,也可以将数个文件合并成一个文件；\n格式：格式：cat[参数]<文件名>\ncat  test.txt：显示test.txt文件内容；\ncat  test.txt | more  ：逐页显示test.txt文件中的内容；\ncat  test.txt >> test1.txt ：将test.txt的内容附加到test1.txt文件之后；\ncat  test.txt test2.txt >readme.txt　: 将test.txt和test2.txt文件合并成readme.txt 文件；\nhead:显示文件的头几行（默认10行） -n:指定显示的行数格式：head -n 文件名；\ntail：显示文件的末尾几行（默认10行）-n：指定显示的行数   -f：追踪显示文件更新 （一般用于查看日志，命令不会退出，而是持续显示新加入的内容）；\n格式：格式：tail[参数]<文件名>\ntail-10 /etc/passwd ：显示/etc/passwd/文件的倒数10行内容；\ntail+10 /etc/passwd ：显示/etc/passwd/文件从第10行开始到末尾的内容；\nmore：用于翻页显示文件内容（只能向下翻页）；\nmore命令是一般用于要显示的内容会超过一个画面长度的情况。为了避免画  面显示时瞬间就闪过去，用户可以使用more命令，让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按Q键停止显示；\nls  -al  |more：以长格形式显示etc目录下的文件列表，显示满一个画面便暂停，可 按空格键继续显示下一画面，或按Q键跳离；\nless：翻页显示文件内容（带上下翻页）按下上键分页，按q退出；\nless命令的用法与more命令类似，也可以用来浏览超过一页的文件。所不同  的是less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在less命令的提示符“：”下按Q键即可；\nls  -al | less：以长格形式列出/etc目录中所有的内容。用户可按上下键浏览或按Q键跳离。\n3、查看硬件信息\n\nIspci：查看PCI设备  -v：查看详细信息\nIsusb：查看USB设备 -v：查看详细信息\nIsmod：查看加载的模块(驱动)\n4、关机、重启\n\nshutdown关闭、重启计算机\nshutdown[关机、重启]时间  -h关闭计算机   -r：重启计算机\n如：立即关机：shutdown -h now\n10分钟后关机：shutdown -h +10\n23:30分关机：shutdown -h 23:30\n立即重启：shutdown -r now\npoweroff：立即关闭计算机\nreboot：立即重启计算机\n5、归档、压缩\n\nzip:压缩文件  zip liuyazhuang.zip myfile  格式为：“zip 压缩后的zip文件文件名”\nunzip：解压文件  unzip liuyazhuang.zip\ngzip：压缩文件 gzip 文件名\ntar：归档文件\ntar -cvf out.tar liuyazhuang  打包一个归档（将文件\"liuyazhuang\"打包成一个归档）\ntar -xvf liuyazhuang.tar     释放一个归档（释放liuyazhuang.tar归档）\ntar -cvzf backup.tar.gz/etc  \n-z参数将归档后的归档文件进行gzip压缩以减少大小。\n-c：创建一个新tar文件\n-v：显示运行过程的信息\n-f：指定文件名\n-z：调用gzip压缩命令进行压缩\n-t：查看压缩文件的内容\n-x：解开tar文件\ntar  -cvf test.tar  *：将所有文件打包成test.tar,扩展名.tar需自行加上\ntar  -zcvf test.tar.gz  *：将所有文件打包成test.tar,再用gzip命令压缩\ntar -tf   test.tar ：查看test.tar文件中包括了哪些文件\ntar -xvf test.tar       将test.tar解开\ntar -zxvf foo.tar.gz   解压缩\ngzip各gunzip命令\ngziptest.txt ：压缩文件时，不需要任何参数\ngizp–l test.txt.gz：显示压缩率\n6、查找\n\nlocate：快速查找文件、文件夹：locate keyword\n此命令需要预先建立数据库，数据库默认每天更新一次，可用updatedb命令手工建立、更新数据库。\nfind查找位置查找参数\n如：\nfind . -name *liuyazhuang* 查找当前目录下名称中含有\"liuyazhuang\"的文件\nfind / -name *.conf  查找根目录下（整个硬盘）下后缀为.conf的文件\nfind / -perm 777 查找所有权限是777的文件\nfind / -type d 返回根目录下所有的目录\nfind . -name \"a*\"-exec ls -l {} \\;\nfind功能：用来寻找文件或目录\n格式：find [<路径>] [匹配条件]\nfind / -name httpd.conf  搜索系统根目录下名为httpd.conf的文件\n7、ctrl+c :终止当前的命令\n8、who或w命令\n\n功能：查看当前系统中有哪些用户登录\n格式：who/w[参数]\n9、dmesg命令\n功能：显示系统诊断信息、操作系统版本号、物理内存的大小以及其它信息。\n10、df命令\n功能：用于查看文件系统的各个分区的占用情况。\n\n11、du命令\n\n功能：查看某个目录中各级子目录所使用的硬盘空间数。\n格式：du [参数] <目录名>\n12、free命令\n\n功能：用于查看系统内存，虚拟内存（交换空间）的大小占用情况。\n\n## 27.VIM\n\n\n\nVIM是一款功能强大的命令行文本编辑器，在Linux中通过vim命令可以启动vim编辑器。\n一般使用vim + 目标文件路径 的形式使用vim\n\n如果目标文件存在，则vim打开目标文件，如果目标文件不存在，则vim新建并打开该文件。\n:q：退出vim编辑器\nVIM模式\nvim拥有三种模式：\n（1）命令模式（常规模式）\n\nvim启动后，默认进入命令模式，任何模式都可以通过esc键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。\n命名模式常用命令如下：\ni : 在光标前插入文本\no:在当前行的下面插入新行\ndd:删除整行\nyy：将当前行的内容放入缓冲区（复制当前行）\nn+yy :将n行的内容放入缓冲区（复制n行）\np:将缓冲区中的文本放入光标后（粘贴）\nu：撤销上一个操作\nr:替换当前字符\n/ 查找关键字\n（2）插入模式\n\n在命令模式下按 \" i \"键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用esc键可以返回命令模式。\n（3）ex模式\n\n在命令模式中按\" : \"键可以进入ex模式，光标会移动到底部，在这里可以保存修改或退出vim.\next模式常用命令如下：\n:w ：保存当前的修改\n:q ：退出\n:q! ：强制退出，保存修改\n:x  :保存并退出，相当于:wq\n:set number 显示行号\n:! 系统命令  执行一个系统命令并显示结果\n:sh ：切换到命令行，使用ctrl+d切换回vim\n28. 软件包管理命令(RPM)\n\n1、软件包的安装\n\n使用RPM命令的安装模式可以将软件包内所有的组件放到系统中的正确路径，安装软件包的命令是:rpm –ivh wu-ftpd-2.6.2-8.i386.rpm\ni：作用rpm的安装模式 v: 校验文件信息h: 以＃号显示安装进度。\n2、软件包的删除\n\n删除模式会将指定软件包的内容全部删除，但并不包括已更改过的配置文件，删除RPM软件包的命令如下：rpm –e  wu-ftpd\n注意：这里必须使用软件名“wu-ftpd”或”wu-ftpd-2.6.2-8而不是使用当初安装时的软件包名.wu-ftpd-2.6.2-8.i386.rpm\n3、软件包升级\n\n升级模式会安装用户所指定的更新版本，并删除已安装在系统中的相同软件包，升级软件包命令如下：rpm –Uvh wu-ftpd-2.6.2-8.i386.rpm  –Uvh：升级参数。\n4、软件包更新\n\n更新模式下，rpm命令会检查在命令行中所指定的软件包是否比系统中原有的软件 包更新。如果情况属实，rpm命令会自动更新指定的软件包；反之，若系统中并没有指定软件包的较旧版本，rpm命令并不会安装此软件包。而在升级模式下，不管系统中是否有较旧的版本，rpm命令都会安装指定的软件包。\nrpm –Fvhwu-ftpd-2.6.2-8.i386.rpm   -Fvh：更新参数\n5、软件包查询\n\n若要获取RPM软件包的相关信息，可以使用查询模式。使用-q参数可查询一个已  安装的软件包的内容。\nrpm  –q wu-ftpd\n查询软件包所安装的位置：rpm –ql package-name\nrpm –ql xv (l参数：显示文件列表)\n## 28.Windows 连接Linux\n```shell\nssh @root ip\n```\n"},{title:"在工作中遇到的有关Linux的问题",headers:[{level:2,title:"linux 查找文件",slug:"linux-查找文件",link:"#linux-查找文件",children:[]},{level:2,title:"java linux 启动和关闭脚本",slug:"java-linux-启动和关闭脚本",link:"#java-linux-启动和关闭脚本",children:[]}],path:"/posts/linux/linuxWork.html",pathLocale:"/",extraFields:"---\ntitle: 在工作中遇到的有关Linux的问题\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - linux\ntag:\n  - linux\n  - tomcat\n  - shell\n---\n在工作中遇到的有关Linux的问题\n\n\x3c!-- more --\x3e\n\n# 设置tomcat 开机自启\n\n```shell\ncrontab -e\n# 在其中添加 下面这行代码（startup.sh 自行更好，只有一行时 & 不要） 保存\nreboot sudo -u root /home/debian/tomcat9/bin/startup.sh start &\n```\n\n# 设置 jar 开机自启\n编写脚本文件\nstart.sh\n```shell\n#!/bin/bash\nnohup java -server -jar XXX.jar > /dev/null 2>&1 &\n#nohup 确保即使用户退出登录，Java进程也会继续运行。\n#java -server -jar XXX.jar 启动指定的JAR文件。\n#-server 是一个JVM选项，表示以服务器模式运行JVM。服务器模式下的JVM通常会进行更多的优化，适合长时间运行的应用程序。\n#> /dev/null 将标准输出（控制台输出）丢弃。\n#2>&1 将标准错误（错误信息）也丢弃。\n#& 将整个命令放在后台执行。\n```\n进入 rc.d目录\n```shell\ncd /etc/rc.d\ncat rc.local\n```\n执行命令：vim rc.local  , 修改rc.local 。按【i】键进入编辑模式，在最后添加代码：\n```shell\nsleep 60\ncd /myApp/test\nsh /myApp/test/startup.sh\n \n#第一句为进入你项目所在的目录，我这里把项目放在/myApp/test下\n#第二句执行该目录下的sh文件\n \n##说明\n#如果不提前进入所在目录，直接执行第二句，也会开机自启动，但是日志文件会在根目录下的log文件中。只有先进入，再执行，项目的日志文件才会在test文件夹下\n \n##test文件中有jar包、startup.sh、以及jar包的日志文件logs\n```\n设置权限：\n```shell\nchmod +x /etc/rc.d/rc.local\nchmod +x /myApp/test/startup.sh\n```\n\n## linux 查找文件\n1.使用 `find` 命令\n\n`find` 是一个非常强大的命令行工具，用于在文件系统中搜索文件和目录。它可以在指定的路径下递归查找，并支持复杂的条件匹配。\n\n2.基本用法\n\n```bash\nfind /path/to/search -name \"filename\"\n```\n\n## java linux 启动和关闭脚本\n启动： sh server.sh start\n关闭： sh server.sh stop\nserver.sh\n```shell\n#!/usr/bin/env sh\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nAPP_HOME=$(cd $(dirname $0)/../;pwd)                    # shell脚本必须指定，因为脚本不会自动加载环境变量，不写的话导致出现此错误\napp=$APP_HOME'/app.jar'    #jar包的决定路径\nargs='-server -Xms4096m -Xmx4096m -XX:PermSize=512m -XX:SurvivorRatio=2 -XX:+UseParallelGC'  #java程序启动参数，可不写\nargs1='--spring.config.location='$APP_HOME'/config/application.properties --logging.config='$APP_HOME'/config/logback-spring.xml --db.file='$APP_HOME'/config/config.db --logging.file.path='$APP_HOME'/logs/'\nLOGS_FILE=/dev/null                           # 把打印的日志扔进垃圾桶\n\ncmd=$1                                        #获取执行脚本的时候带的参数\npid=`ps -ef|grep java|grep $app|awk '{print $2}'`                # 抓取对应的java进程\n\n\n\nstartup(){\n  aa=`nohup java -jar $args $app $args1 >> $LOGS_FILE 2>&1 &`\n  echo \"nohup java -jar $args $app $args1 >> $LOGS_FILE 2>&1 &\"\n}\n\nif [ ! $cmd ]; then\n  echo \"Please specify args 'start|restart|stop'\"\n  exit\nfi\n\nif [ $cmd = 'start' ]; then\n  if [ ! $pid ]; then\n    startup\n  else\n    echo \"$app is running! pid=$pid\"\n  fi\nfi\n\nif [ $cmd = 'restart' ]; then\n  if [ $pid ]\n    then\n      echo \"$pid will be killed after 3 seconds!\"\n      sleep 3\n      kill -9 $pid\n  fi\n  startup\nfi\n\nif [ $cmd = 'stop' ]; then\n  if [ $pid ]; then\n    echo \"$pid will be killed after 3 seconds!\"\n    sleep 3\n    kill -9 $pid\n  fi\n  echo \"$app is stopped\"\nfi\n```\n"},{title:"idea 使用方便记录",headers:[{level:2,title:"springboot的yml文件没有小叶子",slug:"springboot的yml文件没有小叶子",link:"#springboot的yml文件没有小叶子",children:[]},{level:2,title:"好用的插件",slug:"好用的插件",link:"#好用的插件",children:[]},{level:2,title:"快捷键",slug:"快捷键",link:"#快捷键",children:[]},{level:2,title:"使用过程中遇到的问题",slug:"使用过程中遇到的问题",link:"#使用过程中遇到的问题",children:[{level:3,title:"启动报错 windows defender might impact performance",slug:"启动报错-windows-defender-might-impact-performance",link:"#启动报错-windows-defender-might-impact-performance",children:[]}]}],path:"/posts/idea/idea.html",pathLocale:"/",extraFields:"---\n# 这是文章的标题\ntitle: idea 使用方便记录\ncover: https://webstatic.mihoyo.com/upload/contentweb/2022/07/04/d063646e97392638e07da24ce6b8c3cb_3567507076955258130.png\nicon: file\nauthor: xuyong\ndate: 2024-12-21\nlastUpdated: true\ncategory:\n  - idea\ntag:\n  - 使用指南\nsticky: false\nstar: false\n---\n\n记录 idea 使用过程中遇到的问题\n\n\x3c!-- more --\x3e\n\n## springboot的yml文件没有小叶子\n\n下载 Spring Boot Helper 插件\n\n## 好用的插件\n| 名字       | 作用   |  操作  |官网|\n| --------   | :-----  | :---- |:---- |\n| translation |翻译帮助翻译英文文档|   Ctrl+Q查看注释，Ctrl+shift+y 翻译 ，或者打开自动翻译文档 |https://yiiguxing.gitee.io/translation-plugin/#/docs?id=usage|\n| Spring Boot Helper |yml文件小叶子和其他|   下载就有小叶子   |不知道|\n\n\n\n## 快捷键\n```shell\n格式化文档：Ctrl+Shift+Alt+L\n文件内替换：Ctrl+R\n进入方法体：Ctrl+B\n提交git的commit：Ctrl+K\n快速折叠if/else语句：Ctrl+Shift+。\ntry-catch-finally:Ctrl+Alt+T\n```\n## 使用过程中遇到的问题\n### 启动报错 windows defender might impact performance\n```shell\nwindows defender might impact performance\n\nexclude IDE and project directories from antivirus scans:\n\n*****\n\n*****\n\nAlternatively, add the IDE process as an exclusion\n\nExclude directories    Don't show again\n```\n\nwindows defender可能会影响性能\n从防病毒扫描中排除IDE和项目目录\n\n解决方法：\n**下面两个选项都可以点击，点击之后一路默认即可，或者直接×掉**\n"},{title:"DDL常用命令，操作数据库和表结构",headers:[{level:2,title:"操作数据库",slug:"操作数据库",link:"#操作数据库",children:[]},{level:2,title:"修改数据库密码",slug:"修改数据库密码",link:"#修改数据库密码",children:[]},{level:2,title:"修改数据库连接权限",slug:"修改数据库连接权限",link:"#修改数据库连接权限",children:[]},{level:2,title:"查看当前数据库的连接数",slug:"查看当前数据库的连接数",link:"#查看当前数据库的连接数",children:[]},{level:2,title:"操作表",slug:"操作表",link:"#操作表",children:[]}],path:"/posts/mysql/DDL.html",pathLocale:"/",extraFields:'\ufeff---\ntitle: DDL常用命令，操作数据库和表结构\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nDDL常用命令，操作数据库和表结构\n\x3c!-- more --\x3e\n\n\n# DDL常用命令，操作数据库和表结构\n\n标签（空格分隔）： mysql\n\n---\n（data definition language）数据库定义语言\n## 操作数据库\n```shell\nSHOW DATABASES;--查询所有数据库\nCREATE DATABASE 数据库名称;--创建数据库\nCREATE DATABASE IF NOT EXISTS 数据库名称;--创建数据库(判断，如果不存在则创建)\nDROP DATABASE 数据库名称;--删除数据库\nDROP DATABASE IF EXISTS 数据库名称;--删除数据库(判断，如果存在则删除)\nUSE 数据库名称;--切换到当前数据库\nSELECT DATABASE();--查看当前使用的数据库\n```\n\n\n## 修改数据库密码\n```shell\nmysql> use mysq;\n-- 查询主机用户名密码：5.7版本之前的\nmysql> select host,user,plugin,password from user;\n-- 查询主机用户名密码：5.7版本之后的，包括5.7\nmysql> select host,user,plugin,authentication_string from user;\nmysql> select host,user,plugin,authentication_string from user\\G;\nmysql> select host,user,plugin,authentication_string from mysql.user;\n-- 修改密码，刷新权限\nmysql> update user set password=password("新密码") where user="root";\nmysql> flush privileges;\nmysql> quit\n-- 上面修改密码是在5.7版本之前的。若是5.7版本之后的（包括5.7），没有password这个字段了，则修改方法如下：\nmysql> alter user "root"@"localhost" identified by "新密码";  -- 方法1\nmysql> update user set authentication_string=password("新密码") where user="root";  -- 方法2\nmysql> flush privileges;\nmysql> quit\n```\n\n## 修改数据库连接权限\n```shell\nupdate user set host=\'%\' where user=\'root\';\n```\n## 查看当前数据库的连接数\n```shell\nshow status like \'Threads%\';\n```\n\n## 操作表\n```shell\nSHOW TABLES;--查询当前数据库下所有表名称\nDESC 表名称;--查询表结构\n--创建表\nCREATE TABLE 表名 (\n\t字段名1  数据类型1,\n\t字段名2  数据类型2,\n\t…\n\t字段名n  数据类型n\n);\nDROP TABLE 表名;--删除表\nDROP TABLE IF EXISTS 表名;--删除表时判断表是否存在\nALTER TABLE 表名 RENAME TO 新的表名;--修改表名\nALTER TABLE 表名 ADD 列名 数据类型;--添加一列\nALTER TABLE 表名 MODIFY 列名 新数据类型;--修改数据类型\nALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;--修改列名和数据类型\nALTER TABLE 表名 DROP 列名;--删除列\n```\n\n\n\n\n'},{title:"DML和DQL常用命令，操作表数据",headers:[{level:2,title:"DML（Data Manipulation Language）",slug:"dml-data-manipulation-language",link:"#dml-data-manipulation-language",children:[]},{level:2,title:"DQL（data query language）",slug:"dql-data-query-language",link:"#dql-data-query-language",children:[{level:3,title:"排序查询",slug:"排序查询",link:"#排序查询",children:[]},{level:3,title:"聚合函数",slug:"聚合函数",link:"#聚合函数",children:[]},{level:3,title:"分组查询",slug:"分组查询",link:"#分组查询",children:[]}]}],path:"/posts/mysql/DML_DQL.html",pathLocale:"/",extraFields:"\ufeff---\ntitle: DML和DQL常用命令，操作表数据\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nDML和DQL常用命令，操作表数据\n\x3c!-- more --\x3e\n\n# DML和DQL常用命令，操作表数据\n\n\n## DML（Data Manipulation Language）\n```shell\nINSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);--给指定列添加数据\nINSERT INTO 表名 VALUES(值1,值2,…);--给全部列添加数据\n--批量添加数据\nNSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\nINSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\n\nUPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;--修改表数据\nDELETE FROM 表名 [WHERE 条件] ;--删除数据\n\n```\n\n## DQL（data query language）\n\n```shell\nSELECT 字段列表 FROM 表名;\nSELECT * FROM 表名; -- 查询所有数据\nSELECT DISTINCT 字段列表 FROM 表名;--去除重复记录\n--起别名，AS: AS 也可以省略\n\nSELECT 字段列表 FROM 表名 WHERE 条件列表;--条件查询\nSELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;--分页查询\nselect * from stu where name like '_%';--模糊查询，（1）_ : 代表单个任意字符，（2）% : 代表任意个数字符\n```\n### 排序查询\n\n```sql\n    SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;\n```\n\n上述语句中的排序方式有两种，分别是：\n\n* ASC ： 升序排列 **（默认值）**\n* DESC ： 降序排列\n\n> 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序\n\n\n### 聚合函数\n==将一列数据作为一个整体，进行纵向计算==\n| 函数名      | 功能                             |\n| ----------- | -------------------------------- |\n| count(列名) | 统计数量（一般选用不为null的列） |\n| max(列名)   | 最大值                           |\n| min(列名)   | 最小值                           |\n| sum(列名)   | 求和                             |\n| avg(列名)   | 平均值                           |\n\n\n```sql\nSELECT 聚合函数名(列名) FROM 表;\n```\n\n> 注意：null 值不参与所有聚合函数运算\n\n\n### 分组查询\n\n\n```sql\nSELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];\n```\n\n> 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\n\n\n"},{title:"mysql使用中遇到的问题记录",headers:[{level:2,title:"Packet for query is too large错误",slug:"packet-for-query-is-too-large错误",link:"#packet-for-query-is-too-large错误",children:[]},{level:2,title:"索引失效",slug:"索引失效",link:"#索引失效",children:[]}],path:"/posts/mysql/mysqlBug.html",pathLocale:"/",extraFields:"\ufeff---\ntitle: mysql使用中遇到的问题记录\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nmysql使用中遇到的问题记录\n\x3c!-- more --\x3e\n\n## Packet for query is too large错误\n```txt\n在mysql安装目录中找到my.ini配置文件\n在最后添加 max_allowed_packet=10485760\n```\n数值可以 MB为单位，16M\n\n\n##  索引失效\neg：假设age是整数类型，但是却使用字符串类型\n```shell\nSELECT * FROM user WHERE age = '20';\n```\nMySQL 需要在查询时转换 '20' 为整数类型，可能会导致索引无法使用。 某个电商平台就有这么一个类似的bug，导致下单超时崩盘30分钟。"},{title:"mysql 存储过程",headers:[{level:2,title:"什么是存储过程",slug:"什么是存储过程",link:"#什么是存储过程",children:[]},{level:2,title:"存储过程的作用（优点）",slug:"存储过程的作用-优点",link:"#存储过程的作用-优点",children:[]},{level:2,title:"存储过程的缺点",slug:"存储过程的缺点",link:"#存储过程的缺点",children:[]},{level:2,title:"创建存储过程",slug:"创建存储过程",link:"#创建存储过程",children:[{level:3,title:"1.具体语法详解",slug:"_1-具体语法详解",link:"#_1-具体语法详解",children:[]}]}],path:"/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html",pathLocale:"/",extraFields:"---\ntitle: mysql 存储过程\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nDDL常用命令，操作数据库和表结构\n\x3c!-- more --\x3e\n\n# mysql 存储过程\n\n## 什么是存储过程\n存储过程就是一些SQL语句的集合，可以简单理解为类似Java中的一个接口函数，函数里面可以使用查询SQL、流程控制语句、定义参数、条件等，用来实现更复杂逻辑的处理。\n\n## 存储过程的作用（优点）\n1.执行速度更快（因为不需要从应用程序调用MySQL服务，减少了获取连接、网络传输的耗时）\n\n2.相比普通SQL实现了复杂的逻辑处理。比如可以应用在测试数据的预置，有时我们在性能测试的时候，需要预置大量的测试数据，利用代码当然能实现预置测试数据，但是一方面测试代码有时候是不能上传到测试环境的，修改发布也不方便。这时候用存储过程就可以轻松修改变量，直接在数据库中执行。\n\n## 存储过程的缺点\n1.书写复杂的存储过程，会显得晦涩难懂。\n\n2.存储过程难以调试，很少工具可以调试存储过程，使得开发和维护都不容易。\n\n3.不能移植，存储过程只能在数据中执行。\n\n## 创建存储过程\n\n### 1.具体语法详解\n\n```shell\nCREATE PROCEDURE sp_name ([proc_parameter])\n[characteristice ...] routine_body\n```\n\nCREATE PROCEDURE：创建存储过程的关键字\n\nsp_name：存储过程的名称\n\nproc_parameter：存储过程的参数列表，列表形式如 [IN | OUT | INOUT] param_name type\n\n* IN：输入\n\n* OUT：输出\n\n* INOUT：输入或输出\n\n* param_name：参数名\n\n* type：参数类型，可以是MySQL数据库中的任意类型\n\ncharacteristics：存储过程的特性，有以下取值\n\n* LANGUAGUE SQL：说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL。SQL是LANGUAGE特性的唯一值\n\n* [NOT]DETERMINISTIC：存储过程执行的结果是否确定。DETERMINISTIC表示是确定的，输入相同的参数，只会得到相同的结果。如果没有指定值，默认为 NOT DETERMINISTIC。\n\n* { CONTAINTS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制\n\n  - CONTAINTS SQL：表明子程序包含SQL语句，但不包含读写数据的语句\n\n  - NO SQL：表明子程序不包含SQL语句\n\n  - READS SQL DATA：表明子程序包含读写数据的语句 \n  - MODIFIES SQL DATA：表明子程序包含读写数据的语句\n\n  - 默认默认为 CONTAINTS SQL\n\n* SQL SECURITY{ DEFINER | INVOKER }：指明谁有权执行\n\n    - DEFINER：表示只有定义者才能执行\n\n    - INVOKER：表示有权调用者可以执行\n\n    - 系统默认为 DEFINER\n\n* COMMENT 'string'：注释信息"},{title:"mysql 安装",headers:[{level:2,title:"下载",slug:"下载",link:"#下载",children:[]},{level:2,title:"配置环境变量",slug:"配置环境变量",link:"#配置环境变量",children:[]},{level:2,title:"创建 my.ini配置文件",slug:"创建-my-ini配置文件",link:"#创建-my-ini配置文件",children:[]},{level:2,title:"cmd 到bin目录",slug:"cmd-到bin目录",link:"#cmd-到bin目录",children:[]},{level:2,title:"执行 sc delete mysql",slug:"执行-sc-delete-mysql",link:"#执行-sc-delete-mysql",children:[]},{level:2,title:"执行 mysqld --install",slug:"执行-mysqld-install",link:"#执行-mysqld-install",children:[]}],path:"/posts/mysql/mysql%E5%AE%89%E8%A3%85.html",pathLocale:"/",extraFields:"---\ntitle: mysql 安装\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nmysql 安装指南\n\x3c!-- more --\x3e\n\n# mysql安装\n\n\n## 下载\n压缩包下载地址：https://dev.mysql.com/downloads/mysql/5.5.html#downloads\n\n## 配置环境变量\n主要是将bin目录放入path环境中\n\n## 创建 my.ini配置文件\n填入\n```shell\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld]\n# 设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir = D:\\\\mysql\\\\mysql-8.0.17-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir = D:\\\\mysql\\\\mysql-8.0.17-winx64\\\\data\n# 允许最大连接数\nmax_connections=20\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 创建模式\nsql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n\n```\n\n## cmd 到bin目录\n初始化,执行下述命令之后，会多出一个data文件夹，文件夹里面会有一个 .err 结尾的文件，里面有初始密码\n```shell\nmysqld --initialize\n```\n## 执行 sc delete mysql\n删除 先前安装的 mysql 残余\n\n## 执行 mysqld --install\n如果报错 `Install/Remove of the Service Denied!`\n以管理员身份运行 cmd 重新执行\n然后登陆修改密码"},{title:"mysql 数据格式",headers:[],path:"/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html",pathLocale:"/",extraFields:"---\ntitle: mysql 数据格式\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nmysql 数据格式\n\x3c!-- more --\x3e\n# mysql 数据格式\n| 分类         | 数据类型      | 大小          | 描述                  | 优点           | 缺点               |\n| ------------ | ------------- | ------------- | --------------------- | -------------- | ------------------ |\n| **数值类型** | TINYINT       | 1 byte        | 小整数值              |                |                    |\n| **数值类型** | SMALLINT      | 2 bytes       | 大整数值              |                |                    |\n| **数值类型** | MEDIUMINT     | 3 bytes       | 大整数值              |                |                    |\n| **数值类型** | INT或INTEGER  | 4 bytes       | 大整数值              |                |                    |\n| **数值类型** | BIGINT        | 8 bytes       | 极大整数值            |                |                    |\n| **数值类型** | FLOAT         | 4 bytes       | 单精度浮点数值        |                |                    |\n| **数值类型** | DOUBLE        | 8 bytes       | 双精度浮点数值        |                |                    |\n| **数值类型** | DECIMAL       |               | 小数值                |                |                    |\n| **日期和时间类型** | DATE   | 3             | 日期值                |                |                    |\n| **日期和时间类型** | TIME   | 3             | 时间值或持续时间      |                |                    |\n| **日期和时间类型** | YEAR   | 1             | 年份值                |                |                    |\n| **日期和时间类型** | DATETIME | 8             | 混合日期和时间值      |                |                    |\n| **日期和时间类型** | TIMESTAMP | 4             | 混合日期和时间值，时间戳 |                |                    |\n| **字符串类型** | CHAR        | 0-255 bytes   | 定长字符串            | 存储性能高     | 浪费空间,长度固定  |\n| **字符串类型** | VARCHAR     | 0-65535 bytes | 变长字符串            | 节约空间       | 存储性能低         |\n| **字符串类型** | TINYBLOB    | 0-255 bytes   | 不超过 255 个字符的二进制字符串 |                |                    |\n| **字符串类型** | TINYTEXT    | 0-255 bytes   | 短文本字符串          |                |                    |\n| **字符串类型** | BLOB        | 0-65 535 bytes | 二进制形式的长文本数据 |                |                    |\n| **字符串类型** | TEXT        | 0-65 535 bytes | 长文本数据            |                |                    |\n| **字符串类型** | MEDIUMBLOB  | 0-16 777 215 bytes | 二进制形式的中等长度文本数据 |                |                    |\n| **字符串类型** | MEDIUMTEXT  | 0-16 777 215 bytes | 中等长度文本数据      |                |                    |\n| **字符串类型** | LONGBLOB    | 0-4 294 967 295 bytes | 二进制形式的极大文本数据 |                |                    |"},{title:"mysql约束",headers:[{level:2,title:"1，约束",slug:"_1-约束",link:"#_1-约束",children:[{level:3,title:"1.1  概念",slug:"_1-1-概念",link:"#_1-1-概念",children:[]},{level:3,title:"1.2  分类",slug:"_1-2-分类",link:"#_1-2-分类",children:[]},{level:3,title:"1.3  非空约束",slug:"_1-3-非空约束",link:"#_1-3-非空约束",children:[]},{level:3,title:"1.4  唯一约束",slug:"_1-4-唯一约束",link:"#_1-4-唯一约束",children:[]},{level:3,title:"1.5  主键约束",slug:"_1-5-主键约束",link:"#_1-5-主键约束",children:[]},{level:3,title:"1.6  默认约束",slug:"_1-6-默认约束",link:"#_1-6-默认约束",children:[]},{level:3,title:"1.7  约束练习",slug:"_1-7-约束练习",link:"#_1-7-约束练习",children:[]},{level:3,title:"1.8  外键约束",slug:"_1-8-外键约束",link:"#_1-8-外键约束",children:[]}]}],path:"/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html",pathLocale:"/",extraFields:"\ufeff---\ntitle: mysql约束\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nmysql约束\n\x3c!-- more --\x3e\n\n\n# mysql约束\n\n## 1，约束\n\n### 1.1  概念\n\n* 约束是作用于表中列上的规则，用于限制加入表的数据\n\n  例如：我们可以给id列加约束，让其值不能重复，不能为null值。\n\n* 约束的存在保证了数据库中数据的正确性、有效性和完整性\n\n  添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。\n\n### 1.2  分类\n\n* **非空约束： 关键字是 NOT NULL**\n\n  保证列中所有的数据不能有null值。\n\n* **唯一约束：关键字是  UNIQUE**\n\n  保证列中所有数据各不相同。\n\n  例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。\n\n* **主键约束： 关键字是  PRIMARY KEY**\n\n  主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。\n\n\n* **检查约束： 关键字是  CHECK** \n\n  保证列中的值满足某一条件。\n\n  > 注意：MySQL不支持检查约束。\n  >\n  > 这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。\n\n* **默认约束： 关键字是   DEFAULT**\n\n  保存数据时，未指定值则采用默认值。\n\n* **外键约束： 关键字是  FOREIGN KEY**\n\n  外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\n\n  外键约束现在可能还不太好理解，后面我们会重点进行讲解。\n\n### 1.3  非空约束\n\n* 概念\n\n  非空约束用于保证列中所有数据不能有NULL值\n\n* 语法\n\n  * 添加约束\n\n    ```sql\n    -- 创建表时添加非空约束\n    CREATE TABLE 表名(\n       列名 数据类型 NOT NULL,\n       …\n    ); \n    \n    ```\n\n    ```sql\n    -- 建完表后添加非空约束\n    ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;\n    ```\n\n  * 删除约束\n\n    ```sql\n    ALTER TABLE 表名 MODIFY 字段名 数据类型;\n    ```\n\n### 1.4  唯一约束\n\n* 概念\n\n  唯一约束用于保证列中所有数据各不相同\n\n* 语法\n\n  * 添加约束\n\n    ```sql\n    -- 创建表时添加唯一约束\n    CREATE TABLE 表名(\n       列名 数据类型 UNIQUE [AUTO_INCREMENT],\n       -- AUTO_INCREMENT: 当不指定值时自动增长\n       …\n    ); \n    CREATE TABLE 表名(\n       列名 数据类型,\n       …\n       [CONSTRAINT] [约束名称] UNIQUE(列名)\n    ); \n    ```\n\n    ```sql\n    -- 建完表后添加唯一约束\n    ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;\n    ```\n\n  * 删除约束\n\n    ```sql\n    ALTER TABLE 表名 DROP INDEX 字段名;\n    ```\n\n### 1.5  主键约束\n\n* 概念\n\n  主键是一行数据的唯一标识，要求非空且唯一\n\n  一张表只能有一个主键\n\n* 语法\n\n  * 添加约束\n\n    ```sql\n    -- 创建表时添加主键约束\n    CREATE TABLE 表名(\n       列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],\n       …\n    ); \n    CREATE TABLE 表名(\n       列名 数据类型,\n       [CONSTRAINT] [约束名称] PRIMARY KEY(列名)\n    ); \n    \n    ```\n\n    ```sql\n    -- 建完表后添加主键约束\n    ALTER TABLE 表名 ADD PRIMARY KEY(字段名);\n    ```\n\n  * 删除约束\n\n    ```sql\n    ALTER TABLE 表名 DROP PRIMARY KEY;\n    ```\n\n### 1.6  默认约束\n\n* 概念\n\n  保存数据时，未指定值则采用默认值\n\n* 语法\n\n  * 添加约束\n\n    ```sql\n    -- 创建表时添加默认约束\n    CREATE TABLE 表名(\n       列名 数据类型 DEFAULT 默认值,\n       …\n    ); \n    ```\n\n    ```sql\n    -- 建完表后添加默认约束\n    ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;\n    ```\n\n  * 删除约束\n\n    ```sql\n    ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;\n    ```\n\n### 1.7  约束练习\n\n**根据需求，为表添加合适的约束**\n\n```sql\n-- 员工表\nCREATE TABLE emp (\n\tid INT,  -- 员工id，主键且自增长\n    ename VARCHAR(50), -- 员工姓名，非空且唯一\n    joindate DATE,  -- 入职日期，非空\n    salary DOUBLE(7,2),  -- 工资，非空\n    bonus DOUBLE(7,2)  -- 奖金，如果没有将近默认为0\n);\n```\n\n上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：\n\n```sql\nDROP TABLE IF EXISTS emp;\n\n-- 员工表\nCREATE TABLE emp (\n  id INT PRIMARY KEY, -- 员工id，主键且自增长\n  ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一\n  joindate DATE NOT NULL , -- 入职日期，非空\n  salary DOUBLE(7,2) NOT NULL , -- 工资，非空\n  bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0\n);\n```\n\n通过上面语句可以创建带有约束的 `emp` 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'张三','1999-11-11',8800,5000);\n```\n\n* **验证主键约束，非空且唯一**\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'张三','1999-11-11',8800,5000);\n```\n\n执行结果如下：\n\n<img src=\"assets/image-20210724114548170.png\" alt=\"image-20210724114548170\" style=\"zoom:80%;\" />\n\n从上面的结果可以看到，字段 `id` 不能为null。那我们重新添加一条数据，如下：\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'张三','1999-11-11',8800,5000);\n```\n\n执行结果如下：\n\n<img src=\"assets/image-20210724114805350.png\" alt=\"image-20210724114805350\" style=\"zoom:80%;\" />\n\n从上面结果可以看到，1这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(2,'李四','1999-11-11',8800,5000);\n```\n\n执行结果如下：\n\n<img src=\"assets/image-20210724115024106.png\" alt=\"image-20210724115024106\" style=\"zoom:80%;\" />\n\n* **验证非空约束**\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(3,null,'1999-11-11',8800,5000);\n```\n\n执行结果如下：\n\n<img src=\"assets/image-20210724115149415.png\" alt=\"image-20210724115149415\" style=\"zoom:80%;\" />\n\n从上面结果可以看到，`ename` 字段的非空约束生效了。\n\n* **验证唯一约束**\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(3,'李四','1999-11-11',8800,5000);\n```\n\n执行结果如下：\n\n<img src=\"assets/image-20210724115336916.png\" alt=\"image-20210724115336916\" style=\"zoom:80%;\" />\n\n从上面结果可以看到，`ename` 字段的唯一约束生效了。\n\n* **验证默认约束**\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary) values(3,'王五','1999-11-11',8800);\n```\n\n执行完上面语句后查询表中数据，如下图可以看到王五这条数据的bonus列就有了默认值0。\n\n<img src=\"assets/image-20210724115547951.png\" alt=\"image-20210724115547951\" style=\"zoom:80%;\" />\n\n==注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。==\n\n如下：\n\n```sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(4,'赵六','1999-11-11',8800,null);\n```\n\n执行完上面语句后查询表中数据，如下图可以看到赵六这条数据的bonus列的值是null。\n\n<img src=\"assets/image-20210724115826516.png\" alt=\"image-20210724115826516\" style=\"zoom:80%;\" />\n\n* **验证自动增长： auto_increment  当列是数字类型 并且唯一约束**\n\n重新创建 `emp` 表，并给id列添加自动增长\n\n```sql\n-- 员工表\nCREATE TABLE emp (\n  id INT PRIMARY KEY auto_increment, -- 员工id，主键且自增长\n  ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一\n  joindate DATE NOT NULL , -- 入职日期，非空\n  salary DOUBLE(7,2) NOT NULL , -- 工资，非空\n  bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0\n);\n```\n\n接下来给emp添加数据，分别验证不给id列添加值以及给id列添加null值，id列的值会不会自动增长：\n\n```sql\nINSERT INTO emp(ename,joindate,salary,bonus) values('赵六','1999-11-11',8800,null);\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'赵六2','1999-11-11',8800,null);\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'赵六3','1999-11-11',8800,null);\n```\n\n\n\n### 1.8  外键约束\n\n#### 1.8.1  概述\n\n外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\n\n如何理解上面的概念呢？如下图有两张表，员工表和部门表：\n\n<img src=\"assets/image-20210724120904180.png\" alt=\"image-20210724120904180\" style=\"zoom:80%;\" />\n\n员工表中的dep_id字段是部门表的id字段关联，也就是说1号学生张三属于1号部门研发部的员工。现在我要删除1号部门，就会出现错误的数据（员工表中属于1号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的1号部门的数据将无法删除。\n\n#### 1.8.2  语法\n\n* 添加外键约束\n\n```sql\n-- 创建表时添加外键约束\nCREATE TABLE 表名(\n   列名 数据类型,\n   …\n   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) \n); \n```\n\n```sql\n-- 建完表后添加外键约束\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\n```\n\n* 删除外键约束\n\n```sql\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n```\n\n\n\n#### 1.8.3  练习\n\n根据上述语法创建员工表和部门表，并添加上外键约束：\n\n```sql\n-- 删除表\nDROP TABLE IF EXISTS emp;\nDROP TABLE IF EXISTS dept;\n\n-- 部门表\nCREATE TABLE dept(\n\tid int primary key auto_increment,\n\tdep_name varchar(20),\n\taddr varchar(20)\n);\n-- 员工表 \nCREATE TABLE emp(\n\tid int primary key auto_increment,\n\tname varchar(20),\n\tage int,\n\tdep_id int,\n\n\t-- 添加外键 dep_id,关联 dept 表的id主键\n\tCONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id)\t\n);\n```\n\n添加数据\n\n```sql\n-- 添加 2 个部门\ninsert into dept(dep_name,addr) values\n('研发部','广州'),('销售部', '深圳');\n\n-- 添加员工,dep_id 表示员工所在的部门\nINSERT INTO emp (NAME, age, dep_id) VALUES \n('张三', 20, 1),\n('李四', 20, 1),\n('王五', 20, 1),\n('赵六', 20, 2),\n('孙七', 22, 2),\n('周八', 18, 2);\n```\n\n此时删除 `研发部` 这条数据，会发现无法删除。\n\n删除外键\n\n```sql\nalter table emp drop FOREIGN key fk_emp_dept;\n```\n\n重新添加外键\n\n```sql\nalter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);\n```\n\n\n\n\n\n\n"},{title:"mysql自定义函数",headers:[{level:2,title:"建库函数",slug:"建库函数",link:"#建库函数",children:[]},{level:2,title:"建表函数",slug:"建表函数",link:"#建表函数",children:[]},{level:2,title:"加字段函数",slug:"加字段函数",link:"#加字段函数",children:[]},{level:2,title:"自定义函数中调用其他函数做循环",slug:"自定义函数中调用其他函数做循环",link:"#自定义函数中调用其他函数做循环",children:[]}],path:"/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html",pathLocale:"/",extraFields:"---\ntitle: mysql自定义函数\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\nmysql自定义函数\n\x3c!-- more --\x3e\n\n# mysql自定义函数\n\n\n\n## 建库函数\n```sql\nCREATE DEFINER=`root`@`%` PROCEDURE `createdatabases`()\nBEGIN\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant where TENANTCODE<>'incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET Done = 1;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\t#CREATE DATABASE str CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\tSET @strsql = CONCAT('CREATE DATABASE  if not exists ',str,' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci');\n    ## 预处理需要执行的动态SQL,其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\nEND\n```\n\n## 建表函数\n\n```sql\nCREATE DEFINER=`root`@`%` PROCEDURE `addtable`()\nBEGIN\n\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant WHERE TENANTCODE!='incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR 1243 SET Done = 0;\nDECLARE CONTINUE HANDLER FOR 1146 SET Done = 0;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\tSET @strsql = CONCAT(\"CREATE TABLE  IF NOT EXISTS \" ,str,\".`sys_module_operation_record` (\n  `ID` varchar(36) NOT NULL COMMENT '主键',\n  `CODE` varchar(100) DEFAULT NULL COMMENT '编号',\n  `EVENTTIME` datetime DEFAULT NULL COMMENT '事件时间',\n  `OPERATIONUSERID` varchar(36) DEFAULT NULL COMMENT '操作用户ID',\n  `OPERATIONUSERNAME` varchar(50) DEFAULT NULL COMMENT '操作用户名称',\n  `EVENTTYPE` varchar(50) DEFAULT NULL COMMENT '事件类型',\n  `EVENTTYPENAME` varchar(50) DEFAULT NULL COMMENT '事件类型名称',\n  `EVENTDESCRIBE` varchar(300) DEFAULT '' COMMENT '事件描述',\n  `TABLENAME` varchar(100) DEFAULT NULL COMMENT '关联主表',\n  `IP` varchar(50) DEFAULT NULL COMMENT 'IP',\n  `OPURL` varchar(200) DEFAULT NULL COMMENT 'URL',\n  `CLIENTINFO` varchar(200) DEFAULT NULL COMMENT '客户端',\n  `ISMOBILE` varchar(20) DEFAULT NULL COMMENT '是否移动端',\n  `ROPTION` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '扩展json格式配置',\n  `DELETED` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '0' COMMENT '是否删除Y/N',\n  `REMARK` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '备注',\n  `CREATEDATE` datetime DEFAULT NULL COMMENT '创建时间',\n  `CREATEUSERID` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建用户ID',\n  `MODIFYDATE` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改日期',\n  `MODIFYUSERID` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改用户ID',\n  `CREATEUSERNAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建人名称',\n  `MODIFYUSERNAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改人名称',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='日志记录';\");\n    ## 预处理需要执行的动态SQL，其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\n\nEND\n\n```\n\n## 加字段函数\n```sql\nCREATE DEFINER=`root`@`%` PROCEDURE `adddatabaseclumn`()\nBEGIN\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant WHERE TENANTCODE!='incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR 1243 SET Done = 0;\nDECLARE CONTINUE HANDLER FOR 1146 SET Done = 0;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\t#alter table wf_run_task add COLUMN AUDITTIMELIMIT datetime COMMENT '审批时限';\n\tSET @strsql = CONCAT('alter table ',str,'.wf_run_task add COLUMN AUDITTIMELIMIT datetime COMMENT \\'审批时限\\'');\n    ## 预处理需要执行的动态SQL,其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\nEND\n\n```\n\n## 自定义函数中调用其他函数做循环\n```sql\nCREATE DEFINER=`root`@`%` PROCEDURE `createAllBlades`()\nBEGIN\n\t#Routine body goes here...\n\n\tDECLARE macId VARCHAR(64) ;   -- 自定义变量tableName\n\tDECLARE done INT DEFAULT FALSE;\n  declare runsql varchar(1000);\n\n\t-- 定义游标并输入结果集\n\tDECLARE cur_account CURSOR FOR select machine_id from qacs2000_config_2010.c_machine;\n\n\t-- 将结束标志绑定到游标，游标循环结束自动转true\n\tDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n\n\t-- 打开游标\n\tOPEN  cur_account;\n\t-- 开始循环，read_loop为自定义循环名,结束循环时用到\n\t  read_loop: LOOP\n\n\t\t-- 取值 将游标当前读取行的数据顺序赋予自定义变量\n\t\tFETCH cur_account INTO macId;\n\n\t\t-- 判断是否继续循环\n\t\tIF done THEN\n\t\t\tLEAVE read_loop; -- 结束循环\n\t\tEND IF;\n\n    set @sqlStr= concat('call dgm2000_1_2010.createtables(', macId, ')');\n    PREPARE stmt from @sqlStr;\n    EXECUTE stmt;\n    deallocate prepare stmt;\n\n\tEND LOOP read_loop;\n\n\tCLOSE cur_account; -- 关闭游标\n\nEND\n```"},{title:"触发器",headers:[{level:2,title:"触发器",slug:"触发器",link:"#触发器",children:[]}],path:"/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html",pathLocale:"/",extraFields:"---\ntitle: 触发器\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - mysql\n\ntag:\n  - sql\n\n---\n\n触发器\n\x3c!-- more --\x3e\n\n\n## 触发器\n1.触发器创建,语法如下\n```shell\nCREATE TRIGGER trigger_name\n{BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON table_name\nFOR EACH ROW\nBEGIN\n    -- 触发器主体\n    -- 你的SQL语句\nEND;\n```\neg:\n创建 order  表\n```shell\nCREATE TABLE orders (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product VARCHAR(255),\n    quantity INT,\n    order_date DATE\n);\n```\n创建 order_summary 表\n```shell\nCREATE TABLE orders (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product VARCHAR(255),\n    quantity INT,\n    order_date DATE\n);\n```\n创建触发器\n```shell\nDELIMITER $$\n\nCREATE TRIGGER after_insert_order\nAFTER INSERT ON orders\nFOR EACH ROW\nBEGIN\n    UPDATE order_summary SET total_orders = total_orders + 1;\nEND$$\nDELIMITER ;\n\n```\n\n测试触发器\n```shell\n-- 插入几条订单记录\nINSERT INTO orders (product, quantity, order_date) VALUES ('Apple', 10, '2024-11-28');\nINSERT INTO orders (product, quantity, order_date) VALUES ('Banana', 5, '2024-11-28');\n\n-- 查看当前的总订单数\nSELECT * FROM order_summary;\n```\n\n注意事项：databases.tableName 在mybatis 和 jdbc中，手动 database 写死无效，只能初始化数据库的时候设置的 database 就是 table 所存在的库才有效"},{title:"ftp",headers:[{level:2,title:"概述",slug:"概述",link:"#概述",children:[]},{level:2,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:2,title:"Server Reply: SSH-2.0-OpenSSH_7.4 报错",slug:"server-reply-ssh-2-0-openssh-7-4-报错",link:"#server-reply-ssh-2-0-openssh-7-4-报错",children:[]},{level:2,title:"老是连接超时",slug:"老是连接超时",link:"#老是连接超时",children:[]},{level:2,title:"getReplyCode() 返回530",slug:"getreplycode-返回530",link:"#getreplycode-返回530",children:[]},{level:2,title:"sortFile 连接超时",slug:"sortfile-连接超时",link:"#sortfile-连接超时",children:[]}],path:"/posts/network/ftp.html",pathLocale:"/",extraFields:"---\ntitle: ftp\nicon: pen-to-square\ndate: 2023-06-05\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - bug\n---\n\nftp 的一些基础内容\n\n\x3c!-- more --\x3e\n\n## 概述\n文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。\n\nFTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。\n## 引入依赖\n```xml\n <dependency>\n    <groupId>commons-net</groupId>\n    <artifactId>commons-net</artifactId>\n    <version>3.3</version>\n</dependency>\n```\n\n## Server Reply: SSH-2.0-OpenSSH_7.4 报错\n端口号设置错误，22是sftp的默认端口，ftp默认使用的端口是21。\n\n## 老是连接超时\n阿里云每一开放21端口号\n\n## getReplyCode() 返回530\n就是你连接上了，只是ftpClient.getReplyCode()的返回值是530，那么就是因为你当前用户没有传输文件的权限，先提供如下解决办法。     \n一般root用户是有权限的若是root      还返回530，就用一下方法：先查看/etc/vsftpd/下面的文件ftpusers和user_list里面是否有你的用户名，若有注释就可以了。这两个文件中的用户都是没有权限。\n\n## sortFile 连接超时\n将下述代码放在建立连接之前\n```java\n ftpClient.enterLocalPassiveMode();//开启被动模式\n```"},{title:"计算机网络",headers:[{level:2,title:"1.计算机网络概述",slug:"_1-计算机网络概述",link:"#_1-计算机网络概述",children:[{level:3,title:"1.1.互联网的构成",slug:"_1-1-互联网的构成",link:"#_1-1-互联网的构成",children:[]},{level:3,title:"1.2.网络分类",slug:"_1-2-网络分类",link:"#_1-2-网络分类",children:[]},{level:3,title:"1.3.接入网",slug:"_1-3-接入网",link:"#_1-3-接入网",children:[]},{level:3,title:"1.4.网络核心的两大功能",slug:"_1-4-网络核心的两大功能",link:"#_1-4-网络核心的两大功能",children:[]},{level:3,title:"1.5.网络分层",slug:"_1-5-网络分层",link:"#_1-5-网络分层",children:[]},{level:3,title:"1.6.三种交换方式",slug:"_1-6-三种交换方式",link:"#_1-6-三种交换方式",children:[]},{level:3,title:"1.7.计算机网络的性能指标",slug:"_1-7-计算机网络的性能指标",link:"#_1-7-计算机网络的性能指标",children:[]},{level:3,title:"1.8.计算机网络体系结构",slug:"_1-8-计算机网络体系结构",link:"#_1-8-计算机网络体系结构",children:[]}]}],path:"/posts/network/internet.html",pathLocale:"/",extraFields:'---\ntitle: 计算机网络\nicon: pen-to-square\ndate: 2023-06-05\nlastUpdated: true\ncategory:\n  - network\ntag:\n  - internet\n---\n\n计算机网络学习笔记\n\n\x3c!-- more --\x3e\n\n\n\n## 1.计算机网络概述\n\n### 1.1.互联网的构成\n\n**网络：**（Network）由若干节点（Node）和连接这些节点的链路（Link）组成\n\n**网络边缘**:位于互联网边缘与互联网相连的计算机和其他设备,如桌面计算机、移动计算机、服务器、其他智能终端设备\n\n**网络核心**:由互联端系统的分组交换设备和通信链路构成的网状网络\n\n如：分组交换路由器、链路层交换机、通信链路(光纤、铜缆、无线电、激光链路)\n\n**网络：**\n\n### 1.2.网络分类\n\n#### 1.2.1.按覆盖范围分类\n\n**个域网PAN（ Personal Area Network）**\n\n* 能在便携式消费电器与通信设备之间进行短距离通信的网络\n\n* 覆盖范围一般在10米半径以内，如蓝牙耳机等\n\n**局域网LAN（Local Area Network）**\n\n* 局部地区形成的区域网络，如企业网络\n\n* 分布地区范围有限，可大可小，大到一栋建筑、小到办公室内的组网\n\n* 电脑WLAN接入，打印机共享等等\n\n**城域网MAN（Metropolitan Area Network ）**\n\n* 范围覆盖一个城市的网络\n\n**广域网WAN（Wide Area Network）**\n\n* 覆盖很大地理区域，乃至覆盖地区和国家\n\n  \n\n#### 1.2.2.按交换技术分类\n\n* 电路交换网络\n* 报文交换网络\n* 分组交换网络\n\n#### 1.2.3.按使用者分类\n\n* 共用网\n* 专用网\n\n#### 1.2.4.按传输介质分类\n\n* 有线网络\n* 无线网络\n\n#### 1.2.5.按拓扑结构分类\n\n* 总线型网络\n* 星型网络\n* 环形网络\n* 网状型网络\n\n\n\n### 1.3.接入网\n\n**边缘路由器**：顾名思义，就是局域网和广域网交界处的路由器。\n\n**各种异构网络通过边缘路由器接入**\n\n**接入网的用途**\n\n* 将主机连接到边缘路由器上\n* 边缘路由器是端系统Host去往任何其他远程端系统的路径上的第一台路由器\n\n**接入网分类：**\n\n* 光纤到户FTTH（fiber to the home）：就是光纤接到家中\n* 数字用户线DSL（Digital Subscriber Line）：是对在[本地电话网](https://baike.baidu.com/item/本地电话网/5924475?fromModule=lemma_inlink)线上所提供的数字数据传输的一整套技术的总称，是通过**铜线**或者**本地电话网**提供数字连接的一种技术\n\n* 同轴电缆：是一种电线及信号传输线\n* 无线接入：无线接入是指从交换节点到用户终端之间，部分或全部采用了无线手段，比如WiFi？\n\n* 企业和家庭网络：企业贵\n\n### 1.4.网络核心的两大功能\n\n**①路由**\n\n确定数据分组从源到目标所使用的路径（全局操作）\n\n**②转发**\n\n路由器或交换机将接受到的数据分组转发出去（即移动到该设备的某个输出口）（本地操作）\n\n\n\n### 1.5.网络分层\n\n#### 1.5.1.OSI七层模型\n\n|     分类      |         功能 | \n| :-----------: | :------------- | \n| 应用层（Application Layer） | 通过应用层协议，提供应用程序（进程间的交互）便携的网络服务调用 | \n| 表示层（Presentation Layer) |      关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构 | \n|       会话层（Session Layer）     |     利用传输层提供的服务，在应用程序之间建立和维持会话，并能使会话获得同步 | \n|传输层（Transport Layer）|1、将数据从源端口发送到目的端口（进程到进程），以及传输出现错误的处理 <br> 2、网络层定位到一台主机（host），传输层的作用域具体到主机上的某一个进程 <br> 3、网络层的控制主要面向运营商，传输层为终端用户提供端到端的数据传输控制<br>4、两类模式：可靠的传输模式，或不可靠传输模式<br>5、可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等<br>6、不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等|\n|网络层（Network Layer）|1、将数据包跨越网络从源设备发送到目的设备（host to host）<br>2、路由（Routing）：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由<br>3、路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息<br>4、服务质量（QoS）控制：处理网络拥塞、负载均衡、准入控制、保障延迟<br>5、异构网络互联：在异构编址和异构网络中路由寻址和转发|\n| 数据链路层（Data Link Layer）| 1、实现相邻（Neighboring）网络实体间的数据传输<br>2、成帧（Framing）：从物理层的比特流中提取出完整的帧<br>3、错误检测与纠正：为提供可靠数据通信提供可能<br>4、物理地址（MAC address）：48位，理论上唯一网络标识，烧录在网卡，不便更改。用于识别各主机<br>5、流量控制，避免“淹没（overwhelming）:当快速的发送端遇上慢速的接收端，接收端缓存溢出<br>6、共享信道上的访问控制（MAC）：同一个信道，同时传输信号。如同：同一个Wifi热点（AP）连接着多个无线用户（手机），则多个用户同时需要发送数据，如何控制发送顺序？或者说，协调各主机争用总线。|\n|物理层（Physical Layer）| 1、决定采用怎样的传输介质<br>2、决定采用怎样的物理接口<br>3、决定使用怎样的信号表示比特0和1|\n\n\n #### 1.5.2.TCP/IP 4层模型\n|     分类      |         功能 |  内部 |\n| :-----------: | :------------- |  :-------------|\n|应用层|解决通过应用进程的交互来实现特定网络应用的问题|HTTP……SMTP；DNS……RTP|\n|传输层|解决进程之间基于网络的通信问题|TCP；UDP（分号对应上一行|\n|传输网层|暂未总结| IP：<br>1、IP协议可以为各种网络应用提供服务(上一行）<br>2、使用ip协议互连不同的网络接口（下一行）|\n|网络接口层|可以拆分为数据链路层和物理层，适合教学|网络接口1、2、3……|\n\n\n\n#### 1.5.3.两种模型比较 \n\n OSI的失败：糟糕的时机、技术、实现、政策。\n |     OSI模型的不足      |         TCP/IP模型的不足 | \n| :----------- | :------------- | \n|\t1、从未真正被实现：TCP/IP已成为实施标准，OSI缺少厂家支持<br> 2、技术实现糟糕：<br> &ensp;&ensp; ① OSI分成缺少技术考虑：某些层内容少，有些层太多。模型和协议过于复杂。<br >&ensp;&ensp;② 分层功能重复出现<br>3、非技术原因：TCP/IP实现为UNIX一部分，免费；OSI被认为是政府和机构的加强标准|1、核心概念未能提现：未明确区分服务、接口和协议等核心概念<br>2、不具备通用性：不适用于描述TCP/IP之外的其他协议栈<br>3、混用接口与分层的设计：链路层和物理层一起呗定义为网络接口层，而非真正意义上的分层<br>4、模型欠缺完整性：未包含物理层和数据链路层；物理层和链路层是至关重要的部分|\n\n\n### 1.6.三种交换方式\n\n#### 1.6.1.电路交换\n\n一开始是电话和电话直接用一根线连接在一起；后面出现电话交换机，之后电话只需要连到交换机上，由交换机转发。\n\n* 电话交换机接通电话线的方式称为电路交换；\n* 从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输路线的资源；\n* 电路交换的三个步骤：\n  * 建立连接（分配通信资源）\n  * 通话（一直占用通信资源）\n  * 释放连接（归还通信资源）\n\n\n\n\n\n#### 1.6.2.报文交换和分组交换\n\n**报文交换：**在报文交换中没有专用的电路来传输数据。相反，我们可以通过添加一个标头，在数据准备好的任何时候发送一块数据，它就是分组或数据包（packet）。标头里包含了数据包的目标地址。\n\n\n\n**分组交换：**当数据过大时，拆分数据，此时就变成了分组交换。\n\n分组交换包括三方：\n\n* 发送方：构造分组，发送分组。\n* 路由器：缓存分组，转发分组。\n* 接收方：接收分组，还原报文。\n\n过程如下：\n\n```tex\n100001111[头部]\n```\n\n\n\n当数据量过大时，会拆分如下的两个数据包发送：\n\n```tex\n10001111[头部]……1110011[头部]\n```\n\n目标收到之后，在去掉头部拼接在一起，就构成了完整的数据。\n\n```tex\n10001111……1110011\n```\n\n\n\n\n\n#### 1.6.3.三种交换方式的对比\n\n\n\n\n\n| 交换方式 | 优点                                                         | 缺点                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 电路交换 | 1)通信时延小<br/>2)有序传输<br/>3)没有冲突<br/>4)适用范围广<br/>5)实时性强<br/>6)控制简单 | 1)建立连接时间长<br/>2)线路独占，使用效率低<br/>3)灵活性差<br/>4)难以规格化 |\n| 报文交换 | 1)无需建立连接<br/>2)动态分配线路<br/>3)提高线路可靠性<br/>4)提高线路利用率<br/>5)提供多目标服务 | 1）引起了转发时延<br/>2）需要较大存储缓存空间<br/>3）需要传拍额外的信息量 |\n| 分组交换 | 1)无需建立连接)<br/>2)线路利用率高<br/>3)简化了存储管理<br/>4)加速传输<br/>5减少出错概率和重发数据量 | 1)引起了转发时延<br/>2)需要传铂额外的信息量<br/>3)对于数据报服务，存在失序、丢失或重复分组的问题;对于虚电路服务。存在呼叫建立、数据传输和虚电路释放三个过程 |\n\n\n\n\n\n### 1.7.计算机网络的性能指标\n\n* 速率\n* 宽带\n* 吞吐量\n* 时延\n* 时延带宽积\n* 往返时间\n* 利用率\n* 丢包率\n\n#### 1.7.1.速率\n\n**比特**：是计算机中数据量的单位，也是信息论中信息量的单位，就是存储单位。一个比特就是二进制数字中的一个1或0。\n\n* 常用单位：TB = K * GB = K * K * MB = K * K * K * KB = 2^10 * 2^10 * 2^10 * 2^10 B = 2^10 * 2^10 * 2^10 * 2^10 * 8 bit\n\n\n\n**速率**：链接在计算机网络上的主机在数字信道上传送比特的速率，也称比特率或数据率。\n\n* 常用单位：Tb/s = K * Gb/s = K * K * Mb/s = K * K * K * Kb/s  = 10^3 * 10^3 * 10^3 * 10^3 b/s\n* b/s = bps = bit/s\n\neg:有一个待发送的数据块，大小为100MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间？\n\n解：100MB 除以 100Mbps = 8.388 s；\n平时估算时，M直接约掉：B 除以 b = 8 s\n\n#### 1.7.2.带宽\n**带宽：** \n* 在模拟信号系统中的意义：信号所包含的各种不同频段成分所占据的频率范围；\n  * 常用单位：HZ（kHz，MHz，GHz）\n* 在计算机网络中的意义：\n  * 单位时间内从一点到另一点所能通过的最大数据率 \n\n#### 1.7.3.吞吐量\n**吞吐量：**\n* 表示在单位时间内通过某个网络（或信道、接口） 的数据量。\n* 被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。\n* 吞吐量收网络的带宽或额定速率的限制。\n\n#### 1.7.4.时延\n**时延：**\n* 发送时延=分组长度（b）/发送速率（b/s）\n* 传播时延=信道长度（m）/电磁波传输速率（m/s）\n* 处理时延=一般不便于计算\n\neg：数据块长度为100MB，信道带宽为1Mb/s,传送举例为1000Km，计算发送时延和传播时延。\n解：发送时延= 分组长度（b）除以 发送速率(b/s) = 100 * 2^20 * 8b 除以 10^6 b/s = 838.86 s\n传播时延 = 信道长度 除以 电磁波传播速度 = 1000 * 10^3 除以 2*10^8 = 0.005 s\n\n#### 1.7.5.时延带宽积\n\n时延带宽积 = 传播时延 * 带宽\n\n* 若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了**时延带宽积个比特**;\n* 链路的时延带宽积又称为**以比特为单位的链路长度**。\n\n\n\n#### 1.7.6.往返时间\n\n* 在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互;\n* 我们有时很需要知道双向交互一次所需的时间;\n* 因此，往返时间RTT(Round-Trip Time)也是一个重要的性能指标\n\n\n\n#### 1.7.7.利用率\n\n* 利用率\n  * 信道利用率：用来表示某信道有百分之几的时间是被利用的 (有数据通过)。\n  * 网络利用率：全网络的信道利用率的加权平均。\n\n\n\n* 根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加;\n* 因此，**信道利用率并非越高越好**。\n* D=Do/(1-u)，如果令Do表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用前面的简单公式来表示D、Do和利用率U之间的关系:\n  * 当网络的利用率达到50%时，时延就要加倍;\n  * 当网络的利用率超过50%时，时延急剧增大:\n  * 当网络的利用率接近100%时，时延就趋于无穷大;\n  * 因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽。当然也不能太低，保持在一个合理的范围内。\n\n#### 1.7.8.丢包率\n\n* 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中**丢失的分组数量与总分组数量的比率**。\n* 丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。\n* 丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标因为他们通常意识不到网络丢包。\n* 分组丢失主要有两种情况:\n  * 分组在传输过程中出现**误码**，被结点丢弃;\n  * 分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成**网络拥塞**。\n\n* 因此，丢包率反映了网络的拥塞情况:\n  * 无拥塞时路径丢包率为0\n  * 轻度拥塞时路径丢包率为1%~4%\n  * 严重拥塞时路径丢包率为5%~15%\n\n### 1.8.计算机网络体系结构\n\n#### 1.8.1.常见的计算机网络体系结构\n\n* OSI七层模型（**法律**上的国际标准）\n* TCP/IP体系结构（**事实**上的国际标准）\n\n#### 1.8.2.计算机网络体系结构分层的必要性\n\n简单来说，就是简单功能复杂化。\n\n#### 1.8.3.计算机网络体系结构分层思想举例\n\n应用进程间基于网络通信，`ETH+HTTP+TCP+IP+ETH`，生成比特流\n\nIP数据报：`HTTP+TCP+IP`;\n\n帧：`ETH+HTTP+TCP+IP+ETH`\n\n#### 1.8.4.计算机网络体系结构中的专用术语\n\n* 实体：任何可发送或接收信息的**硬件**或**软件进程**。\n  * 对等实体：收发双方**相同层次中的实体**。就是应用层-》应用层，网络层-》网络层；以此类推。\n\n* 协议：控制两个对等实体进行逻辑通信的规则的集合。\n\n* 协议的三要素：\n\n  * 语法：定义所交换信息的格式\n  * 语义：定义收发双方索要完成的操作。\n  * 同步：定义收发双方的时序关系\n\n  \n\n* 服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务\n  * 要实现本层协议，还需要使用下面一层所提供的服务。\n  * 协议是“水平的”，服务是“垂直的”。\n  * 实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是"透明”的。\n* 服务访问点：在同一系统中**相邻两层的实体交换信息的逻辑接口**，用于区分不同的服务类型。\n  * 数据链路层的服务访问点为帧的“类型”字段。\n  * 网络层的服务访问点为IP数据报首部中的“协议字段”。\n  * 运输层的服务访问点为“端口号”。\n* 上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。\n\n\n\n* 协议数据单元PDU：**对等层次之间传送的数据包**称为该层的协议数据单元。\n* 服务数据单元SDU：同一系统内，**层与层之间交换的数据包**称为服务数据单元。\n* 多个SDU也可划分为几个PDU.多个SDU可以合成为一个PDU:\n\n\n\n​\t![alt text](./../../../src/.vuepress/public/assets/images/blogs/Internet1.png)\n'},{title:"redis 学习笔记之实战篇",headers:[{level:2,title:"1.短信登陆",slug:"_1-短信登陆",link:"#_1-短信登陆",children:[{level:3,title:"1.1实现发送短信验证码功能",slug:"_1-1实现发送短信验证码功能",link:"#_1-1实现发送短信验证码功能",children:[]},{level:3,title:"1.2.实现登陆拦截功能",slug:"_1-2-实现登陆拦截功能",link:"#_1-2-实现登陆拦截功能",children:[]},{level:3,title:"1.3.session共享问题",slug:"_1-3-session共享问题",link:"#_1-3-session共享问题",children:[]},{level:3,title:"1.4.Redis代替session的业务流程",slug:"_1-4-redis代替session的业务流程",link:"#_1-4-redis代替session的业务流程",children:[]},{level:3,title:"1.5.用Redis代替session存储短信验证码",slug:"_1-5-用redis代替session存储短信验证码",link:"#_1-5-用redis代替session存储短信验证码",children:[]},{level:3,title:"1.6.基于Redis实现短信登陆",slug:"_1-6-基于redis实现短信登陆",link:"#_1-6-基于redis实现短信登陆",children:[]},{level:3,title:"1.7.修改优化拦截器",slug:"_1-7-修改优化拦截器",link:"#_1-7-修改优化拦截器",children:[]}]},{level:2,title:"2.商户查询缓存",slug:"_2-商户查询缓存",link:"#_2-商户查询缓存",children:[{level:3,title:"2.1.什么是缓存",slug:"_2-1-什么是缓存",link:"#_2-1-什么是缓存",children:[]},{level:3,title:"2.2.添加商户缓存",slug:"_2-2-添加商户缓存",link:"#_2-2-添加商户缓存",children:[]},{level:3,title:"2.3.缓存更新策略",slug:"_2-3-缓存更新策略",link:"#_2-3-缓存更新策略",children:[]},{level:3,title:"2.4.实现商铺和缓存与数据库双写一致",slug:"_2-4-实现商铺和缓存与数据库双写一致",link:"#_2-4-实现商铺和缓存与数据库双写一致",children:[]},{level:3,title:"2.5.缓存穿透问题的解决思路",slug:"_2-5-缓存穿透问题的解决思路",link:"#_2-5-缓存穿透问题的解决思路",children:[]},{level:3,title:"2.6.编码解决商品查询的缓存穿透问题：",slug:"_2-6-编码解决商品查询的缓存穿透问题",link:"#_2-6-编码解决商品查询的缓存穿透问题",children:[]},{level:3,title:"2.7.缓存雪崩问题及解决思路",slug:"_2-7-缓存雪崩问题及解决思路",link:"#_2-7-缓存雪崩问题及解决思路",children:[]},{level:3,title:"2.8.缓存击穿问题及解决思路",slug:"_2-8-缓存击穿问题及解决思路",link:"#_2-8-缓存击穿问题及解决思路",children:[]},{level:3,title:"2.9.封装Redis工具类",slug:"_2-9-封装redis工具类",link:"#_2-9-封装redis工具类",children:[]}]},{level:2,title:"3.优惠券秒杀",slug:"_3-优惠券秒杀",link:"#_3-优惠券秒杀",children:[{level:3,title:"3.1.全局唯一ID",slug:"_3-1-全局唯一id",link:"#_3-1-全局唯一id",children:[]},{level:3,title:"3.2.Redis实现全局唯一Id",slug:"_3-2-redis实现全局唯一id",link:"#_3-2-redis实现全局唯一id",children:[]},{level:3,title:"3.3.添加优惠券",slug:"_3-3-添加优惠券",link:"#_3-3-添加优惠券",children:[]},{level:3,title:"3.4.实现秒杀下单(基础逻辑）",slug:"_3-4-实现秒杀下单-基础逻辑",link:"#_3-4-实现秒杀下单-基础逻辑",children:[]},{level:3,title:"3.5.库存超卖问题分析",slug:"_3-5-库存超卖问题分析",link:"#_3-5-库存超卖问题分析",children:[]},{level:3,title:"3.6.乐观锁解决超卖问题",slug:"_3-6-乐观锁解决超卖问题",link:"#_3-6-乐观锁解决超卖问题",children:[]},{level:3,title:"3.7.优惠券秒杀-一人一单",slug:"_3-7-优惠券秒杀-一人一单",link:"#_3-7-优惠券秒杀-一人一单",children:[]},{level:3,title:"3.8.集群环境下的并发问题",slug:"_3-8-集群环境下的并发问题",link:"#_3-8-集群环境下的并发问题",children:[]}]},{level:2,title:"4.分布式锁",slug:"_4-分布式锁",link:"#_4-分布式锁",children:[{level:3,title:"4.1.基本原理和实现方式对比",slug:"_4-1-基本原理和实现方式对比",link:"#_4-1-基本原理和实现方式对比",children:[]},{level:3,title:"4.2.Redis分布式锁的实现核心思路",slug:"_4-2-redis分布式锁的实现核心思路",link:"#_4-2-redis分布式锁的实现核心思路",children:[]},{level:3,title:"4.3.实现分布式锁版本一",slug:"_4-3-实现分布式锁版本一",link:"#_4-3-实现分布式锁版本一",children:[]}]}],path:"/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html",pathLocale:"/",extraFields:'\ufeff---\ntitle: redis 学习笔记之实战篇\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - redis\n\ntag:\n  - java\n  - spring\n  - springboot\n  - redis\n\n---\n\nredis 学习笔记之实战篇\n\x3c!-- more --\x3e\n\n\n\n# redis 学习笔记之实战篇\n\n标签（空格分隔）： redis\n\n---\n## 1.短信登陆\n### 1.1实现发送短信验证码功能\n1）发送验证码\n```java\n public Result sendCode(String phone, HttpSession session) {\n        // 1.校验手机号\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.符合，生成验证码\n        String code = RandomUtil.randomNumbers(6);\n\n        // 4.保存验证码到 session\n        session.setAttribute("code",code);\n        // 5.发送验证码\n        System.out.println("code:"+code);\n        // 返回ok\n        return Result.ok();\n    }\n```\n使用postman进行测试：http://localhost:10086/student/code\n参数：phone 12312XXX\n\n2）登录\n```java\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n        // 1.校验手机号\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.校验验证码\n        Object cacheCode = session.getAttribute("code");\n        String code = loginForm.getCode();\n        if(cacheCode == null || !cacheCode.toString().equals(code)){\n            //3.不一致，报错\n            return Result.fail("验证码错误");\n        }\n        //一致，根据手机号查询用户\n        Student stu = StudentList.findByPhone(phone);\n        //5.判断用户是否存在\n        if(stu == null){\n            //不存在，则创建\n            stu =  createUserWithPhone(phone);\n        }\n        //7.保存用户信息到session中\n        session.setAttribute("stu", BeanUtil.copyProperties(stu, StudentDTO.class));\n\n        return Result.ok();\n    }\n```\n使用postman进行测试：http://localhost:10086/student/login\n参数：\n```json\n{\n"phone":"XXXXXXX",\n"code":"前面获取的，是后台打印"\n}\n```\n\n### 1.2.实现登陆拦截功能\n使用threadlocal来做到线程隔离，每个线程操作自己的一份数据。\n\n1）拦截器代码\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        //1.获取session\n        HttpSession session = request.getSession();\n        //2.获取session中的用户\n        Object stu = session.getAttribute("stu");\n        //3.判断用户是否存在\n        if(stu == null){\n            //4.不存在，拦截，返回401状态码\n            response.setStatus(401);\n            return false;\n        }\n        //5.存在，保存用户信息到Threadlocal\n        StudentHolder.saveStudent((StudentDTO) stu);\n        //6.放行\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        // 移除用户\n        StudentHolder.removeStudent();\n\n    }\n}\n```\n2）让拦截器生效\n```java\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        "/student/code",\n                        "/student/login"\n                );\n    }\n}\n```\n### 1.3.session共享问题\n**核心思路分析：**\n\n集群的每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了\n\n但是这种方案具有两个大问题\n\n1、每台服务器中都有完整的一份session数据，服务器压力过大。\n\n2、session拷贝数据时，可能会出现延迟\n\n所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了\n\n**session共享问题：**多台Tomcat并不共享session存储空间，当请求切换到不同Tomcat服务时，导致数据丢失的问题。\nsession的替代方案应该满足：\n\n- 数据共享\n- 内存存储\n- key、value结构\n\n### 1.4.Redis代替session的业务流程\n#### 1.4.1.设计key的结构\n首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如果使用String，注意他的value，会多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。\n\n#### 1.4.2.设计key的具体细节\n所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了\n\n在设计这个key的时候，我们之前讲过需要满足两点\n\n1、key要具有唯一性\n\n2、key要方便携带\n\n如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了\n\n#### 1.4.3.整体访问流程\n当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。\n\n### 1.5.用Redis代替session存储短信验证码\n```java\n//session.setAttribute("code",code);\n// set key value ex 120\nstringRedisTemplate.opsForValue().set("login:code"+phone,code,2,TimeUnit.MINUTES);\n```\n\n### 1.6.基于Redis实现短信登陆\n```java\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n        // 1.校验手机号\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.校验验证码,TODO 之后从redis中获取\n//        Object cacheCode = session.getAttribute("code");\n        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);\n        String code = loginForm.getCode();\n        if(cacheCode == null || !cacheCode.toString().equals(code)){\n            //3.不一致，报错\n            return Result.fail("验证码错误");\n        }\n        //一致，根据手机号查询用户\n        Student stu = StudentList.findByPhone(phone);\n        //5.判断用户是否存在\n        if(stu == null){\n            //不存在，则创建\n            stu =  createUserWithPhone(phone);\n        }\n        //7.保存用户信息到session中，TODO 之后用redis代替\n//        session.setAttribute("stu", BeanUtil.copyProperties(stu, StudentDTO.class));\n        // TODO 7.1.随机生成token，作为登录令牌\n        String token = UUID.randomUUID().toString(true);\n        //TODO 7.2.将User对象转为HashMap存储\n        StudentDTO stuDTO = BeanUtil.copyProperties(stu, StudentDTO.class);\n        Map<String, Object> stuMap = BeanUtil.beanToMap(stuDTO, new HashMap<>(),\n                CopyOptions.create() // 数据拷贝是的选项\n                        .setIgnoreNullValue(true) //忽略空的值\n                        .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));//修改字段，将long的id转为String\n        //TODO 7.3.存储\n        String tokenKey = LOGIN_STU_KEY + token;\n        stringRedisTemplate.opsForHash().putAll(tokenKey, stuMap);\n        // TODO 7.4.设置token有效期\n        stringRedisTemplate.expire(tokenKey, LOGIN_STU_TTL, TimeUnit.MINUTES);\n//        return Result.ok();\n        return Result.ok(token);//TODO 返回token\n    }\n```\n### 1.7.修改优化拦截器\n目前位置，上述代码只能在登陆的时候刷新token，其他访问路径不刷新token，因此修改拦截器：\n- 保证所有路径都会刷新token\n- 判断用户是否存在，且拦截路径访问\n\n所以使用两个拦截器：\n1）所有路劲刷新token\n```java\npublic class RefreshTokenInterceptor implements HandlerInterceptor {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            // 1.获取请求头中的token\n            String token = request.getHeader("authorization");\n            if (StrUtil.isBlank(token)) {\n                return true;\n            }\n            // 2.基于TOKEN获取redis中的用户\n            String key  = LOGIN_STU_KEY + token;\n            Map<Object, Object> stuMap = stringRedisTemplate.opsForHash().entries(key);\n            // 3.判断用户是否存在\n            if (stuMap.isEmpty()) {\n                return true;\n            }\n            // 5.将查询到的hash数据转为stuDTO\n            StudentDTO studentDTO = BeanUtil.fillBeanWithMap(stuMap, new StudentDTO(), false);\n            // 6.存在，保存用户信息到 ThreadLocal\n            StudentHolder.saveStudent(studentDTO);\n            // 7.刷新token有效期\n            stringRedisTemplate.expire(key, LOGIN_STU_TTL, TimeUnit.MINUTES);\n            // 8.放行\n            return true;\n        }\n\n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            // 移除用户\n            StudentHolder.removeStudent();\n        }\n    }\n```\n2）判断用户是否存在，且拦截路径访问\n```java\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.判断是否需要拦截（ThreadLocal中是否有用户）\n        if (StudentHolder.getStudent() == null) {\n            // 没有，需要拦截，设置状态码\n            response.setStatus(401);\n            // 拦截\n            return false;\n        }\n        // 有用户，则放行\n        return true;\n    }\n```\n3）配置拦截器生效\n```java\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        "/student/code",\n                        "/student/login"\n                ).order(1);// order(1) 后执行，值越小，执行等级越高\n        // token刷新的拦截器\n        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns("/**").order(0);// order(0) 先执行\n    }\n```\n然后可以测试一下，查看登陆之后的信息：http://localhost:10086/student/me\n需要带上`authorization`\n## 2.商户查询缓存\n### 2.1.什么是缓存\n**缓存**(Cache),就是数据交换的**缓冲区**,俗称的缓存就是**缓冲区内的数据**,一般从数据库中获取,存储于本地代码(例如:\n\n```java\n例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发\n\n例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存\n\n例3:Static final Map<K,V> map =  new HashMap(); 本地缓存\n```\n\n由于其被**Static**修饰,所以随着类的加载而被加载到**内存之中**,作为本地缓存,由于其又被**final**修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;\n\n#### 2.1.1为什么要使用缓存\n一句话:因为**速度快,好用**\n缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低**用户访问并发量带来的**服务器读写压力\n\n#### 2.1.2如何使用缓存\n实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用\n\n**浏览器缓存**：主要是存在于浏览器端的缓存\n\n**应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存\n\n**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中\n\n**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\n\n### 2.2.添加商户缓存\n在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存\n```java\n@GetMapping("/{id}")\npublic Result queryShopById(@PathVariable("id") Long id) {\n    //这里是直接查询数据库\n    return shopService.queryById(id);\n}\n```\n#### 2.2.1.缓存模型和思路\n标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。\n\n#### 2.2.2.代码如下\n代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。\n\n```java\n    public Result queryById(Long id) {\n\n        String key = "cache:shop:" + id;\n        // 1. Mredis查询商铺缓存\n         String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n            return Result.ok(shop);\n\n        }\n        //4.不存在，根据id查询数据库\n        Shop shop = getById(id);\n        //5.不存在，返回错误\n        if (shop == null) {\n            return Result.fail("店铺不存在!");\n        }\n        //6.存在，写入\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));\n        //7.返回\n        return Result.ok(shop);\n        }\n```\n测试查询：http://localhost:10086/shop/2\n\n### 2.3.缓存更新策略\n缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。\n**内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\n\n**超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存\n\n**主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\n\n| ///     | 内存淘汰   |  超时剔除  |主动更新  |\n| :--------:   | :-----:  | :----:  |:----:  |\n| 说明     | 不用自己维护，利用Redis的内存淘汰机制，当内存不足时，自动淘汰部分数据。下次查询时更新缓存 |   给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存     |编写业务逻辑，在修改数据库的同时，更新缓存     |\n| 一致性        |   差   |   一般   |好     |\n| 维护成本        |    无    |  低  |高     |\n\n业务场景：\n\n- 低一致性需求：使用内存淘汰机制。eg：店铺类型的存缓查询\n- 高一致性需求：主动更新，并以超时剔除作为兜底方案。eg：店铺详情查询的缓存\n\n#### 2.3.1.数据库缓存不一致方案：（主动更新）\n由于我们的**缓存的数据源来自于数据库**,而数据库的**数据是会发生变化的**,因此,如果当数据库中**数据发生变化,而缓存却没有同步**,此时就会有**一致性问题存在**,其后果是:\n用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案\n\n>* Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\n\n>* Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理\n\n>* Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致\n\n#### 2.3.2.数据库和缓存不一致采用什么方案（主动更新之Cache Aside Pattern ）\n综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题\n\n操作缓存和数据库时有三个问题需要考虑：\n\n\n\n如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来\n\n* 删除缓存还是更新缓存？\n  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多\n  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存\n\n* 如何保证缓存与数据库的操作的同时成功或失败？\n  * 单体系统，将缓存与数据库操作放在一个事务\n  * 分布式系统，利用TCC等分布式事务方案\n\n应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\n\n* 先操作缓存还是先操作数据库？\n  * 先删除缓存，再操作数据库\n  * 先操作数据库，再删除缓存(**这个好**）\n\n### 2.4.实现商铺和缓存与数据库双写一致\n核心思路如下：\n\n修改ShopController中的业务逻辑，满足下面的需求：\n\n根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间\n\n根据id修改店铺时，先修改数据库，再删除缓存\n\n**修改重点代码1**：修改**ShopService**的queryById方法\n\n**设置redis缓存时添加过期时间**\n```java\nstringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);\n```\n  \n  **修改重点代码2**\n\n代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题\n```java\n @Transactional\n    public Result updateById(Shop shop){\n        Long id = shop.getId();\n        if(id == null){\n            return Result.fail("店铺id不能为空");\n        }\n        // 1.更新数据库\n        ShopList.updateById(shop);\n        // 2.删除缓存\n        stringRedisTemplate.delete(CACHE_SHOP_KEY + id);\n        return Result.ok();\n    }\n```\n测试更新 http://localhost:10086/shop\n参数：\n```json\n{\n"id":2,\n"name":"你看我名字变了吧",\n"address":"你看我地址也变了吧"\n}\n```\n### 2.5.缓存穿透问题的解决思路\n缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n\n常见的解决方案有两种：\n\n* 缓存空对象\n  * 优点：实现简单，维护方便\n  * 缺点：\n      * 额外的内存消耗\n      * 可能造成短期的不一致\n* 布隆过滤\n  * 优点：内存占用较少，没有多余key\n  * 缺点：\n        * 实现复杂\n        * 存在误判可能\n\n\n\n**缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了\n\n\n\n**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，\n\n假设布隆过滤器判断这个数据不存在，则直接返回\n\n这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突\n\n### 2.6.编码解决商品查询的缓存穿透问题：\n核心思路如下：\n\n在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的\n\n现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。\n\n\n**小总结：**\n\n缓存穿透产生的原因是什么？\n\n* 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\n\n缓存穿透的解决方案有哪些？\n\n* 缓存null值\n* 布隆过滤\n* 增强id的复杂度，避免被猜测id规律\n* 做好数据的基础格式校验\n* 加强用户权限校验\n* 做好热点参数的限流\n\n\n### 2.7.缓存雪崩问题及解决思路\n缓存雪崩：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n解决方案：\n\n* 给不同的Key的TTL添加随机值\n* 利用Redis集群提高服务的可用性\n* 给缓存业务添加降级限流策略\n* 给业务添加多级缓存\n\n### 2.8.缓存击穿问题及解决思路\n缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n\n常见的解决方案有两种：\n\n* 互斥锁\n* 逻辑过期\n\n逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大\n\n**解决方案一**、使用锁来解决：\n\n因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。\n\n假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\n\n解决方案二、逻辑过期方案\n\n方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。\n\n我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\n\n这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\n\n\n进行对比\n\n**互斥锁方案：**由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响\n\n**逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦\n\n\n| 解决方案        | 优点   |  缺点  |\n| --------   | :----- | :----  |\n| 互斥锁     | 1）没有额外的内存消耗<br>2）保证一致性<br>3）实现简单|    1）线程需要等待，性能受影响<br>2）可能有死锁风险  |\n| 逻辑过期        |   线程无需等待，性能较好   |   1）不保证一致性<br>2）有额外内存消耗<br>3）实现复杂   |\n\n\n#### 2.8.1.利用互斥锁解决缓存击穿问题\n核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询\n\n如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿\n\n**操作锁的代码：**\n**setnx**:第一次赋值之后，不能被覆盖，相当于获取锁。释放锁就是删掉就好了。\n核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。\n\n```java\n    private boolean tryLock(String key) {\n        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);//setnx\n        return BooleanUtil.isTrue(flag);//帮助拆箱，如果封装类是null会包空指针异常\n    }\n\n    private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n    }\n```\n\n**操作代码：**\n```java\n public Shop queryWithMutex(Long id){\n        String key = CACHE_SHOP_KEY + id;\n        // 1. Mredis查询商铺缓存\n        String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            return JSONUtil.toBean(shopJson, Shop.class);\n\n        }\n        //判断命中的是不是空值，缓存空对象，解决缓存穿透的策略\n        if(shopJson != null){\n            //返回一个错误信息\n            return null;\n        }\n        //4.实现缓存重建\n        //4.1获取互斥锁\n        String lockKey = "lock:shop:" + id;\n        Shop shop = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            //4.2判断是否获取成功\n            if (!isLock){\n                //4.3失败，则休眠或者重试\n                Thread.sleep(50);\n                return queryWithMutex(id);\n            }\n            //4.4成功，根据id查询数据库\n\n            //4.不存在，根据id查询数据库\n            shop = ShopList.findById(id);\n            // 模拟重建的延迟\n            Thread.sleep(200);\n            //5.不存在，返回错误\n            if (shop == null) {\n                //缓存空对象，解决缓存穿透\n                stringRedisTemplate.opsForValue().set(key, "",CACHE_NULL_TTL, TimeUnit.MINUTES);\n                return null;\n            }\n            //6.存在，写入\n            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            //7.释放锁\n            unlock(lockKey);\n        }\n        //8.返回\n        return shop;\n    }\n```\n\n#### 2.8.2.利用逻辑过期解决缓存击穿问题\n\n**需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题**\n\n思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\n\n如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你\n\n**步骤一、**\n\n新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。\n\n```\n@Data\npublic class RedisData {\n    private LocalDateTime expireTime;\n    private Object data;\n}\n```\n\n**步骤二、**\n\n在**ShopService** 新增此方法，利用单元测试进行缓存预热\n```java\n    public void saveShop2Redis(Long id,Long expireSeconds) throws InterruptedException {\n        Thread.sleep(200);\n        //1.查询店铺数据\n        Shop shop = ShopList.findById(id);\n        //2.封装逻辑过期时间\n        RedisData redisData = new RedisData();\n        redisData.setData(shop);\n        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));\n        //3.写入redis\n        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id ,JSONUtil.toJsonStr(redisData));\n    }\n```\n\n**在测试类中**\n\n```java\n@Test\n    public void testSaveShop() throws InterruptedException {\n        shopService.saveShop2Redis(2l,10l);\n    }\n```\n\n步骤三：正式代码\n**ShopService**\n```java\n// 创建一个线程池\n    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);\n    public Shop queryWithLogicalExpire(Long id){\n        String key = CACHE_SHOP_KEY + id;\n        // 1. Mredis查询商铺缓存\n        String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            return null;\n\n        }\n        //4.命中，需要先把JSON序列化为对象\n        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);\n        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        //5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return shop;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock){\n            CACHE_REBUILD_EXECUTOR.submit( ()->{\n\n                try{\n                    //重建缓存\n                    this.saveShop2Redis(id,20L);\n                }catch (Exception e){\n                    throw new RuntimeException(e);\n                }finally {\n                    unlock(lockKey);\n                }\n            });\n        }\n        //7.返回\n        return shop;\n\n\n    }\n```\n\n### 2.9.封装Redis工具类\n基于StringRedisTemplate封装一个缓存工具类，满足下列需求：\n\n* 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间\n* 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓\n\n存击穿问题\n\n* 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\n* 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\n\n将逻辑进行封装\n```java\n\n@Slf4j\n@Component\npublic class CacheClient {\n\n    private final StringRedisTemplate stringRedisTemplate;\n\n    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);//创建线程池\n\n    public CacheClient(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    /**\n     * 序列化java对象\n     * @param key 键\n     * @param value 被序列化的对象\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return void\n     * @author xuy\n     * @date 2022/12/27 17:20\n     */\n    public void set(String key, Object value, Long time, TimeUnit unit) {\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);\n    }\n\n    /**\n     * 逻辑过期 缓存重建\n     * @param key 键\n     * @param value java 对象\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return void\n     * @author xuy\n     * @date 2022/12/27 17:19\n     */\n    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {\n        // 设置逻辑过期\n        RedisData redisData = new RedisData();\n        redisData.setData(value);\n        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));\n        // 写入Redis\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));\n    }\n\n    /**\n     * 缓存穿透 用缓存空对象解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:24\n     */\n    public <R,ID> R queryWithPassThrough(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit){\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(json)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(json, type);\n        }\n        // 判断命中的是否是空值\n        if (json != null) {\n            // 返回一个错误信息\n            return null;\n        }\n\n        // 4.不存在，根据id查询数据库\n        R r = dbFallback.apply(id);\n        // 5.不存在，返回错误\n        if (r == null) {\n            // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.存在，写入redis\n        this.set(key, r, time, unit);\n        return r;\n    }\n\n    /**\n     * 缓存击穿 逻辑过期解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:27\n     */\n    public <R, ID> R queryWithLogicalExpire(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isBlank(json)) {\n            // 3.存在，直接返回\n            return null;\n        }\n        // 4.命中，需要先把json反序列化为对象\n        RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        // 5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return r;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock){\n            // 6.3.成功，开启独立线程，实现缓存重建\n            CACHE_REBUILD_EXECUTOR.submit(() -> {\n                try {\n                    // 查询数据库\n                    R newR = dbFallback.apply(id);\n                    // 重建缓存\n                    this.setWithLogicalExpire(key, newR, time, unit);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }finally {\n                    // 释放锁\n                    unlock(lockKey);\n                }\n            });\n        }\n        // 6.4.返回过期的商铺信息\n        return r;\n    }\n\n    /**\n     * 缓存击穿 互斥锁解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:38\n     */\n    public <R, ID> R queryWithMutex(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(shopJson, type);\n        }\n        // 判断命中的是否是空值\n        if (shopJson != null) {\n            // 返回一个错误信息\n            return null;\n        }\n\n        // 4.实现缓存重建\n        // 4.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        R r = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            // 4.2.判断是否获取成功\n            if (!isLock) {\n                // 4.3.获取锁失败，休眠并重试\n                Thread.sleep(50);\n                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n            }\n            // 4.4.获取锁成功，根据id查询数据库\n            r = dbFallback.apply(id);\n            // 5.不存在，返回错误\n            if (r == null) {\n                // 将空值写入redis\n                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);\n                // 返回错误信息\n                return null;\n            }\n            // 6.存在，写入redis\n            this.set(key, r, time, unit);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            // 7.释放锁\n            unlock(lockKey);\n        }\n        // 8.返回\n        return r;\n    }\n\n    private boolean tryLock(String key) {\n        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);//setnx\n        return BooleanUtil.isTrue(flag);//帮助拆箱，如果封装类是null会包空指针异常\n    }\n\n    private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n    }\n}\n```\n\n在ShopService中：\n```java\n  @Resource\n    private CacheClient cacheClient;//封装之后的工具类\n\n    public Result queryById(Long id) {\n        //解决缓存穿透\n        //Shop shop = queryWithPassThrough(id);\n        Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        //互斥锁解决缓存击穿\n        // Shop shop = queryWithMutex(id);\n//        Shop shop = cacheClient.queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        //逻辑过期解决缓存击穿\n        // Shop shop = queryWithLogicalExpire(id);\n//        Shop shop = cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        if (shop == null) {\n            return Result.fail("店铺不存在！");\n        }\n        return Result.ok(shop);\n```\n\n## 3.优惠券秒杀\n### 3.1.全局唯一ID\n每个店铺都可以发布优惠券：\n\n当用户抢购时，就会生成订单并保存到订单表中，而订单表如果使用数据库自增ID就存在一些问题：\n\n* id的规律性太明显\n* 受单表数据量的限制\n\n场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。\n\n场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。\n\n**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：\n>* 唯一性\n>* 高可用\n>* 高性能\n>* 递增性\n>* 安全性\n\n为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：\n`符号位（0）+时间戳（32bit）+ 序列号（32bit）`\n\nID的组成部分：\n\n* 符号位：1bit，永远为零\n* 时间戳：31bit，以秒为单位，可以使用69年\n* 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID\n\n### 3.2.Redis实现全局唯一Id\n\n```java\n@Component\npublic class RedisIdWorker {\n    /**\n     * 开始时间戳\n     */\n    private static final long BEGIN_TIMESTAMP = 1640995200L;\n    /**\n     * 序列号的位数\n     */\n    private static final int COUNT_BITS = 32;\n\n    private StringRedisTemplate stringRedisTemplate;\n\n    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    public long nextId(String keyPrefix) {\n        // 1.生成时间戳\n        LocalDateTime now = LocalDateTime.now();\n        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);\n        long timestamp = nowSecond - BEGIN_TIMESTAMP;\n\n        // 2.生成序列号\n        // 2.1.获取当前日期，精确到天\n        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));\n        // 2.2.自增长\n        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);\n\n        // 3.拼接并返回\n        return timestamp << COUNT_BITS | count;//时间戳左移32位。或运算填充序列号\n    }\n}\n```\n测试类：\n```java\n @Test\n    public void testRedisIdWorker() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(300);\n        Runnable task = ()->{\n            for (int i = 0; i < 100; i++) {\n                System.out.println("id:"+redisIdWorker.nextId("order"));\n            }\n            latch.countDown();\n        };\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < 300; i++) {\n            es.submit(task);//线程池是异步的，得借助CountDownLatch\n        }\n        latch.await();//等待所有countdown结束\n        long end = System.currentTimeMillis();\n        System.out.println("time:"+(end - begin));\n    }\n```\n知识小贴士：关于countdownlatch\n\ncountdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题\n\n我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch\n\nCountDownLatch 中有两个最重要的方法\n\n1、countDown\n\n2、await\n\nawait 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。\n\n\n### 3.3.添加优惠券\n每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：\n平价优惠券表：优惠券的基本信息，优惠金额、使用规则等。\n特价优惠券表：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息\n\n平价卷由于优惠力度并不是很大，所以是可以任意领取\n\n而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段\n**新增普通卷代码：  **\n**VoucherController**\n```java\n @PostMapping\n    public Result addVoucher(@RequestBody Voucher voucher) {\n        VoucherList.add(voucher);\n        return Result.ok(voucher.getId());\n    }\n```\n\n**新增秒杀卷代码：**\n\n**VoucherController**\n```java\n@PostMapping("seckill")\n    public Result addSeckillVoucher(@RequestBody Voucher voucher) {\n        voucherService.addSeckillVoucher(voucher);\n        return Result.ok(voucher.getId());\n    }\n```\n\n**VoucherService**\n```java\n    //@Transactional\n    public void addSeckillVoucher(Voucher voucher) {\n        // 保存优惠券\n        VoucherList.add(voucher);\n        // 保存秒杀信息\n        SeckillVoucher seckillVoucher = new SeckillVoucher();\n        seckillVoucher.setVoucherId(voucher.getId());\n        seckillVoucher.setStock(voucher.getStock());\n        seckillVoucher.setBeginTime(voucher.getBeginTime());\n        seckillVoucher.setEndTime(voucher.getEndTime());\n        SeckillVoucherList.add(seckillVoucher);\n        // 保存秒杀库存到Redis中\n        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());\n    }\n```\n测试：http://localhost:10086/voucher/seckill\n参数：\n```json\n{\n"id": 2,\n"shopId": 2,\n"titile": "一百元代金券",\n"subTitle": "周一至周日均可以使用",\n"rules": "全场通用\\\\n无需预约\\\\n可无限叠加",\n"payValue": 8000,\n"actualValue": 10000,\n"type": 1,\n"stock": 100,\n"beginTime": "2022-12-26T10:09:17",\n"endTime": "2023-12-26T10:09:17"\n}\n```\n### 3.4.实现秒杀下单(基础逻辑）\n\n秒杀下单应该思考的内容：\n\n下单时需要判断两点：\n\n* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\n* 库存是否充足，不足则无法下单\n\n下单核心逻辑分析：\n\n当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件\n\n比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。\n\nVoucherOrderService\n\n```java\n public Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        //5，扣减库存\n        voucher.setStock(voucher.getStock()-1);\n        Boolean success = SeckillVoucherList.updateById(voucher);\n        if (!success) {\n            //扣减库存\n            return Result.fail("库存不足！");\n        }\n        //6.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 6.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 6.2.用户id\n        Long stuId = StudentHolder.getStudent().getId();\n        voucherOrder.setUserId(stuId);\n        // 6.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        //        创建优惠券订单\n        VoucherOrderList.add(voucherOrder);\n        return Result.ok(orderId);\n    }\n```\n测试：http://localhost:10086/voucher-order/seckill/2\n### 3.5.库存超卖问题分析\n有关超卖问题分析：在我们原有代码中是这么写的\n```java\n // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        //5，扣减库存\n        voucher.setStock(voucher.getStock()-1);\n        Boolean success = SeckillVoucherList.updateById(voucher);\n        if (!success) {\n            //扣减库存\n            return Result.fail("库存不足！");\n        }\n```\n假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。\n\n超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：\n\n**悲观锁：**\n\n 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等\n\n**乐观锁：**\n\n  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas\n\n  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值\n\n  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\n  \n```java\nint var5;\ndo {\n    var5 = this.getIntVolatile(var1, var2);\n} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\nreturn var5;\n```\n\n**课程中的使用方式：**\n\n课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功\n\n\n### 3.6.乐观锁解决超卖问题\n**修改代码方案一、**\n\nVoucherOrderService 在扣减库存时，改为下面SQL语句的意思：\n\n```sql\nupdate table set stock = stock -1 where id = ？ and stock = ?\n```\n\n核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败\n\n**修改代码方案二、**\n\n之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成下面SQL语句的意思\n\n```sql\nupdate table set stock = stock -1 where id = ？ and stock > 0\n```\n\n**知识小扩展：**（暂时看不懂）\n针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决\n\nJava8 提供的一个对AtomicLong改进后的一个类，LongAdder\n\n大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好\n\n所以利用这么一个类，LongAdder来进行优化\n\n如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值\n\n\n### 3.7.优惠券秒杀-一人一单\n需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单\n\n**现在的问题在于：**\n\n优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单\n\n具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单\n\n**初步代码**\n```java\n    @Transactional\npublic Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        Long stuId = StudentHolder.getStudent().getId();\n        // TODO 判断用户是否获取过优惠券\n        VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n        if (order != null){\n            // 用户已经购买过了\n            return Result.fail("用户已经购买过一次！");\n        }\n        //5，扣减库存\n        if(voucher.getStock() > 0){\n            voucher.setStock(voucher.getStock()-1);\n            Boolean success = SeckillVoucherList.updateById(voucher);\n            if (!success) {\n                //扣减库存\n                return Result.fail("库存不足！");\n            }\n        }\n        //6.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 6.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 6.2.用户id\n        voucherOrder.setUserId(stuId);\n        // 6.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n//        创建优惠券订单\n        VoucherOrderList.add(voucherOrder);\n        System.out.println(SeckillVoucherList.findById(voucherId));//剩下的订单\n        return Result.ok(orderId);\n    }\n```\n**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作\n\n**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁\n\n```java\n    @Transactional\npublic synchronized Result createVoucherOrder(Long voucherId) {\n        // 5.1.查询订单\n        Long stuId = StudentHolder.getStudent().getId();\n        VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n        // 5.2.判断是否存在\n        if (order != null ) {\n            // 用户已经购买过了\n            return Result.fail("用户已经购买过一次！");\n        }\n        // 6.扣减库存\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        if(voucher.getStock() > 0){\n            voucher.setStock(voucher.getStock()-1);\n            Boolean success = SeckillVoucherList.updateById(voucher);\n            if (!success) {\n                // 扣减失败\n                return Result.fail("库存不足！");\n            }\n        }\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(stuId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        VoucherOrderList.add(voucherOrder);\n        // 7.返回订单id\n        return Result.ok(orderId);\n    }\n```\n，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度** 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：\nintern() 这个方法是从常量池中拿到数据，如果我们直接使用stuId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法\n\n```java\n    @Transactional\n    public Result createVoucherOrder(Long voucherId) {\n        Long stuId = StudentHolder.getStudent().getId();\n        synchronized (stuId.toString().intern()){\n            // 5.1.查询订单\n            VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n            // 5.2.判断是否存在\n            if (order != null ) {\n                // 用户已经购买过了\n                return Result.fail("用户已经购买过一次！");\n            }\n            // 6.扣减库存\n            SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n            if(voucher.getStock() > 0){\n                voucher.setStock(voucher.getStock()-1);\n                Boolean success = SeckillVoucherList.updateById(voucher);\n                if (!success) {\n                    // 扣减失败\n                    return Result.fail("库存不足！");\n                }\n            }\n            // 7.创建订单\n            VoucherOrder voucherOrder = new VoucherOrder();\n            // 7.1.订单id\n            long orderId = redisIdWorker.nextId("order");\n            voucherOrder.setId(orderId);\n            // 7.2.用户id\n            voucherOrder.setUserId(stuId);\n            // 7.3.代金券id\n            voucherOrder.setVoucherId(voucherId);\n            VoucherOrderList.add(voucherOrder);\n            // 7.返回订单id\n            return Result.ok(orderId);\n        }\n    }\n```\n\n但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：\n\n在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度\n```java\nsynchronized (stuId.toString().intern()) {\n            return this.createVoucherOrder(voucherId);\n        }\n```\n\n但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务\n```java\n        synchronized (stuId.toString().intern()) {\n            //获取代理对象(事务)\n            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();\n            return proxy.createVoucherOrder(voucherId);\n        }\n```\n\n### 3.8.集群环境下的并发问题\n通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。\n\n**有关锁失效原因分析**\n\n由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。\n\n## 4.分布式锁\n### 4.1.基本原理和实现方式对比\n\n分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。\n\n分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路\n\n那么分布式锁他应该满足一些什么样的条件呢？\n\n可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思\n\n互斥：互斥是分布式锁的最基本的条件，使得程序串行执行\n\n高可用：程序不易崩溃，时时刻刻都保证较高的可用性\n\n高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能\n\n安全性：安全也是程序中必不可少的一环\n\n常见的分布式锁有三种\n\nMysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见\n\nRedis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁\n\nZookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案\n| \\        | MySQL   | Redis |Zookeeper|\n| --------   | -----:  | :----:  |----:|\n| 互斥     | 利用mysql本身的互斥锁机制 |   利用setnx这样的互斥命令     |利用节点的唯一性和有序性实现互斥|\n| 高可用        |   好   |   好   |好|\n| 高性能        |    一般    |  好  |一般|\n| 安全性        |    断开连接，自动释放锁    | 利用锁超时时间，到期释放  |临时节点，断开连接自动释放|\n\n### 4.2.Redis分布式锁的实现核心思路\n实现分布式锁时需要实现的两个基本方法：\n\n* 获取锁：\n\n  * 互斥：确保只能有一个线程获取锁\n  * 非阻塞：尝试一次，成功返回true，失败返回false\n\n* 释放锁：\n\n  * 手动释放\n  * 超时释放：获取锁时添加一个超时时间\n  * `DEL key`释放锁，删除即可\n\n\n核心思路：\n我们利用redis 的setNx方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。\n  \n### 4.3.实现分布式锁版本一\n\n* 加锁逻辑\n\n```java\npublic interface ILock {\n    /**\n     * 尝试获取锁\n     * @param timeoutSec 锁持有的超时时间，过期后自动释放\n     * @return true代表获取锁成功; false代表获取锁失败\n     */\n    boolean tryLock(long timeoutSec);\n\n    /**\n     * 释放锁\n     */\n    void unlock();\n}\n```\n\n**SimpleRedisLock**\n\n利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性。\n```java\nprivate static final String KEY_PREFIX="lock:";\n@Override\npublic boolean tryLock(long timeoutSec) {\n    // 获取线程标示\n    String threadId = Thread.currentThread().getId();\n    // 获取锁\n    Boolean success = stringRedisTemplate.opsForValue()\n            .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS);\n    return Boolean.TRUE.equals(success);\n}\n```\n* 释放锁逻辑\n\nSimpleRedisLock\n\n释放锁，防止删除别人的锁\n```java\npublic void unlock() {\n    //通过del删除锁\n    stringRedisTemplate.delete(KEY_PREFIX + name);\n}\n```\n* 修改业务代码\n```java\n  @Override\n    public Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        Long userId = UserHolder.getUser().getId();\n        //创建锁对象(新增代码)\n        SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);\n        //获取锁对象\n        boolean isLock = lock.tryLock(1200);\n\t\t//加锁失败\n        if (!isLock) {\n            return Result.fail("不允许重复下单");\n        }\n        try {\n            //获取代理对象(事务)\n            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();\n            return proxy.createVoucherOrder(voucherId);\n        } finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n```\n  \n'},{title:"redis 学习笔记之快速入门",headers:[{level:2,title:"1.初识Redis",slug:"_1-初识redis",link:"#_1-初识redis",children:[{level:3,title:"1.1.认识Nosql",slug:"_1-1-认识nosql",link:"#_1-1-认识nosql",children:[]},{level:3,title:"1.2.认识redis",slug:"_1-2-认识redis",link:"#_1-2-认识redis",children:[]},{level:3,title:"1.3.安装redis",slug:"_1-3-安装redis",link:"#_1-3-安装redis",children:[]},{level:3,title:"1.4.Redis桌面客户端",slug:"_1-4-redis桌面客户端",link:"#_1-4-redis桌面客户端",children:[]}]},{level:2,title:"2.Redis常用命令",slug:"_2-redis常用命令",link:"#_2-redis常用命令",children:[{level:3,title:"2.1.Redis通用命令",slug:"_2-1-redis通用命令",link:"#_2-1-redis通用命令",children:[]},{level:3,title:"2.2.String类型",slug:"_2-2-string类型",link:"#_2-2-string类型",children:[]},{level:3,title:"2.2.1.String常用命令",slug:"_2-2-1-string常用命令",link:"#_2-2-1-string常用命令",children:[]},{level:3,title:"2.2.2.Key结构",slug:"_2-2-2-key结构",link:"#_2-2-2-key结构",children:[]},{level:3,title:"2.3.Hash类型",slug:"_2-3-hash类型",link:"#_2-3-hash类型",children:[]},{level:3,title:"2.4.List类型",slug:"_2-4-list类型",link:"#_2-4-list类型",children:[]},{level:3,title:"2.5.Set类型",slug:"_2-5-set类型",link:"#_2-5-set类型",children:[]},{level:3,title:"2.6.SortedSet类型",slug:"_2-6-sortedset类型",link:"#_2-6-sortedset类型",children:[]}]},{level:2,title:"3.1.Redis客户端",slug:"_3-1-redis客户端",link:"#_3-1-redis客户端",children:[{level:3,title:"3.1.1.快速入门",slug:"_3-1-1-快速入门",link:"#_3-1-1-快速入门",children:[]},{level:3,title:"3.1.2.连接池",slug:"_3-1-2-连接池",link:"#_3-1-2-连接池",children:[]}]},{level:2,title:"3.2.SpringDataRedis客户端",slug:"_3-2-springdataredis客户端",link:"#_3-2-springdataredis客户端",children:[{level:3,title:"3.2.1.快速入门",slug:"_3-2-1-快速入门",link:"#_3-2-1-快速入门",children:[]}]},{level:2,title:"3.2.2.自定义序列化",slug:"_3-2-2-自定义序列化",link:"#_3-2-2-自定义序列化",children:[{level:3,title:"3.2.3.StringRedisTemplate",slug:"_3-2-3-stringredistemplate",link:"#_3-2-3-stringredistemplate",children:[]}]}],path:"/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",pathLocale:"/",extraFields:'\ufeff---\ntitle: redis 学习笔记之快速入门\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\norigin: reprint\nreprint_from: "https://example.com/original-article" # 可选，用于提供原始链接\ncategory:\n  - redis\n\ntag:\n  - java\n  - spring\n  - springboot\n  - redis\n\n---\n\nredis 学习笔记之快速入门\n\x3c!-- more --\x3e\n\n# redis 学习笔记之快速入门\n\n标签（空格分隔）： redis\n\n---\n\n## 1.初识Redis\nRedis是一种键值型的NoSql数据库，这里有两个关键字：\n>* 键值型\n>* NoSql\n\n其中**键值型**，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json。\n\n### 1.1.认识Nosql\n**NoSql**可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为**非关系型数据库**。\n\n#### 1.1.1.结构化和非结构化\n传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束。\n\n而NoSql则对数据库格式没有严格约束，往往形式松散，自由。可以键值型，文档型，图格式。\n\n#### 1.1.2.关联和非关联\n传统数据库的表与表之间往往存在关联，例如外键。\n而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：\n```json\n{\n  id: 1,\n  name: "张三",\n  orders: [\n    {\n       id: 1,\n       item: {\n\t id: 10, title: "荣耀6", price: 4999\n       }\n    },\n    {\n       id: 2,\n       item: {\n\t id: 20, title: "小米11", price: 3999\n       }\n    }\n  ]\n}\n```\n此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。\n\n#### 1.1.3.查询方式\n传统关系型数据库会基于Sql语句做查询，语法有统一标准。\n而不同的非关系数据库查询语法差异极大，五花八门各种各样：\n```sql\n# 关系型 SQL \nselect * from t_user where id = 1;\n# 非关系型 Redis\nget user:1\n# 非关系型 MongoDB\n`db.users.find({_id:1})`\n# 非关系型 elasticsearch\nGET http://localhost:9200/users/1\n```\n#### 1.1.4.事务\n传统关系型数据库能满足事务ACID的原则。\n而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。\n\n|     区别    | SQL  |  NoSQL  |\n| --------   | :-----  | :----  |\n| 数据结构     | 结构化 |   非结构化    |\n| 数据关联        |   关联的   |   无关联   |\n| 查询方式    |    SQL查询   |  非SQL  |\n| 事务特性        | ACID   |  BASE  |\n| 存储方式     | 磁盘 |   内存     |\n| 扩展性        |   垂直   |   水平   |\n| 使用场景        |    1）数据结构固定 <br>2)相关业务对数据安全性、一致性要求较高    |  1）数据结构不固定<br> 2）对一致性、安全性要求不高 <br>3）对性能要求  |\n\n\n+ 存储方式\n    - 关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响\n    - 非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些\n    \n+ 扩展性\n    - 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。\n    - 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。\n    - 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦\n\n### 1.2.认识redis\nRedis诞生于2009年全称是**Re**mote  **D**ictionary **S**erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n**特征**：\n\n>* 键值（key-value）型，value支持多种不同数据结构，功能丰富\n>* 单线程，每个命令具备原子性\n>* 低延迟，速度快（基于内存、IO多路复用、良好的编码）。\n>* 支持数据持久化\n>* 支持主从集群、分片集群\n>* 支持多语言客户端\n\n**作者**：Antirez\n\nRedis的官方网站地址：https://redis.io/\n\n### 1.3.安装redis\n自行百度，之后在记录\n#### 1.3.1.默认启动\n```cmd\n# 默认启动\nredis-server\n\n```\n#### 1.3.2.指定配置启动\n修改redis.conf文件中的一些配置：\n\n```properties\n# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0\nbind 0.0.0.0\n# 守护进程，修改为yes后即可后台运行\ndaemonize yes \n# 密码，设置后访问Redis必须输入密码\nrequirepass 123321\n```\nRedis的其它常见配置：\n\n```properties\n# 监听的端口\nport 6379\n# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录\ndir .\n# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15\ndatabases 1\n# 设置redis能够使用的最大内存\nmaxmemory 512mb\n# 日志文件，默认为空，不记录日志，可以指定日志文件名\nlogfile "redis.log"\n```\n\n启动Redis：\n\n```sh\n# 进入redis安装目录 \ncd /usr/local/src/redis-6.2.6\n# 启动\nredis-server redis.conf\n```\nWindows启动方法：\n```sh\nredis-server.exe redis.windows.conf\n# 进入命令行\nredis-cli.exe\n```\n停止服务：\n\n```sh\n# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，\n# 因为之前配置了密码，因此需要通过 -u 来指定密码\nredis-cli -u 123321 shutdown\n```\n#### 1.3.3.开机自启\n我们也可以通过配置来实现开机自启。\n\n首先，新建一个系统服务文件：\n\n```sh\nvi /etc/systemd/system/redis.service\n```\n\n内容如下：\n\n```shell\n[Unit]\nDescription=redis-server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n\n\n然后重载系统服务：\n\n```sh\nsystemctl daemon-reload\n```\n\n\n\n现在，我们可以用下面这组命令来操作redis了：\n\n```sh\n# 启动\nsystemctl start redis\n# 停止\nsystemctl stop redis\n# 重启\nsystemctl restart redis\n# 查看状态\nsystemctl status redis\n```\n\n\n\n执行下面的命令，可以让redis开机自启：\n\n```sh\nsystemctl enable redis\n```\n\n### 1.4.Redis桌面客户端\n安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：\n\n>* 命令行客户端\n>* 图形化桌面客户端\n>* 编程客户端\n\n\n#### 1.4.1.Redis命令行客户端\nRedis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：\n```sh\nredis-cli [options] [commonds]\n```\n\n其中常见的options有：\n\n- `-h 127.0.0.1`：指定要连接的redis节点的IP地址，默认是127.0.0.1\n- `-p 6379`：指定要连接的redis节点的端口，默认是6379\n- `-a 123321`：指定redis的访问密码，一开始不指定密码，之后命令行可以用 `auth 123321` 来指定密码进行连接\n\n其中的commonds就是Redis的操作命令，例如：\n\n- `ping`：与redis服务端做心跳测试，服务端正常会返回`pong`\n\n不指定commond时，会进入`redis-cli`的交互控制台。\n\n\n#### 1.4.2.图形化桌面客户端\nGitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager\n不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。\n\n在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\n\n\n\n## 2.Redis常用命令\n\n| 数据类型 | 示例值                | 类型说明       |\n| -------- | --------------------- | -------------- |\n|          |                       | **数据类型**   |\n| String   | hello world           | 基本类型       |\n| Hash     | `{name:"Jack",age:21}`  | 基本类型       |\n| List     | `[A -> B -> C]`         | 基本类型       |\n| Set      | `{A,B,C}  `             | 基本类型       |\n| SortSet  | `{A:1,B:2,C:3 } `        | 基本类型       |\n| GEO      | `{A:(120.3,30.5)}  `    | 特殊类型       |\n| BitMap   | 0110110101110101011    | 特殊类型       |\n| HyperLog | 0110110101110101011    | 特殊类型       |\n\n*注意：第一列 "数据类型" 实际上跨越了三列，第二列 "类型说明" 中的 "基本类型" 跨越了五行，"特殊类型" 跨越了三行。这里通过重复内容来模拟这些效果。*\n\nRedis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ [https://redis.io/commands ](https://redis.io/commands)）可以查看到不同的命令：\n\n不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：eg:help get\n\n### 2.1.Redis通用命令\n    \n通用指令是部分数据类型的，都可以使用的指令，常见的有：\n\n- KEYS：查看符合模板的所有key\n- DEL：删除一个指定的key\n- EXISTS：判断key是否存在\n- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除：eg:set name jack ex 10，十秒Jack消失\n- TTL：查看一个KEY的剩余有效期\n\n通过help [command] 可以查看一个命令的具体用法，例如：\n\n```sh\n# 查看keys命令的帮助信息：\n127.0.0.1:6379> help keys\n\nKEYS pattern\nsummary: Find all keys matching the given pattern\nsince: 1.0.0\ngroup: generic\n```\n### 2.2.String类型\nString类型，也就是字符串类型，是Redis中最简单的存储类型。\n\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\n\n- string：普通字符串\n- int：整数类型，可以做自增、自减操作\n- float：浮点类型，可以做自增、自减操作\n\n不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.\n\n### 2.2.1.String常用命令\nString的常见命令有：\n\n- SET：添加或者修改已经存在的一个String类型的键值对\n- GET：根据key获取String类型的value\n- MSET：批量添加多个String类型的键值对\n- MGET：根据多个key获取多个String类型的value\n- INCR：让一个整型的key自增1\n- INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\n- INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\n- SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\n- SETEX：添加一个String类型的键值对，并且指定有效期\n\n### 2.2.2.Key结构\nRedis的key允许有多个单词形成层级结构，多个单词之间用\':\'隔开，格式如下：\n>* \t项目名:业务名:类型:id\n\n如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：\n\n| **KEY**         | **VALUE**                                  |\n| --------------- | ------------------------------------------ |\n| heima:user:1    | `{"id":1,  "name": "Jack", "age": 21} `      |\n| heima:product:1 | `{"id":1,  "name": "小米11", "price": 4999}` |\n\n### 2.3.Hash类型\nHash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\nString结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便。\n\nHash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。结构如下：\n| heima:user:1 | 属性  | 值    |\n| ------------ | ----- | ----- |\n| heima:user:1 | name  | Jack  |\n| heima:user:1 | age   | 21    |\n\n*注意：`heima:user:1` 实际上跨越了两行，在这里重复是为了兼容 Markdown 表格格式。*\n\nHash的常见命令有：\n\n- HSET key field value：添加或者修改hash类型key的field的值\n- HGET key field：获取一个hash类型key的field的值\n- HMSET：批量添加多个hash类型key的field的值\n- HMGET：批量获取多个hash类型key的field的值\n- HGETALL：获取一个hash类型的key中的所有的field和value\n- HKEYS：获取一个hash类型的key中的所有的field\n- HINCRBY:让一个hash类型key的字段值自增并指定步长\n- HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n\n\n### 2.4.List类型\n\nRedis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\n\n特征也与LinkedList类似：\n\n- 有序\n- 元素可以重复\n- 插入和删除快\n- 查询速度一般\n\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\n\n\n\nList的常见命令有：\n\n- LPUSH key element ... ：向列表左侧插入一个或多个元素\n- LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\n- RPUSH key element ... ：向列表右侧插入一个或多个元素\n- RPOP key：移除并返回列表右侧的第一个元素\n- LRANGE key star end：返回一段角标范围内的所有元素\n- BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n\n\n\n\n### 2.5.Set类型\n\nRedis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\n\n- 无序\n- 元素不可重复\n- 查找快\n- 支持交集、并集、差集等功能\n\n\n\nSet的常见命令有：\n\n- SADD key member ... ：向set中添加一个或多个元素\n- SREM key member ... : 移除set中的指定元素\n- SCARD key： 返回set中元素的个数\n- SISMEMBER key member：判断一个元素是否存在于set中\n- SMEMBERS：获取set中的所有元素\n- SINTER key1 key2 ... ：求key1与key2的交集\n\n### 2.6.SortedSet类型\n\nRedis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\nSortedSet具备下列特性：\n\n- 可排序\n- 元素不重复\n- 查询速度快\n\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\n\n\n\nSortedSet的常见命令有：\n\n- ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\n- ZREM key member：删除sorted set中的一个指定元素\n- ZSCORE key member : 获取sorted set中的指定元素的score值\n- ZRANK key member：获取sorted set 中的指定元素的排名\n- ZCARD key：获取sorted set中的元素个数\n- ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\n- ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\n- ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\n- ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\n- ZDIFF、ZINTER、ZUNION：求差集、交集、并集\n\n注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：\n\n- **升序**获取sorted set 中的指定元素的排名：ZRANK key member\n\n- **降序**获取sorted set 中的指定元素的排名：ZREVRANK key memeber\n\n\n## 3.1.Redis客户端\nJedis的官网地址： https://github.com/redis/jedis\n### 3.1.1.快速入门\n1）先引入依赖\n```xml\n\x3c!--jedis--\x3e\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n\x3c!--单元测试--\x3e\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.7.0</version>\n    <scope>test</scope>\n</dependency>\n```\n2）建立连接\n建一个测试类\n```java\nprivate Jedis jedis;\n\n@BeforeEach\nvoid setUp() {\n    // 1.建立连接\n    jedis = new Jedis("192.168.150.101", 6379);\n    //jedis = JedisConnectionFactory.getJedis();\n    // 2.设置密码\n    jedis.auth("123321");\n    // 3.选择库\n    jedis.select(0);\n}\n```\n3）测试\n```java\n@Test\nvoid testString() {\n    // 存入数据\n    String result = jedis.set("name", "虎哥");\n    System.out.println("result = " + result);\n    // 获取数据\n    String name = jedis.get("name");\n    System.out.println("name = " + name);\n}\n\n@Test\nvoid testHash() {\n    // 插入hash数据\n    jedis.hset("user:1", "name", "Jack");\n    jedis.hset("user:1", "age", "21");\n\n    // 获取\n    Map<String, String> map = jedis.hgetAll("user:1");\n    System.out.println(map);\n}\n```\n4）释放资源\n```java\n@AfterEach\nvoid tearDown() {\n    if (jedis != null) {\n        jedis.close();\n    }\n}\n```\n### 3.1.2.连接池\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式。\n```java\npackage com.heima.jedis.util;\n\nimport redis.clients.jedis.*;\n\npublic class JedisConnectionFactory {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 配置连接池\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(8);//设置总共的连接的最大数量\n        poolConfig.setMaxIdle(8);//最大空闲连接数, 默认8个\n        poolConfig.setMinIdle(0);//最小空闲连接数, 默认0\n        poolConfig.setMaxWaitMillis(1000);//超时时间\n        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码\n        jedisPool = new JedisPool(poolConfig, "192.168.150.101", 6379, 1000, "123321");\n    }\n\n    public static Jedis getJedis(){\n        return jedisPool.getResource();\n    }\n}\n```\n\n## 3.2.SpringDataRedis客户端\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis\n\n- 提供了对不同Redis客户端的整合（Lettuce和Jedis）\n- 提供了RedisTemplate统一API来操作Redis\n- 支持Redis的发布订阅模型\n- 支持Redis哨兵和Redis集群\n- 支持基于Lettuce的响应式编程\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\n- 支持基于Redis的JDKCollection实现\n\nSpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\n\n| API        | 返回值类型   |  说明  |\n| --------   | -----:  | :----:  |\n| redisTemplate.opsForValue()     | ValueOperations |   操作**String**类型数据     |\n| redisTemplate.opsForHash()     | HashOperations |   操作**Hash**类型数据     |\n| redisTemplate.opsForList()     | ListOperations |   操作**List**类型数据     |\n| redisTemplate.opsForSet()     | SetOperations |   操作**Set**类型数据     |\n| redisTemplate.opsForZSet()     | ZSetOperations |   操作**SortedSet**类型数据     |\n| redisTemplate     |  |   通用命令     |\n\n### 3.2.1.快速入门\nSpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。\n\n\n\n首先，新建一个maven项目，然后按照下面步骤执行：\n1）引入依赖\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.7</version>\n        <relativePath/> \x3c!-- lookup parent from repository --\x3e\n    </parent>\n    <groupId>com.heima</groupId>\n    <artifactId>redis-demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>redis-demo</name>\n    <description>Demo project for Spring Boot</description>\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n    <dependencies>\n        \x3c!--redis依赖--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        \x3c!--common-pool--\x3e\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n        </dependency>\n        \x3c!--Jackson依赖--\x3e\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n2）配置Redis\n```shell\nspring:\n  redis:\n    host: 192.168.150.101\n    port: 6379\n    password: 123321\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        min-idle: 0\n        max-wait: 100ms\n```\n3）注入RedisTemplate\n因为有了SpringBoot的自动装配，我们可以拿来就用：\n```java\n@SpringBootTest\nclass RedisStringTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n}\n```\n4）编写测试类\n```java\n@SpringBootTest\nclass RedisStringTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    void testString() {\n        // 写入一条String数据\n        redisTemplate.opsForValue().set("name", "虎哥");\n        // 获取string数据\n        Object name = stringRedisTemplate.opsForValue().get("name");\n        System.out.println("name = " + name);\n    }\n}\n```\n## 3.2.2.自定义序列化\n    \nRedisTemplate可以接收任意Object作为值写入Redis：\n只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：\n>* "\\"\\xe8\\x99\\x8e\\xe5\\x93\\xa5\\""\n\n缺点：\n\n- 可读性差\n- 内存占用较大\n\n我们可以自定义RedisTemplate的序列化方式，代码如下：\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){\n        // 创建RedisTemplate对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n        // 创建JSON序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer = \n            \t\t\t\t\t\t\tnew GenericJackson2JsonRedisSerializer();\n        // 设置Key的序列化\n        template.setKeySerializer(RedisSerializer.string());\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置Value的序列化\n        template.setValueSerializer(jsonRedisSerializer);\n        template.setHashValueSerializer(jsonRedisSerializer);\n        // 返回\n        return template;\n    }\n}\n```\n\n这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如下：\n```json\n{\n    "@class": "com.heima.redis.pojo.User",\n    "name": "虎哥",\n    "age": 21\n}\n```\n整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。\n\n### 3.2.3.StringRedisTemplate\n为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。\n\n因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。\n\n这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。\n\n省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：\n\n```java\n@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n// JSON序列化工具\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\n@Test\nvoid testSaveUser() throws JsonProcessingException {\n    // 创建对象\n    User user = new User("虎哥", 21);\n    // 手动序列化\n    String json = mapper.writeValueAsString(user);\n    // 写入数据\n    stringRedisTemplate.opsForValue().set("user:200", json);\n\n    // 获取数据\n    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");\n    // 手动反序列化\n    User user1 = mapper.readValue(jsonUser, User.class);\n    System.out.println("user1 = " + user1);\n}\n\n```\n'},{title:"redis 使用过程中的bug记录",headers:[{level:2,title:"Windows环境",slug:"windows环境",link:"#windows环境",children:[]},{level:2,title:"MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.",slug:"misconf-redis-is-configured-to-save-rdb-snapshots-but-it-is-currently-not-able-to-persist-on-disk-commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-rdb-snapshotting-fails-stop-writes-on-bgsave-error-option-please-check-the-redis-logs-for-details-about-the-rdb-error",link:"#misconf-redis-is-configured-to-save-rdb-snapshots-but-it-is-currently-not-able-to-persist-on-disk-commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-rdb-snapshotting-fails-stop-writes-on-bgsave-error-option-please-check-the-redis-logs-for-details-about-the-rdb-error",children:[]}],path:"/posts/redis/redisBUG.html",pathLocale:"/",extraFields:"\ufeff---\ntitle: redis 使用过程中的bug记录\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - redis\n\ntag:\n  - java\n  - spring\n  - springboot\n  - redis\n\n---\n\nredis 使用过程中的bug记录\n\x3c!-- more --\x3e\n\n# redisBUG\n\n标签（空格分隔）： redis\n\n---\n\n## Windows环境\n\n1、Could not connect to Redis at 127.0.0.1:6379: 由于目标计算机积极拒绝，无法连接。\n``\n\n\n2、报错如下\n```shell\nD:\\Redis-x64-5.0.14.1>redis-server.exe redis.windows.conf\n[7948] 29 Jan 10:06:50.399 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n[7948] 29 Jan 10:06:50.399 # Redis version=5.0.14.1, bits=64, commit=ec77f72d, modified=0, pid=7948, just started\n[7948] 29 Jan 10:06:50.400 # Configuration loaded\n[7948] 29 Jan 10:06:50.402 # Could not create server TCP listening socket 127.0.0.1:6379: bind: 操作成功完成。\n```\n解决：\n```shell\nredis-cli.exe      # 进入客户端\nshutdown  # 关闭该redis服务\nexit       # 退出\nredis-server.exe redis.windows.conf  # 重新启动reids 服务\n```\n## MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\nRedis配置为保存RDB快照，但它当前无法在磁盘上持久化。可以修改数据集的命令被禁用，因为此实例配置为在RDB快照失败时报告写入期间的错误（停止对bgsave error的写入选项）\n\n原因是因为强制关闭 Redis 快照导致不能持久化（之前部署Redis的机器断电过，猜测是因为这个导致的）\n\n解决方案就是重启Redis后，登录进去，将stop-writes-on-bgsave-error设置为no\n\n```shell\n127.0.0.1:6379> config set stop-writes-on-bgsave-error no\n```\n但需要注意的是，执行这个命令只能暂时解决无法 set 的问题，具体的问题还是要看 Redis 的 log 信息详细排查错误才行"},{title:"shell 基础知识",headers:[{level:2,title:"1、@echo off",slug:"_1、-echo-off",link:"#_1、-echo-off",children:[]},{level:2,title:"2、%0 %1——给批处理脚本传递参数",slug:"_2、-0-1——给批处理脚本传递参数",link:"#_2、-0-1——给批处理脚本传递参数",children:[]},{level:2,title:"3、变量声明、设置、拼接、截取",slug:"_3、变量声明、设置、拼接、截取",link:"#_3、变量声明、设置、拼接、截取",children:[]},{level:2,title:"4、路径相关%cd%和%~dp0的区别",slug:"_4、路径相关-cd-和-dp0的区别",link:"#_4、路径相关-cd-和-dp0的区别",children:[]},{level:2,title:"5、遍历指定目录下资源文件并更新",slug:"_5、遍历指定目录下资源文件并更新",link:"#_5、遍历指定目录下资源文件并更新",children:[]},{level:2,title:"6、替换字符串中匹配的子串",slug:"_6、替换字符串中匹配的子串",link:"#_6、替换字符串中匹配的子串",children:[]},{level:2,title:"7、各种形式的变量%0、%i、%%i、var、%var%、!var!的含义和区别",slug:"_7、各种形式的变量-0、-i、-i、var、-var-、-var-的含义和区别",link:"#_7、各种形式的变量-0、-i、-i、var、-var-、-var-的含义和区别",children:[{level:3,title:"7.1、%0",slug:"_7-1、-0",link:"#_7-1、-0",children:[]},{level:3,title:"7.2、%i",slug:"_7-2、-i",link:"#_7-2、-i",children:[]},{level:3,title:"7.3、%%i",slug:"_7-3、-i",link:"#_7-3、-i",children:[]},{level:3,title:"7.4、var,%var%",slug:"_7-4、var-var",link:"#_7-4、var-var",children:[]},{level:3,title:"7.5、!var!",slug:"_7-5、-var",link:"#_7-5、-var",children:[]}]},{level:2,title:"8、替换带有等号=的字符串的子串",slug:"_8、替换带有等号-的字符串的子串",link:"#_8、替换带有等号-的字符串的子串",children:[]},{level:2,title:"9、从路径字符串中截取盘符、文件名、后缀名等信息",slug:"_9、从路径字符串中截取盘符、文件名、后缀名等信息",link:"#_9、从路径字符串中截取盘符、文件名、后缀名等信息",children:[]},{level:2,title:"10、替换字符串中包含百分号%的子串",slug:"_10、替换字符串中包含百分号-的子串",link:"#_10、替换字符串中包含百分号-的子串",children:[]},{level:2,title:"来源",slug:"来源",link:"#来源",children:[]}],path:"/posts/shell/shell.html",pathLocale:"/",extraFields:'---\ntitle: shell 基础知识\nicon: pen-to-square\ndate: 2023-06-05\nlastUpdated: true\ncategory:\n  - windows\ntag:\n  - script\n  - shell\n---\n\n入门 shell 脚本的基础知识\n\n\x3c!-- more --\x3e\n\n## 1、@echo off\n\n* 回显：这条命令后的内容显示到控制台上。\n\n* 新建一个文件：test_echooff.bat,输入如下内容\n```shell\n@echo off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause\n```\n如果乱码，另存为，设置ANSI编码，重新运行。\n\n* 修改文件内容，将其中的@ 符号去掉，内容如下：\n```shell \necho off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause\n```\n`echo off`执行以后，后面所有的命令均不显示，但本条命令是显示的。\n\n* 继续修改文件内容，将第一条命令注释掉，内容如下：\n```shell\n::echo off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause\n```\n结果就是在cmd 回显了`echo off`后面的命令。\n\n**总结**：\n@echo off表示执行了这条命令后关闭所有命令(包括本身这条命令)的回显。而echo off命令则表示关闭其他所有命令(不包括本身这条命令)的回显，@的作用就是关闭紧跟其后的一条命令的回显，关于上述例子应该表现的很清楚了，不过还有几点需要解释一下：\n\n* pause也是一条命令，作用就是使程序暂停，也就是输出“请按任意键继续…”的原因。\n* ::是批处理文件中一种注释语句的方式，其与rem命令的区别我们后续再说。\n* @echo off执行以后，后面所有的命令均不显示，包括本条命令。\n* echo off执行以后，后面所有的命令均不显示，但本条命令是显示的。\n\n\n\n## 2、%0 %1——给批处理脚本传递参数\n\n\n\n* 批处理文件中可引用的参数为%0~%9，%0是指批处理文件的本身，也可以说是一个外部命令；%1%9是批处理参数，也称形参，我们来新建一个文件，文件命名为test_argv.bat，文件内容如下：\n\n```shell\n@echo off\n\necho param[0] = %0\necho param[1] = %1\necho param[2] = %2\necho param[3] = %3\necho param[4] = %4\necho param[5] = %5\necho ...\npause\n```\n\n* 在控制台输入命令运行：`test_argv.bat 1 game test what`\n\n**总结：**\n\n* 如果不借助其他其他命令，批处理做多接收9个额外的参数。\n* 使用`shift`命令可以对参数进行偏移，从而取到更多的参数。\n* 如果使用的某个参数没有传递进来，则该变量为空，如例子中的%5。\n\n\n\n## 3、变量声明、设置、拼接、截取\n\n假设我们的批处理脚本要实现这样一个功能：从控制台接收参数，前两个参数为信息发送者，第三个参数为信息接收者，最后一个参数为信息内容，请输出所有发送者、接收者和信息内容。\n\n* 代码实现，新建一个文件命名为test_set.bat然后编写如下代码：\n\n```shell\n@echo off\n\n::设置变量\nSET Sender1=%1\nSET Sender2=%2\nSET Receiver=%3\nSET Content=%4\n\n::字符串拼接(等号前面不能有空格)\nSET Sender=%Sender1%, %Sender2% \n::字符串截取\nSET RealContent=%Content:~1,-1%\n\necho Sender = %Sender%\necho ---------------------------------/\necho Receiver = %Receiver%\necho ---------------------------------/\necho Content = %Content%\necho ---------------------------------/\necho RealContent = %RealContent%\necho ---------------------------------/\n\npause\n```\n\n\n\n* 在控制台输入命令运行：`test_set.bat tom jerry xiaoming "I miss you"`\n\n\n\n**总结**:\n\n* 这其中有几个点需要注意，首先变量设置只需要使用SET 任意变量名=所要表达的内容;\n* 变量的拼接只要把变量依次写在一起就可以，形如SET 变量=变量1变量2 内容3，字符串4，不同部分之间可以没有连接符，直接相连或者用空格。\n* 变量的截取需要使用固定的格式%变量:~a,b%，这就表示把变量从第a个字符截取到第b个字符，b可以为负数，表示从字符串后面计数，-1表示最后一个字符。\n* 关于例子中信息内容这最后一个参数，其中的双引号使我故意加的，也是非常必要的，这样可以把这句包含空格的话作为一个变量传递到批处理脚本中，如果不加双引号的话，变量Content的内容就是I了，后两个单词就被丢掉了。\n\n## 4、路径相关%cd%和%~dp0的区别\n\n在DOS命令中，有两个[环境变量](https://so.csdn.net/so/search?q=环境变量&spm=1001.2101.3001.7020)可以跟当前路径有关，一个是`%cd%`, 一个是`%~dp0`。但是这两个变量的用法和代表的内容是不同的。\n\n- `%cd%`可以用在批处理文件中，也可以用在命令行中，内容为执行命令所在的目录（包含驱动器盘符）。\n- `%~dp0`只可以用在批处理文件中，由所在的批处理文件的目录位置决定的，内容为批处理文件所在的目录（包含驱动器盘符）。\n- 比如我们在目录`F:\\batTool\\`下新建一个文件命名为test_dir.bat，其代码的内容如下：\n\n```shell\n@echo off\n\n::对比%cd%和%~dp0的不同\necho %%cd%% = %cd%     \necho %%~dp0 = %~dp0  \n```\n\n* 我们在不同目录下的执行结果为：\n\n```cmd\nF:\\batTool>test_dir.bat\n%cd% = F:\\batTool\n%~dp0 = F:\\batTool\\\n\nF:\\batTool>cd /d E:\n\nE:>F:\\batTool\\test_dir.bat\n%cd% = E:\\\n%~dp0 = F:\\batTool\\\n\nE:>cd /d D:\n\nD:>F:\\batTool\\test_dir.bat\n%cd% = D:\\\n%~dp0 = F:\\batTool\\\n```\n\n**总结：**\n\n* `%cd%`表示执行命令时所在的目录，`%~dp0`表示批处理文件所在的目录。\n* `%cd%`是可以改变的，因为它表示的是当前目录，如果在批处理中使用了`cd`命令就会改变他的值。\n* `%~dp0`是在执行某个批处理结束之前是不会改变的，因为代表的是脚本文件在磁盘的位置。\n\n\n\n## 5、遍历指定目录下资源文件并更新\n\n**前言**\n\n先来看这样一个需求，假设有A，B两个目录，其中A目录是资源目录，B目录是工作目录，其中资源目录不定期更新，资源文件都在A目录下，并且没有子目录层级关系，但是资源要被使用时需要更新到B工作目录，B目录根据工程需要建立了一个包含众多子目录的层级体系，这样当A目录中的一个资源文件更新后，需要手动复制A目录中更新的资源文件，然后在B目录中找到对应的位置，然后进行粘贴替换，这样的操作如果很久一次、或者每次只有1、2个文件还好，如果资源文件大范围更新，那么要一个个找到更新文件在B目录中的位置然后替换就成了一件令人苦恼的事情，所以根据这个需求，才有了下面的探索过程。\n\n\n\n**思路的转变**\n\n一开始想把A目录作为出发点，毕竟A目录中包含了修改后的资源文件，但是A目录更新后怎样才能准确的修改对应的B目录呢？我想到了配表，每次新增资源后，都会修改配置表，将A目录中的各个文件资源与B目录中的位置建立对应关系，这样A目录下的资源更新后就可以根据配置文件统一更新B目录了。\n\n但这样的做法就是，需要经常维护配置文件，特别是增加或者删除资源的时候，然后我就想到了现在的这个做法，从B目录出发，注意本文主要解决的是资源文件的更新，而不是新增，更新就说明是原有的文件，只是内容发生了变化，比如一些UI文件，这些文件经常会做布局格式的调整，控件的增加和删除等等，调整结束后需要更新到工作目录。\n\n**实现过程**\n\n实现的过程并没有想象的那么顺利，期间遇到了诸多问题和一些新的概念，比如for循环的语法，for循环中的变量定义，if条件的语法，字符串变量的替换，文件目录的处理，延迟环境变量扩展等等，这些问题每一项都可以作为一个单独的知识点，后续我会抽时间慢慢总结到一起，总之最后终于可以用了，前后大约花了1个半小时的时间，想想也是醉了，下面是一个具体的示例及对应的实现代码。\n\n* A资源目录对应实际的”E:/dirZ”，结构如下：\n\n```shell\nroot:[E:/dirZ]\n+--aaa.txt\n+--bbb.txt\n+--ccc.txt\n+--ddd.txt\n+--eee.txt\n+--extra.c\n+--extra.h\n+--fff.txt\n+--ggg.txt\n```\n\n* B工作目录对应实际的”E:/dirA”，结构如下：\n\n```shell\nroot:[E:/dirA]\n+--aaa.txt\n+--bbb.txt\n+--dirB\n|    +--ccc.txt\n|    +--extra.c\n|    +--extra.h\n+--dirC\n|    +--ddd.txt\n|    +--dirD\n|    |    +--eee.txt\n+--dirE\n|    +--dirF\n|    |    +--fff.txt\n|    |    +--ggg.txt\n```\n\n* 现在需要把`E:/dirZ`目录中的txt文件，按照`E:/dirA`目录的层级结构，更新到对应位置，并且不更新`ggg.txt`文件，以下是实现的代码:\n\n```shell\n@echo off\n\nrem 启用延迟环境变量扩展\nsetlocal enabledelayedexpansion\n\nrem 定义不需要更新的文件\nSET EXCEPT_FILE=ggg.txt\n\nrem 定义工作目录和资源目录\nSET WORK_PATH=E:\\dirA\\\nSET RESO_PATH=E:\\dirZ\\\n\nrem 简单输出查看一下\necho WORK_PATH is %WORK_PATH%\necho RESO_PATH is %RESO_PATH%\necho ------------------------\n\nrem for循环递归遍历WORK_PATH目录中的.txt文件，文件的全路径放在变量f中\nfor /R %WORK_PATH% %%f in (*.txt) do (\n rem 使用TARGET_FILE变量记录绝对文件名，注意延迟变量的使用\n SET TARGET_FILE=%%f\n echo !TARGET_FILE!\n\n rem 去掉路径，只保留文件名及扩展名\n SET "FILE_PATH_NO_EXT=%%~nxf"\n rem 利用资源路径和文件名，拼接出资源的绝对全路径\n SET SOURCE_FILE=%RESO_PATH%!FILE_PATH_NO_EXT!\n echo !SOURCE_FILE!\n\n rem 条件判断是否是不需要更新的文件\n if NOT !FILE_PATH_NO_EXT!==%EXCEPT_FILE% (\n     copy !SOURCE_FILE! !TARGET_FILE!\n )\n)\npause\n```\n\n* 运行结果\n\n```shell\nWORK_PATH is E:\\dirA\\\nRESO_PATH is E:\\dirZ\\\n<hr />\n\nE:\\dirA\\aaa.txt\nE:\\dirZ\\aaa.txt\n已复制         1 个文件。\nE:\\dirA\\bbb.txt\nE:\\dirZ\\bbb.txt\n已复制         1 个文件。\nE:\\dirA\\dirB\\ccc.txt\nE:\\dirZ\\ccc.txt\n已复制         1 个文件。\nE:\\dirA\\dirC\\ddd.txt\nE:\\dirZ\\ddd.txt\n已复制         1 个文件。\nE:\\dirA\\dirC\\dirD\\eee.txt\nE:\\dirZ\\eee.txt\n已复制         1 个文件。\nE:\\dirA\\dirE\\dirF\\fff.txt\nE:\\dirZ\\fff.txt\n已复制         1 个文件。\nE:\\dirA\\dirE\\dirF\\ggg.txt\nE:\\dirZ\\ggg.txt\n请按任意键继续. . .\n```\n\n**总结**\n\n到此为止我们就解决了这个资源更新的实际问题，每次资源更新后只要运行这个批处理文件就可以更新工作目录中对应的资源文件了，在这个例子中关于目录的截取，一开始走了很多弯路，其实有很多现成的方式，所以需要在此记录一下，方便以后查找使用，具体查看示例代码：\n\n```shell\nECHO off\nSETlOCAL enabledelayedexpansion\n\nSET FIND_DIR=E:\\dirA\\dirC\\dirD\n\nfor /R %FIND_DIR% %%f in (*.txt) do (\n    SET FULL_PATH=%%f\n    ECHO 完整的路径: !FULL_PATH!\n\n    SET FILE_DIR=%%~dpf\n    ECHO 所在的目录: !FILE_DIR!\n\n    SET FILE_NAME=%%~nf\n    ECHO 无后缀文件: !FILE_NAME!\n\n    SET FILE_EXT=%%~xf\n    ECHO 文件名后缀: !FILE_EXT!\n\n    SET "FILE_NAME_NOT_PATH=%%~nxf"\n    ECHO 无路径文件: !FILE_NAME_NOT_PATH!\n\n    SET "FULL_PATH_NOT_EXT=%%~dpnf"\n    ECHO 无后缀全名: !FULL_PATH_NOT_EXT!\n)\npause\n```\n\n运行结果：\n\n```shell\n完整的路径: E:\\dirA\\dirC\\dirD\\eee.txt\n所在的目录: E:\\dirA\\dirC\\dirD\\\n无后缀文件: eee\n文件名后缀: .txt\n无路径文件: eee.txt\n无后缀全名: E:\\dirA\\dirC\\dirD\\eee\n```\n\n## 6、替换字符串中匹配的子串\n\n**前言**\n\n关于字符串的操作通常是编程生涯中不可避免的，在各种竞赛中、工作中常常能使用到，许多语言中都有专门负责处理字符串的模块或者类，对于字符串的替换一般也有专门的函数，比如Lua中的string.gsub()、Python中的replece()等，那么批处理在进行字符串操作的时候，有没有好用的替换函数呢？\n\n前两天在使用批处理更新资源文件的时候发现，批处理中也有专门处理字符串替换的方法，并且这是我见到的最有意思的字符串替换方式，就是利用A:B=C的方式来替换字符串，具体含义就是在字符串变量A中查找所有的子串B并且替换成子串C，看起来很有意思吧？下面举一个具体的示例看一下。\n**代码示例**\n\n```shell\n@echo off\n\nSET INPUT_PARAM=%1\n\nrem 替换输入变量中的world为China\necho source string is %INPUT_PARAM%\necho ===   China replace world   ===\necho replace result is %INPUT_PARAM:world=China%\n\necho.\n\nrem 将路径中的反斜杠替换成斜杠\nSET IMAGE_PATH=C:\\NVIDIA\\AndroidWorks\\001\necho source string is %IMAGE_PATH%\necho ===   \\ replace /   ===\necho replace result is %IMAGE_PATH:\\=/%\n\necho.\n\necho ABCD:A=a\n\npause\n```\n\n代码中举了两个例子，将变量中的world为China、将路径中的反斜杠替换成斜杠都成功地替换了子串的内容，但是我们发现这个的作用对象只能是变量，对于最后一句`echo ABCD:A=a`并没有发生替换，下面可以看一下运行结果。\n\n**运行结果**\n\n```shell\nE:\\batTool>Replace.bat "Hello wolrd, All over the world!"\nsource string is "Hello wolrd, All over the world!"\n===   China replace world   ===\nreplace result is "Hello wolrd, All over the China!"\n\nsource string is C:\\NVIDIA\\AndroidWorks\\001\n===   \\ replace /   ===\nreplace result is C:/NVIDIA/AndroidWorks/001\n\nABCD:A=a\n请按任意键继续. . .\n```\n\n**总结**\n\n1. bat处理字符串替换的方式比较有意思，需要知道`A:B=C`形式的替换方法\n2. 字符串替换只能是针对变量，对于文本貌似不起作用。\n\n## 7、各种形式的变量%0、%i、%%i、var、%var%、!var!的含义和区别\n\n**前言**\n\n最近使用批处理程序处理文件的时候，发现这 `bat`中的变量形式真是“变化多端”，有时候加1个百分号%，有时候加2个百分号%%，还有的时候加感叹号!，真是让初学者一头雾水，于是查询资料做了一些小测试，终于大致弄清楚了这些变量的含义，接下来一一列举出来。\n\n**变量对比**\n\n下面通过一些具体的例子来看下标题中提到的这些变量什么时候使用，使用的时候有哪些注意事项。\n\n### 7.1、%0\n\n这个是批处理程序中的固定用法，类似于C++程序main函数中argv变量数组，类比可以知道，argv[0]表示exe程序的文件名，argv[1]表示启动程序的第1个参数，后面依次类推。而在批处理程序中%0表示这个批处理程序的文件名，%1表示调用这个批处理时传入的第1个参数，%2表示调用这个批处理时传入的第2个参数，最大可以到%9，具体用法可以参考之前的总结《.bat批处理（二）：%0 %1——给批处理脚本传递参数》，简单测试如下：\n\n\n```shell\n@echo off\n\necho param0=%0\necho param0=%1\necho param0=%2\n\n```\n\n将上述代码保存在文件testparams.bat中，从cmd命令行运行批处理文件，只传入一个参数，运行结果如下：\n\n```shell\nC:\\Users\\Administrator\\Downloads>testparams.bat “hello world”\nparam0=testparams.bat\nparam1=“hello world”\nparam2=\n```\n\n### 7.2、%i\n\n在题目所列的这些变量中，这一个比较特殊，因为它不是批处理文件中的变量，只能用于cmd命令行下的for循环中，在命令行中for循环的语法是for %variable in (set) do command [command-parameters]，其中的variable只能是单字母或者非特殊含义的字符，同样的for循环语句如果写在批处理文件中variable之前就要加两个%%了，先来看看%i的用法，直接在命令行中遍历集合打印输出：\n\n\n```shell\nC:\\Users\\Administrator\\Downloads>for %i in (1,3,5,8) do echo %i\nC:\\Users\\Administrator\\Downloads>echo 1\n1\nC:\\Users\\Administrator\\Downloads>echo 3\n3\nC:\\Users\\Administrator\\Downloads>echo 5\n5\nC:\\Users\\Administrator\\Downloads>echo 8\n8\n```\n\n如果将其中的%i改成%%i，就会报语法错误，测试结果如下：\n\n```shell\nC:\\Users\\Administrator\\Downloads>for %%i in (1,3,5,8) do echo %%i\n此时不应有 %%i。\n```\n\n### 7.3、%%i\n\n这种类型也是for循环中特有的，与%i相对，属于批处理程序的用法，换句话说就是在for循环中遍历的索引变量，如果在命令行中定义需要一个%，如果相同的语句定义在批处理文件中需要2个%%，语法为for %%variable in (set) do command [command-parameters]，variable同样只能是单个字母或者普通字符，至于为什么同样含义的变量在批处理中要多加一个%，至今也没有找到官方的说法，查找MSDN也没有发现说明，不过就我个人理解可能就像我们在命令行中打印一个%，可以正常打印输出，如果通过printf()想输出%就需要2个%的原理一样吧，测试如下：\n```shell\nfor %%i in (1,3,5,8) do echo %%i\n```\n\n直接在终端中运行命令会报上面的错误，保存为文件在进入cmd中运行，结果如下：\n\n```shell\nD:\\test\\battest>testPrecent.bat\nD:\\test\\battest>for %i in (1 3 5 8) do echo %i\nD:\\test\\battest>echo 1\n1\nD:\\test\\battest>echo 3\n3\nD:\\test\\battest>echo 5\n5\nD:\\test\\battest>echo 8\n8\n```\n\n观察运行结果发现，运行批处理文件的时候，实际上去掉了%%i变量的1个%，将文件中代码改为1个%试下：\n\n```shell\nfor %i in (1,3,5,8) do echo %i\n```\n\n运行结果：\n\n```shell\nC:\\Users\\Administrator\\Downloads>testfor.bat\n此时不应有 i。\n```\n\n### 7.4、var,%var%\n\n先了解`set /a`，表示当前变量执行数学计算，如：`set /a var2=var1+1`\n\n这个变量看起来挺正常的，也没有那么多奇奇怪怪的字符，和Lua、Python等语言中的变量长得挺像，实际上变量的这种形式很“短暂”，一般只能出现在给变量赋值的时候，也就是set语句之后，作为左值接受赋值时，或者在等号右测可评估的表达式中，举个例子，编写下面代码保存在normalVar.bat中：\n\n\n```shell\n@echo off\n\nset var1=1\nset /a var2=var1+1\n\necho var1\necho var2\n```\n\n运行之后的结果为:\n\n```shell\nC:\\Users\\Administrator\\Downloads>normalVar.bat\nvar1\nvar2\n```\n\n看完结果之后觉得很神奇是不是，为什么和我学的其他语言不一样呢，我使用set分别为var1和var2赋了值，但是输出的时候居然不是数字而是变量名，其实这就引出了之后%var%这种用法，接着往下看。\n\n\n\n在批处理中除了上面所说的在set语句后面的两种情况，再要想引用变量就需要在变量两端各加一个百分号%，明确的告诉引用者这是一个变量，使用时需要评估一下值，而不要当成字符串，上一个例子中echo后面想要输出的变量没有加%，那就被当成一个字符串处理，原样输出了，修改上个例子如下：\n\n```shell\n@echo off\n\nset var1=1\nset /a var2=var1+1\n\nset var3=%var2%\n\necho %var1%\necho %var2%\necho %var3%\n```\n\n运行之后运行结果入下：\n\n```shell\nC:\\Users\\Administrator\\Downloads>normalVar.bat\n1\n2\n2\n```\n\n看了这次的结果感觉正常多了，有一点需要注意，`set var3=%var2%`这一句中var2变量中的%不能省略，因为它既不属于左值也不属于被评估值的表达式，如果不加%，赋值后var3的值会变成“var2”这个字符串。\n\n### 7.5、!var!\n\n这是最后一种常见的变量形式，同时也是一种不太好理解的形式，需要记住一点，这种变量与延迟环境变量扩展有关，如果没开启延迟环境变量扩展，那么!var!就是一个普通的包含5个字母的字符串，如果开启了延迟环境变量扩展，那么它就是变量var的实际值，可能说到这有的人会产生疑惑，引用变量var的值不是使用%var%吗？那么在开启延迟环境变量扩展的情况下，%var%和!var!有什么区别呢？下面举个例子测试下，编写如下代码保存在extVar.bat文件中：\n```shell\n@echo off\n\nset var1=110\nset var1=120&echo %var1%\n```\n\n运行之后的结果为：\n\n```shell\nC:\\Users\\Administrator\\Downloads>extVar.bat\n110\n```\n\n\n\n看到结果的时候是不是再次怀疑了世界，在打印变量var1之前明明重新赋值了120，为什么打印出来还是110呢？其实这是批处理脚本执行机制导致的，它会按行执行，在执行之前会先预处理，当执行`set var1=110`之后，变量var1变成了110，在执行s`et var1=120&echo %var1%`之前先预处理，将变量%var1%替换成了110，然后语句变成了`set var1=120&echo 110`，所以就得到了我们上面测试的结果。\n\n想要解决这个问题就需要开启延迟环境变量扩展，语句为`setlocal enabledelayedexpansion`，然后将引用变量的形式由%var1%改为!var1!即可，所以可以修改代码如下：\n\n```shell\n@echo off\n\nsetlocal enabledelayedexpansion\nset var1=110\nset var1=120&echo !var1!\n```\n\n这回输出的结果符合预期了，开启了延迟环境变量扩展之后，!var!形式的变量在用之前才会评估确切的值，这是一个知识点，也是一个易错点，特别是在for循环中要格外注意，因为for循环语句的循环体括号中，所有的操作被看成是同一行，所以经常会用到延迟环境变量扩展。\n\n**总结**\n\n* for循环在cmd命令行中的固定用法for %i in (set) do (...)，循环变量格式为%i\n* for循环在bat处理程序中的固定用法for %%i in (set) do (...)，循环变量格式为%%i\n* 至于为什么for语法在批处理中需要多写一个%，希望知道的小伙伴能给出答案和参考资料，不胜感激\n* 想要变量被使用的时候再评估值需要开启延迟环境变量扩展，语法为setlocal enabledelayedexpansion，同时使用!var!形式的变量\n  \n\n## 8、替换带有等号=的字符串的子串\n\n**前言**\n今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为《.bat批处理（六）：替换字符串中匹配的子串》的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 =，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 = 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。\n\n在尝试多次失败之后，我意识到事情远没有想象的那么简单，开始在网上寻找解决方案，结果有些让人意外，绝大多数人都说这是 SET 命令的执行规则决定的，无法实现这种需求。当要替换的子串中包含 = 时，第一个 = 就会被认为是替换语法中的 =，进而导致无法得到正确的结果，即使是使用转义字符都无法完成正确替换，加入的转义字符会影响匹配，导致替换失败。还有一些人建议用其他工具来完整这种需求，比如记事本的替换功能 O(∩_∩)O。\n\n**遇到的问题**\n看了上面的叙述，可能有些小伙伴对我所说的问题还没有太直观的认识，接下来我们举个例子来说一下这个问题究竟是怎样产生的。\n\n**0x00 带有 = 的字符串**\n首先需要被替换的字符串中要包含等号，我们来定义一个这样的变量：\n\n```shell\nset STR=abcdo=ocar12a=ajdjko=ot\n```\n\n变量的名字是` STR`，变量的值是 `abcdo=ocar12a=ajdjko=ot`，其中包含了三个 =。\n\n**0x01 带有 = 的想要被替换的子串**\n确定一下我们想要替换的子串` o=o`，假如我们想把它替换成字母` A`，按照一般的替换规则`X:Y=Z`，在 `X `串中寻找到` Y` 串之后把它替换成` Z` 串，实现的代码如下：\n\n```shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset RESULT=%STR:o=o=A%\n\necho %RESULT%\npause > nul\n```\n\n\n运行之后的结果是：\n\n```shell\nabcdo=A=o=Acar12a=ajdjko=A=o=At\n```\n\n\n\n和我们想法不一样，我们本来想把 o=o 替换成 A，但是从结果来看应该是把 o 替换成了 o=A，原因就是我们选择的被替换中的子串 o=o 包含一个 =，而这个 = 被当成了替换语法 X:Y=Z 中的 =，所以就不对了。\n\n**0x02 尝试用转义字符来处理**\n\n很多语言中都有转义字符，比如 Markdown 语法中的反斜杠 \\，在 Markdown 语法中被星号 * 包裹的文字是倾斜的，但是如果想正常的输出一个 * 怎么办呢？就需要在 * 前面加一个反斜杠 \\，变成 \\*，这样 * 原本的倾斜文字的作用就被转义了，变成了一个普通的输出字符。\n\n在批处理中也有转义字符的概念，它就是 ^，我们知道在批处理中 >、| 等符号都是有特殊用处的，所以不能简单的输出，比如 echo > 是无法输出一个大于号的，要写成 echo ^> 才能正常输出一个 > 符号。\n\n我们就利用这个转义字符来告诉替换命令，被替换的子串中的 = 是一个普通字符，不能作为替换规则的一部分，所以被替换的子串写成了 o^=o，我们实现下面的代码，看看能不能达到目的：\n\n```shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset RESULT=%STR:o^=o=A%\n\necho %RESULT%\npause > nul\n```\n\n\n运行之后结果如下：\n\n```shell\nabcdo=ocar12a=ajdjko=ot\n```\n\n与替换前对比发现没有任何变化，看来转义字符的想法没能帮助我们解决问题，还是想想其他的办法吧。\n\n**稳扎稳打的解决方案**\n\n既然 = 这么特殊，我们就先想办法干掉等号，直接替换的方式不好使，我们可以一个字符一个字符的判断啊，虽然麻烦一点，但是解决问题才是最重要的。\n\n既然要一个个的字符去判断，就需要遍历原字符串，最简单的可以使用字符串分割啊，语法为 原串:~偏移,长度 就可以了，如果不太清楚可以参考一下 《.bat批处理（三）：变量声明、设置、拼接、截取》，截取第一个字符的语法是 原串:~0,1， 截取第二个字符的语法是 原串:~1,1，以此类推。\n\n具体的思路就是我们先判断第一个字符，如果是 = 就进行替换，如果不是 = 就放到结果字符串里，然后继续判断第二个字符进行操作，最后所有的字符处理一遍就完成了替换。\n\n需要使用 goto 语句来写一个循环，代码逻辑比较简单，就是遍历所有字符，是 = 就替换，不是 = 就保留，假设我们先把 = 替换成 #，实现的代码如下：\n\n```shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset CURSTR=%STR%\nset RESULT=\n\n:next\nif "%CURSTR%" equ "" goto end\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT=%RESULT%#) else (set RESULT=%RESULT%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next\n\n:end\necho source string is %STR%\necho result string is %RESULT%\npause > nul\n```\n\n\n:next 是循环的入口，每次截取第一个字符，判断是 = 就在结果中拼接 # 字符，相当于完成了替换，如果字符不是 = ，就将字符直接拼接到结果中，操作之后将原串的第一个字符删除形成新的原串，然后再判断第一个字符，以此类推，直到原串为空，运行结果如下：\n\n```shell\nsource string is abcdo=ocar12a=ajdjko=ot\nresult string is abcdo#ocar12a#ajdjko#ot\n```\n\n**最终方案**\n\n事情到了这里好像还没完，在实际操作中有些情况不是替换一个 =，往往是替换的内容中包含 =，上面将 = 替换成 # 不具有通用型，如果是一开始的请求，将 o=o替换成 A 就不能这样写了，就应该是每次判断3个字符了，写起来有些麻烦，批处理中没有获得字符串长度的函数，需要自己实现一个，如果是100个字符的被替换串，那代码就很难写了。\n\n既然 = 都能被我们替换掉，肯定有办法实现上面我们这种将 o=o替换成 A 的要求，下面我们就列举一种通用的处理方法。\n\n**0x00 首先将 = 替换成一个原串中不可能出现的字符或者序列**\n\n这步替换可能最后需要还原的，所以要求我们替换成的目标序列不能在原串中出现，比如我们上面把 = 替换成了 #， 如果原串中有 # 就会弄混了，不能确定是原来字符串中就存在的 #，还是由 = 变成的 #。\n\n这个序列我们可以定义的变态一点，比如把 = 替换成 ###i#am#happy###，我们把它记作 α。\n\n**0x01 用这个不能出现序列替换我们之前要查找替换子串中的 =**\n\n我们之前要查找替换的子串是 o=o，那么替换之后形成 o###i#am#happy###o，我们把它记作 β。\n\n**0x02 将第1步结束获得的替换结果作为原串，将其中的 β 替换成 A**\n\n其实就是把第1步替换完结果作为原串，把其中的 o###i#am#happy###o 也就是原来的 o=o 替换成 A。\n\n**0x03 将第3步结果的子串作为原串，将其中的 α 替换为 =**\n\n这一步就是处理那些虽然是 =，但是这个 = 不是我要替换的结果子串中的，所以要还原\n\n代码实现\n步骤梳理清楚了，下面来写代码，按照步骤一步步写就可以了：\n\n```\n@echo off\n\nrem 第一步\nset CORESTR=###i#am#happy###\nset STR=abcdo=ocar12a=ajdjko=ot\nset CURSTR=%STR%\nset RESULT1=\n\n:next1\nif "%CURSTR%" equ "" goto end1\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT1=%RESULT1%%CORESTR%) else (set RESULT1=%RESULT1%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next1\n\n:end1\necho source1 string is %STR%\necho result1 string is %RESULT1%\npause > nul\n\n\nrem 第 2 步\nset CORESTR=###i#am#happy###\nset STR=o=o\nset CURSTR=%STR%\nset RESULT2=\n\n:next2\nif "%CURSTR%" equ "" goto end2\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT2=%RESULT2%%CORESTR%) else (set RESULT2=%RESULT2%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next2\n\n:end2\necho source2 string is %STR%\necho result2 string is %RESULT2%\npause > nul\n\n\nrem 第3步，需要开启延迟变量\nsetlocal ENABLEDELAYEDEXPANSION\nset RESULT3=!RESULT1:%RESULT2%=A!\necho result3 string is %RESULT3%\npause > nul\n\n\nrem 第4步\nset RESULT4=!RESULT3:%CORESTR%==!\n\necho finally result is %RESULT4%\n```\n\n\n运行之后的结果为：\n\n```shell\nsource1 string is abcdo=ocar12a=ajdjko=ot\nresult1 string is abcdo###i#am#happy###ocar12a###i#am#happy###ajdjko###i#am#happy###ot\nsource2 string is o=o\nresult2 string is o###i#am#happy###o\nresult3 string is abcdAcar12a###i#am#happy###ajdjkAt\nfinally result is abcdAcar12a=ajdjkAt\n```\n\n这次终于替换成功了，o=o 被成功替换成了字母 A，代码中用到了延迟变量，主要是为了实现被替换字符串是变量的情况，不清楚延迟变量的用法可以简单查询一下，至此文章开头提出的问题我们就成功解决了，虽然路途有些坎坷。\n\n**总结**\n\n* 批处理程序中的 = 比较特殊，使用常规的 X:Y=Z 的语法不能替换包含 = 的子串\n* 遇到上述情况可以将字符串切割，采用逐个字符比较的方式，将 = 替换成其他字符再进行后续操作\n* 有时候也不必非得使用批处理来替换包含 = 的字符串，随便一个文本工具，比如记事本都可以文本进行替换\n* 如果非得用命令解决，也可以使用从 linux 的 sed 命令移植到 windows 的 sed.exe 程序来很方便的进行替换\n* 使用 sed 命令的语法是 echo abcdo=ocar12a=ajdjko=ot | sed -e "s/o=o/A/g"，一步就可以完成了文章开头的需求了\n* 如果你暂时没有 sed.exe 程序，可以点击这个链接 sed.exe程序 下载，若不是在同一目录使用，记得将命令目录添加到环境变量中\n\n\n\n## 9、从路径字符串中截取盘符、文件名、后缀名等信息\n\n**前言**\n\n又是实际开发中的问题，想要截取一个文件路径中的盘符、文件名等信息，第一反应是正则表达式？或者是 split 函数？这些往往都是“高级”语言中才会有的实现方法，对于批处理来说有点“带不动”啊，那么在bat批处理中要怎样处理类似的请求呢？最近找到了两种方法，接下来会逐一展示一下，不过在展示具体的写法前，我们先来看一下 %~dp0的含义。\n\n**%~dp0的含义**\n关于 %~dp0 的作用在之前的总结中 《.bat批处理（四）：路径相关%cd%和%~dp0的区别》 有提到过，它表示当前运行的批处理文件所在的目录，那么它是一个特殊的变量吗？\n\n可以说算是吧，这个变量特殊在它是从参数变量 %0 扩展而来的，提到 %0 很多人都会想到它是批处理脚本的第一个参数，表示当前运行的脚本全路径，可以写个脚本试一下：\n\n```shell\nAlbert at home-pc in D:\\data\\bat [0:03:25]\n% Get-Content showparams.bat\n@echo off\n\necho %0\necho %1\n\nAlbert at home-pc in D:\\data\\bat [0:03:31]\n% ./showparams.bat good\n"D:\\data\\bat\\showparams.bat"\ngood\n```\n\n\n类似的变量还有 1%、2%、3%… 一直到9%，都依次表示运行批处理脚本时传入的参数，这些变量还有一个本领，那就是支持扩展，写起来花里胡哨的。\n\n**扩展字符串**\n\n扩展字符串是批处理自带的功能，可以实现对表示文件路径的字符串进行特殊的处理，以%0 参数为例，具体功能列举如下：\n\n* %~0 - 删除路径中的引号\n* %~f0 - 将 %0 扩展到一个完全合格的路径名\n* %~d0 - 将 %0 扩展到一个驱动器号\n* %~p0 - 将 %0 扩展到一个路径\n* %~n0 - 将 %0 扩展到一个文件名\n* %~x0 - 将 %0 扩展到一个文件扩展名\n* %~s0 - 将 %0 扩展的路径只含有短名\n* %~a0 - 将 %0 扩展到文件的文件属性\n* %~t0 - 将 %0 扩展到文件的日期/时间\n* %~z0 - 将 %0 扩展到文件的大小\n* %~$PATH:0 查找变量0%在环境变量$PATH的目录，并将 %0 扩展到找到的第一个完全合格的名称，$PATH未被定义或没找到文件，则结果为空字符串\n\n当然这个写法也可以进行组合，比如 %~d0 和 %~p0 组合后变成 %~dp0 也就是我们常见的那个变量啦~\n\n可以将这些变量打印出来看一下具体的值：\n\n```shell\nAlbert at home-pc in D:\\data\\bat [0:26:17]\n% Get-Content showparams.bat\n@echo off\n\necho %0\necho %~0\necho %~f0\necho %~d0\necho %~p0\necho %~n0\necho %~x0\necho %~s0\necho %~a0\necho %~t0\necho %~z0\necho %~dp0\necho %~nx0\nAlbert at home-pc in D:\\data\\bat [0:26:28]\n% .\\showparams.bat\n"D:\\data\\bat\\showparams.bat"\nD:\\data\\bat\\showparams.bat\nD:\\data\\bat\\showparams.bat\nD:\n\\data\\bat\\\nshowparams\n.bat\nD:\\data\\bat\\showparams.bat\n--a--------\n2021/10/17 00:26\n156\nD:\\data\\bat\\\nshowparams.bat\n```\n\n**从字符串中截取路径、文件名**\n\n上面的部分解释了%~dp0，同时也知道了这些脚本参数指出扩展语法，如果是普通变量的话就不能使用扩展语法了，那么对于一个普通的包含字符串怎么才能使用扩展语法，截取到想要的部分呢？目前我知道的有两种方法：一种是传参使其变成脚本参数，也就是 %n的形式，另一种方法就是使用 for 语句，接下来分别看一下。\n\n**脚本传参**\n\n普通的字符串无法进行扩展，如果想把这种变量就需要把它们变成脚本参数，这就需要将参数传递给另一个脚本，这样实现起来会将脚本调用变得复杂一些，实际上可以在一个脚本中完成截取工作，类似于C/C++中的函数调用，可以在批处理中使用 call 命令搭配标签实现，具体代码如下：\n\n\n\n```\nAlbert at home-pc in D:\\data\\bat [17:37:54]\n% Get-Content extract1.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\necho %OriginStr%\n\ncall :extract %OriginStr%\ngoto :eof\n\n:extract\nrem 获取到文件路径\necho %~dp1\nrem 获取到文件盘符\necho %~d1\nrem 获取到文件名称\necho %~n1\nrem 获取到文件后缀\necho %~x1\n\nAlbert at home-pc in D:\\data\\bat [17:41:25]\n% .\\extract1.bat\n"C:/Demo/myproject/example.txt"\nC:\\Demo\\myproject\\\nC:\nexample\n.txt\n```\n\n\n在这段代码中 :eof 标签是一个默认的标签，表示文件结尾，实际需求中需根据具体要求进行调整。\n\n**for语法扩展**\n\n使用 for 循环是另一种实现方式，因为循环变量也可以支持扩展，可以将需要截取的字符串路径放在循环范围中，然后先循环输出测试下：\n\n```\nAlbert at home-pc in D:\\data\\bat [17:46:29]\n% Get-Content extract2.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\n\nfor %%I in (%OriginStr%) do echo %%I\n\nAlbert at home-pc in D:\\data\\bat [17:46:57]\n% .\\extract2.bat\n"C:/Demo/myproject/example.txt"\n```\n\n在批处理中的循环变量是 %%I的形式，需要两个 % 才可以，后面的变量名可以换成26个字母中的任意一个，并且字母会区分大小写，然后利用这些循环变量就可以进行扩展，然后完成最开始的需求，实现代码如下：\n\n```\nAlbert at home-pc in D:\\data\\bat [17:53:53]\n\n% Get-Content extract2.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\n\nfor %%I in (%OriginStr%) do echo %%I\n\nrem 获取到文件路径\nfor %%I in (%OriginStr%) do echo %%~dpI\nrem 获取到文件盘符\nfor %%I in (%OriginStr%) do echo %%~dI\nrem 获取到文件名称\nfor %%I in (%OriginStr%) do echo %%~nI\nrem 获取到文件后缀\nfor %%I in (%OriginStr%) do echo %%~xI\n\nAlbert at home-pc in D:\\data\\bat [17:54:01]\n\n% .\\extract2.bat\n"C:/Demo/myproject/example.txt"\nC:\\Demo\\myproject\\\nC:\nexample\n.txt\n```\n\n\n这种写法的好处就是无需控制标签跳转流程，通过循环命令 for 就可以获取想要的参数，使用起来会方便很多。\n\n**总结**\n\n* 在批处理文件中 %~dp0 表示批处理文件所在的目录，而 %cd% 表示执行命令时所在的目录\n* 在批处理文件中想要截取目录操作可以使用变量扩展来实现，而变量必须是 %i 的形式，其中的 i 是可以是 a~zA~Z0~9\n* for 表达式中的循环变量在cmd命令行中是 %i 的形式，而在批处理文件中需要协程 %%i 的形式\n* 常用的变量扩展有：获取到文件盘符使用 %~d0，获取到文件名称使用 %~n0，获取到文件后缀使用 %~x0\n  \n\n## 10、替换字符串中包含百分号%的子串\n\n**前言**\n今天这篇总结是之前批处理替换字符串的延伸问题，同样来源于读者的提问，要处理的问题是被替换的子串中如果有百分号 % 要怎样替换，因为 % 在批处理脚本中也比较特殊，如果要想表示一个 % 字符，那么在给变量赋值时需要写成 %% 的样子，用两个表示一个，类似于进行转义，因为在批处理中， %开头的内容通常表示一个变量。\n\n之前也处理过一些替换问题，列举如下，不过今天的问题需要新的解法。\n\n《.bat批处理（六）：替换字符串中匹配的子串》\n《.bat批处理（九）：替换带有等号=的字符串的子串》\n问题示例\n\n```shell\n将字符串 https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925 中的 %3c 替换成字母 e\n```\n\n问题比较明确，就是因为被替换的子串中包含了 % 导致常规的替换写法 %a:b=c% 的写法失效了。\n\n**解决方法**\n\n既然子串中包含 % 会影响变量替换字符串的写法，我们就可以考虑换一种变量写法，用 ! 代替 %，看到这很多人应该反应过来了，那就是启用延迟变量扩展，这个我就不展开说了，之前总结过，可以看一下这篇文章《.bat批处理（八）：各种形式的变量%0、%i、%%i、var、%var%、!var!的含义和区别》。\n\n**示例代码**\n\n```\n@echo off\nrem 将输入字符串中的%3c替换成字母e\n\nSET INPUT_PARAM=%1\nsetlocal EnableDelayedExpansion\n\necho -\necho replace result is !INPUT_PARAM:%%3c=e!\necho -\n\npause\n```\n\n\n运行结果\n\n```\nD:\\data\\bat>replace%.bat https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925\n-\nreplace result is https://blog.csdn.net/albertsh/article/details/124760925\n-\n请按任意键继续. . .\n```\n\n**总结**\n\n```shell\n批处理脚本中的替换语法不仅可以写成 %a:b=c%，还可以写成 !a:b=c!的形式\n批处理脚本执行机制是会按行执行，在执行之前会先预处理\n开启延迟环境变量扩展setlocal enabledelayedexpansion，变量会在用到时再估值，不会预处理了\n```\n\n## 来源\n\n学习来源：[(257条消息) Dos/bat_AlbertS的博客-CSDN博客](https://blog.csdn.net/albertsh/category_6454495.html)'},{title:"工作中遇到的 shell",headers:[{level:2,title:"1、脚本启动停止jar包，并生成日志文件",slug:"_1、脚本启动停止jar包-并生成日志文件",link:"#_1、脚本启动停止jar包-并生成日志文件",children:[]},{level:2,title:"2、上面的变种",slug:"_2、上面的变种",link:"#_2、上面的变种",children:[]}],path:"/posts/shell/shellWork.html",pathLocale:"/",extraFields:'---\ntitle: 工作中遇到的 shell\nicon: pen-to-square\ndate: 2024-05-13\nlastUpdated: true\ncategory:\n  - windows\ntag:\n  - script\n  - shell\n---\n\n工作中遇到有关 shell 脚本的情景和处理记录\n\n\x3c!-- more --\x3e\n\n## 1、脚本启动停止jar包，并生成日志文件\nstart.bat\n```shell\n@echo off\n%1 mshta vbscript:CreateObject("WScript.Shell").Run("%~s0 ::",0,FALSE)(window.close)&&exit\njava -jar 包名.jar >StartupLog.log  2>&1 &\nexit\n```\n其中，StartupLog.log 是日志文件\n\nstop.bat\n```shell\n@echo off\nset port=程序端口号\nfor /f "tokens=1-5" %%i in (\'netstat -ano^|findstr ":%port%"\') do taskkill /f /pid %%m\n```\n\n原文链接：https://blog.csdn.net/weixin_47148475/article/details/126747188\n\n## 2、上面的变种\n\nstart2.bat\n```shell\nset JAVA_HOME=./jdk\n \nset CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n \nset Path=%JAVA_HOME%\\bin;\n \njava -jar DMS_DEMO-1.0-SNAPSHOT.jar\n```\n\nstop2.bat\n```shell\n@echo off\n# 项目启动后，会占用的端口\nset port=9021\nfor /f "tokens=1-5" %%i in (\'netstat -ano^|findstr ":%port%"\') do (\n    echo kill the process %%m who use the port %port%\n    # 根据 进程id pid 信息，杀掉进程\n    taskkill /f /pid %%m\n)\n\n```\n\n'},{title:"Windows 工作中遇到的问题",headers:[{level:2,title:"windows 端口占用",slug:"windows-端口占用",link:"#windows-端口占用",children:[]},{level:2,title:"windows 启动 jar包",slug:"windows-启动-jar包",link:"#windows-启动-jar包",children:[]},{level:2,title:"windows 停止 jar包",slug:"windows-停止-jar包",link:"#windows-停止-jar包",children:[]}],path:"/posts/windows/workcondition.html",pathLocale:"/",extraFields:'\ufeff---\ntitle: Windows 工作中遇到的问题\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\n\ntag:\n  - java\n  - spring\n  - springboot\n  - shell\n\n---\n\nWindows 工作中遇到的问题\n\x3c!-- more --\x3e\n# work condition\n\n标签（空格分隔）： Windows\n\n---\n## windows 端口占用\n```sh\n# 查找端口号，监听的程序id\nnetstat -aon|findstr "9011"\n# 通过程序id，找到程序\ntasklist|findstr "24548"\n# 通过程序id，杀死这个程序\ntaskkill -pid 24548 -f\n```\n\n## windows 启动 jar包\n```shell\n@echo off\nsetlocal\n\nREM 改变当前工作目录到 JAR 文件所在目录, /d 参数允许同时更改驱动器和目录\ncd /d D:\\transferData\\\n\nREM 指定Java应用程序和参数\nset "JAVA_PATH=D:\\transferData\\jdk1.8.0_351\\jre\\bin\\java"\nset "JAR_FILE=datatransport-0.0.1-SNAPSHOT.jar"\n\nREM 启动Java应用程序\n"%JAVA_PATH%" -jar "%JAR_FILE%" --server.port=10086\nendlocal\nPAUSE\n```\n## windows 停止 jar包\n1.根据端口号停止服务\n```shell\n@echo off\nREM 确保在批处理脚本中对环境变量所做的更改只在该脚本内部有效，不会影响到批处理脚本外部的环境变量\nsetlocal\n\nREM 设置要查找和停止的端口号\nset PORT=10086\n\nREM 查找并终止监听指定端口的Java进程\nfor /f "tokens=5" %%i in (\'netstat -ano ^| findstr :%PORT%\') do (\n    taskkill /F /PID %%i\n)\n\necho Attempted to stop Java process listening on port %PORT%.\n\nendlocal\nPAUSE\n```\n2.停止脚本，去除重复的pid\n```shell\n@echo off\nsetlocal\n\nREM 设置要查找和停止的端口号\nset PORT=10086\n\nREM 初始化变量用于存储唯一PID\nset UNIQUE_PIDS=\n\nREM 查找并终止监听指定端口的Java进程，同时去重\nfor /f "tokens=5" %%i in (\'netstat -ano ^| findstr :%PORT%\') do (\n    set NEW_PID=%%i\n    set found=\n    for /f "tokens=*" %%j in (\'set pid_%%i 2^>nul\') do set found=true\n    if not defined found (\n        echo Process ID listening on port %PORT% is %%i\n        taskkill /F /PID %%i\n        if errorlevel 1 (\n            echo Failed to stop the process with PID %%i.\n        ) else (\n            echo Successfully stopped the Java process with PID %%i.\n            set pid_%%i=1\n        )\n    )\n)\n\nif "%UNIQUE_PIDS%"=="" (\n    echo No process found listening on port %PORT%.\n) else (\n    echo All matching processes have been processed.\n)\n\nendlocal\nPAUSE\n```\n3.根据文件位置和名称 停止\n```shell\n@echo off\nsetlocal\n\nREM 设置JDK路径和JAR文件路径\nset "jdkPath=D:\\transferData\\jdk1.8.0_351"\nset "jarFileName=datatransport-0.0.1-SNAPSHOT.jar"\n\nREM 保存当前的JAVA_HOME和PATH\nset "original_JAVA_HOME=%JAVA_HOME%"\nset "original_PATH=%PATH%"\n\nREM 设置新的JAVA_HOME环境变量\nset "JAVA_HOME=%jdkPath%"\n\nREM 添加JDK的bin目录到PATH环境变量\nset "PATH=%JAVA_HOME%\\bin;%PATH%"\n\nREM 打印当前设置的JAVA_HOME和PATH\necho JAVA_HOME is set to: %JAVA_HOME%\necho PATH is set to: %PATH%\n\nREM 检查jps是否存在\nwhere jps >nul 2>&1\nif errorlevel 1 (\n    echo Error: jps not found in PATH.\n    goto end\n)\n\nREM 获取正在运行的Java进程列表，并查找包含指定JAR文件名的进程\necho Searching for Java processes...\nfor /f "tokens=1,2 delims= " %%p in (\'jps -l\') do (\n    if "%%q"=="%jarFileName%" (\n        echo Found process with PID %%p running %jarFileName%\n        echo Killing process with PID %%p\n        taskkill /PID %%p /F\n        if errorlevel 1 (\n            echo Failed to kill process with PID %%p\n        ) else (\n            echo Successfully killed process with PID %%p\n        )\n    ) else (\n        REM 检查命令行参数是否包含JAR文件路径\n        for /f "tokens=*" %%a in (\'wmic process where processid^=%%p get commandline ^| findstr /i "%jarFileName%"\') do (\n            if not "%%a"=="" (\n                echo Found process with PID %%p running %jarFileName%\n                echo Killing process with PID %%p\n                taskkill /PID %%p /F\n                if errorlevel 1 (\n                    echo Failed to kill process with PID %%p\n                ) else (\n                    echo Successfully killed process with PID %%p\n                )\n            )\n        )\n    )\n)\n\nREM 如果没有找到任何进程\nif \'%errorlevel%\'==\'0\' (\n    echo No matching Java processes found.\n)\n\n:end\nREM 恢复原来的JAVA_HOME和PATH\nset "JAVA_HOME=%original_JAVA_HOME%"\nset "PATH=%original_PATH%"\n\necho Restored original JAVA_HOME and PATH.\n\nendlocal\npause\n```\n\n'},{title:"什么是面向对象编程",headers:[{level:2,title:"1.什么是面向过程？",slug:"_1-什么是面向过程",link:"#_1-什么是面向过程",children:[{level:3,title:"1.1.关键特点",slug:"_1-1-关键特点",link:"#_1-1-关键特点",children:[]}]},{level:2,title:"2.什么是面向对象编程 (OOP)？",slug:"_2-什么是面向对象编程-oop",link:"#_2-什么是面向对象编程-oop",children:[{level:3,title:"2.1.面向对象编程的核心概念",slug:"_2-1-面向对象编程的核心概念",link:"#_2-1-面向对象编程的核心概念",children:[]},{level:3,title:"2.2.面向对象编程的优势",slug:"_2-2-面向对象编程的优势",link:"#_2-2-面向对象编程的优势",children:[]}]},{level:2,title:"3.面向对象和面向过程的总结",slug:"_3-面向对象和面向过程的总结",link:"#_3-面向对象和面向过程的总结",children:[]},{level:2,title:"4.面向对象的三大基本特征",slug:"_4-面向对象的三大基本特征",link:"#_4-面向对象的三大基本特征",children:[{level:3,title:"4.1. 封装 (Encapsulation)",slug:"_4-1-封装-encapsulation",link:"#_4-1-封装-encapsulation",children:[]},{level:3,title:"4.2. 继承 (Inheritance)",slug:"_4-2-继承-inheritance",link:"#_4-2-继承-inheritance",children:[]},{level:3,title:"4.3. 多态 (Polymorphism)",slug:"_4-3-多态-polymorphism",link:"#_4-3-多态-polymorphism",children:[]}]},{level:2,title:"5.面向对象的五大基本原则 (SOLID)",slug:"_5-面向对象的五大基本原则-solid",link:"#_5-面向对象的五大基本原则-solid",children:[{level:3,title:"5.1. 单一职责原则 (Single Responsibility Principle, SRP)",slug:"_5-1-单一职责原则-single-responsibility-principle-srp",link:"#_5-1-单一职责原则-single-responsibility-principle-srp",children:[]},{level:3,title:"5.2. 开闭原则 (Open/Closed Principle, OCP)",slug:"_5-2-开闭原则-open-closed-principle-ocp",link:"#_5-2-开闭原则-open-closed-principle-ocp",children:[]},{level:3,title:"5.3. 里氏替换原则 (Liskov Substitution Principle, LSP)",slug:"_5-3-里氏替换原则-liskov-substitution-principle-lsp",link:"#_5-3-里氏替换原则-liskov-substitution-principle-lsp",children:[]},{level:3,title:"5.4. 接口隔离原则 (Interface Segregation Principle, ISP)",slug:"_5-4-接口隔离原则-interface-segregation-principle-isp",link:"#_5-4-接口隔离原则-interface-segregation-principle-isp",children:[]},{level:3,title:"5.5. 依赖倒置原则 (Dependency Inversion Principle, DIP)",slug:"_5-5-依赖倒置原则-dependency-inversion-principle-dip",link:"#_5-5-依赖倒置原则-dependency-inversion-principle-dip",children:[]},{level:3,title:"5.6.总结",slug:"_5-6-总结",link:"#_5-6-总结",children:[]}]}],path:"/posts/java/basic/1.object-oriented-programming.html",pathLocale:"/",extraFields:'---\ntitle: 什么是面向对象编程\nicon: pen-to-square\ncover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2024-12-23\nlastUpdated: true\norder: -1 \ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 面向对象基本信息介绍\n\n\x3c!-- more --\x3e\n\n\n## 1.什么是面向过程？\n\n**面向过程开发（Procedural Programming）** 是一种编程范式，它以一系列明确的步骤或过程（也称为函数、子程序或方法）来组织代码。这些过程通常执行特定的任务，并且可以接受输入参数和返回输出结果。面向过程编程强调的是程序的流程控制和数据的顺序处理。\n\n### 1.1.关键特点\n\n- **过程/函数**\n  - 面向过程的程序由多个过程组成，每个过程负责完成一个特定的功能。程序通过调用这些过程来实现更复杂的操作。\n  \n- **全局状态**\n  - 在面向过程的编程中，程序的状态通常存储在全局变量或静态变量中。这允许过程之间共享数据，但同时也可能引入副作用，因为一个过程可能会改变另一个过程使用的数据。\n\n- **顺序执行**\n  - 程序按照代码编写的顺序从上到下依次执行。条件语句（如 `if-else`）和循环结构（如 `for` 和 `while`）用于控制这个顺序，使程序能够根据不同的情况做出不同的反应。\n\n- **模块化**\n  - 为了提高代码的可读性和可维护性，面向过程的程序经常被划分为若干个模块，每个模块包含一组相关的功能。这种模块化有助于简化大型程序的设计和调试。\n\n- **重复利用**\n  - 通过定义通用的过程，可以在程序的不同部分重用它们，从而减少冗余代码并提升效率。\n\n- **简单直接**\n  - 面向过程的编程模型相对简单，对于一些不需要复杂抽象的小型应用程序来说，它是一个非常有效的解决方案。\n\n\n\n## 2.什么是面向对象编程 (OOP)？\n\n**面向对象编程（Object-Oriented Programming, OOP）** 是一种编程范式，它通过“对象”来组织代码，这些对象通常是数据结构（称为属性或字段）和可以对这些数据进行操作的函数（称为方法）的封装体。OOP 的目标是模拟现实世界中的实体及其交互方式，以提高软件开发的效率和代码的可维护性。\n\n### 2.1.面向对象编程的核心概念\n\n#### 2.1.1. 类 (Class)\n- **定义**: 类是创建对象的蓝图或模板。它定义了对象将具有的属性和行为。类描述了所有属于该类型的对象共有的特征和功能。\n- **特性**: 包含属性（数据成员）和方法（成员函数），用于表示对象的状态和行为。\n\n#### 2.1.2. 对象 (Object)\n- **定义**: 对象是类的具体实例。它是根据类创建出来的具体实体，具有特定的属性值，并能执行由类定义的方法。\n- **特性**: 每个对象都是独立的，拥有自己的状态（属性值），但共享同一类的行为（方法）。\n\n#### 2.1.3. 封装 (Encapsulation)\n- **定义**: 封装是指将数据（属性）和操作数据的方法捆绑在一起，并隐藏对象内部的工作细节。这有助于保护数据不被外部直接访问，同时提供公共接口来进行交互。\n- **实现**: 通常使用访问修饰符如 `private`、`protected` 和 `public` 来控制不同级别的访问权限。\n\n#### 2.1.4. 继承 (Inheritance)\n- **定义**: 继承允许一个类从另一个类继承属性和方法，从而促进代码重用并建立类之间的层次关系。子类可以从父类那里获得属性和方法，还可以添加新的或者覆盖已有的行为。\n- **优点**: 提高了代码的复用性和扩展性。\n\n#### 2.1.5. 多态 (Polymorphism)\n- **定义**: 多态意味着不同的对象可以通过共同的接口以不同方式处理相同的消息。多态使得子类可以改变父类方法的行为，或者不同类的对象可以通过相同的接口调用而表现出不同的行为。\n- **形式**: 方法重写（override）和接口/抽象类是实现多态的主要手段。\n\n#### 2.1.6. 抽象 (Abstraction)\n- **定义**: 抽象是指忽略不必要的细节，只关注对象的关键特征。在 OOP 中，可以通过抽象类和接口来定义一组通用的操作，而不必关心具体的实现。\n- **作用**: 提供了一种简化复杂系统的方式，让开发者专注于高层次的设计而非底层的实现。\n\n### 2.2.面向对象编程的优势\n\n- **模块化**: 程序可以更容易地分解为多个小部分，每个部分负责单一功能，提高了代码的清晰度和可管理性。\n- **易维护**: 由于封装和模块化，程序更易于理解和修改，减少了耦合性。\n- **可扩展性**: 继承机制允许轻松添加新特性，而不影响现有代码，增强了系统的灵活性。\n- **代码重用**: 继承和组合促进了代码的重复利用，降低了冗余。\n- **真实世界的建模**: OOP 的概念与现实世界的实体和关系非常吻合，使得某些类型的应用程序更容易设计和理解。\n\n## 3.面向对象和面向过程的总结\n\n通过上述特性，面向对象编程提供了一种强大的工具集，用于构建复杂且易于维护的软件系统。它不仅提升了开发效率，还促进了团队协作和代码质量的提升。\n\n与面向对象编程（OOP）相比，面向过程编程不强调将数据和行为封装在一起。在 OOP 中，你创建的对象不仅包含了数据（属性），还包含了可以对这些数据执行的操作（方法）。OOP 更加注重类和继承等概念，而面向过程编程则更加关注函数和过程的逻辑流。\n\n## 4.面向对象的三大基本特征\n\n面向对象编程（OOP）有三大核心特征，它们是：\n\n1. **封装 (Encapsulation)**\n2. **继承 (Inheritance)**\n3. **多态 (Polymorphism)**\n\n### 4.1. 封装 (Encapsulation)\n\n- **定义**: 封装是指将数据（属性）和操作数据的方法捆绑在一起，并隐藏对象内部的工作细节。它允许开发者创建一个黑盒式的组件，用户只需要知道如何与之交互，而不需要了解其内部实现。\n- **优点**: 提高了安全性，减少了外部代码对类内部状态的直接访问；增强了模块化，使得代码更易于维护和扩展。\n\n### 4.2. 继承 (Inheritance)\n\n- **定义**: 继承允许一个类从另一个类继承属性和方法，从而促进代码重用并建立类之间的层次关系。子类可以获得父类的所有功能，并可以选择性地添加新的行为或修改已有的行为。\n- **优点**: 提高了代码复用性和系统的可扩展性，简化了复杂系统的设计。\n\n### 4.3. 多态 (Polymorphism)\n\n- **定义**: 多态意味着不同的对象可以通过共同的接口以不同方式处理相同的消息。多态性允许同一操作作用于不同类型的对象上时产生不同的行为。\n- **形式**: 主要通过方法重写（override）和接口/抽象类来实现。\n- **优点**: 增加了灵活性，允许编写更加通用的代码，减少了代码冗余，提高了代码的可读性和可维护性。\n\n这三大特征共同构成了面向对象编程的基础，帮助开发者构建出结构良好、易于理解和维护的软件系统。\n\n\n## 5.面向对象的五大基本原则 (SOLID)\n\n面向对象设计中有五个重要的原则，它们共同构成了 SOLID 原则。这些原则旨在指导开发者创建更易于维护、扩展和测试的软件系统。每个字母代表一个原则：\n\n### 5.1. **单一职责原则 (Single Responsibility Principle, SRP)**\n\n- **定义**: 一个类应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项功能或职责。\n- **优点**: 确保类的设计足够简单，使得它们更容易理解、测试和维护。\n\n  例子：\n```java\n// 错误做法：多个职责\nclass User {\n    public void register() { /* 注册逻辑 */ }\n    public void sendEmail() { /* 发送邮件逻辑 */ }\n}\n\n// 正确做法：单一职责\nclass UserService {\n    public void register() { /* 注册逻辑 */ }\n}\n\nclass EmailService {\n    public void sendEmail() { /* 发送邮件逻辑 */ }\n}\n```\n\n### 5.2. **开闭原则 (Open/Closed Principle, OCP)**\n\n- **定义**: 软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。这意味着我们应该能够通过添加新代码来扩展行为，而不是修改现有代码。\n- **优点**: 减少了对现有代码的更改需求，降低了引入错误的风险，并提高了系统的稳定性。\n\n例子：\n```java\n// 错误做法：违反开闭原则\nclass DiscountCalculator {\n    public double calculateDiscount(String userType, double amount) {\n        if ("VIP".equals(userType)) {\n            return amount * 0.8;\n        } else {\n            return amount;\n        }\n    }\n}\n\n// 正确做法：遵循开闭原则\ninterface DiscountStrategy {\n    double apply(double amount);\n}\n\nclass VIPDiscount implements DiscountStrategy {\n    @Override\n    public double apply(double amount) {\n        return amount * 0.8;\n    }\n}\n\nclass DiscountCalculator {\n    private DiscountStrategy strategy;\n\n    public DiscountCalculator(DiscountStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public double calculateDiscount(double amount) {\n        return strategy.apply(amount);\n    }\n}\n```\n### 5.3. **里氏替换原则 (Liskov Substitution Principle, LSP)**\n\n- **定义**: 子类型必须能够替换它们的基类型而不影响程序的正确性。即子类应该可以替换父类出现在任何地方，并且不会导致程序逻辑出错。\n- **优点**: 保证了继承结构的健壮性和一致性，避免了不合理的继承关系带来的问题。\n\n例子：\n```java\n// 错误做法：违反里氏替换原则\nclass Rectangle {\n    protected int width, height;\n\n    public void setWidth(int w) { width = w; }\n    public void setHeight(int h) { height = h; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int w) {\n        super.setWidth(w);\n        super.setHeight(w); // 违反了LSP，因为Square改变了Rectangle的行为\n    }\n\n    @Override\n    public void setHeight(int h) {\n        super.setHeight(h);\n        super.setWidth(h);\n    }\n}\n\n// 正确做法：遵循里氏替换原则\ninterface Shape {\n    double area();\n}\n\nclass Rectangle implements Shape {\n    private final int width, height;\n\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        return width * height;\n    }\n}\n\nclass Square implements Shape {\n    private final int side;\n\n    public Square(int side) {\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        return side * side;\n    }\n}\n```\n### 5.4. **接口隔离原则 (Interface Segregation Principle, ISP)**\n\n- **定义**: 客户端不应该被迫依赖于它们不使用的接口。换言之，接口应该是小而专注的，不要把不需要的功能强加给实现者。\n- **优点**: 提高了灵活性，减少了不必要的依赖，使得接口更加清晰和易于使用。\n\n例子：\n```java\n// 错误做法：大而全的接口\ninterface Worker {\n    void work();\n    void eat();\n}\n\nclass HumanWorker implements Worker {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { /* 吃饭 */ }\n}\n\nclass RobotWorker implements Worker {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { throw new UnsupportedOperationException("Robots don\'t eat!"); }\n}\n\n// 正确做法：分离接口\ninterface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\nclass HumanWorker implements Workable, Eatable {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { /* 吃饭 */ }\n}\n\nclass RobotWorker implements Workable {\n    @Override\n    public void work() { /* 工作 */ }\n}\n```\n### 5.5. **依赖倒置原则 (Dependency Inversion Principle, DIP)**\n\n- **定义**: 高层次模块不应该依赖于低层次模块，两者都应该依赖于抽象。此外，抽象不应该依赖于细节，而细节应该依赖于抽象。\n- **优点**: 促进了松耦合的设计，使得组件之间的依赖关系更加灵活，便于测试和维护。\n\n例子：\n```java\n// 错误做法：高层次依赖于低层次\nclass LightBulb {\n    public void turnOn() { /* 打开电灯 */ }\n}\n\nclass Switch {\n    private LightBulb lightBulb;\n\n    public Switch(LightBulb bulb) {\n        this.lightBulb = bulb;\n    }\n\n    public void operate() {\n        lightBulb.turnOn();\n    }\n}\n\n// 正确做法：依赖于抽象\ninterface Switchable {\n    void turnOn();\n}\n\nclass LightBulb implements Switchable {\n    @Override\n    public void turnOn() { /* 打开电灯 */ }\n}\n\nclass Switch {\n    private Switchable device;\n\n    public Switch(Switchable device) {\n        this.device = device;\n    }\n\n    public void operate() {\n        device.turnOn();\n    }\n}\n```\n### 5.6.总结\n\nSOLID 原则是面向对象设计中非常重要的指导方针，遵循这些原则可以帮助开发者构建出结构良好、易于理解和维护的软件系统。虽然严格遵守 SOLID 可能会增加一些前期设计的工作量，但从长远来看，它有助于减少技术债务并提高软件的质量。\n'},{title:"面向对象的三大基本特征",headers:[{level:2,title:"1.Java 的封装 (Encapsulation)",slug:"_1-java-的封装-encapsulation",link:"#_1-java-的封装-encapsulation",children:[{level:3,title:"1.1.定义",slug:"_1-1-定义",link:"#_1-1-定义",children:[]},{level:3,title:"1.2.目标",slug:"_1-2-目标",link:"#_1-2-目标",children:[]},{level:3,title:"1.3.实现方式",slug:"_1-3-实现方式",link:"#_1-3-实现方式",children:[]},{level:3,title:"1.4.示例代码",slug:"_1-4-示例代码",link:"#_1-4-示例代码",children:[]},{level:3,title:"1.5.总结",slug:"_1-5-总结",link:"#_1-5-总结",children:[]}]},{level:2,title:"2.继承 (Inheritance)",slug:"_2-继承-inheritance",link:"#_2-继承-inheritance",children:[{level:3,title:"2.1.示例",slug:"_2-1-示例",link:"#_2-1-示例",children:[]},{level:3,title:"2.2.方法重写 (Method Overriding)详细说明",slug:"_2-2-方法重写-method-overriding-详细说明",link:"#_2-2-方法重写-method-overriding-详细说明",children:[]}]},{level:2,title:"3.多态 (Polymorphism)",slug:"_3-多态-polymorphism",link:"#_3-多态-polymorphism",children:[{level:3,title:"3.1.示例",slug:"_3-1-示例",link:"#_3-1-示例",children:[]},{level:3,title:"3.2.方法重载 (Method Overloading)细节说明",slug:"_3-2-方法重载-method-overloading-细节说明",link:"#_3-2-方法重载-method-overloading-细节说明",children:[]}]},{level:2,title:"4.构造函数 (Constructor)",slug:"_4-构造函数-constructor",link:"#_4-构造函数-constructor",children:[{level:3,title:"4.1.示例",slug:"_4-1-示例",link:"#_4-1-示例",children:[]},{level:3,title:"4.2.默认构造函数 (Default Constructor)",slug:"_4-2-默认构造函数-default-constructor",link:"#_4-2-默认构造函数-default-constructor",children:[]}]},{level:2,title:"5.类变量 (Class Variables) 和 成员变量 (Instance Variables)",slug:"_5-类变量-class-variables-和-成员变量-instance-variables",link:"#_5-类变量-class-variables-和-成员变量-instance-variables",children:[{level:3,title:"5.1示例",slug:"_5-1示例",link:"#_5-1示例",children:[]}]},{level:2,title:"6.局部变量 (Local Variables)",slug:"_6-局部变量-local-variables",link:"#_6-局部变量-local-variables",children:[{level:3,title:"6.1.示例",slug:"_6-1-示例",link:"#_6-1-示例",children:[]}]},{level:2,title:"7.成员变量和方法的作用域 (Scope of Instance Variables and Methods)",slug:"_7-成员变量和方法的作用域-scope-of-instance-variables-and-methods",link:"#_7-成员变量和方法的作用域-scope-of-instance-variables-and-methods",children:[{level:3,title:"7.1示例",slug:"_7-1示例",link:"#_7-1示例",children:[]}]},{level:2,title:"8.平台无关性 (Platform Independence)",slug:"_8-平台无关性-platform-independence",link:"#_8-平台无关性-platform-independence",children:[]},{level:2,title:"9.值传递 (Pass by Value)",slug:"_9-值传递-pass-by-value",link:"#_9-值传递-pass-by-value",children:[{level:3,title:"9.1.示例",slug:"_9-1-示例",link:"#_9-1-示例",children:[]}]}],path:"/posts/java/basic/2.three-features.html",pathLocale:"/",extraFields:'---\ntitle: 面向对象的三大基本特征\nicon: pen-to-square\ncover: https://webstatic.mihoyo.com/upload/contentweb/2023/02/06/df329c62acad08953832134777166e57_5667154156652123154.png\ndate: 2024-12-24\nlastUpdated: true\norder: -1\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 封装、继承、多态介绍\n\n\x3c!-- more --\x3e\n\n## 1.Java 的封装 (Encapsulation)\n\n### 1.1.定义\n\n**封装（Encapsulation）** 是面向对象编程的四大基本概念之一，它指的是将数据（属性）和操作数据的方法捆绑在一起，并隐藏对象内部的工作细节。通过封装，可以保护对象的状态不被外部直接访问，同时提供公共接口来进行交互。\n\n### 1.2.目标\n\n- **信息隐藏**: 限制对类成员的访问，以防止外部代码随意修改对象状态。\n- **提高安全性**: 减少了外部代码对类内部状态的直接访问，增强了数据的安全性。\n- **增强模块化**: 封装使得每个类都成为独立的模块，易于维护和扩展。\n\n### 1.3.实现方式\n\n在 Java 中，封装主要通过以下几种方式实现：\n\n1. **访问修饰符**\n  - **private**: 最严格的访问级别，只能在定义它的类中访问。\n  - **protected**: 可以在同一个包中的所有类以及不同包中的子类中访问。\n  - **default**（无修饰符）: 只能在同一个包内的类中访问。\n  - **public**: 最宽松的访问级别，可以在任何地方访问。\n\n2. **getter 和 setter 方法**\n  - 提供受控访问：即使属性是私有的，也可以通过公共方法来获取或设置它们的值。\n  - **Getter 方法**: 用于读取私有属性的值。\n  - **Setter 方法**: 用于设置私有属性的值，通常会包含验证逻辑以确保数据的有效性。\n\n3. **构造函数**\n  - 初始化对象时设置初始状态，确保对象创建时具有有效的值。\n\n### 1.4.示例代码\n\n```java\npublic class Person {\n    // 私有属性，外界无法直接访问\n    private String name;\n    private int age;\n\n    // 默认构造函数\n    public Person() {}\n\n    // 带参数的构造函数\n    public Person(String name, int age) {\n        this.name = name;\n        setAge(age); // 使用setter进行验证\n    }\n\n    // Getter 方法\n    public String getName() {\n        return name;\n    }\n\n    // Setter 方法，包含验证逻辑\n    public void setName(String name) {\n        if (name != null && !name.isEmpty()) {\n            this.name = name;\n        } else {\n            System.out.println("Name cannot be empty.");\n        }\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println("Invalid age value.");\n        }\n    }\n}\n```\n\n### 1.5.总结\n\n通过使用访问修饰符、构造函数和 getter/setter 方法，Java 的封装特性允许开发者控制对类成员的访问，从而保护对象的状态并提供安全的数据访问途径。这不仅提高了代码的安全性和可维护性，还促进了更好的模块化设计。\n\n\n\n## 2.继承 (Inheritance)\n\n继承是面向对象编程（OOP）中的一种机制，它允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。这促进了代码的重用，并有助于建立类之间的层次结构。\n\n- **关键字**: `extends`\n- **特点**:\n  - 子类继承了父类的所有非私有成员（字段、方法）。\n  - 构造器不被继承，但可以通过 `super()` 调用父类构造器。\n  - 子类可以覆盖父类的方法（通过方法重写实现）。\n  - 子类可以添加新的字段和方法。\n\n### 2.1.示例\n\n```java\nclass Animal {\n    void eat() {\n        System.out.println("This animal eats.");\n    }\n}\n\nclass Dog extends Animal {\n    // 方法重写\n    @Override\n    void eat() {\n        System.out.println("The dog eats dog food.");\n    }\n\n    // 新增方法\n    void bark() {\n        System.out.println("Woof!");\n    }\n}\n```\n\n### 2.2.方法重写 (Method Overriding)详细说明\n\n**方法重写**是指子类可以重新定义父类中的方法。被重写的方法签名（包括名称、参数列表）必须完全一致，而返回类型、抛出异常列表等可以在一定条件下有所不同。重写方法的实际执行版本是在运行时根据对象的实际类型决定的，这是动态多态性的体现。\n\n- **特点**:\n  - 必须出现在继承关系中（即发生在父类与子类之间）。\n  - 方法签名必须相同（包括方法名和参数列表）。\n  - 子类的方法不能比父类的方法更严格的访问权限（如父类是`public`，子类不能是`private`或`protected`）。\n  - 子类的方法可以有不同的返回类型，但只能是父类返回类型的子类型（协变返回类型）。\n  - 使用 `@Override` 注解来表明这是一个重写的方法，有助于编译器检查是否正确实现了重写。\n\n#### 2.2.1.示例\n\n```java\nclass Animal {\n    void sound() {\n        System.out.println("Some generic animal sound.");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println("Woof!");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    void sound() {\n        System.out.println("Meow!");\n    }\n}\n\npublic class OverridingExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n\n        myDog.sound(); // 输出: Woof!\n        myCat.sound(); // 输出: Meow!\n    }\n}\n```\n\n\n## 3.多态 (Polymorphism)\n\n多态是指相同的操作作用于不同的对象时，可以有不同的解释，产生不同的执行结果。在Java中，多态主要体现在两个方面：\n\n1. **编译时多态（静态多态/方法重载）**：\n   - 同一个类中有多个同名但参数列表不同的方法。\n   - 方法的选择是在编译期决定的。\n\n2. **运行时多态（动态多态/方法重写）**：\n   - 父类引用指向子类对象，并调用子类重写的方法。\n   - 方法的实际执行版本是在运行时根据对象的实际类型决定的。\n\n### 3.1.示例\n\n```java\n// 假设我们有上述定义的Animal和Dog类\npublic class PolymorphismExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog(); // 父类引用指向子类对象\n        myDog.eat(); // 输出: The dog eats dog food.\n        \n        // 下面这行代码会报错，因为myDog是Animal类型的引用，\n        // 它不知道Dog特有的bark()方法\n        // myDog.bark();\n    }\n}\n\n\n```\n\n### 3.2.方法重载 (Method Overloading)细节说明\n\n**方法重载**是指在一个类中可以有多个同名的方法，但这些方法必须具有不同的参数列表（即参数的数量、类型或顺序不同）。编译器根据调用时提供的参数自动选择合适的方法版本。这被称为静态多态性，因为方法的选择是在编译期确定的。\n\n- **特点**:\n  - 只能在同一个类中进行。\n  - 参数列表必须不同（包括参数的数量、类型或顺序）。\n  - 返回类型可以相同也可以不同，但不能仅靠返回类型区分重载方法。\n  - 访问修饰符可以不同。\n\n#### 3.2.1示例\n\n```java\nclass Calculator {\n    // 加法：两个整数相加\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    // 加法：三个整数相加\n    int add(int a, int b, int c) {\n        return a + b + c;\n    }\n\n    // 加法：两个浮点数相加\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n\npublic class OverloadingExample {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        System.out.println(calc.add(1, 2));       // 输出: 3\n        System.out.println(calc.add(1, 2, 3));    // 输出: 6\n        System.out.println(calc.add(1.5, 2.5));   // 输出: 4.0\n    }\n}\n```\n\n\n## 4.构造函数 (Constructor)\n\n构造函数是一种特殊的方法，用于初始化新创建的对象。每个类都可以有一个或多个构造函数，它们的名字必须与类名相同，并且没有返回类型（包括`void`）。如果一个类没有显式定义任何构造函数，Java 编译器会自动提供一个无参的默认构造函数。\n\n- **特点**:\n  - 名称必须与类名相同。\n  - 没有返回类型。\n  - 可以重载（即可以有多个不同参数列表的构造函数）。\n  - 构造函数主要用于对象初始化，比如设置初始值等。\n\n### 4.1.示例\n\n```java\nclass Person {\n    String name;\n    int age;\n\n    // 默认构造函数\n    public Person() {\n        this.name = "Unknown";\n        this.age = 0;\n    }\n\n    // 带参数的构造函数\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n### 4.2.默认构造函数 (Default Constructor)\n\n如果一个类中没有任何构造函数，则编译器会自动生成一个无参数的默认构造函数。这个默认构造函数不会执行任何操作，只是简单地调用父类的无参数构造函数（如果有的话）。一旦你在类中定义了至少一个构造函数，编译器将不再生成默认构造函数。\n\n## 5.类变量 (Class Variables) 和 成员变量 (Instance Variables)\n\n- **类变量**: 被 `static` 关键字修饰的变量，属于整个类而不是单个对象。所有该类的实例共享同一个类变量。\n- **成员变量**: 未被 `static` 修饰的变量，属于每个对象的私有数据。每个实例都有自己的一份副本。\n\n### 5.1示例\n\n```java\nclass Counter {\n    static int count = 0; // 类变量\n    int instanceCount = 0; // 成员变量\n\n    Counter() {\n        count++;\n        instanceCount++;\n    }\n}\n```\n\n## 6.局部变量 (Local Variables)\n\n局部变量是在方法、构造函数或块内部声明的变量。它们的作用域仅限于声明它们的代码块内，在离开该代码块后就会被销毁。局部变量不能使用访问修饰符（如 `public`, `private`, `protected`），但可以使用其他修饰符如 `final`。\n\n### 6.1.示例\n\n```java\npublic class Example {\n    void methodWithLocalVariable() {\n        int localVariable = 10; // 局部变量\n        System.out.println(localVariable);\n    }\n}\n```\n\n## 7.成员变量和方法的作用域 (Scope of Instance Variables and Methods)\n\n- **成员变量** 的作用域是整个类，可以在类中的任何地方访问，除非它们被更细粒度的作用域限制（例如在静态上下文中尝试访问非静态成员变量会导致编译错误）。\n- **方法** 的作用域也是整个类，可以从类内的任何地方调用，除非它们是私有的（`private`），那么只能在声明它们的类内部访问。\n\n### 7.1示例\n\n```java\nclass ScopeExample {\n    private String memberVariable = "I\'m a member variable"; // 私有成员变量\n\n    public void printMemberVariable() {\n        System.out.println(memberVariable); // 在类的方法中访问成员变量\n    }\n\n    public void anotherMethod() {\n        printMemberVariable(); // 在另一个方法中调用公共方法\n    }\n}\n```\n\n\n\n\n## 8.平台无关性 (Platform Independence)\n\nJava 语言的一个显著特点是它的 **平台无关性**，这使得 Java 程序可以在不同的操作系统上运行而无需重新编译。这种特性主要得益于 Java 虚拟机（JVM）和字节码（Bytecode）的概念。\n\n- **Java 源代码**：开发者编写的是 `.java` 文件。\n- **编译过程**：Java 编译器将源代码编译成与平台无关的中间代码，即字节码（`.class` 文件）。这个过程生成的字节码不是针对任何特定硬件架构的机器指令，而是专为 JVM 设计的一种抽象指令集。\n- **解释执行**：当程序运行时，JVM 将字节码转换为具体操作系统的本地机器指令，并在该平台上执行。每个操作系统都有自己的 JVM 实现，负责处理这一转换。\n\n由于 JVM 可以在多种平台上实现，因此只要安装了相应的 JVM，相同的 Java 字节码就可以在 Windows、Linux、macOS 等不同系统上无缝运行，这就是所谓的“一次编写，到处运行”（Write Once, Run Anywhere）。\n\n## 9.值传递 (Pass by Value)\n\nJava 中的所有参数传递都是 **按值传递**（pass by value），这意味着当你传递一个变量给方法时，实际上是在传递该变量值的一份副本。对于基本数据类型（如 `int`, `float`, `char` 等），传递的就是实际值；而对于引用类型（如对象、数组等），传递的是对象引用的副本。这意味着即使你改变了传入的方法中的参数值，也不会影响到原始变量，因为它们是独立的副本。\n\n然而，对于引用类型的参数，虽然传递的是引用的副本，但副本仍然指向堆内存中同一个对象，所以如果修改了对象的状态（例如改变对象的属性），这些更改会反映在原始对象上，因为两者指向的是同一个实例。\n\n### 9.1.示例\n\n```java\npublic class PassByValueExample {\n\n    // 对于基本数据类型，传递的是值的副本\n    public static void changePrimitive(int x) {\n        x = 100;\n    }\n\n    // 对于引用类型，传递的是引用的副本，但是引用指向的对象是相同的\n    public static void changeObject(Builder builder) {\n        builder.setName("Changed Name");\n    }\n\n    public static void main(String[] args) {\n        int num = 5;\n        changePrimitive(num);\n        System.out.println(num); // 输出: 5，因为传递的是值的副本\n\n        Builder myBuilder = new Builder("Original Name");\n        changeObject(myBuilder);\n        System.out.println(myBuilder.getName()); // 输出: Changed Name，因为修改了对象的状态\n    }\n}\n\nclass Builder {\n    private String name;\n\n    public Builder(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n'},{title:"java 基础知识",headers:[{level:2,title:"1. Java基本数据类型",slug:"_1-java基本数据类型",link:"#_1-java基本数据类型",children:[{level:3,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:3,title:"1.2 详细分类",slug:"_1-2-详细分类",link:"#_1-2-详细分类",children:[]},{level:3,title:"1.3 自动拆装箱",slug:"_1-3-自动拆装箱",link:"#_1-3-自动拆装箱",children:[]},{level:3,title:"1.4 浮点数与金额问题",slug:"_1-4-浮点数与金额问题",link:"#_1-4-浮点数与金额问题",children:[]}]},{level:2,title:"2. String类型",slug:"_2-string类型",link:"#_2-string类型",children:[{level:3,title:"2.1.不可变性的实现",slug:"_2-1-不可变性的实现",link:"#_2-1-不可变性的实现",children:[]},{level:3,title:"2.2.不可变性的优点",slug:"_2-2-不可变性的优点",link:"#_2-2-不可变性的优点",children:[]},{level:3,title:"2.3.示例代码",slug:"_2-3-示例代码",link:"#_2-3-示例代码",children:[]},{level:3,title:"2.4. 常用方法",slug:"_2-4-常用方法",link:"#_2-4-常用方法",children:[]},{level:3,title:"2.5. 使用选择",slug:"_2-5-使用选择",link:"#_2-5-使用选择",children:[]},{level:3,title:"2.6. 字符串池、常量池概念",slug:"_2-6-字符串池、常量池概念",link:"#_2-6-字符串池、常量池概念",children:[]},{level:3,title:"2.7. intern方法",slug:"_2-7-intern方法",link:"#_2-7-intern方法",children:[]},{level:3,title:"2.8. String长度限制",slug:"_2-8-string长度限制",link:"#_2-8-string长度限制",children:[]}]},{level:2,title:"3. Java关键字",slug:"_3-java关键字",link:"#_3-java关键字",children:[{level:3,title:"3.1. 访问控制",slug:"_3-1-访问控制",link:"#_3-1-访问控制",children:[]},{level:3,title:"3.2. 类、接口、抽象相关",slug:"_3-2-类、接口、抽象相关",link:"#_3-2-类、接口、抽象相关",children:[]},{level:3,title:"3.3. 修饰符",slug:"_3-3-修饰符",link:"#_3-3-修饰符",children:[]},{level:3,title:"3.4. 流程控制",slug:"_3-4-流程控制",link:"#_3-4-流程控制",children:[]},{level:3,title:"3.5. 异常处理",slug:"_3-5-异常处理",link:"#_3-5-异常处理",children:[]},{level:3,title:"3.6. 其他",slug:"_3-6-其他",link:"#_3-6-其他",children:[]}]}],path:"/posts/java/basic/3.java-basic.html",pathLocale:"/",extraFields:'---\ntitle: java 基础知识\nicon: pen-to-square\ncover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png\ndate: 2024-12-27\nlastUpdated: true\n# order: 3\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 基本类型、String、关键字等内容介绍\n\n\x3c!-- more --\x3e\n\n## 1. Java基本数据类型\n### 1.1 概述\nJava基本数据类型是构建程序数据存储和运算的基石，分为四类八种，不同类型具有特定的取值范围、存储字节数，以适应多样的编程需求。\n\n### 1.2 详细分类\n| 数据类型 | 字节数 | 取值范围 | 示例 | 用途场景 |\n| ---- | ---- | ---- | ---- | ---- |\n| `byte` | 1 | -128 ～ 127 | `byte num = 10;` | 底层数据存储、网络传输字节流处理，节省内存 |\n| `short` | 2 | -32768 ～ 32767 | `short age = 30;` | 特定数值范围运算，对内存有一定要求的简单场景 |\n| `int` | 4 | -2147483648 ～ 2147483647 | `int count = 100;` | 常规整数运算，如循环控制、数组下标 |\n| `long` | 8 | -9223372036854775808 ～ 9223372036854775807 | `long timestamp = 1609459200000L;` | 处理大整数，如时间戳、大数据统计计数 |\n| `float` | 4 | 约 ±3.4×10³⁸ （有效数字约 7 位） | `float pi = 3.14F;` | 科学计算近似值，需注意精度问题，定义加 `F` |\n| `double` | 8 | 约 ±1.79×10³⁰⁸ （有效数字约 15 位） | `double salary = 5000.50;` | 默认浮点型，高精度科学、工程计算 |\n| `char` | 2 | 0 ～ 65535（Unicode 编码值） | `char ch = \'A\';` | 存储单个字符，文本处理 |\n| `boolean` | 1（实际因 JVM 而异） | `true`、`false` | `boolean flag = true;` | 条件判断、逻辑控制 |\n\n### 1.3 自动拆装箱\n自动装箱：基本类型自动转为包装类，如 `Integer numObj = 10;` ，编译器将 `int` 10 包装成 `Integer`。\n自动拆箱：包装类自动转为基本类型，如 `Integer numObj = new Integer(20); int num = numObj;`。\n注意：频繁拆装箱有性能开销，如在循环内大量操作包装类集合。\n\n### 1.4 浮点数与金额问题\n浮点数由于二进制存储表示，存在精度丢失问题，绝不能直接用于精确金额计算。\n```java\ndouble amount1 = 0.1;\ndouble amount2 = 0.2;\ndouble sum = amount1 + amount2; \n// 此时 sum 可能不是精确的 0.3，而接近 0.30000000000000004\n```\n金融领域通常使用 `BigDecimal` 类确保金额精准。\n\n## 2. String类型\nJava 中 `String` 类的不可变性（Immutability）意味着一旦创建了 `String` 对象，它的值就不能被改变。这种设计有多个方面的原因和好处：\n\n### 2.1.不可变性的实现\n\n- **私有化构造函数**：`String` 类的构造函数是私有的，这意味着不能直接通过构造函数来修改内部的字符数组。\n- **final 关键字**：`String` 类本身以及它用来存储字符序列的字段（通常是 `char[] value` 或者在较新的 Java 版本中为了节省空间而采用的 `byte[] value` 和编码标志）都被声明为 `final`，这表示它们不能被继承或重新赋值。\n- **返回新对象**：所有可能改变字符串内容的方法实际上并不改变原始字符串，而是创建并返回一个新的 `String` 对象。\n\n### 2.2.不可变性的优点\n\n- **线程安全**：由于字符串不能被修改，因此可以在多线程环境中共享同一个字符串实例，无需担心同步问题。\n- **缓存散列码**：因为字符串不会改变，所以它的哈希码可以被计算一次然后缓存起来，提高性能。\n- **安全性**：不可变对象作为参数传递时，接收方无法更改其状态，这有助于防止意外或者恶意的状态改变。\n- **字符串驻留机制**：Java 使用字符串驻留（String Interning）来保存唯一的字符串副本，从而节省内存。如果字符串是可变的，那么这将导致驻留池中的数据不稳定。\n\n### 2.3.示例代码\n\n```java\nString s1 = "Hello";\nString s2 = s1.concat(" World"); // 这不会改变s1，而是返回一个新的String对象给s2\nSystem.out.println(s1); // 输出: Hello\nSystem.out.println(s2); // 输出: Hello World\n```\n\n在这个例子中，`s1.concat(" World")` 并没有改变 `s1` 的值；相反，它创建了一个新的 `String` 对象，并将其引用赋给了 `s2`。\n\n总之，`String` 的不可变性是 Java 设计的一个重要特性，它不仅保证了语言的安全性和可靠性，还提供了性能上的优化。\n\n### 2.4. 常用方法\n| 方法名 | 描述 | 示例 |\n| ---- | ---- | ---- |\n| `length()` | 返回字符串长度 | `String str = "Hello"; int len = str.length();` |\n| `charAt(int index)` | 获取指定索引字符 | `char ch = str.charAt(2); // 取 \'l\'` |\n| `substring(int start, int end)` | 截取子串（含 start，不含 end） | `String sub = str.substring(1, 4); // "ell"` |\n| `indexOf(String str)` | 查找子串首次出现位置 | `int pos = str.indexOf("ll"); // 2` |\n| `lastIndexOf(String str)` | 查找子串最后出现位置 | `int lastPos = str.lastIndexOf("l"); // 3` |\n| `contains(String str)` | 判断是否包含子串 | `boolean has = str.contains("lo"); // true` |\n| `equals(String other)` | 比较字符串内容是否相等 | `boolean eq = str.equals("Hello"); // true` |\n| `equalsIgnoreCase(String other)` | 忽略大小写比较 | `boolean ieq = str.equalsIgnoreCase("hello"); // true` |\n| `trim()` | 去除首尾空白字符 | `String trimStr = "  Hello  ".trim(); // "Hello"` |\n| `replace(char oldChar, char newChar)` | 替换字符 | `String replaced = str.replace(\'l\', \'x\'); // "Hexxo"` |\n| `split(String regex)` | 按正则表达式分割字符串 | `String[] parts = "a,b,c".split(","); // ["a", "b", "c"]` |\n\n### 2.5. 使用选择\n - 用 `""` 创建空字符串，比 `new String()` 高效，后者创建新对象。\n - 连接字符串优先用 `StringBuilder` 或 `StringBuffer`（多线程）：\n```java\nStringBuilder sb = new StringBuilder();\nsb.append("Hello");\nsb.append(" Java");\nString result = sb.toString(); \n```\n - 比较字符串用 `equals`，避免 `==`，`==` 比较引用地址，`equals` 比较内容。\n\n### 2.6. 字符串池、常量池概念\n - **字符串池**：存于堆内存，存放字面量字符串。相同字面量只存一份，如 `String s1 = "Hello"; String s2 = "Hello"; s1 == s2; // true`，指向同一对象。\n - **Class常量池**：在方法区，存编译生成常量，如字符串、基本类型常量，为类加载运行供基础数据。\n - **运行时常量池**：方法区动态扩展，含 Class 常量解析及动态生成常量，如 `String.intern()` 处理后的字符串。\n\n### 2.7. intern方法\n`intern()` 将字符串入池，若池无相同串，加入并返回池内引用，有则返回池内已有引用。\n```java\nString s1 = new String("world").intern();\nString s2 = "world";\nSystem.out.println(s1 == s2); // true\n```\n\n### 2.8. String长度限制\n - 编译期：常量字符串受编译器限制，通常几千字节。\n - 运行时：受堆内存、JVM 实现制约，创建超长串要谨慎，防 `OutOfMemoryError`。\n\n## 3. Java关键字\n### 3.1. 访问控制\n| 关键字 | 访问权限 | 示例 |\n| ---- | ---- | ---- |\n| `public` | 所有类可见 | `public class MyClass {}` |\n| `private` | 仅所属类可见 | `private int secret;` |\n| `protected` | 同包类及子类可见 | `protected void method() {}` |\n| （默认，无关键字） | 同包类可见 | `class DefaultClass {}` |\n\n### 3.2. 类、接口、抽象相关\n - `class`：定义类，如 `class Dog {}`，类是对象蓝图，含属性、方法。\n - `interface`：定义接口，如 `interface Shape {}`，含方法签名、常量，无实现，供多类遵循实现多态。\n - `abstract`：修饰抽象类或方法，抽象类可含抽象方法，子类必须实现，引导继承拓展，如：\n```java\nabstract class Vehicle {\n    abstract void move();\n}\n```\n\n### 3.3. 修饰符\n - `final`：修饰类不可继承，方法不可重写，变量成常量，如：\n```java\nfinal class FinalClass {}\nclass AnotherClass {\n    final void finalMethod() {}\n    final int CONSTANT = 10;\n}\n```\n - `static`：修饰成员归类所有，可直接用类名访问，静态方法不能访问非静态成员，如：\n```java\nclass Utility {\n    static int count;\n    static void increment() { count++; }\n}\n```\n - `synchronized`：用于多线程，修饰方法或块，保证同一时刻单线程访问共享资源，如：\n```java\nclass SharedResource {\n    synchronized void access() {}\n}\n```\n\n### 3.4. 流程控制\n - `if`、`else`：基本条件分支，如 `if (condition) {} else {}`。\n - `switch`、`case`、`default`：多分支，如：\n```java\nswitch (var) {\n    case 1: break;\n    case 2: break;\n    default: break;\n}\n```\n - `while`、`do - while`：循环，前者先判断后循环，后者先循环后判断，如：\n```java\nwhile (condition) {}\ndo {} while (condition);\n```\n - `for`：万能循环，如 `for (init; condition; update) {}`，常用于遍历数组、集合。\n\n### 3.5. 异常处理\n - `try`、`catch`、`finally`：异常处理铁三角，如：\n```java\ntry {\n    // 可能抛异常代码\n} catch (Exception e) {\n    // 处理异常\n} finally {\n    // 必执行，清理资源\n}\n```\n - `throw`：手动抛异常，如 `throw new RuntimeException("Error");`。\n - `throws`：在方法声明，示警调用者方法可能抛异常，如 `public void riskyMethod() throws IOException {}`。\n\n### 3.6. 其他\n - `this`：类内指代当前对象，区分同名变量，调用构造函数，如：\n```java\nclass Person {\n    private int age;\n    public Person(int age) {\n        this.age = age;\n    }\n}\n```\n - `super`：子类中访问父类成员、调用父类构造，如：\n```java\nclass Child extends Parent {\n    public Child() {\n        super();\n    }\n    void parentMethod() {\n        super.method();\n    }\n}\n```\n - `new`：创建对象，如 `Object obj = new Object();`。\n - `null`：空引用，易引发空指针，操作需谨慎。\n\n\n'},{title:"java 集合",headers:[{level:2,title:"1. 集合框架概述",slug:"_1-集合框架概述",link:"#_1-集合框架概述",children:[]},{level:2,title:"2. Collection 接口",slug:"_2-collection-接口",link:"#_2-collection-接口",children:[{level:3,title:"2.1. 特点",slug:"_2-1-特点",link:"#_2-1-特点",children:[]},{level:3,title:"2.2. 常用方法",slug:"_2-2-常用方法",link:"#_2-2-常用方法",children:[]}]},{level:2,title:"3. List 接口及实现类",slug:"_3-list-接口及实现类",link:"#_3-list-接口及实现类",children:[{level:3,title:"3.1. 特点",slug:"_3-1-特点",link:"#_3-1-特点",children:[]},{level:3,title:"3.2. 常用实现类",slug:"_3-2-常用实现类",link:"#_3-2-常用实现类",children:[]}]},{level:2,title:"4. Set 接口及实现类",slug:"_4-set-接口及实现类",link:"#_4-set-接口及实现类",children:[{level:3,title:"4.1. 特点",slug:"_4-1-特点",link:"#_4-1-特点",children:[]},{level:3,title:"4.2. 常用实现类",slug:"_4-2-常用实现类",link:"#_4-2-常用实现类",children:[]}]},{level:2,title:"5. Map 接口及实现类",slug:"_5-map-接口及实现类",link:"#_5-map-接口及实现类",children:[{level:3,title:"5.1. 特点",slug:"_5-1-特点",link:"#_5-1-特点",children:[]},{level:3,title:"5.2. 常用实现类",slug:"_5-2-常用实现类",link:"#_5-2-常用实现类",children:[]}]},{level:2,title:"6. 迭代器（Iterator）",slug:"_6-迭代器-iterator",link:"#_6-迭代器-iterator",children:[]},{level:2,title:"7. 面试题",slug:"_7-面试题",link:"#_7-面试题",children:[{level:3,title:"7.1. ArrayList 和 LinkedList 的区别？",slug:"_7-1-arraylist-和-linkedlist-的区别",link:"#_7-1-arraylist-和-linkedlist-的区别",children:[]},{level:3,title:"7.2. HashSet 如何保证元素唯一性？",slug:"_7-2-hashset-如何保证元素唯一性",link:"#_7-2-hashset-如何保证元素唯一性",children:[]},{level:3,title:"7.3. HashMap 的底层原理是什么？",slug:"_7-3-hashmap-的底层原理是什么",link:"#_7-3-hashmap-的底层原理是什么",children:[]},{level:3,title:"7.4. 如何实现一个自定义类作为 HashMap 的键？",slug:"_7-4-如何实现一个自定义类作为-hashmap-的键",link:"#_7-4-如何实现一个自定义类作为-hashmap-的键",children:[]}]}],path:"/posts/java/basic/4.collection.html",pathLocale:"/",extraFields:'---\ntitle: java 集合\nicon: pen-to-square\ncover: https://uploadstatic.mihoyo.com/contentweb/20200312/2020031219451784892.png\ndate: 2024-12-27\nlastUpdated: true\n# order: 3\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 集合相关内容\n\n\n\n\x3c!-- more --\x3e\n## 1. 集合框架概述\nJava 集合框架提供了一套性能优良、使用方便的接口和类，用于存储和操作对象组。它位于 `java.util` 包下，集合框架主要解决了以下问题：\n- 提供了对对象的存储、检索、修改等通用操作，避免了开发者重复造轮子。\n- 不同类型的集合适用于不同场景，方便开发者根据需求选择最合适的数据结构，提高程序性能。\n\n集合框架主要接口有 `Collection`、`List`、`Set`、`Map`，其中 `Collection` 是集合层次结构中的根接口，`List` 和 `Set` 继承自它，`Map` 是独立的接口用于存储键值对。\n\n## 2. Collection 接口\n### 2.1. 特点\n`Collection` 是最基本的集合接口，它定义了一些通用的集合操作方法，如添加元素、删除元素、判断元素是否存在、遍历集合等。它不包含关于元素存储顺序或是否包含重复元素的假设，这些特性由具体的子接口和实现类来定义。\n\n### 2.2. 常用方法\n```java\nboolean add(E e); // 向集合中添加元素，成功返回 true，若集合不允许添加重复元素且已存在相同元素则返回 false\nboolean remove(Object o); // 从集合中移除指定元素，若元素存在并移除成功返回 true，否则返回 false\nboolean contains(Object o); // 判断集合是否包含指定元素，包含返回 true，否则返回 false\nint size(); // 返回集合中元素的个数\nboolean isEmpty(); // 判断集合是否为空，为空返回 true，否则返回 false\nIterator<E> iterator(); // 返回一个迭代器，用于遍历集合中的元素\n```\n\n## 3. List 接口及实现类\n### 3.1. 特点\n`List` 是有序的集合，元素可以重复。用户可以通过索引（位置）来访问、插入、删除和替换列表中的元素，索引从 0 开始。\n\n### 3.2. 常用实现类\n- **ArrayList**：\n    - 底层基于数组实现，查询效率高，时间复杂度为 O(1)，因为可以通过数组下标直接定位元素。\n    - 插入和删除操作相对较慢，平均时间复杂度为 O(n)，因为需要移动数组元素。\n    - 动态扩容机制：当数组容量不足时，会自动创建一个更大的新数组，并将原数组元素复制过去。初始容量默认为 10，扩容因子为 1.5 倍。\n```java\nArrayList<String> arrayList = new ArrayList<>();\narrayList.add("apple");\narrayList.add("banana");\nString element = arrayList.get(0); // 获取索引为 0 的元素，即 "apple"\n```\n- **LinkedList**：\n    - 底层基于双向链表实现，插入和删除操作效率高，时间复杂度为 O(1)，只需修改节点间的引用关系。\n    - 查询效率低，时间复杂度为 O(n)，因为需要遍历链表查找元素。\n    - 提供了一些操作链表头部和尾部的便捷方法，如 `addFirst`、`addLast`、`removeFirst`、`removeLast` 等。\n```java\nLinkedList<Integer> linkedList = new LinkedList<>();\nlinkedList.add(1);\nlinkedList.add(2);\nlinkedList.addFirst(0); // 在链表头部添加元素 0\n```\n\n## 4. Set 接口及实现类\n### 4.1. 特点\n`Set` 是不包含重复元素的集合，它的实现类通常基于某种数据结构保证元素的唯一性。元素无序（部分实现类有特殊排序规则，如 `TreeSet`）。\n\n### 4.2. 常用实现类\n- **HashSet**：\n    - 基于哈希表实现，通过 `hashCode` 和 `equals` 方法来确定元素的唯一性。添加、删除、查询操作的平均时间复杂度接近 O(1)。\n    - 不保证元素的顺序，迭代时元素的顺序可能与添加顺序不同。\n```java\nHashSet<Character> hashSet = new HashSet<>();\nhashSet.add(\'a\');\nhashSet.add(\'b\');\nhashSet.add(\'a\'); // 重复元素，不会被添加\n```\n- **TreeSet**：\n    - 基于红黑树实现，元素默认按照自然顺序（实现 `Comparable` 接口定义的顺序）或自定义比较器 `Comparator` 进行排序。\n    - 插入、删除、查询操作的时间复杂度为 O(log n)，性能相对稳定。适用于需要对元素排序的场景。\n```java\nTreeSet<Integer> treeSet = new TreeSet<>();\ntreeSet.add(3);\ntreeSet.add(1);\ntreeSet.add(2); \n// 元素按升序排列，遍历结果为 1, 2, 3\n```\n\n## 5. Map 接口及实现类\n### 5.1. 特点\n`Map` 用于存储键值对（key-value）形式的数据，键具有唯一性，一个键对应一个值。通过键可以快速检索、更新和删除对应的值。\n\n### 5.2. 常用实现类\n- **HashMap**：\n    - 基于哈希表实现，提供了快速的插入、删除和查找操作，时间复杂度接近 O(1)。\n    - 允许键和值为 null，键最多只能有一个 null 值，因为键必须唯一。\n    - 当哈希冲突严重时，性能可能会下降，哈希冲突指不同键计算出相同的哈希码。\n```java\nHashMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put("apple", 1);\nhashMap.put("banana", 2);\nInteger value = hashMap.get("apple"); // 获取键 "apple" 对应的值 1\n```\n- **TreeMap**：\n    - 基于红黑树实现，键按照自然顺序或自定义比较器排序，遍历 `TreeMap` 时会按照键的顺序输出。\n    - 插入、删除、查找操作的时间复杂度为 O(log n)，适用于需要按键排序输出的场景。键不能为 null，否则会抛出 `NullPointerException`。\n```java\nTreeMap<String, Double> treeMap = new TreeMap<>();\ntreeMap.put("orange", 3.5);\ntreeMap.put("grape", 2.0);\n// 按键升序遍历，输出顺序与键的排序一致\n```\n\n## 6. 迭代器（Iterator）\n迭代器用于遍历集合中的元素，它提供了一种统一的方式来访问集合元素，而不需要了解集合的内部结构。\n\n```java\nCollection<String> collection = new ArrayList<>();\ncollection.add("one");\ncollection.add("two");\nIterator<String> iterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    String element = iterator.next();\n    System.out.println(element);\n}\n```\n通过 `hasNext` 方法判断是否还有下一个元素，`next` 方法获取下一个元素并将迭代器指针后移一位。注意，在迭代过程中，不能使用集合的修改方法（如 `add`、`remove`），否则可能会抛出 `ConcurrentModificationException`，如需修改，推荐使用迭代器自身的 `remove` 方法。\n\n## 7. 面试题\n### 7.1. ArrayList 和 LinkedList 的区别？\n- 数据结构：ArrayList 基于数组，LinkedList 基于双向链表。\n- 访问效率：ArrayList 查询快（O(1)），LinkedList 查询慢（O(n)）。\n- 插入删除效率：ArrayList 插入删除中间元素慢（O(n)），LinkedList 头部或尾部插入删除快（O(1)）。\n- 内存占用：ArrayList 连续内存空间，LinkedList 节点除数据额外存储前后节点引用，内存占用稍高。\n\n### 7.2. HashSet 如何保证元素唯一性？\nHashSet 通过 `hashCode` 和 `equals` 方法来判断元素是否重复。当向 HashSet 中添加元素时，先计算元素的 `hashCode` 值，根据这个值确定在哈希表中的存储位置，如果该位置没有元素，则直接添加；如果已有元素，再调用 `equals` 方法比较两个元素是否真正相等，若相等则不添加，保证了元素的唯一性。\n\n### 7.3. HashMap 的底层原理是什么？\nHashMap 底层基于哈希表（数组 + 链表/红黑树）实现。初始容量默认为 16，当元素个数超过负载因子（默认为 0.75）与当前容量的乘积时，会进行扩容操作，扩容为原来的 2 倍。\n添加元素时，先计算键的 `hashCode` 值，再经过扰动函数处理得到哈希值，通过哈希值确定在数组中的索引位置，如果该位置为空，直接插入新节点；如果不为空，且键值相等则覆盖旧值，否则以链表形式链接在该位置（当链表长度超过 8 且数组容量大于等于 64 时，链表会转换为红黑树，提高查找效率）。\n\n### 7.4. 如何实现一个自定义类作为 HashMap 的键？\n自定义类作为 HashMap 的键需要重写 `hashCode` 和 `equals` 方法：\n```java\nclass MyKey {\n    private int id;\n    private String name;\n\n    public MyKey(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass()!= o.getClass()) return false;\n        MyKey myKey = (MyKey) o;\n        return id == myKey.id && Objects.equals(name, myKey.name);\n    }\n}\n```\n确保 `hashCode` 返回值能均匀分布，且 `equals` 方法能准确判断两个对象的逻辑相等性，这样 HashMap 才能正确处理自定义键的存储、检索和唯一性判断。\n'},{title:"comparator 基本使用",headers:[{level:2,title:"3.1 实现 Comparator 接口",slug:"_3-1-实现-comparator-接口",link:"#_3-1-实现-comparator-接口",children:[]},{level:2,title:"3.2 匿名内部类",slug:"_3-2-匿名内部类",link:"#_3-2-匿名内部类",children:[]},{level:2,title:"3.3 Lambda 表达式",slug:"_3-3-lambda-表达式",link:"#_3-3-lambda-表达式",children:[]},{level:2,title:"3.4 链接多个 Comparator",slug:"_3-4-链接多个-comparator",link:"#_3-4-链接多个-comparator",children:[]},{level:2,title:"3.5 Comparator 工具方法",slug:"_3-5-comparator-工具方法",link:"#_3-5-comparator-工具方法",children:[]}],path:"/posts/java/basic/comparator.html",pathLocale:"/",extraFields:'---\ntitle: comparator 基本使用\nicon: pen-to-square\ndate: 2024-12-17\nlastUpdated: true\norder: -1 \ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nComparator 的一些基本使用\n\n\x3c!-- more --\x3e\n\n# 1. Java Comparator 使用指南\n\n`Comparator` 是 Java 中用于定义对象比较规则的接口，它允许您根据自定义逻辑对对象进行排序。这对于实现复杂或特定的排序需求非常有用。下面将详细介绍 `Comparator` 的使用方法。\n\n# 2. Comparator 接口概述\n\n`Comparator` 接口包含以下两个主要方法：\n\n- **`int compare(T o1, T o2)`**：比较两个对象 `o1` 和 `o2`。如果 `o1` 小于 `o2` 返回负数；如果 `o1` 等于 `o2` 返回 0；如果 `o1` 大于 `o2` 返回正数。\n- **`boolean equals(Object obj)`**：指示某个其他对象是否等于此 `Comparator`。通常情况下不需要重写此方法，除非有特殊需求。\n\n# 3. 创建和使用 Comparator\n\n## 3.1 实现 Comparator 接口\n\n您可以创建一个实现了 `Comparator` 接口的类，并在其中定义 `compare` 方法来指定排序逻辑。\n\n```java\nimport java.util.Comparator;\n\nclass AgeComparator implements Comparator<Person> {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return Integer.compare(p1.getAge(), p2.getAge());\n    }\n}\n```\n\n## 3.2 匿名内部类\n\n如果您只需要一次性的比较器，可以使用匿名内部类。\n\n```java\nList<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25));\npeople.sort(new Comparator<Person>() {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return p1.getName().compareTo(p2.getName());\n    }\n});\n```\n\n## 3.3 Lambda 表达式\n\n从 Java 8 开始，由于 `Comparator` 是一个函数式接口，因此可以直接使用 Lambda 表达式简化代码。\n\n```java\npeople.sort((p1, p2) -> p1.getName().compareTo(p2.getName()));\n// 或者更简洁的形式\npeople.sort(Comparator.comparing(Person::getName));\n```\n\n## 3.4 链接多个 Comparator\n\n有时候需要根据多个属性进行排序，这时可以链接多个 `Comparator`。\n\n```java\npeople.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName));\n```\n\n## 3.5 Comparator 工具方法\n\nJava 8 引入了多个静态方法，使 `Comparator` 更加易用：\n\n- **`Comparator.comparing(Function<? super T, ? extends U> keyExtractor)`**：基于提供的键提取函数创建比较器。\n- **`Comparator.thenComparing()`**：链接另一个比较器以处理当主比较器结果相等时的情况。\n- **`Comparator.reversed()`**：返回当前比较器的反转版本。\n- **`Comparator.nullsFirst(Comparator<? super T> comparator)` 和 `Comparator.nullsLast(Comparator<? super T> comparator)`**：控制 `null` 值的排序位置。\n\n# 4. 示例代码\n\n假设我们有一个 `Person` 类，想要根据年龄和名字对 `Person` 对象列表进行排序。\n\n```java\nimport java.util.*;\n\nclass Person {\n    private String name;\n    private int age;\n\n    // 构造函数、getter 和 setter 方法省略\n\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n            new Person("Alice", 30),\n            new Person("Bob", 25),\n            new Person("Charlie", 35)\n        );\n\n        // 按年龄升序排序，若年龄相同则按名字排序\n        people.sort(Comparator.comparingInt(Person::getAge).thenComparing(Person::getName));\n\n        // 输出排序后的列表\n        people.forEach(person -> System.out.println(person.getName() + " (" + person.getAge() + ")"));\n    }\n}\n```\n\n# 5. 总结\n\n`Comparator` 接口提供了极大的灵活性，使得我们可以按照自己的业务逻辑对对象进行排序。通过结合 Java 8 引入的新特性如 Lambda 表达式和流 API，编写简洁且高效的排序逻辑变得轻而易举。\n\n希望这份简短的指南能够帮助您开始使用 Java 中的 `Comparator`。对于更复杂的案例或特定需求，请参考官方文档和其他资源深入学习。\n\n'},{title:"io 流的基本使用",headers:[{level:2,title:"InputStream ,ByteArrayInputStream",slug:"inputstream-bytearrayinputstream",link:"#inputstream-bytearrayinputstream",children:[]},{level:2,title:"DataInputStream",slug:"datainputstream",link:"#datainputstream",children:[]}],path:"/posts/java/basic/ioStream.html",pathLocale:"/",extraFields:"---\ntitle: io 流的基本使用\nicon: pen-to-square\ndate: 2023-06-05\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nIO 流的一些基本使用，后续记得完善\n\n\x3c!-- more --\x3e\n\n程序 通过 ByteArrayInputStream 读取 ByteArray\n程序 通过 ByteArrayOutputStream 写入 ByteArray\n\n```java\nbyte[] bb = new byte[]{49,50,51};\nInputStream in = new ByteArrayInputStream(bb);\nDataInputStream dis = new DataInputStream(in);\n```\n## InputStream ,ByteArrayInputStream\n\n## DataInputStream"},{title:"java8 stream",headers:[{level:2,title:"00.不可变集合",slug:"_00-不可变集合",link:"#_00-不可变集合",children:[]},{level:2,title:"01.Stream流的思想和获取Stream流",slug:"_01-stream流的思想和获取stream流",link:"#_01-stream流的思想和获取stream流",children:[]},{level:2,title:"02.Stream流的中间方法",slug:"_02-stream流的中间方法",link:"#_02-stream流的中间方法",children:[]},{level:2,title:"03.Stream流的终结方法",slug:"_03-stream流的终结方法",link:"#_03-stream流的终结方法",children:[]},{level:2,title:"0.前置",slug:"_0-前置",link:"#_0-前置",children:[]},{level:2,title:"1.Stream初相识",slug:"_1-stream初相识",link:"#_1-stream初相识",children:[]},{level:2,title:"2.Stream方法使用",slug:"_2-stream方法使用",link:"#_2-stream方法使用",children:[{level:3,title:"2.1.map与flatMap",slug:"_2-1-map与flatmap",link:"#_2-1-map与flatmap",children:[]},{level:3,title:"2.2.peek和foreach",slug:"_2-2-peek和foreach",link:"#_2-2-peek和foreach",children:[]},{level:3,title:"2.3.filter、sorted、distinct、limit",slug:"_2-3-filter、sorted、distinct、limit",link:"#_2-3-filter、sorted、distinct、limit",children:[]},{level:3,title:"2.4.简单结果终止方法",slug:"_2-4-简单结果终止方法",link:"#_2-4-简单结果终止方法",children:[]}]},{level:2,title:"3.避坑提醒",slug:"_3-避坑提醒",link:"#_3-避坑提醒",children:[]},{level:2,title:"4.结果收集终止方法",slug:"_4-结果收集终止方法",link:"#_4-结果收集终止方法",children:[{level:3,title:"4.1.生成集合",slug:"_4-1-生成集合",link:"#_4-1-生成集合",children:[]},{level:3,title:"4.2.生成拼接字符串",slug:"_4-2-生成拼接字符串",link:"#_4-2-生成拼接字符串",children:[]},{level:3,title:"4.3.数据批量数学运算",slug:"_4-3-数据批量数学运算",link:"#_4-3-数据批量数学运算",children:[]}]},{level:2,title:"5.并行Stream",slug:"_5-并行stream",link:"#_5-并行stream",children:[{level:3,title:"5.1.机制说明",slug:"_5-1-机制说明",link:"#_5-1-机制说明",children:[]},{level:3,title:"5.2.约束与限制",slug:"_5-2-约束与限制",link:"#_5-2-约束与限制",children:[]}]},{level:2,title:"6.回答最初的问题",slug:"_6-回答最初的问题",link:"#_6-回答最初的问题",children:[]}],path:"/posts/java/basic/java8Stream.html",pathLocale:"/",extraFields:'---\ntitle: java8 stream\nicon: pen-to-square\ndate: 2023-06-03\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava8 stream 梳理\n\n\x3c!-- more --\x3e\n\n# stream流\n\n标签（空格分隔）： java\n\n---\n## 00.不可变集合\n\n**创建不可变集合的应用场景**\n\n* 如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是很好的实践。\n* 当集合对象被不可信的库调用时，不可变形式是安全的。\n\n**简单理解：不想让别人修改集合中的内容。**\n\n\n\n创建不可变集合的书写格式。\n\n在List、Set、Map结构中，都存在静态的of方法，可以获取一个不可变的集合。\n\n注意的是，这个集合不能添加，不能删除，不能修改。\n\n```java\n// 创建不可变的list集合，只能进行查询操作，这是要jdk9\nList.of("1","2","3");\nSet.of(……);\n//Map的of方法，参数有上限，最多20个，就是10个键值对。\n//因为of方法没有可变参数的设置。key不能重复。\n//专属ofEntries()方法。超过10个键值对使用。\n//更简单的还是 copyOf，要jdk10.\nMap.of("key1","val1","key2","val2");\n```\n\n\n\n创建集合添加元素，完成以下需求:\n1.把所有以“张”开头的元素存储到新集合中\n2.把“张”开头的，长度为3的元素再存储到新集合中\n3.遍历打印最终结果\n\n```java\nArrayListcstring> list1 = new ArrayList<>(];\nlist1.add("张无忌");\nlist1.add("周芷若");\nlist1.add("赵敏");\nlist1.add("张濒");\nlistl.add("张三丰");\nlist1.stream().filter(name->name.startsWith("张")).filter(name->name.length()== 3).forEach(name -> System.out.println(name));\n\n```\n\n\n\n## 01.Stream流的思想和获取Stream流\n\n类似工厂加工流水线……加工数据。\n\n利用Stream流中的API操作，其中API可以分为中间方法，和终结方法。\n\n结合了Lambda表达式，简化集合、数组的操作。\n\n| 获取方式     | 方法名                                        | 说明                     |\n| ------------ | --------------------------------------------- | ------------------------ |\n| 单列集合     | `<code>default Stream<E> stream()            </code>`        | Collection中的默认方法   |\n| 双列集合     | 无                                            | 无法直接使用stream流     |\n| 数组         | `<code>public static <T> Stream<T> stream(T[] array) </code>`| Arrays工具类中的静态方法 |\n| 一堆零散数据 |`<code> public static<T> Stream<T> of(T...values)   </code>`  | Stream接口中的静态方法   |\n\n* 单列集合获取stream流\n\n```java\n//1.单列集合获取stream流\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list,  "a","b", "c", "d", "e");//获取到一条流水线，并把集合中的数据放到流水线上\nList<String> list = new ArrayList<>();\nlist.stream().forEach(s-> System.out.println(s));\n```\n\n* 双列集合获取stream流 \n\n```java\n//1.创建双列集合\nHashMap<String, Integer> hm = new HashMap<>();//2.添加数据\nhm.put("aaa", 111);\nhm.put("b66", 222);\nhm.put("ccc", 333);\nhm.put("ddd", 444);\n//3.第一种获收stream流\n//hm.keySet().stream().forEach(s -> System.out.println(s));\n//4.第二种获取stream流\nhm.entrySet().stream().forEach(s -> System.out.println(s));\n```\n\n* 数组获取Stream流\n\n```java\n//1.创建数组\nint[] arr1 = {1,2,3,4,5,6,7,8,9,103};String[] arr2 = {"a","b","c"};\n//2.获取stream流\nArrays.stream(arr1).forEach(s-> System.out.println(s));\nSystem.out.println("=================");\nArrays.stream(arr2).forEach(s-> System.out.println(s));\n```\n\n* 一堆零散数据获取Stream流，类型必须相同。\n\n```java\n//注意:\n//stream接口中静态方法of的细节\n//方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组\n//但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。\nStream.of(1,2,3,4,5).forEach(s-> System.out.println(s));\nStream.of(" ","b","c","d","e").forEach(s-> System.out.println(s));\n```\n\n\n\n## 02.Stream流的中间方法\n\n| API名称                                          | 功能说明                               |\n| ------------------------------------------------ | -------------------------------------- |\n| `<code>Stream<T> filter(Predicate<? super T> predicate)</code> `| 过滤                                   |\n| `<code>Stream<T> map(Function<T,R> mapper)   </code>           `| 转换流中的数据类型                     |\n| `<code>Stream<T> limit(long maxSize)         </code>           `| 获取前几个元素                         |\n| `<code>Stream<T> skip(long n)            </code>               `| 跳过前几个元素                         |\n| `<code>static <T> Stream<T> concat(Stream a,Stream b)</code>   `| 合并a和b两个流为一个流                 |\n| `<code>Stream<T> distinct()           </code>                  `| 元素去重，依赖（hashCode和equals方法） |\n\n注意1:中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程\n\n注意2:修改Stream流中的数据，不会影响原来集合或者数组中的数据\n\n* map训练\n\n```java\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list,"水品-15","花养-14","赵镇-13","张-20","张二卡-100","张柴山-40","张良-35","王二嘛子-2");\n//需求:只获取里面的年龄并进行打印\n//String->int\n//第一个类型：流中原本你的数据类型\n//第二个类型：要转成之后的类型。\n\n//apply的形参s：依次表示流里面的每一个数据\n//返回值：表示转换之后的数据\n\n//当map方法执行完毕之后，流上的数据就变成了整数。\n//所以在下面的forEach当中，s一次表示流里面的每一个数据，这个数据现在就是整数了。\nlist.stream().map(new Function<String, Integer>(){\n    @Override\n    public Integer apply(String s) {\n        String[] arr = s.split("-");\n        String ageString = arr[1];\n        int age = Integer.parseInt(ageString);\n        return age;\n    }\n}).forEach(s-> System.out.println(s));\n\n//Lambda表达式写法\nlist.stream().map(s -> Integer.parseInt(s.split("-")[1])).forEach(s -> System.out.println(s));\n```\n\n\n\n\n\n## 03.Stream流的终结方法\n\n\n\n| API名称                       | 说明                       |\n| ----------------------------- | -------------------------- |\n| void forEach(Consumer action) | 遍历                       |\n| long count()                  | 统计                       |\n| toArray()                     | 收集流中的数据，放到数组中 |\n| collect(Collector collector)  | 收集流中的数据，放到集合中 |\n\n\n\n* toArray\n\n```java\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list, "水品-15", "花养-14", "赵镇-13", "张-20", "张二卡-100", "张柴山-40", "张良-35", "王二嘛子-2");\n// toArray()\n// 收集流中的数据，放到数组中\n//Object[] arr1 = list.stream().toArray();//system.out.printIn(Arrays .tostring(arr1));\n//IntFunction的泛型:具体类型的数组\n//apply的形参:流中数据的个数，要跟数组的长度保持一致\n//apply的返回值:具体类型的数组\n//方法体:就是创建数组\n//toArray方法的参数的作用: 负责创建一个指定类型的数组\n// toArray方法的底层，会依次得到流里面的每一个数据，并把数据放到数组当中\n// toArray方法的返回值: 是一个装着流里面所有数据的致组\nString[] arr = list.stream().toArray(new IntFunction<String[]>() {\n    @Override\n    public String[] apply(int value) {\n        return new String[value];\n    }\n});\n\n//Lambda 表达式写法\nString[] arr2 = list.stream().toArray(value -> new String[value]);\nSystem.out.println(Arrays.toString(arr2));\n```\n\n* collect\n\n```java\n```\n\n\n\n\n\n## 0.前置\n\n看题：从给定句子中返回单词长度大于5的单词列表，按长度倒序输出，最多返回3个\n不用steam流的写法：\n```java\n/**\n * 【常规方式】\n * 从给定句子中返回单词长度大于5的单词列表，按长度倒序输出，最多返回3个\n *\n * @param sentence 给定的句子，约定非空，且单词之间仅由一个空格分隔\n * @return 倒序输出符合条件的单词列表\n */\npublic List<String> sortGetTop3LongWords(@NotNull String sentence) {\n    // 先切割句子，获取具体的单词信息\n    String[] words = sentence.split(" ");\n    List<String> wordList = new ArrayList<>();\n    // 循环判断单词的长度，先过滤出符合长度要求的单词\n    for (String word : words) {\n        if (word.length() > 5) {\n            wordList.add(word);\n        }\n    }\n    // 对符合条件的列表按照长度进行排序\n    wordList.sort((o1, o2) -> o2.length() - o1.length());\n    // 判断list结果长度，如果大于3则截取前三个数据的子list返回\n    if (wordList.size() > 3) {\n        wordList = wordList.subList(0, 3);\n    }\n    return wordList;\n}\n```\n借住jdk8之后的steam流会更优雅：\n```java\n\n/**\n * 【Stream方式】\n * 从给定句子中返回单词长度大于5的单词列表，按长度倒序输出，最多返回3个\n *\n * @param sentence 给定的句子，约定非空，且单词之间仅由一个空格分隔\n * @return 倒序输出符合条件的单词列表\n */\npublic List<String> sortGetTop3LongWordsByStream(@NotNull String sentence) {\n    return Arrays.stream(sentence.split(" "))\n            .filter(word -> word.length() > 5)\n            .sorted((o1, o2) -> o2.length() - o1.length())\n            .limit(3)\n            .collect(Collectors.toList());\n}\n```\n## 1.Stream初相识\n概括讲，可以将Stream流操作分为3种类型：\n\n* 创建Stream\n* Stream中间处理\n* 终止Steam\n\n| 创建Stream        | Stream操作1,2,3……  |  stream操作n  |终止stream  |\n| --------   | -----  | :----  |:----:  |\n|  `<code>stream()<br>Stream<T>.of(...)<br>paralleleStream()</code>`<br>创建出一个stream管道流对象| `<code>filter()<br>map()<br>flatMap()<br>limit(n)<br>skip(n)<br>concat()<br>dictinct()<br>sorted()<br>peek() </code>`|   每一个环节操作完成之后<br>都是返回一个新的Stream对象，<br>可以基于此新的Stream对象基础上<br>叠加其余的操作     |`<code> count()<br>max()<br>main()<br>findFirst()<br>findAny()<br>anyMatch()<br>allMatch()<br>noneMatch()<br>collect()<br>toArray()<br>Iterator()</code>`<br>foreach()<br>终止stream操作，获取结果或者者执行操作|\n\n每个Stream管道操作类型都包含若干API方法，先列举下各个API方法的功能介绍。\n\n* 开始管道\n\n主要负责新建一个Stream流，或者基于现有的数组、List、Set、Map等集合类型对象创建出新的Stream流。\n\n| API        | 功能说明   | \n| --------   | -----  |\n| stream()     | 创建出一个新的steam串行流对象 |  \n| parallelStream()        |   创建出一个可并行执行的stream流对象   | \n| Stream.of()        |    通过给定的一系列元素创建一个新的Stream串行流对象    | \n\n\n* 中间管道\n负责对Stream进行处理操作，并返回一个新的Stream对象，中间管道操作可以进行叠加。\n\n| API        | 功能说明   | \n| --------   | -----  |\n|filter()|\t按照条件过滤符合要求的元素， 返回新的stream流|\n|map()\t|将已有元素转换为另一个对象类型，一对一逻辑，返回新的stream流|\n|flatMap()|\t将已有元素转换为另一个对象类型，一对多逻辑，即原来一个元素对象可能会转换为1个或者多个新类型的元素，返回新的stream流|\n|limit()|\t仅保留集合前面指定个数的元素，返回新的stream流|\n|skip()|\t跳过集合前面指定个数的元素，返回新的stream流|\n|concat()|\t将两个流的数据合并起来为1个新的流，返回新的stream流|\n|distinct()|\t对Stream中所有元素进行去重，返回新的stream流|\n|sorted()|\t对stream中所有的元素按照指定规则进行排序，返回新的stream流|\n|peek()\t|对stream流中的每个元素进行逐个遍历处理，返回处理后的stream流|\n\n\n* 终止管道\n顾名思义，通过终止管道操作之后，Stream流将会结束，最后可能会执行某些逻辑处理，或者是按照要求返回某些执行后的结果数据。\n\n| API        | 功能说明   | \n| --------   | -----  |\n|count()|\t返回stream处理后最终的元素个数|\n|max()|\t返回stream处理后的元素最大值|\n|min()|\t返回stream处理后的元素最小值|\n|findFirst()|\t找到第一个符合条件的元素时则终止流处理|\n|findAny()|\t找到任何一个符合条件的元素时则退出流处理，这个对于串行流时与findFirst相同，对于并行流时比较高效，任何分片中找到都会终止后续计算逻辑|\n|anyMatch()\t|返回一个boolean值，类似于isContains(),用于判断是否有符合条件的元素|\n|allMatch()|\t返回一个boolean值，用于判断是否所有元素都符合条件|\n|noneMatch()|\t返回一个boolean值， 用于判断是否所有元素都不符合条件|\n|collect()|\t将流转换为指定的类型，通过Collectors进行指定|\n|toArray()|\t将流转换为数组|\n|iterator()\t|将流转换为Iterator对象|\n|foreach()|\t无返回值，对元素进行逐个遍历，然后执行给定的处理逻辑|\n\n\n## 2.Stream方法使用\n\n### 2.1.map与flatMap\nmap与flatMap都是用于转换已有的元素为其它元素，区别点在于：\n\n* map 必须是一对一的，即每个元素都只能转换为1个新的元素\n* flatMap 可以是一对多的，即每个元素都可以转换为1个或者多个新的元素\n\n#### 2.1.1.map\n比如：**有一个字符串ID列表，现在需要将其转为User对象列表**。可以使用map来实现：\n```java\n/**\n * 演示map的用途：一对一转换\n */\npublic void stringToIntMap() {\n    List<String> ids = Arrays.asList("205", "105", "308", "469", "627", "193", "111");\n    // 使用流操作\n    List<User> results = ids.stream()\n            .map(id -> {\n                User user = new User();\n                user.setId(id);\n                return user;\n            })\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n```\n执行之后，会发现每一个元素都被转换为对应新的元素，但是**前后总元素个数是一致的**：\n\n```java\n[User{id=\'205\'}, \n User{id=\'105\'},\n User{id=\'308\'}, \n User{id=\'469\'}, \n User{id=\'627\'}, \n User{id=\'193\'}, \n User{id=\'111\'}]\n```\n#### 2.1.2.flatMap\n再比如：现有一个句子列表，需要将句子中每个单词都提取出来得到一个所有单词列表。这种情况用map就搞不定了，需要flatMap上场了：\n```java\n\npublic void stringToIntFlatmap() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 使用流操作\n    List<String> results = sentences.stream()\n            .flatMap(sentence -> Arrays.stream(sentence.split(" ")))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n```\n执行结果如下，可以看到结果列表中元素个数是比原始列表元素个数要多的：\n```java\n[hello, world, Jia, Gou, Wu, Dao]\n```\n这里需要补充一句，flatMap操作的时候其实是先每个元素处理并返回一个新的Stream，然后将多个Stream展开合并为了一个完整的新的Stream。\n\n### 2.2.peek和foreach\npeek和foreach，都可以用于对元素进行遍历然后逐个的进行处理。\n\n但根据前面的介绍，peek属于中间方法，而foreach属于终止方法。这也就意味着peek只能作为管道中途的一个处理步骤，而没法直接执行得到结果，其后面必须还要有其它终止操作的时候才会被执行；而foreach作为无返回值的终止方法，则可以直接执行相关操作。\n```java\npublic void testPeekAndforeach() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 演示点1： 仅peek操作，最终不会执行\n    System.out.println("----before peek----");\n    sentences.stream().peek(sentence -> System.out.println(sentence));\n    System.out.println("----after peek----");\n    // 演示点2： 仅foreach操作，最终会执行\n    System.out.println("----before foreach----");\n    sentences.stream().forEach(sentence -> System.out.println(sentence));\n    System.out.println("----after foreach----");\n    // 演示点3： peek操作后面增加终止操作，peek会执行\n    System.out.println("----before peek and count----");\n    sentences.stream().peek(sentence -> System.out.println(sentence)).count();\n    System.out.println("----after peek and count----");\n}\n```\n\n输出结果可以看出，peek独自调用时并没有被执行、但peek后面加上终止操作之后便可以被执行，而foreach可以直接被执行：\n```java\n----before peek----\n----after peek----\n----before foreach----\nhello world\nJia Gou Wu Dao\n----after foreach----\n----before peek and count----\nhello world\nJia Gou Wu Dao\n----after peek and count----\n```\n\n### 2.3.filter、sorted、distinct、limit\n这几个都是常用的Stream的中间操作方法，具体的方法的含义在上面的表格里面有说明。具体使用的时候，可以根据需要选择一个或者多个进行组合使用，或者同时使用多个相同方法的组合：\n```java\npublic void testGetTargetUsers() {\n    List<String> ids = Arrays.asList("205","10","308","49","627","193","111", "193");\n    // 使用流操作\n    List<Dept> results = ids.stream()\n            .filter(s -> s.length() > 2)\n            .distinct()\n            .map(Integer::valueOf)\n            .sorted(Comparator.comparingInt(o -> o))\n            .limit(3)\n            .map(id -> new Dept(id))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}\n```\n上面的代码片段的处理逻辑很清晰：\n\n1、使用filter过滤掉不符合条件的数据\n2、通过distinct对存量元素进行去重操作\n3、通过map操作将字符串转成整数类型\n4、借助sorted指定按照数字大小正序排列\n5、使用limit截取排在前3位的元素\n6、又一次使用map将id转为Dept对象类型\n7、使用collect终止操作将最终处理后的数据收集到list中\n输出结果：\n```java\n[Dept{id=111},  Dept{id=193},  Dept{id=205}]\n```\n\n### 2.4.简单结果终止方法\n按照前面介绍的，终止方法里面像count、max、min、findAny、findFirst、anyMatch、allMatch、nonneMatch等方法，均属于这里说的简单结果终止方法。所谓简单，指的是其结果形式是数字、布尔值或者Optional对象值等。\n```java\npublic void testSimpleStopOptions() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    // 统计stream操作后剩余的元素个数\n    System.out.println(ids.stream().filter(s -> s.length() > 2).count());\n    // 判断是否有元素值等于205\n    System.out.println(ids.stream().filter(s -> s.length() > 2).anyMatch("205"::equals));\n    // findFirst操作\n    ids.stream().filter(s -> s.length() > 2)\n            .findFirst()\n            .ifPresent(s -> System.out.println("findFirst:" + s));\n}\n```\n其执行后的结果为：\n```java\n6\ntrue\nfindFirst:205\n```\n## 3.避坑提醒\n\n这里需要补充提醒下，一旦一个Stream被执行了终止操作之后，后续便不可以再读这个流执行其他的操作了，否则会报错，看下面示例：\n```java\npublic void testHandleStreamAfterClosed() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    Stream<String> stream = ids.stream().filter(s -> s.length() > 2);\n    // 统计stream操作后剩余的元素个数\n    System.out.println(stream.count());\n    System.out.println("-----下面会报错-----");\n    // 判断是否有元素值等于205\n    try {\n        System.out.println(stream.anyMatch("205"::equals));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println("-----上面会报错-----");\n}\n```\n执行的时候结果如下：\n```java\n\n6\n-----下面会报错-----\njava.lang.IllegalStateException: stream has already been operated upon or closed\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)\n\tat java.util.stream.ReferencePipeline.anyMatch(ReferencePipeline.java:449)\n\tat com.veezean.skills.stream.StreamService.testHandleStreamAfterClosed(StreamService.java:153)\n\tat com.veezean.skills.stream.StreamService.main(StreamService.java:176)\n-----上面会报错-----\n```\n因为stream已经被执行count()终止方法了，所以对stream再执行anyMatch方法的时候，就会报错stream has already been operated upon or closed，这一点在使用的时候需要特别注意。\n\n## 4.结果收集终止方法\n因为Stream主要用于对集合数据的处理场景，所以除了上面几种获取简单结果的终止方法之外，更多的场景是获取一个集合类的结果对象，比如List、Set或者HashMap等。\n\n这里就需要collect方法出场了，它可以支持生成如下类型的结果数据：\n\n* 一个集合类，比如List、Set或者HashMap等\n* StringBuilder对象，支持将多个字符串进行拼接处理并输出拼接后结果\n* 一个可以记录个数或者计算总和的对象（数据批量运算统计）\n\n### 4.1.生成集合\n应该算是collect最常被使用到的一个场景了：\n```java\npublic void testCollectStopOptions() {\n    List<Dept> ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));\n    // collect成list\n    List<Dept> collectList = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toList());\n    System.out.println("collectList:" + collectList);\n    // collect成Set\n    Set<Dept> collectSet = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toSet());\n    System.out.println("collectSet:" + collectSet);\n    // collect成HashMap，key为id，value为Dept对象\n    Map<Integer, Dept> collectMap = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toMap(Dept::getId, dept -> dept));\n    System.out.println("collectMap:" + collectMap);\n}\n```\n结果如下：\n```java\ncollectList:[Dept{id=22}, Dept{id=23}]\ncollectSet:[Dept{id=23}, Dept{id=22}]\ncollectMap:{22=Dept{id=22}, 23=Dept{id=23}}\n```\n### 4.2.生成拼接字符串\n将一个List或者数组中的值拼接到一个字符串里并以逗号分隔开，这个场景相信大家都不陌生吧？\n\n如果通过for循环和StringBuilder去循环拼接，还得考虑下最后一个逗号如何处理的问题，很繁琐:\n```java\npublic void testForJoinStrings() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    StringBuilder builder = new StringBuilder();\n    for (String id : ids) {\n        builder.append(id).append(\',\');\n    }\n    // 去掉末尾多拼接的逗号\n    builder.deleteCharAt(builder.length() - 1);\n    System.out.println("拼接后：" + builder.toString());\n}\n```\n但是现在有了Stream，使用collect可以轻而易举的实现：\n```java\npublic void testCollectJoinStrings() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    String joinResult = ids.stream().collect(Collectors.joining(","));\n    System.out.println("拼接后：" + joinResult);\n}\n```\n两种方式都可以得到完全相同的结果，但Stream的方式更优雅：\n```java\n拼接后：205,10,308,49,627,193,111,193\n```\n### 4.3.数据批量数学运算\n还有一种场景，实际使用的时候可能会比较少，就是使用collect生成数字数据的总和信息，也可以了解下实现方式：\n```java\npublic void testNumberCalculate() {\n    List<Integer> ids = Arrays.asList(10, 20, 30, 40, 50);\n    // 计算平均值\n    Double average = ids.stream().collect(Collectors.averagingInt(value -> value));\n    System.out.println("平均值：" + average);\n    // 数据统计信息\n    IntSummaryStatistics summary = ids.stream().collect(Collectors.summarizingInt(value -> value));\n    System.out.println("数据统计信息： " + summary);\n}\n```\n上面的例子中，使用collect方法来对list中元素值进行数学运算，结果如下：\n\n```java\n平均值：30.0\n总和： IntSummaryStatistics{count=5, sum=150, min=10, average=30.000000, max=50}\n```\n## 5.并行Stream\n### 5.1.机制说明\n使用并行流，可以有效利用计算机的多CPU硬件，提升逻辑的执行速度。并行流通过将一整个stream划分为多个片段，然后对各个分片流并行执行处理逻辑，最后将各个分片流的执行结果汇总为一个整体流。\n### 5.2.约束与限制\n并行流类似于多线程在并行处理，所以与多线程场景相关的一些问题同样会存在，比如死锁等问题，所以在并行流终止执行的函数逻辑，必须要保证线程安全。\n\n## 6.回答最初的问题\n到这里，关于JAVA Stream的相关概念与用法介绍，基本就讲完了。我们再把焦点切回本文刚开始时提及的一个问题：\n\nStream相较于传统的foreach的方式处理stream，到底有啥优势？\n\n根据前面的介绍，我们应该可以得出如下几点答案：\n\n* 代码更简洁、偏声明式的编码风格，更容易体现出代码的逻辑意图\n* 逻辑间解耦，一个stream中间处理逻辑，无需关注上游与下游的内容，只需要按约定实现自身逻辑即可\n* 并行流场景效率会比迭代器逐个循环更高\n* 函数式接口，延迟执行的特性，中间管道操作不管有多少步骤都不会立即执行，只有遇到终止操作的时候才会开始执行，可以避免一些中间不必要的操作消耗\n当然了，Stream也不全是优点，在有些方面也有其弊端：\n\n* 代码调测debug不便\n* 程序员从历史写法切换到Stream时，需要一定的适应时间'},{title:"java 零碎知识点",headers:[{level:2,title:"去除科学计数法",slug:"去除科学计数法",link:"#去除科学计数法",children:[]},{level:2,title:"时间戳转为日期格式",slug:"时间戳转为日期格式",link:"#时间戳转为日期格式",children:[]},{level:2,title:"判断一个字符串是否能转为数字",slug:"判断一个字符串是否能转为数字",link:"#判断一个字符串是否能转为数字",children:[]},{level:2,title:"Byte 高位/低位（大端格式/小端格式）",slug:"byte-高位-低位-大端格式-小端格式",link:"#byte-高位-低位-大端格式-小端格式",children:[{level:3,title:"大端格式（Big-Endian）",slug:"大端格式-big-endian",link:"#大端格式-big-endian",children:[]},{level:3,title:"小端格式（Little-Endian）",slug:"小端格式-little-endian",link:"#小端格式-little-endian",children:[]},{level:3,title:"网络字节序",slug:"网络字节序",link:"#网络字节序",children:[]}]}],path:"/posts/java/basic/jottings.html",pathLocale:"/",extraFields:'---\ntitle: java 零碎知识点\nicon: pen-to-square\ndate: 2023-06-04\nlastUpdated: true\n# order: 1\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 零碎知识点记录\n\n\x3c!-- more --\x3e\n\n## 去除科学计数法\n将其转为大精度直接输出\n首先，需要将科学计数法转换成一下：\n例如：\nBigDecimal bd = new BigDecimal("3.40256010353E11");\n然后转换成字符串：\nString str = bd.toPlainString();\n如果这个数字的长度是在int的范围内的话，是可以转换成int类型：\nint a = Integer.parsInt(str);\n如果这个数字的长度不是在Int范围内的话，得到的就不是你想要的数字了！换其他类型\n\n```java\nBigDecimal bg=new BigDecimal(val+"");//去除科学计数法\n```\n\n## 时间戳转为日期格式\n\n```java\n public static String timeStamp2Date(String time) {\n        Long timeLong = Long.parseLong(time);\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//要转换的时间格式\n        Date date;\n        try {\n        date = sdf.parse(sdf.format(timeLong));\n        return sdf.format(date);\n        } catch (ParseException e) {\n        e.printStackTrace();\n        return null;\n        }\n}\n```\n\n\n\n## 判断一个字符串是否能转为数字\nisNumeric方法\n\n## Byte 高位/低位（大端格式/小端格式）\n高位/低位（大端格式/小端格式）指的是多字节数据类型在计算机内存中的存储顺序。不同的计算机架构可能采用不同的字节序，这主要取决于硬件设计和所使用的处理器类型。\n\n### 大端格式（Big-Endian）\n\n在大端格式中，最高位字节（最左边的字节或最重要的字节）存储在最低地址处，而最低位字节（最右边的字节或最不重要的字节）存储在最高地址处。这种排序与人类阅读多位数的习惯相同，从左到右依次是最高位到最低位。例如：\n\n如果有一个16位的整数0x1234，在大端格式机器上它会被存储为：\n```\nMemory Address:  0x00    0x01\nContents:        0x12    0x34\n```\n\n### 小端格式（Little-Endian）\n\n在小端格式中，最低位字节存储在最低地址处，而最高位字节存储在最高地址处。也就是说，字节被“倒置”地存储。这种格式对于某些处理器架构来说更高效。例如：\n\n同样的16位整数0x1234，在小端格式机器上它会被存储为：\n```\nMemory Address:  0x00    0x01\nContents:        0x34    0x12\n```\n\n### 网络字节序\n\n网络上的通信通常使用大端格式作为标准，称为网络字节序。这意味着在网络编程中，发送方需要将本地的小端格式转换为大端格式，接收方则需要将接收到的大端格式转换回自己的本地格式。为此，许多编程语言提供了专门的函数来处理这样的转换，比如C语言中的`htonl()`、`htons()`、`ntohl()`和`ntohs()`等。\n\n了解你的系统是大端还是小端很重要，特别是在进行跨平台开发或者直接操作二进制数据时。如果你不确定系统的字节序，可以通过编写一个简单的程序来检测，例如创建一个多字节数并检查其内存表示。\n'},{title:"多线程基础",headers:[{level:2,title:"继承 Thread 类",slug:"继承-thread-类",link:"#继承-thread-类",children:[]},{level:2,title:"实现 Runnable 接口",slug:"实现-runnable-接口",link:"#实现-runnable-接口",children:[]},{level:2,title:"实现 Callable 接口 （JDK5.0 新增）",slug:"实现-callable-接口-jdk5-0-新增",link:"#实现-callable-接口-jdk5-0-新增",children:[]},{level:2,title:"线程池",slug:"线程池",link:"#线程池",children:[]},{level:2,title:"synchronized",slug:"synchronized",link:"#synchronized",children:[]},{level:2,title:"Lock 接口：JDK5.0新增",slug:"lock-接口-jdk5-0新增",link:"#lock-接口-jdk5-0新增",children:[]},{level:2,title:"死锁产生的原因",slug:"死锁产生的原因",link:"#死锁产生的原因",children:[]},{level:2,title:"死锁产生的四个必要条件？",slug:"死锁产生的四个必要条件",link:"#死锁产生的四个必要条件",children:[]},{level:2,title:"如何防止死锁？",slug:"如何防止死锁",link:"#如何防止死锁",children:[]},{level:2,title:"sleep() 和 wait()的异同？",slug:"sleep-和-wait-的异同",link:"#sleep-和-wait-的异同",children:[]},{level:2,title:"synchronized 与 Lock的异同？",slug:"synchronized-与-lock的异同",link:"#synchronized-与-lock的异同",children:[]}],path:"/posts/java/basic/multithreading.html",pathLocale:"/",extraFields:'---\ntitle: 多线程基础\nicon: pen-to-square\ndate: 2023-06-02\nlastUpdated: true\norder: -1 \ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n多线程基础\n\n\x3c!-- more --\x3e\n# 多线程\n\n标签（空格分隔）： java\n\n---\n@[TOC](Java SE 多线程)\n# 创建多线程的四种方式\n## 继承 Thread 类\n步骤：\n① 用一个类继承 Thread 类，**重写 run() 方法**；run 方法中就是此线程需要执行的操作。\n② 在需要用到的地方 **new** 一个 继承了 Thread 类的**子类的对象**，调用 start() 方法启动线程。start() 会调用 run()  方法中的代码。\n\n```java\n// ①\npublic class Test extends Thread{\n\t@Override\n\tpublic void run(){\n       ......\n\t}\n}\n// ②\nclass Main{\n\tpublic static void main(String[] args){\n\t\tTest test = new Test();\n\t\ttest.start();//只能调用start 方法 ，不能调用run，直接调用run()方法是和主线程一起共用一个线程，并没有开启一个线程。\n\t}\n}\n```\n## 实现 Runnable 接口\n\n1. 相比 Thread 的优势：\n   ① 因为是接口，所以弥补了单继承的局限性。\n   ② 节省资源，因为 Thread 每开启一个线程就需要new Test() ，也就是资源类。Runnable 可以只用new 一个 资源类。\n\n2. 步骤：\n   ① 用一个类实现 Runnable 接口，重写 run 方法。\n   ② 在需要的地方创建上述类的子类，把创建的类放入 new Thread（子类）中，调用 start 方法。\n```java\npublic class Test implements Runnable {\n\t@Override\n\tpublic void run(){\n\t\t……\n\t}\n}\nclass Main {\n\tpublic static void main(String[] args){\n\t\tTest test = new Test();\n\t\tnew Thread(test).start();\n\t}\n}\n```\n## 实现 Callable 接口 （JDK5.0 新增）\n\n1. 诞生原因（优势）：Callable 接口的方式比 Rannable 接口的方式更强大：因为 call() 可以有返回值、可以抛出异常，Callable 还支持泛型。\n2. 步骤：和 Runnable 差不多，只是 void -> Object（可变）、run -> call 、有 return Object、需要将资源类 放入 FutrueTask() 中，再放入 Thread 中。\n\n```java\npublic class Test implements Callable{\n\t@Override\n\tpublic Object call() thorws Exception {\n\t\t……\n\t\treturn Object;\n\t}\n}\nclass Main{\n\tpublic static void main(String[] args){\n\t\tTest test= new Test();\n\t\tFutureTask futureTask = new FutureTask(test);\n\t\tnew Thread(futureTask).start();\n\t\t\n\t\ttry{\n\t\t\tObject obj = futureTast.get();//获取返回值的方式\n\t\t}catch(ExecutionException e ){\n\t\t\te.printStackTrace();\n\t\t}\n```\n## 线程池\n\n1. 优势：\n   ① 提高了响应速度（减少了创建新线程的时间）。\n   ② 降低资源消耗 （重复利用线程池中线程，不需要每次都创建）\n   ③ 便于线程管理，里面设有各种参数，如最大线程数、核心池大小、线程没有任务时会保存多久终止等。暂时了解到这里，有兴趣的看一下源码就明白了。\n\n```java\nclass Test implements Runnable {// 也可以用 Callable\n\t@Override\n\tpublic void run(){\n\t\t……\n\t}\n}\nclass Main {\n\tpublic static void main(String[] args){\n\t\tExecutorService servie = Executors.newFixedThreadPool(10);//参数表示 线程的最大数量 \n\t\tThreadPoolExecutor service1 = (ThreadPoolExecutor) servie;\n\t\tservice.execute(new Test());// 适用于 Runnable\n\t\tservice.submit(Callable callable);// 适用于 Callable\n\t\tservice.shutdown();// 关闭连接池\n\t}\n}\n```\n# 线程的 常用方法 和 生命周期\n\n1. 常用方法：\n ```java\n 测试Thread中的常用方法：\n1. start():启动当前线程；调用当前线程的run()\n2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中\n3. currentThread():静态方法，返回执行当前代码的线程\n4. getName():获取当前线程的名字\n5. setName():设置当前线程的名字\n6. yield():释放当前cpu的执行权，执行机会让给相同或者更高优先级的线程。\n7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才\n          结束阻塞状态。\n8. stop():已过时。当执行此方法时，强制结束当前线程。\n9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前\n                         线程是阻塞状态，不释放锁。\n10. isAlive():判断当前线程是否存活\n\n线程的优先级：\n1.\nMAX_PRIORITY：10\n MIN _PRIORITY：1\nNORM_PRIORITY：5  --\x3e默认优先级\n2.如何获取和设置当前线程的优先级：\n  getPriority():获取线程的优先级\n  setPriority(int p):设置线程的优先级\n  说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下\n  被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。\n ```\n\n\n\n2. 生命周期\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/d5d740b78c774b7193c43d45ec8ad485.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqM54i3Lg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n① 就绪状态（Runnable）：该状态的线程位于可运行的线程池中，**等待获取 CPU 的使用权。**\n② 运行状态（Running）：就绪状态获取了 CPU ，执行代码。\n③ 阻塞状态（Blocked）：因为某种原因放弃 CPU 的使用权，暂时停止运行。阻塞状态分三种：\n（一）等待阻塞（wait）：运行的线程执行 wait 方法，JVM 会把该线程放入等待池中。（**wait 会释放持有的锁**）。\n（二）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用了，则JVM 会把该线程放入锁池中。\n（三）其他阻塞：运行的线程执行 sleep、join 方法或者发出了 I/O 请求时，JVM 会把该线程设置为阻塞状态。当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。（注意：**sleep 是不会释放持有锁**）\n\n\n\n# 锁（synchronized、Lock：JDK5.0）\n## synchronized\n1. 介绍：synchronized 是 Java 的关键字，用来给**对象**、**方法**、**代码块**、**类**加锁；当他锁定一个方法或者一个代码块时，同一时刻最多只能有一个线程执行这段代码。它是解决线程安全问题的方式之一。\n2. 看个例子：说买票过程中，出现了重票、错票，也就是线程安全问题，那怎么解决呢？\n   ① 分析原因：两个线程操作了同一张票，导致了重票。\n   ② 解决方法：也就是说，每卖一张票，只能有一个线程去操作，其他的线程必须等待。代码如下：\n ```java\nclass Window implements Runnable{\n\tprivate int ticket = 100;//卖一百张票；不要想把这里改为 static 会有用，两个线程同时操作一张票（此时没有加 synchronized）是指，线程一 还没有执行到 ticket--，线程二已经到了输出语句。\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tsynchronized(this){//此时的 this 是唯一的 Window 对象（加锁）；也可以用其他对象\n\t\t\t\tif(ticket > 0){\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);\n\t\t\t\t\tticket--;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tWindow w = new Window();\n\t\tThread t1 = new Thread(w);\n\t\tThread t2 = new Thread(w);\n\t\tt1.setName("窗口1");\n\t\tt2.setName("窗口2");\n\t\tt1.start();\n\t\tt2.start();\n\t}\n\t\t\n ```\n③ 上述代码的 synchronized 是放在代码块的，此时称为 **同步代码块**，我们也可以把它放在方法上，run 去调用这个方法就行了，此时称为 **同步方法**（**多用这个**） 其实差不多，看下代码：\n```java\nclass Window implements Runnable{\n//局部 run()\n\tpublic void run(){while(true){show();}}\n//同步方法\n\tprivate synchronized void show(){//此时锁的对象是调用 show() 的 对象，也就是 Window\n\t\tif(ticket > 0)……\n\t}\n}\n```\n## Lock 接口：JDK5.0新增\n1. 介绍：Lock 锁比 synchronized 要灵活一些；前者需要手动启动 （lock()），同步结束也需要手动释放锁（unlock()）；后者在执行完相应同步代码后，自动释放同步监视器（锁）。因此 **Lock 多用在同步代码块**，此时已经进入了方法体，分配了相应资源。\n2. 步骤：① 先 new 一个实现了 Lock 接口的类的 对象，也就是 ReentrantLock；② 就是上锁，位置和 synchronized 差不多；只需要最后得 释放锁，因此一般用 lock 都在 try- finally 里面。\n\n ```java\nclass Window implements Runnable{\n\tprivate int ticket = 100;\n\tprivate ReentrantLock lock = new ReentrantLock();\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tlock.lock();\n\t\t\t\tif(ticket > 0){\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + "：售票，票号为：" + ticket);\n\t\t\t\t\tticket--;\n\t\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}finally{\n\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\t}\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tWindow w = new Window();\n\t\tThread t1 = new Thread(w);\n\t\tThread t2 = new Thread(w);\n\t\tt1.setName("窗口1");\n\t\tt2.setName("窗口2");\n\t\tt1.start();\n\t\tt2.start();\n   \t\t}\n   \t}\n ```\n# 死锁\n1. 介绍：是指多个线程在运行过程中，因争夺资源而造成的一种僵局，当处于这种僵持状态时，若无外力作用，他们都无法再向前推进。最简单的就是：不同的线程占用对方需要的同步资源不放弃，都在等着对方放弃自己需要的同步资源，就形成了死锁；而且不会有异常，不会提示，只是所有线程都处于阻塞状态，无法继续。通俗来讲就是，你绑了他老婆，他绑了你老婆，但是你和他都在等待对方放了自己的老婆，僵持。\n2. 先看个例子：\n```java \npublic class DeadLock{\n\tpublic static void main(String[] args){\n\t\tStringBuffer s1 = new StringBuffer();// 拿来当锁用\n\t\tStringBuffer s2 = new StringBuffer();// 拿来当锁用\n\t\tnew Thread(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tsynchronized(s1){\n\t\t\t\t\ts1.append("a");\n\t\t\t\t\ts2.append("1");\n\t\t\t\t\tsynchronized(s2){// 执行到这里时，s2 已经被 下面一个线程 占用\n\t\t\t\t\t\ts1.append("b");\n\t\t\t\t\t\ts2.append("2");\n\t\t\t\t\t\tSystem.out.println(s1);\n                        System.out.println(s2);\n                    }\n               }\n           }\n       }.start();\n       \n       new Thread(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tsynchronized(s2){\n\t\t\t\t\ts1.append("c");\n\t\t\t\t\ts2.append("3");\n\t\t\t\t\tsynchronized(s1){// 这里又被上面 线程 占用，僵持了\n\t\t\t\t\t\ts1.append("d");\n\t\t\t\t\t\ts2.append("4");\n\t\t\t\t\t\tSystem.out.println(s1);\n                        System.out.println(s2);\n                    }\n               }\n           }\n       }.start();\n       }\n  }\n```\n## 死锁产生的原因\n前置知识：系统中资源可以分为两类：可剥夺资源 和 不可剥夺资源\n① 可剥夺资源：是指在某线程获得这类资源后，该资源还可以被其他线程或者系统剥夺，CPU 和 主存均属于可剥夺性资源。\n② 不可剥夺资源：当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后释放；如打印机。\n**产生死锁的原因如下：**\n1. 竞争资源：\n   ① 竞争不可剥夺资源；如系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。假定P1已占用了打印机R1，P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机R2，P1也将阻塞。于是，在P1和P2之间就形成了僵局，两个进程都在等待对方释放自己所需要的资源，但是它们又都因不能继续获得自己所需要的资源而不能继续推进，从而也不能释放自己所占有的资源，以致进入死锁状态。\n\n② 竞争临时资源：通常消息通信顺序进行不当，则会产生死锁。\n2. 进程推进顺序非法：\n   若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。\n\n## 死锁产生的四个必要条件？\n1. 互斥条件：线程要求对所分配的资源进行排它性控制，即在一段时间内某一资源仅为一个线程锁占用。\n2. 请求并保持条件：当线程因请求资源而阻塞，对已获得的资源保持不放。\n3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时自己释放。\n4. 环路等待条件：在发生死锁时，必然存在一个进程---资源的环形链。环路上的每个进程都在等待下一个进程占有的资源。\n\n## 如何防止死锁？\n① 破坏四个必要条件；② 预防死锁（有相关算法，这里暂不讨论）\n1. 破坏互斥条件：如果允许系统资源**都能共享使用**，则系统不会进入死锁状态。\n2. 破坏请求条件并保持条件：采用预先静态预分配，即进程运行前一次性申请完它所需要的物资，在物资为满足前，不能投入运行；一旦运行后，这些物资就一直归他所有，也不再发出其他物资请求。\n3. 破坏不可剥夺条件：当一个保持了某些不可剥夺资源的进程，请求新的资源没有办法满足时，**它必须释放已经保持的所有资源，待以后需要时在重新申请。**\n4. 破坏环路等待条件：采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。\n\n# 线程的通信\n线程的通信涉及到三个方法\n```java\nwait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器（锁）。\nnotify()：一旦执行此方法，就会唤醒被 wait 的线程。如果有多个线程被 wait ，就换醒优先级最高的那个。\nnotifyAll()：一旦执行此方法，就会唤醒所有被 wait 的线程。\n说明：\n这三个方法是定义在 java.lang.Object 类中；\n必须使用在同步代码块或同步方法中；\n它们的调用者必须是同步代码块或同步方法中的同步监视器。\n```\n看个线程通信的例子：使用两个线程打印 1-100。线程一，线程二 交替打印。\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Number number = new Number();\n        Thread t1 = new Thread(number);\n        Thread t2 = new Thread(number);\n        t1.setName("线程一");\n        t2.setName("线程二");\n        t1.start();\n        t2.start();\n    }\n\n    static class Number implements Runnable {\n        private int num = 1;\n        private Object obj = new Object();// 拿来当锁\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (obj) {\n                    obj.notify();\n                    if (num <= 100) {\n                        System.out.println(Thread.currentThread().getName() + ":" + num++);\n                        try {\n                            obj.wait();//线程一 num++ 后 必须刹一脚； 上面线程二 进来又唤醒 线程一。\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\t\n```\n# 线程通信应用\n必须掌握的经典例子：生产者 / 消费者 问题。\n问题：生产者（Productor）将产品交给店员（clerk），而消费者（Customer）从店员哪里取走产品，店员一次只能持有固定数量的产品（如：20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了在通知消费者来取走产品。\n```java\nclass Clerk{// 共享数据（店员/产品）\n\n    private int productCount = 0;\n    //生产产品\n    public synchronized void produceProduct() {\n\n        if(productCount < 20){\n            productCount++;\n            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");\n\n            notify();\n\n        }else{\n            //等待\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n    //消费产品\n    public synchronized void consumeProduct() {\n        if(productCount > 0){\n            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");\n            productCount--;\n\n            notify();\n        }else{\n            //等待\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\nclass Producer extends Thread{//生产者\n\n    private Clerk clerk;\n\n    public Producer(Clerk clerk) {\n        this.clerk = clerk;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(getName() + ":开始生产产品.....");\n\n        while(true){\n\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            clerk.produceProduct();\n        }\n\n    }\n}\n\nclass Consumer extends Thread{//消费者\n    private Clerk clerk;\n\n    public Consumer(Clerk clerk) {\n        this.clerk = clerk;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(getName() + ":开始消费产品.....");\n\n        while(true){\n\n            try {\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            clerk.consumeProduct();\n        }\n    }\n}\n\npublic class ProductTest {\n\n    public static void main(String[] args) {\n        Clerk clerk = new Clerk();\n\n        Producer p1 = new Producer(clerk);\n        p1.setName("生产者1");\n\n        Consumer c1 = new Consumer(clerk);\n        c1.setName("消费者1");\n        Consumer c2 = new Consumer(clerk);\n        c2.setName("消费者2");\n\n        p1.start();\n        c1.start();\n        c2.start();\n\n    }\n} \n```\n# 相关面试题\n## sleep() 和 wait()的异同？\n1. 相同点：都可以使当前的进程进入阻塞状态。\n2. 不同点：\n   ① 声明位置不同：Thread 类中声明 sleep() ，Object 类中声明 wait()。\n   ② 调用的要求不同：sleep() 可以在任何需要的场景调用。wait() 必须使用在同步代码块或同步方法中。\n   ③ 关于是否释放同步监视器（锁）：如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放锁，wait() 会释放锁。\n## synchronized 与 Lock的异同？\n1.  相同：二者都可以解决线程安全问题\n2. 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器，Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）\n\n\n\n\n\n**参考：**[https://www.bilibili.com/video/BV1Kb411W75N](https://www.bilibili.com/video/BV1Kb411W75N)，[https://blog.csdn.net/Amosstan/article/details/120161969](https://blog.csdn.net/Amosstan/article/details/120161969)，[https://blog.csdn.net/hd12370/article/details/82814348](https://blog.csdn.net/hd12370/article/details/82814348)'},{title:"java 使用正则表达式",headers:[{level:2,title:"1.1 Java 正则表达式使用指南",slug:"_1-1-java-正则表达式使用指南",link:"#_1-1-java-正则表达式使用指南",children:[]},{level:2,title:"1.2 Pattern 类",slug:"_1-2-pattern-类",link:"#_1-2-pattern-类",children:[]},{level:2,title:"1.3 创建 Pattern 对象",slug:"_1-3-创建-pattern-对象",link:"#_1-3-创建-pattern-对象",children:[]},{level:2,title:"2.1 常用方法",slug:"_2-1-常用方法",link:"#_2-1-常用方法",children:[]},{level:2,title:"3.1 检查字符串是否为有效的电子邮件地址",slug:"_3-1-检查字符串是否为有效的电子邮件地址",link:"#_3-1-检查字符串是否为有效的电子邮件地址",children:[]},{level:2,title:"3.2 提取所有的数字",slug:"_3-2-提取所有的数字",link:"#_3-2-提取所有的数字",children:[]},{level:2,title:"3.3 替换所有非字母字符为空格",slug:"_3-3-替换所有非字母字符为空格",link:"#_3-3-替换所有非字母字符为空格",children:[]},{level:2,title:"3.4 特殊字符和转义",slug:"_3-4-特殊字符和转义",link:"#_3-4-特殊字符和转义",children:[]},{level:2,title:"3.5 分组和捕获",slug:"_3-5-分组和捕获",link:"#_3-5-分组和捕获",children:[]},{level:2,title:"3.6. 总结",slug:"_3-6-总结",link:"#_3-6-总结",children:[]},{level:2,title:"4.1 基本字符匹配",slug:"_4-1-基本字符匹配",link:"#_4-1-基本字符匹配",children:[]},{level:2,title:"4.2 定量符（Quantifiers）",slug:"_4-2-定量符-quantifiers",link:"#_4-2-定量符-quantifiers",children:[]},{level:2,title:"4.3 字符类（Character Classes）",slug:"_4-3-字符类-character-classes",link:"#_4-3-字符类-character-classes",children:[]},{level:2,title:"4.4 预定义字符类",slug:"_4-4-预定义字符类",link:"#_4-4-预定义字符类",children:[]},{level:2,title:"4.5 锚点（Anchors）",slug:"_4-5-锚点-anchors",link:"#_4-5-锚点-anchors",children:[]},{level:2,title:"4.6 分组与捕获（Grouping and Capturing）",slug:"_4-6-分组与捕获-grouping-and-capturing",link:"#_4-6-分组与捕获-grouping-and-capturing",children:[]},{level:2,title:"4.7 替代（Alternation）",slug:"_4-7-替代-alternation",link:"#_4-7-替代-alternation",children:[]},{level:2,title:"4.8 向后引用（Backreferences）",slug:"_4-8-向后引用-backreferences",link:"#_4-8-向后引用-backreferences",children:[]},{level:2,title:"4.9 注释",slug:"_4-9-注释",link:"#_4-9-注释",children:[]},{level:2,title:"4.10 标志（Flags/Modifiers）",slug:"_4-10-标志-flags-modifiers",link:"#_4-10-标志-flags-modifiers",children:[]}],path:"/posts/java/basic/regularExpression.html",pathLocale:"/",extraFields:'---\ntitle: java 使用正则表达式\nicon: pen-to-square\ndate: 2024-12-17\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\njava 正则表达式的基础使用\n\n\x3c!-- more --\x3e\n\n\n\n# 1. 概述\n\n## 1.1 Java 正则表达式使用指南\n\n正则表达式（Regular Expression，简称 regex 或 regexp）是用于匹配字符串中字符模式的工具。在 Java 中，正则表达式的支持主要通过 `java.util.regex` 包来提供。此包包含了三个关键类：`Pattern`、`Matcher` 和 `PatternSyntaxException`。\n\n## 1.2 Pattern 类\n\n`Pattern` 类代表一个编译后的正则表达式，并提供了与该模式相匹配的方法。它是一个线程安全的对象，可以被多个 `Matcher` 实例共享以执行匹配操作。\n\n## 1.3 创建 Pattern 对象\n\n要创建一个 `Pattern` 对象，您需要调用它的静态方法 `compile(String regex)`：\n\n```java\nPattern pattern = Pattern.compile("your_regex_here");\n```\n\n# 2. Matcher 类\n\n`Matcher` 类是对输入序列进行匹配操作的引擎。`Matcher` 由 `Pattern` 的 `matcher(CharSequence input)` 方法生成：\n\n```java\nMatcher matcher = pattern.matcher("input_string_to_match");\n```\n\n## 2.1 常用方法\n\n\n\n- **find()**：尝试找到下一个子序列，该序列从先前匹配结束的地方开始匹配模式。如果找到了这样的序列，则返回 `true`。\n- **matches()**：尝试将整个区域与模式匹配。只有当整个区域都匹配时才返回 `true`。\n- **lookingAt()**：尝试将从区域开头开始的前缀与模式匹配。如果找到了这样的前缀，则返回 `true`。\n- **replaceAll(String replacement)**：用给定的替换字符串替换所有匹配的部分。\n- **replaceFirst(String replacement)**：只替换第一个匹配的部分。\n\n# 3. 示例代码\n\n\n\n下面是一些简单的示例，演示了如何使用正则表达式来进行不同的任务。\n\n## 3.1 检查字符串是否为有效的电子邮件地址\n\n\n\n```java\nString emailRegex = "^[\\\\w.-]+@[\\\\w.-]+\\\\.[a-zA-Z]{2,}$";\nPattern pattern = Pattern.compile(emailRegex);\nMatcher matcher = pattern.matcher("example@example.com");\nboolean isValidEmail = matcher.matches();\n```\n\n## 3.2 提取所有的数字\n\n\n\n```java\nString content = "The price is 100 dollars and the tax is 5%";\nPattern pattern = Pattern.compile("\\\\d+");\nMatcher matcher = pattern.matcher(content);\n\nwhile (matcher.find()) {\n    System.out.println(matcher.group());\n}\n```\n\n## 3.3 替换所有非字母字符为空格\n\n```java\nString text = "Hello, world! 123";\nString cleanedText = text.replaceAll("[^a-zA-Z]", " ");\nSystem.out.println(cleanedText);\n```\n\n## 3.4 特殊字符和转义\n\n某些字符在正则表达式中有特殊含义，例如点号 (`.`)、星号 (`*`) 等。如果您想要匹配这些字符本身，您需要对它们进行转义：\n\n```java\nString specialCharRegex = "\\\\."; // 匹配实际的点号\n```\n\n## 3.5 分组和捕获\n\n您可以使用圆括号 `()` 来分组和捕获匹配的部分。每个捕获组都有一个索引，从左到右编号，从 1 开始。整个表达式被视为组 0。\n\n```java\nString datePattern = "(\\\\d{4})-(\\\\d{2})-(\\\\d{2})"; // 年-月-日格式\nPattern pattern = Pattern.compile(datePattern);\nMatcher matcher = pattern.matcher("2023-04-01");\n\nif (matcher.matches()) {\n    String year = matcher.group(1);\n    String month = matcher.group(2);\n    String day = matcher.group(3);\n}\n```\n\n## 3.6. 总结\n\n正则表达式是非常强大的文本处理工具，但它们可能看起来复杂且难以理解。练习和熟悉常见的正则表达式模式以及如何在 Java 中使用它们将大大提高您的文本处理能力。\n\n# 4. 正则表达式语法指南\n\n正则表达式（Regular Expression，简称 regex 或 regexp）是一种用于描述搜索模式的工具。它们可以用来查找、编辑或操作文本，并广泛应用于各种编程语言中。下面将介绍正则表达式的常见语法元素。\n\n## 4.1 基本字符匹配\n\n- **普通字符**：大多数字符，如字母和数字，直接匹配自身。\n    - 示例：`hello` 匹配字符串 `"hello"`\n\n- **特殊字符**：一些字符在正则表达式中有特殊含义，必须转义才能匹配这些字符本身。\n    - 示例：`.`、`*`、`+`、`?`、`^`、`$` 等等。要匹配这些字符，需使用反斜杠 `\\` 进行转义，例如 `\\\\.` 匹配实际的点号。\n\n## 4.2 定量符（Quantifiers）\n\n定量符用于指定前面的字符或组应该出现多少次：\n\n- `*`：零次或多次\n- `+`：一次或多次\n- `?`：零次或一次\n- `{n}`：恰好 n 次\n- `{n,}`：至少 n 次\n- `{n,m}`：至少 n 次但不超过 m 次\n\n## 4.3 字符类（Character Classes）\n\n字符类定义了一组字符中的任何一个都可作为匹配条件：\n\n- `[abc]`：匹配 a 或 b 或 c 中的一个字符\n- `[a-z]`：匹配任何小写字母\n- `[A-Z]`：匹配任何大写字母\n- `[0-9]`：匹配任何数字\n- `[^abc]`：匹配除 a、b 和 c 之外的任何字符\n- `.`：匹配任意单个字符（除了换行符）\n\n## 4.4 预定义字符类\n\n预定义了一些常用的字符类以简化书写：\n\n- `\\\\d`：匹配一个数字，等价于 `[0-9]`\n- `\\\\D`：匹配一个非数字字符，等价于 `[^0-9]`\n- `\\\\s`：匹配空白字符（包括空格、制表符、换页符等）\n- `\\\\S`：匹配非空白字符\n- `\\\\w`：匹配单词字符（字母、数字和下划线），等价于 `[a-zA-Z_0-9]`\n- `\\\\W`：匹配非单词字符\n\n## 4.5 锚点（Anchors）\n\n锚点并不匹配实际字符，而是匹配位置：\n\n- `^`：匹配输入字符串的开始处\n- `$`：匹配输入字符串的结尾处\n- `\\\\b`：匹配一个单词边界\n- `\\\\B`：匹配非单词边界\n\n## 4.6 分组与捕获（Grouping and Capturing）\n\n圆括号 `()` 可用于分组和创建子表达式：\n\n- `(ab)`：作为一个整体匹配 "ab"\n- `(?:ab)`：非捕获分组，只进行分组不捕获\n- `(ab|cd)`：匹配 "ab" 或 "cd"\n\n## 4.7 替代（Alternation）\n\n竖线 `|` 用于表示“或”的关系：\n\n- `foo|bar`：匹配 "foo" 或 "bar"\n\n## 4.8 向后引用（Backreferences）\n\n使用反斜杠加上数字来引用之前捕获的组：\n\n- `([abc])\\\\1`：匹配两个连续相同的字符，比如 "aa"、"bb" 或 "cc"\n\n## 4.9 注释\n\n可以在正则表达式中添加注释，提高可读性：\n\n- `(?#comment)`：此形式的注释不会影响匹配行为\n\n## 4.10 标志（Flags/Modifiers）\n\n某些情况下，您可能想要改变正则表达式的默认行为，这可以通过标志实现：\n\n- `i`：忽略大小写\n- `m`：多行模式，改变 `^` 和 `$` 的行为\n- `s`：使 `.` 匹配所有字符，包括换行符\n- `x`：扩展模式，忽略空白字符并允许注释\n\n# 4.11 示例\n\n以下是一些简单的正则表达式及其解释：\n\n- `\\\\d{3}-\\\\d{2}-\\\\d{4}`：匹配形如 `123-45-6789` 的社会安全号码格式\n- `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$`：匹配电子邮件地址\n- `\\\\b(https?://[^\\s]+)\\\\b`：匹配 URL 地址\n- `\\\\b\\\\w+\\\\b`：匹配单词\n\n通过以上基础，您可以构建出复杂的正则表达式来满足特定的需求。对于更复杂的应用，请参考相关文档深入学习。希望这份指南能够帮助您理解正则表达式的语法！\n\n'},{title:"java bug 合集",headers:[{level:2,title:"解決BufferedReader读取中文乱码问题",slug:"解決bufferedreader读取中文乱码问题",link:"#解決bufferedreader读取中文乱码问题",children:[]}],path:"/posts/java/bug/bug.html",pathLocale:"/",extraFields:'---\ntitle: java bug 合集\nicon: pen-to-square\ndate: 2023-06-05\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - bug\n---\n\n记录遇见的 Java 相关疑难杂症的 bug\n\n\x3c!-- more --\x3e\n\n\n\n## 解決BufferedReader读取中文乱码问题\n```java\nInputStream in=new FileInputStream("D:\\\\temp\\\\user2.txt");\nSystem.out.println(stream2String(in));\n\n//stream2String方法的主要代码:\n\nsb = new StringBuffer();\n//bfReader = new BufferedReader(new InputStreamReader(in));  //会出乱码\nbfReader = new BufferedReader(new InputStreamReader(in, "UTF-8"));\n\nString line = bfReader.readLine();\n```\n'},{title:"docx4j 基本使用",headers:[{level:2,title:"1.快速入门",slug:"_1-快速入门",link:"#_1-快速入门",children:[{level:3,title:"1.1.引入依赖",slug:"_1-1-引入依赖",link:"#_1-1-引入依赖",children:[]},{level:3,title:"1.2.用一些文本创建文档",slug:"_1-2-用一些文本创建文档",link:"#_1-2-用一些文本创建文档",children:[]},{level:3,title:"1.3.添加带样式的文本",slug:"_1-3-添加带样式的文本",link:"#_1-3-添加带样式的文本",children:[]},{level:3,title:"1.4.添加表格",slug:"_1-4-添加表格",link:"#_1-4-添加表格",children:[]},{level:3,title:"1.5.给表格添加边框",slug:"_1-5-给表格添加边框",link:"#_1-5-给表格添加边框",children:[]},{level:3,title:"1.6.给表格添加其他样式",slug:"_1-6-给表格添加其他样式",link:"#_1-6-给表格添加其他样式",children:[]}]},{level:2,title:"2.加载已有的word修改其表格中的值",slug:"_2-加载已有的word修改其表格中的值",link:"#_2-加载已有的word修改其表格中的值",children:[]},{level:2,title:"3.实际问题",slug:"_3-实际问题",link:"#_3-实际问题",children:[]}],path:"/posts/java/dependence/docx4j.html",pathLocale:"/",extraFields:'---\ntitle: docx4j 基本使用\nicon: pen-to-square\ndate: 2024-12-17\nlastUpdated: true\ncategory:\n  - dependence\ntag:\n  - java\n---\n\ndocx4j 的一些基本使用\n\n\x3c!-- more --\x3e\n\n## 1.快速入门\n\n**官网：**[Office Open XML - OOXML 字处理ML文件的剖析](http://officeopenxml.com/anatomyofOOXML)\n\n### 1.1.引入依赖\n\n有些应该是多的，按需要引入\n\n```shell\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.docx4j</groupId>\n\t\t<artifactId>docx4j-core</artifactId>\n\t\t<version>8.2.6</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.docx4j</groupId>\n\t\t<artifactId>docx4j-JAXB-ReferenceImpl</artifactId>\n\t\t<version>8.2.6</version>\n\t</dependency>\n    <dependency>\n        <groupId>org.docx4j</groupId>\n        <artifactId>docx4j</artifactId>\n        <version>6.1.2</version>\n    </dependency>\n</dependencies>\n```\n\n### 1.2.用一些文本创建文档\n\n```java\n @Test\n    public void test1() throws Docx4JException {\n        WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();//创建一个空白word\n        wordMLPackage.getMainDocumentPart().addParagraphOfText("Hello Word!");//添加一个文本段落\n        wordMLPackage.save(new java.io.File("HelloWord1.docx"));\n    }\n```\n\n### 1.3.添加带样式的文本\n\n```java\n @Test\n    public void test2() throws Docx4JException {\n        WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();\n        wordMLPackage.getMainDocumentPart().addStyledParagraphOfText("Title", "Hello Word!");\n        wordMLPackage.getMainDocumentPart().addStyledParagraphOfText("Subtitle","This is a subtitle!");\n        wordMLPackage.save(new java.io.File("HelloWord2.docx"));\n    }\n```\n\n### 1.4.添加表格\n\n```java\n public void test3() throws Docx4JException {\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl table = factory.createTbl();//创建表格\n        Tr tableRow = factory.createTr();//创建一行\n\n        Tc tableCell_1 = factory.createTc();//创建单元格\n        tableCell_1.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 1"));//设置单元格内容\n        tableRow.getContent().add(tableCell_1);//添加单元格到row中\n\n        Tc tableCell_2 = factory.createTc();\n        tableCell_1.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 2"));\n        tableRow.getContent().add(tableCell_2);\n\n\n        table.getContent().add(tableRow);//将row添加到表格中\n\n        wordMlPackage.getMainDocumentPart().addObject(table);//将表格添加到word中\n        wordMlPackage.save(new File("HelloWord4.docx"));//保存\n    }\n```\n\n### 1.5.给表格添加边框\n\n\n\n```java\n//给表格添加边框\n    @Test\n    public void test4() throws Docx4JException {\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl table = factory.createTbl();\n        Tr tableRow = factory.createTr();\n        Tc tableCell = factory.createTc();//创建单元格\n        tableCell.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 1"));//设置单元格内容\n        tableRow.getContent().add(tableCell);//添加单元格到row中\n        table.getContent().add(tableRow);//将row添加到表格中\n\n        addBorders(table);\n\n        wordMlPackage.getMainDocumentPart().addObject(table);//将表格添加到word中\n        wordMlPackage.save(new File("HelloWord5.docx"));//保存\n    }\n    //加边框\n    void addBorders(Tbl table) {\n        table.setTblPr(new TblPr());\n        CTBorder border = new CTBorder();\n        border.setColor("auto");\n        border.setSz(new BigInteger("4"));\n        border.setSpace(new BigInteger("0"));\n        border.setVal(STBorder.SINGLE);\n\n        TblBorders borders = new TblBorders();\n        borders.setBottom(border);\n        borders.setLeft(border);\n        borders.setRight(border);\n        borders.setTop(border);\n        borders.setInsideH(border);\n        borders.setInsideV(border);\n        table.getTblPr().setTblBorders(borders);\n    }\n```\n\n### 1.6.给表格添加其他样式\n\n```java\n//给表格添加样式\n    @Test\n    public void test6() throws Docx4JException{\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl tab = factory.createTbl();\n        Tr row = factory.createTr();\n        Tc tc = factory.createTc();\n        //第一个单元格\n        tc.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Normal text"));\n        row.getContent().add(tc);\n        //第二个单元格\n        Tc tc2 = factory.createTc();\n        P paragraph = factory.createP();//创建段落\n        Text text = factory.createText();//文本对象\n        text.setValue("Bold text");\n\n        R run = factory.createR();//创建运行块对象,它是一块或多块拥有共同属性的文本的容器\n        run.getContent().add(text);//将文本对象添加到其中.\n\n        paragraph.getContent().add(run);//运行块R添加到段落内容中.\n\n        RPr runProperties = factory.createRPr();//运行属性\n\n        BooleanDefaultTrue b = new BooleanDefaultTrue();//默认为true\n        b.setVal(true);\n\n        runProperties.setB(b);//将运行块属性添加为粗体属性\n\n        HpsMeasure size = new HpsMeasure();//字体大小属性\n        size.setVal(new BigInteger("40"));//这个属性规定是半个点(half-point)大小, 因此字体大小需要是你想在Word中显示大小的两倍,\n\n        runProperties.setSz(size);//猜测是整体大小\n        runProperties.setSzCs(size);//猜测为单元格大小\n\n        run.setRPr(runProperties);//将样式添加进去\n\n        tc2.getContent().add(paragraph);\n        row.getContent().add(tc2);\n\n\n        tab.getContent().add(row);\n        addBorders(tab);\n\n        wordMlPackage.getMainDocumentPart().addObject(tab);\n        wordMlPackage.save(new File("helloWord6.docx"));\n    }\n```\n\n\n\n## 2.加载已有的word修改其表格中的值\n\n```java\n  @Test\n    public void test9(){\n        WordprocessingMLPackage wordMlPackage = null;\n        try {\n            wordMlPackage = WordprocessingMLPackage.load(new File("helloWord6.docx"));\n        } catch (Docx4JException e) {\n            log.error("文件加载失败");\n            e.printStackTrace();\n        }\n        MainDocumentPart mainDocPart = wordMlPackage.getMainDocumentPart();\n        List<Object> children = ((ContentAccessor) mainDocPart).getContent();\n        JAXBElement jaxbElement = (JAXBElement) children.get(0);\n        Tbl tbl = (Tbl) jaxbElement.getValue();\n        List<Object> trList = tbl.getContent();\n        Tr tr = (Tr) trList.get(0);\n\n        JAXBElement jax_tc = (JAXBElement) tr.getContent().get(0);\n        Tc tc = (Tc) jax_tc.getValue();\n        P p = (P) tc.getContent().get(0);//段落\n        R r = (R) p.getContent().get(0);//行\n        JAXBElement jax = (JAXBElement) r.getContent().get(0);\n        Text text = (Text) jax.getValue();\n        String value = text.getValue();\n        log.error("获取到表格中第一列第一行的值为：" + value);\n        text.setValue("我成功啦");\n        try {\n            wordMlPackage.save(new File("helloWord6.docx"));\n        } catch (Docx4JException e) {\n            log.error("保存文件失败");\n            e.printStackTrace();\n        }\n    }\n```\n\n## 3.实际问题\n\n#### 3.1 docx 转 pdf（有些样式会失败）\n\n1.引入依赖\n\n```shell\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.24</version> \x3c!-- 请检查最新版本 --\x3e\n</dependency>\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j</artifactId>\n    <version>6.1.2</version>\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n        \x3c!-- https://mvnrepository.com/artifact/org.docx4j/docx4j-export-fo --\x3e\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j-export-fo</artifactId>\n    <version>6.1.0</version>\n</dependency>\n```\n\n示例：\n\n```java\n\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.docx4j.Docx4J;\nimport org.docx4j.openpackaging.packages.WordprocessingMLPackage;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PdfPageCounter {\n    public static void main(String[] args) {\n        String pdfPath = getPdf(HmiproApplication.getPath(), "mingyang.docx");\n        int pdfCount = getPdfCount(pdfPath);\n        System.out.println(pdfCount);\n    }\n\n    public static String getPdf(String filePath,String fileName) {\n        try {\n            // 设置输入输出文件路径\n            File inputFile = new File(filePath + fileName);\n            String res = filePath+ File.separator + fileName + "pdf.pdf";\n            File outputFile = new File(res);\n\n            // 加载 DOCX 文件\n            WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.load(inputFile);\n\n            // 执行转换\n            Docx4J.toPDF(wordMLPackage, new FileOutputStream(outputFile));\n            return res;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static int getPdfCount(String pdfPath){\n        File file = new File(pdfPath);\n        try (PDDocument document = PDDocument.load(file)) {\n            int numberOfPages = document.getNumberOfPages();\n            document.close();\n            file.deleteOnExit();\n            return numberOfPages;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n}\n```\n\n#### 3.2 docx 转 paf （比上面个好）不支持Linux和mac哦\n\n\n\n```shell\n\n<dependency>\n    <groupId>com.documents4j</groupId>\n    <artifactId>documents4j-local</artifactId>\n    <version>1.0.3</version>\n</dependency>\n<dependency>\n    <groupId>com.documents4j</groupId>\n    <artifactId>documents4j-transformer-msoffice-word</artifactId>\n    <version>1.0.3</version>\n</dependency>\n\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.24</version> \x3c!-- 请检查最新版本 --\x3e\n</dependency>\n\n <dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j</artifactId>\n    <version>6.1.2</version>\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j-export-fo</artifactId>\n    <version>6.1.0</version>\n</dependency>\n```\n\n```java\nimport com.documents4j.api.DocumentType;\nimport com.documents4j.api.IConverter;\nimport com.documents4j.job.LocalConverter;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.docx4j.openpackaging.exceptions.Docx4JException;\n\nimport java.io.*;\n\npublic class PdfPageCounter {\n    public static void main(String[] args) throws Docx4JException {\n        String fileName = "demo.docx";\n        String path = "E:\\\\资料\\\\诊断报告";\n        String targetFile = path + File.separator + fileName;\n        String pdfPath = getPdf(path, fileName);\n        int pdfCount = getPdfCount(pdfPath);\n        System.out.println(pdfCount);\n    }\n    \n\n    public static int getPdfCount(String pdfPath){\n        File file = new File(pdfPath);\n        try (PDDocument document = PDDocument.load(file)) {\n            int numberOfPages = document.getNumberOfPages();\n            document.close();\n            file.deleteOnExit();\n            return numberOfPages;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n\n    public static String getPdf(String path,String fileName) {\n        File inputWord = new File(path + File.separator + fileName);\n        String resPath = path + File.separator + fileName.replace(".docx",".pdf");\n        File outputFile = new File(resPath);\n        try  {\n            InputStream docxInputStream = new FileInputStream(inputWord);\n            OutputStream outputStream = new FileOutputStream(outputFile);\n            IConverter converter = LocalConverter.builder().build();\n            converter.convert(docxInputStream).as(DocumentType.DOCX).to(outputStream).as(DocumentType.PDF).execute();\n            outputStream.close();\n            System.out.println("success");\n            return resPath;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n```'},{title:"Java 有关log的第三方依赖的使用",headers:[{level:2,title:'Failed to load class "org.slf4j.impl.StaticLoggerBinder"',slug:"failed-to-load-class-org-slf4j-impl-staticloggerbinder",link:"#failed-to-load-class-org-slf4j-impl-staticloggerbinder",children:[]},{level:2,title:"WARN No appenders could be found for logger",slug:"warn-no-appenders-could-be-found-for-logger",link:"#warn-no-appenders-could-be-found-for-logger",children:[]},{level:2,title:"Class path contains multiple SLF4J bindings.",slug:"class-path-contains-multiple-slf4j-bindings",link:"#class-path-contains-multiple-slf4j-bindings",children:[]}],path:"/posts/java/dependence/log.html",pathLocale:"/",extraFields:'---\ntitle: Java 有关log的第三方依赖的使用\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - dependence\n\ntag:\n  - java\n  - spring\n  - springboot\n  - logback\n\n---\nJava 有关log的第三方依赖的使用\n\n\x3c!-- more --\x3e\n\n# 引入依赖\n```shell\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.16</version>\n</dependency>\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.30</version>\n</dependency>\n```\n\n# 配置logback-spring.xml 文件放在 resources 路径下\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n\x3c!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\x3e\n\x3c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\x3e\n\x3c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。\n                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration  scan="true" scanPeriod="10 seconds">\n    <contextName>logback-spring</contextName>\n\n    \x3c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\x3e\n    <property name="logging.path" value="./logs" />\n\n    \x3c!--0. 日志格式和颜色渲染 --\x3e\n    \x3c!-- 彩色日志依赖的渲染类 --\x3e\n    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />\n    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />\n    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />\n    \x3c!-- 彩色日志格式 --\x3e\n    <property name="CONSOLE_LOG_PATTERN" value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>\n\n    \x3c!--1. 输出到控制台--\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>debug</level>\n        </filter>\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            \x3c!-- 设置字符集 --\x3e\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--2. 输出到文档--\x3e\n    \x3c!-- 2.1 level为 DEBUG 日志，时间滚动输出  --\x3e\n    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_debug.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 日志归档 --\x3e\n            <fileNamePattern>${logging.path}/web-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录debug级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>debug</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.2 level为 INFO 日志，时间滚动输出  --\x3e\n    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_info.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 每天日志归档路径以及格式 --\x3e\n            <fileNamePattern>${logging.path}/web-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录info级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>info</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.3 level为 WARN 日志，时间滚动输出  --\x3e\n    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_warn.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录warn级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>warn</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.4 level为 ERROR 日志，时间滚动输出  --\x3e\n    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_error.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录ERROR级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>ERROR</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!--\n        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n        以及指定<appender>。<logger>仅有一个name属性，\n        一个可选的level和一个可选的addtivity属性。\n        name:用来指定受此logger约束的某一个包或者具体的某一个类。\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n              如果未设置此属性，那么当前logger将会继承上级的级别。\n        addtivity:是否向上级logger传递打印信息。默认是true。\n        <logger name="org.springframework.web" level="info"/>\n        <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!--过滤掉spring和mybatis的一些无用的DEBUG信息--\x3e\n    <logger name="org.springframework" level="INFO" />\n    <logger name="org.mybatis" level="INFO" />\n    <logger name="org.apache.zookeeper" level="INFO" />\n\n    \x3c!-- 4. 最终的策略 --\x3e\n    \x3c!-- 4.1 开发环境:打印控制台--\x3e\n    <springProfile name="dev">\n        <logger name="com.example.datatransport" level="debug"/>\x3c!-- 修改此处扫描包名 --\x3e\n    </springProfile>\n\n    <root level="info">\n        <appender-ref ref="CONSOLE" />\n        <appender-ref ref="DEBUG_FILE" />\n        <appender-ref ref="INFO_FILE" />\n        <appender-ref ref="WARN_FILE" />\n        <appender-ref ref="ERROR_FILE" />\n    </root>\n\n\x3c!--    4.2 生产环境:输出到文档--\x3e\n    <springProfile name="pro">\n        <root level="info">\n            <appender-ref ref="CONSOLE" />\n            <appender-ref ref="DEBUG_FILE" />\n\x3c!--            <appender-ref ref="INFO_FILE" />--\x3e\n            <appender-ref ref="ERROR_FILE" />\n            <appender-ref ref="WARN_FILE" />\n        </root>\n    </springProfile>\n</configuration>\n\n```\n\n# 遇到的相关 bug\n\n\n## Failed to load class "org.slf4j.impl.StaticLoggerBinder"\n加入如下依赖：\n```xml\n<dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.7.5</version>\n</dependency>\n```\n\n## WARN No appenders could be found for logger\n添加log4j.properties文件\n内容：\n```properties\nlog4j.rootLogger=DEBUG, stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\n```\n\n## Class path contains multiple SLF4J bindings.\n原因：根据上面的错误提示，存在多个SLF4J bindings绑定，即存在多个slf4j的实现类，按上图所示这两个实现分别是logback-classic-1.2.6和slf4j-log4j12-1.6.1，我们需要的是logback而不是log4j\n\n解决：因此，我们去掉log4j的依赖就行；查找slf4j-log4j12-1.6.1并将其删除'},{title:"有关maven的使用",headers:[{level:2,title:"Maven&MyBatis",slug:"maven-mybatis",link:"#maven-mybatis",children:[]},{level:2,title:"1，Maven",slug:"_1-maven",link:"#_1-maven",children:[{level:3,title:"1.1  Maven简介",slug:"_1-1-maven简介",link:"#_1-1-maven简介",children:[]},{level:3,title:"1.2  Maven安装配置",slug:"_1-2-maven安装配置",link:"#_1-2-maven安装配置",children:[]},{level:3,title:"1.3  Maven基本使用",slug:"_1-3-maven基本使用",link:"#_1-3-maven基本使用",children:[]},{level:3,title:"1.4  IDEA使用Maven",slug:"_1-4-idea使用maven",link:"#_1-4-idea使用maven",children:[]},{level:3,title:"1.5  依赖管理",slug:"_1-5-依赖管理",link:"#_1-5-依赖管理",children:[]}]},{level:2,title:"1.6 maven命令行安装",slug:"_1-6-maven命令行安装",link:"#_1-6-maven命令行安装",children:[]},{level:2,title:"maven 相关的bug",slug:"maven-相关的bug",link:"#maven-相关的bug",children:[{level:3,title:"Could not transfer artifact",slug:"could-not-transfer-artifact",link:"#could-not-transfer-artifact",children:[]},{level:3,title:"the trustAnchors parameter must be non-empty",slug:"the-trustanchors-parameter-must-be-non-empty",link:"#the-trustanchors-parameter-must-be-non-empty",children:[]},{level:3,title:"Failure to transfer……from",slug:"failure-to-transfer-from",link:"#failure-to-transfer-from",children:[]}]}],path:"/posts/java/dependence/maven.html",pathLocale:"/",extraFields:"---\ntitle: 有关maven的使用\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - dependence\n\ntag:\n  - java\n  - spring\n  - springboot\n  - maven\n\n---\n\nmaven的基本使用\n\x3c!-- more --\x3e\n## Maven&MyBatis\n\n**目标**\n\n> * 能够使用Maven进行项目的管理\n> * 能够完成Mybatis代理方式查询数据 \n> * 能够理解Mybatis核心配置文件的配置\n\n## 1，Maven\n\nMaven是专门用于管理和构建Java项目的工具，它的主要功能有：\n\n* 提供了一套标准化的项目结构\n\n* 提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n* 提供了一套依赖管理机制\n\n**标准化的项目结构：**\n\n项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便。\n\n\n而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。\n\n\n**标准化的构建流程：**\n\n\n平时我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。\n\n**依赖管理：**\n\n依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。\n\n而Maven使用标准的 ==坐标== 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。\n\n\n市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比\n\n\n### 1.1  Maven简介\n\n> ==Apache Maven== 是一个项目管理和构建==工具==，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。\n>\n> 官网 ：http://maven.apache.org/\n\n通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。\n\n#### 1.1.1  Maven模型\n\n* 项目对象模型 (Project Object Model)\n* 依赖管理模型(Dependency)\n* 插件(Plugin)\n\n\n\n#### 1.1.2  仓库\n\n大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。\n\n**仓库分类：**\n\n* 本地仓库：自己计算机上的一个目录\n\n* 中央仓库：由Maven团队维护的全球唯一的仓库\n\n    * 地址： https://repo1.maven.org/maven2/\n\n* 远程仓库(私服)：一般由公司团队搭建的私有仓库\n\n  今天我们只学习远程仓库的使用，并不会搭建。\n\n当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：\n\n* 如果有，则在项目直接引用;\n\n* 如果没有，则去中央仓库中下载对应的jar包到本地仓库。\n\n\n如果还可以搭建远程仓库，将来jar包的查找顺序则变为：\n\n> 本地仓库 --\x3e 远程仓库--\x3e 中央仓库\n\n\n### 1.2  Maven安装配置\n\n* 解压 apache-maven-3.6.1.rar 既安装完成\n\n  > 建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 `D:\\software` 下。\n  \n\n    * bin目录 ： 存放的是可执行命令。mvn 命令重点关注。\n    * conf目录 ：存放Maven的配置文件。`settings.xml` 配置文件后期需要修改。\n    * lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。\n\n* 配置环境变量 MAVEN_HOME 为安装路径的bin目录\n\n  `此电脑` 右键  --\x3e  `高级系统设置`  --\x3e  `高级`  --\x3e  `环境变量`\n\n  在系统变量处新建一个变量 `MAVEN_HOME`，将刚才的安装目录填入变量值\n\n\n\n  在 `Path` 中进行配置\n\n  `%MAVEN_HOME%\\bin`\n\n  打开命令提示符进行验证:mvn -version\n\n* 配置本地仓库\n\n  修改 conf/settings.xml 中的 `<localRepository>` 为一个指定目录作为本地仓库，用来存储jar包。\n\n* 配置阿里云私服\n\n  中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。\n\n  修改 conf/settings.xml 中的 `<mirrors>`标签，为其添加如下子标签：\n\n  ```xml\n  <mirror>  \n      <id>alimaven</id>  \n      <name>aliyun maven</name>  \n      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n      <mirrorOf>central</mirrorOf>          \n  </mirror>\n  ```\n\n\n\n### 1.3  Maven基本使用\n\n#### 1.3.1  Maven 常用命令\n\n> * compile ：编译\n>\n> * clean：清理\n>\n> * test：测试\n>\n> * package：打包\n>\n> * install：安装\n\n**命令演示：**\n\n\n我们使用上面命令需要在磁盘上进入到项目的 `pom.xml` 目录下，打开命令提示符\n\n\n**编译命令演示：**\n\n```java\ncompile ：编译\n```\n\n执行上述命令可以看到：\n\n* 从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件\n* 在项目下会生成一个 `target` 目录\n\n\n同时在项目下会出现一个 `target` 目录，编译后的字节码文件就放在该目录下\n\n\n**清理命令演示：**\n\n```\nmvn clean\n```\n\n执行上述命令可以看到\n\n* 从阿里云下载清理需要的插件jar包\n* 删除项目下的 `target` 目录\n\n\n**打包命令演示：**\n\n```\nmvn package\n```\n\n执行上述命令可以看到：\n\n* 从阿里云下载打包需要的插件jar包\n* 在项目的 `terget` 目录下有一个jar包（将当前项目打成的jar包）\n\n\n**测试命令演示：**\n\n```\nmvn test  \n```\n\n该命令会执行所有的测试代码。执行上述命令效果如下\n\n**安装命令演示：**\n\n```\nmvn install\n```\n\n该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下：\n\n#### 1.3.2  Maven 生命周期\n\nMaven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件\n\nMaven 对项目构建的生命周期划分为3套：\n\n* clean ：清理工作。\n* default ：核心工作，例如编译，测试，打包，安装等。\n* site ： 产生报告，发布站点等。这套声明周期一般不会使用。\n\n同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：\n\n当我们执行 `install`（安装）命令时，它会先执行 `compile`命令，再执行 `test ` 命令，再执行 `package` 命令，最后执行 `install` 命令。\n\n当我们执行 `package` （打包）命令时，它会先执行 `compile` 命令，再执行 `test` 命令，最后执行 `package` 命令。\n\n默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的：\n\n\n\n### 1.4  IDEA使用Maven\n\n以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。\n\n#### 1.4.1  IDEA配置Maven环境\n\n我们需要先在IDEA中配置Maven环境：\n\n* 选择 IDEA中 File --\x3e Settings\n\n\n* 搜索 maven\n\n* 设置 IDEA 使用本地安装的 Maven，并修改配置文件路径\n\n\n#### 1.4.2  Maven 坐标详解\n\n**什么是坐标？**\n\n* Maven 中的坐标是==资源的唯一标识==\n* 使用坐标来定义项目或引入项目中需要的依赖\n\n**Maven 坐标主要组成**\n\n* groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\n* artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）\n* version：定义当前项目版本号\n\n\n> ==注意：==\n>\n> * 上面所说的资源可以是插件、依赖、当前项目。\n> * 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。\n\n#### 1.4.3  IDEA 创建 Maven项目\n\n* 创建模块，选择Maven，点击Next\n\n\n* 填写模块名称，坐标信息，点击finish，创建完成\n\n\n\n  创建好的项目目录结构如下：\n\n\n* 编写 HelloWorld，并运行\n\n#### 1.4.4  IDEA 导入 Maven项目\n\n大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入：\n\n* 选择右侧Maven面板，点击 + 号\n\n\n* 选中对应项目的pom.xml文件，双击即可\n\n\n* 如果没有Maven面板，选择\n\n  View --\x3e Appearance --\x3e Tool Window Bars\n\n\n\n\n可以通过下图所示进行命令的操作：\n\n\n**配置 Maven-Helper 插件**\n\n* 选择 IDEA中 File --\x3e Settings\n\n\n* 选择 Plugins\n\n\n* 搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept\n\n\n* 重启 IDEA\n\n安装完该插件后可以通过 选中项目右键进行相关命令操作.\n\n\n### 1.5  依赖管理\n\n#### 1.5.1  使用坐标引入jar包\n\n**使用坐标引入jar包的步骤：**\n\n* 在项目的 pom.xml 中编写 `<dependencies>` 标签\n\n* 在 `<dependencies>` 标签中使用 `<dependency>` 引入坐标\n\n* 定义坐标的 groupId，artifactId，version\n\n\n* 点击刷新按钮，使坐标生效\n\n\n>  注意：\n>\n>  * 具体的坐标我们可以到如下网站进行搜索\n>  * https://mvnrepository.com/\n\n**快捷方式导入jar包的坐标：**\n\n每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式\n\n* 在 pom.xml 中 按 alt + insert，选择 Dependency\n\n\n* 在弹出的面板中搜索对应坐标，然后双击选中对应坐标\n\n\n* 点击刷新按钮，使坐标生效\n\n\n**自动导入设置：**\n\n上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成\n\n* 选择 IDEA中 File --\x3e Settings\n\n\n* 在弹出的面板中找到 Build Tools\n\n\n* 选择 Any changes，点击 ok 即可生效\n\n#### 1.5.2  依赖范围\n\n通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。\n\n如下图所示给 `junit` 依赖通过 `scope` 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\n\n\n那么 `scope` 都可以有哪些取值呢？\n\n| **依赖范围** | 编译classpath | 测试classpath | 运行classpath | 例子              |\n| ------------ | ------------- | ------------- | ------------- | ----------------- |\n| **compile**  | Y             | Y             | Y             | logback           |\n| **test**     | -             | Y             | -             | Junit             |\n| **provided** | Y             | Y             | -             | servlet-api       |\n| **runtime**  | -             | Y             | Y             | jdbc驱动          |\n| **system**   | Y             | Y             | -             | 存储在本地的jar包 |\n\n* compile ：作用于编译环境、测试环境、运行环境。\n* test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值\n* provided ：作用于编译环境、测试环境。我们后面会学习 `servlet-api` ，在使用它时，必须将 `scope` 设置为该值，不然运行时就会报错\n* runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 `scope` 设置为该值，当然不设置也没有任何问题\n\n> 注意：\n>\n> * 如果引入坐标不指定 `scope` 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。\n\n\n## 1.6 maven命令行安装\nmvn dependency:copy -Dartifact=org.docx4j:docx4j:6.1.2 -DoutputDirectory=<output_directory>\n\n## maven 相关的bug\n### Could not transfer artifact\n去下载的库里面吧`lastUpdated`结尾的文件删除重新下载\n\n### the trustAnchors parameter must be non-empty\n更换jdk，或者卸载jdk\n\n### Failure to transfer……from\n`去下载的库里面吧`lastUpdated`结尾的文件删除重新下载`:和这个一样\n\n\n"},{title:"mybatis 的基础知识",headers:[{level:2,title:"2，Mybatis",slug:"_2-mybatis",link:"#_2-mybatis",children:[{level:3,title:"2.1  Mybatis概述",slug:"_2-1-mybatis概述",link:"#_2-1-mybatis概述",children:[]},{level:3,title:"2.2  Mybatis快速入门",slug:"_2-2-mybatis快速入门",link:"#_2-2-mybatis快速入门",children:[]},{level:3,title:"2.3  Mapper代理开发",slug:"_2-3-mapper代理开发",link:"#_2-3-mapper代理开发",children:[]},{level:3,title:"2.4  核心配置文件",slug:"_2-4-核心配置文件",link:"#_2-4-核心配置文件",children:[]}]},{level:2,title:"3.CRUD相关",slug:"_3-crud相关",link:"#_3-crud相关",children:[{level:3,title:"3.1 数据库字段和实体字段对不上",slug:"_3-1-数据库字段和实体字段对不上",link:"#_3-1-数据库字段和实体字段对不上",children:[]},{level:3,title:"3.2.参数暂位符",slug:"_3-2-参数暂位符",link:"#_3-2-参数暂位符",children:[]},{level:3,title:"3.3.parameterType使用",slug:"_3-3-parametertype使用",link:"#_3-3-parametertype使用",children:[]},{level:3,title:"3.4.SQL语句中特殊字段处理",slug:"_3-4-sql语句中特殊字段处理",link:"#_3-4-sql语句中特殊字段处理",children:[]},{level:3,title:"3.5.多条件查询",slug:"_3-5-多条件查询",link:"#_3-5-多条件查询",children:[]},{level:3,title:"4.Mybatis参数传递",slug:"_4-mybatis参数传递",link:"#_4-mybatis参数传递",children:[]},{level:3,title:"5.注解实现CRUD",slug:"_5-注解实现crud",link:"#_5-注解实现crud",children:[]}]},{level:2,title:"mybatis 注解相关",slug:"mybatis-注解相关",link:"#mybatis-注解相关",children:[{level:3,title:"日志",slug:"日志",link:"#日志",children:[]},{level:3,title:"@Mapper注解：",slug:"mapper注解",link:"#mapper注解",children:[]},{level:3,title:"@MapperScan",slug:"mapperscan",link:"#mapperscan",children:[]},{level:3,title:"使用@MapperScan注解多个包",slug:"使用-mapperscan注解多个包",link:"#使用-mapperscan注解多个包",children:[]},{level:3,title:"如果dao接口类没有在Spring Boot主程序可以扫描的包或者子包下面，可以使用如下方式进行配置：",slug:"如果dao接口类没有在spring-boot主程序可以扫描的包或者子包下面-可以使用如下方式进行配置",link:"#如果dao接口类没有在spring-boot主程序可以扫描的包或者子包下面-可以使用如下方式进行配置",children:[]},{level:3,title:"SqlSessionTemplate",slug:"sqlsessiontemplate",link:"#sqlsessiontemplate",children:[]}]},{level:2,title:"mybatis 遇到的相关bug",slug:"mybatis-遇到的相关bug",link:"#mybatis-遇到的相关bug",children:[]}],path:"/posts/java/dependence/mybatis.html",pathLocale:"/",extraFields:'---\ntitle: mybatis 的基础知识\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - dependence\n\ntag:\n  - java\n  - spring\n  - springboot\n  - mybatis\n\n---\n\nmybatis 的基本使用\n\x3c!-- more --\x3e\n\n\n# Mybatis\n\n## 2，Mybatis\n\n### 2.1  Mybatis概述\n\n#### 2.1.1  Mybatis概念\n\n> * MyBatis 是一款优秀的==持久层框架==，用于简化 JDBC 开发\n>\n> * MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github\n>\n> * 官网：https://mybatis.org/mybatis-3/zh/index.html\n\n**持久层：**\n\n* 负责将数据到保存到数据库的那一层代码。\n\n  以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。\n\n* JavaEE三层架构：表现层、业务层、持久层\n\n  三层架构在后期会给大家进行讲解，今天先简单的了解下即可。\n\n**框架：**\n\n* 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n* 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦\n\n\n一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦\n\n\n了解了什么是Mybatis后，接下来说说以前 `JDBC代码` 的缺点以及Mybatis又是如何解决的。\n\n#### 2.1.2  JDBC 缺点\n\n下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：\n\n\n* 硬编码\n\n    * 注册驱动、获取连接\n\n      代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。\n\n    * SQL语句\n\n      如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。\n\n* 操作繁琐\n\n    * 手动设置参数\n\n    * 手动封装结果集\n\n      对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。\n\n#### 2.1.3  Mybatis 优化\n\n* 硬编码可以配置到==配置文件==\n* 操作繁琐的地方mybatis都==自动完成==\n\n\n### 2.2  Mybatis快速入门\n\n**需求：查询user表中所有的数据**\n\n* 创建user表，添加数据\n\n  ```sql\n  create database mybatis;\n  use mybatis;\n  \n  drop table if exists tb_user;\n  \n  create table tb_user(\n  \tid int primary key auto_increment,\n  \tusername varchar(20),\n  \tpassword varchar(20),\n  \tgender char(1),\n  \taddr varchar(30)\n  );\n  \n  INSERT INTO tb_user VALUES (1, \'zhangsan\', \'123\', \'男\', \'北京\');\n  INSERT INTO tb_user VALUES (2, \'李四\', \'234\', \'女\', \'天津\');\n  INSERT INTO tb_user VALUES (3, \'王五\', \'11\', \'男\', \'西安\');\n  ```\n\n* 创建模块，导入坐标\n\n  在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标\n\n  ```xml\n  <dependencies>\n      \x3c!--mybatis 依赖--\x3e\n      <dependency>\n          <groupId>org.mybatis</groupId>\n          <artifactId>mybatis</artifactId>\n          <version>3.5.5</version>\n      </dependency>\n  \n      \x3c!--mysql 驱动--\x3e\n      <dependency>\n          <groupId>mysql</groupId>\n          <artifactId>mysql-connector-java</artifactId>\n          <version>5.1.46</version>\n      </dependency>\n  \n      \x3c!--junit 单元测试--\x3e\n      <dependency>\n          <groupId>junit</groupId>\n          <artifactId>junit</artifactId>\n          <version>4.13</version>\n          <scope>test</scope>\n      </dependency>\n  \n      \x3c!-- 添加slf4j日志api --\x3e\n      <dependency>\n          <groupId>org.slf4j</groupId>\n          <artifactId>slf4j-api</artifactId>\n          <version>1.7.20</version>\n      </dependency>\n      \x3c!-- 添加logback-classic依赖 --\x3e\n      <dependency>\n          <groupId>ch.qos.logback</groupId>\n          <artifactId>logback-classic</artifactId>\n          <version>1.2.3</version>\n      </dependency>\n      \x3c!-- 添加logback-core依赖 --\x3e\n      <dependency>\n          <groupId>ch.qos.logback</groupId>\n          <artifactId>logback-core</artifactId>\n          <version>1.2.3</version>\n      </dependency>\n  </dependencies>\n  ```\n\n  注意：需要在项目的 resources 目录下创建logback的配置文件\n\n* 编写 MyBatis 核心配置文件 -- > 替换连接信息 解决硬编码问题\n\n  在模块下的 resources 目录下创建mybatis的配置文件 `mybatis-config.xml`，内容如下：\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <!DOCTYPE configuration\n          PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n          "http://mybatis.org/dtd/mybatis-3-config.dtd">\n  <configuration>\n  \n      <typeAliases>\n          <package name="com.itheima.pojo"/>\n      </typeAliases>\n      \n      \x3c!--\n      environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment\n      --\x3e\n      <environments default="development">\n          <environment id="development">\n              <transactionManager type="JDBC"/>\n              <dataSource type="POOLED">\n                  \x3c!--数据库连接信息--\x3e\n                  <property name="driver" value="com.mysql.jdbc.Driver"/>\n                  <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n                  <property name="username" value="root"/>\n                  <property name="password" value="1234"/>\n              </dataSource>\n          </environment>\n  \n          <environment id="test">\n              <transactionManager type="JDBC"/>\n              <dataSource type="POOLED">\n                  \x3c!--数据库连接信息--\x3e\n                  <property name="driver" value="com.mysql.jdbc.Driver"/>\n                  <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n                  <property name="username" value="root"/>\n                  <property name="password" value="1234"/>\n              </dataSource>\n          </environment>\n      </environments>\n      <mappers>\n         \x3c!--加载sql映射文件--\x3e\n         <mapper resource="UserMapper.xml"/>\n      </mappers>\n  </configuration>\n  ```\n\n* 编写 SQL 映射文件 --\x3e 统一管理sql语句，解决硬编码问题\n\n  在模块的 `resources` 目录下创建映射配置文件 `UserMapper.xml`，内容如下：\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n  <mapper namespace="test">\n      <select id="selectAll" resultType="com.itheima.pojo.User">\n          select * from tb_user;\n      </select>\n  </mapper>\n  ```\n\n* 编码\n\n    * 在 `com.itheima.pojo` 包下创建 User类\n\n      ```java\n      public class User {\n          private int id;\n          private String username;\n          private String password;\n          private String gender;\n          private String addr;\n          \n          //省略了 setter 和 getter\n      }\n      ```\n\n    * 在 `com.itheima` 包下编写 MybatisDemo 测试类\n\n      ```java\n      public class MyBatisDemo {\n      \n          public static void main(String[] args) throws IOException {\n              //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory\n              String resource = "mybatis-config.xml";\n              InputStream inputStream = Resources.getResourceAsStream(resource);\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n      \n              //2. 获取SqlSession对象，用它来执行sql\n              SqlSession sqlSession = sqlSessionFactory.openSession();\n              //3. 执行sql\n              List<User> users = sqlSession.selectList("test.selectAll"); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id\n              System.out.println(users);\n              //4. 释放资源\n              sqlSession.close();\n          }\n      }\n      ```\n\n**解决SQL映射文件的警告提示：**\n\n在入门案例映射配置文件中存在报红的情况。问题如下：\n\n* 产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。\n* 解决方式：在Idea中配置MySQL数据库连接。\n\nIDEA中配置MySQL数据库连接\n\n* 点击IDEA右边框的 `Database` ，在展开的界面点击 `+` 选择 `Data Source` ，再选择 `MySQL`\n\n\n* 在弹出的界面进行基本信息的填写\n\n* 点击完成后就能看到一个操作界面\n  而此界面就和 `navicat` 工具一样可以进行数据库的操作。也可以编写SQL语句\n\n\n### 2.3  Mapper代理开发\n\n#### 2.3.1  Mapper代理开发概述\n\n之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下：\n\n\n这里调用 `selectList()` 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式则不存在硬编码问题。\n\n\n通过上面的描述可以看出 Mapper 代理方式的目的：\n\n* 解决原生方式中的硬编码\n* 简化后期执行SQL\n\nMybatis 官网也是推荐使用 Mapper 代理的方式。\n\n\n\n#### 2.3.2  使用Mapper代理要求\n\n使用Mapper代理方式，必须满足以下要求：\n\n* 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n\n* 设置SQL映射文件的namespace属性为Mapper接口全限定名\n\n\n* 在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n\n\n#### 2.3.3  案例代码实现\n\n* 在 `com.itheima.mapper` 包下创建 UserMapper接口，代码如下：\n\n  ```java\n  public interface UserMapper {\n      List<User> selectAll();\n      User selectById(int id);\n  }\n  ```\n\n* 在 `resources` 下创建 `com/itheima/mapper` 目录，并在该目录下创建 UserMapper.xml 映射配置文件\n\n  ```xml\n  \x3c!--\n      namespace:名称空间。必须是对应接口的全限定名\n  --\x3e\n  <mapper namespace="com.itheima.mapper.UserMapper">\n      <select id="selectAll" resultType="com.itheima.pojo.User">\n          select *\n          from tb_user;\n      </select>\n  </mapper>\n  ```\n\n* 在 `com.itheima` 包下创建 MybatisDemo2 测试类，代码如下：\n\n  ```java\n  /**\n   * Mybatis 代理开发\n   */\n  public class MyBatisDemo2 {\n  \n      public static void main(String[] args) throws IOException {\n  \n          //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory\n          String resource = "mybatis-config.xml";\n          InputStream inputStream = Resources.getResourceAsStream(resource);\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n  \n          //2. 获取SqlSession对象，用它来执行sql\n          SqlSession sqlSession = sqlSessionFactory.openSession();\n          //3. 执行sql\n          //3.1 获取UserMapper接口的代理对象\n          UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n          List<User> users = userMapper.selectAll();\n  \n          System.out.println(users);\n          //4. 释放资源\n          sqlSession.close();\n      }\n  }\n  ```\n\n==注意：==\n\n如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为\n\n```xml\n<mappers>\n    \x3c!--加载sql映射文件--\x3e\n    \x3c!-- <mapper resource="com/itheima/mapper/UserMapper.xml"/>--\x3e\n    \x3c!--Mapper代理方式--\x3e\n    <package name="com.itheima.mapper"/>\n</mappers>\n```\n\n\n\n### 2.4  核心配置文件\n\n核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容\n\n<img src="assets/image-20210726221454927.png" alt="image-20210726221454927" style="zoom:80%;" />\n\n接下来我们先对里面的一些配置进行讲解。\n\n#### 2.4.1  多环境配置\n\n在核心配置文件的 `environments` 标签中其实是可以配置多个 `environment` ，使用 `id` 给每段环境起名，在 `environments` 中使用 `default=\'环境id\'` 来指定使用哪儿段配置。我们一般就配置一个 `environment` 即可。\n\n```xml\n<environments default="development">\n    <environment id="development">\n        <transactionManager type="JDBC"/>\n        <dataSource type="POOLED">\n            \x3c!--数据库连接信息--\x3e\n            <property name="driver" value="com.mysql.jdbc.Driver"/>\n            <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n            <property name="username" value="root"/>\n            <property name="password" value="1234"/>\n        </dataSource>\n    </environment>\n\n    <environment id="test">\n        <transactionManager type="JDBC"/>\n        <dataSource type="POOLED">\n            \x3c!--数据库连接信息--\x3e\n            <property name="driver" value="com.mysql.jdbc.Driver"/>\n            <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n            <property name="username" value="root"/>\n            <property name="password" value="1234"/>\n        </dataSource>\n    </environment>\n</environments>\n```\n\n#### 2.4.2  类型别名\n\n在映射配置文件中的 `resultType` 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 `类型别名`(typeAliases) 可以简化这部分的书写。\n\n首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下：\n\n```xml\n<typeAliases>\n    \x3c!--name属性的值是实体类所在包--\x3e\n    <package name="com.itheima.pojo"/> \n</typeAliases>\n```\n\n通过上述的配置，我们就可以简化映射配置文件中 `resultType` 属性值的编写\n\n```xml\n<mapper namespace="com.itheima.mapper.UserMapper">\n    <select id="selectAll" resultType="user">\n        select * from tb_user;\n    </select>\n</mapper>\n```\n\n## 3.CRUD相关\n\n### 3.1 数据库字段和实体字段对不上\n#### 3.1.1.我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。\n```xml\n<select id="selectAll" resultType="brand">\n    select\n    id, brand_name as brandName, company_name as companyName, ordered, description, status\n    from tb_brand;\n</select>\n```\n而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了`sql` 片段可以提高sql的复用性。\n\n**SQL片段：**\n\n* 将需要复用的SQL片段抽取到 `sql` 标签中\n\n  ```xml\n  <sql id="brand_column">\n  \tid, brand_name as brandName, company_name as companyName, ordered, description, status\n  </sql>\n  ```\n\n  id属性值是唯一标识，引用时也是通过该值进行引用。\n* 在原sql语句中进行引用\n\n  使用 `include` 标签引用上述的 SQL 片段，而 `refid` 指定上述 SQL 片段的id值。\n\n  ```xml\n  <select id="selectAll" resultType="brand">\n      select\n      <include refid="brand_column" />\n      from tb_brand;\n  </select>\n  ```\n#### 3.1.2.使用resultMap\n起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。\n\n那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。\n\n* 在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系\n\n  ```xml\n  <resultMap id="brandResultMap" type="brand">\n      \x3c!--\n              id：完成主键字段的映射\n                  column：表的列名\n                  property：实体类的属性名\n              result：完成一般字段的映射\n                  column：表的列名\n                  property：实体类的属性名\n          --\x3e\n      <result column="brand_name" property="brandName"/>\n      <result column="company_name" property="companyName"/>\n  </resultMap>\n  ```\n\n  > 注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。\n\n* SQL语句正常编写\n\n  ```xml\n  <select id="selectAll" resultMap="brandResultMap">\n      select *\n      from tb_brand;\n  </select>\n  ```\n### 3.2.参数暂位符\nmybatis提供了两种参数占位符：\n\n* #{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 `PreparedStatement`\n\n* ${} ：拼接SQL。底层使用的是 `Statement`，会存在SQL注入问题。\n\n  ```xml\n  <select id="selectById"  resultMap="brandResultMap">\n      select *\n      from tb_brand where id = ${id};\n  </select>\n  ```\n  \n\n#{} 的SQL日志 会是一个 ？,eg：select  * from user where id = ?\n${} 的SQL日志 会直接图换掉参数的值 value,eg：select  * from user where id = 1\n\n### 3.3.parameterType使用\n对于有参数的mapper接口方法，我们在映射配置文件中应该配置 `ParameterType` 来指定参数类型。只不过该属性都可以省略。如下图：\n\n```xml\n<select id="selectById" parameterType="int" resultMap="brandResultMap">\n    select *\n    from tb_brand where id = ${id};\n</select>\n```\n\n### 3.4.SQL语句中特殊字段处理\n以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值，如`select * from user where id < #{id}`\n可以看出报错了，因为映射配置文件是xml类型的问题，而 > < 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义\n转义字符\n\n* 小于是 `&lt;` 就是 `<` 的转义字符。eg:`select * from user where id &lt; #{id};`\n* \\<![CDATA[内容]]>。eg:`select * from user where id <![CDATA[<]> #{id};`\n\n### 3.5.多条件查询\n\n#### 3.5.1.编写接口的方法\n\n假如一个功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现\n\n* 使用 `@Param("参数名称")` 标记每一个参数，在映射配置文件中就需要使用 `#{参数名称}` 进行占位\n\n  ```java\n  List<Brand> selectByCondition(@Param("status") int status, @Param("companyName") String companyName,@Param("brandName") String brandName);\n  ```\n\n* 将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 `#{内容}` 时，里面的内容必须和实体类属性名保持一致。\n\n  ```java\n  List<Brand> selectByCondition(Brand brand);\n  ```\n\n* 将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 `#{内容}` 时，里面的内容必须和map集合中键的名称一致。\n\n  ```\n  List<Brand> selectByCondition(Map map);\n  ```\n\n#### 3.5.2  动态SQL\n\n用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写死的\n\n例如用户只输入 当前状态 时，SQL语句就是\n\n```sql\nselect * from tb_brand where status = #{status}\n```\n\n而用户如果只输入企业名称时，SQL语句就是\n\n```sql\nselect * from tb_brand where company_name like #{companName}\n```\n\n而用户如果输入了 `当前状态` 和 `企业名称 ` 时，SQL语句又不一样\n\n```sql\nselect * from tb_brand where status = #{status} and company_name like #{companName}\n```\n\n针对上述的需要，Mybatis对动态SQL有很强大的支撑：\n\n> * if\n>\n> * choose (when, otherwise)\n>\n> * trim (where, set)\n>\n> * foreach\n\n我们先学习 if 标签和 where 标签：\n\n* if 标签：条件判断\n\n  * test 属性：逻辑表达式\n\n  ```xml\n  <select id="selectByCondition" resultMap="brandResultMap">\n      select *\n      from tb_brand\n      where\n          <if test="status != null">\n              and status = #{status}\n          </if>\n          <if test="companyName != null and companyName != \'\' ">\n              and company_name like #{companyName}\n          </if>\n          <if test="brandName != null and brandName != \'\' ">\n              and brand_name like #{brandName}\n          </if>\n  </select>\n  ```\n\n  如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。\n\n* 但是它也存在问题，如果此时给的参数值是\n\n  ```java\n  Map map = new HashMap();\n  // map.put("status" , status);\n  map.put("companyName", companyName);\n  map.put("brandName" , brandName);\n  ```\n\n  拼接的SQL语句就变成了\n\n  ```sql\n  select * from tb_brand where and company_name like ? and brand_name like ?\n  ```\n\n  而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决\n\n* where 标签\n\n  * 作用：\n    * 替换where关键字\n    * 会动态的去掉第一个条件前的 and \n    * 如果所有的参数没有值则不加where关键字\n\n  ```xml\n  <select id="selectByCondition" resultMap="brandResultMap">\n      select *\n      from tb_brand\n      <where>\n          <if test="status != null">\n              and status = #{status}\n          </if>\n          <if test="companyName != null and companyName != \'\' ">\n              and company_name like #{companyName}\n          </if>\n          <if test="brandName != null and brandName != \'\' ">\n              and brand_name like #{brandName}\n          </if>\n      </where>\n  </select>\n  ```\n\n  > 注意：需要给每个条件前都加上 and 关键字。\n\n#### 3.5.3.单个条件（动态SQL）\n\n在查询时如果只能选择 `品牌名称`、`当前状态`、`企业名称` 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 \n\n这种需求需要使用到  `choose（when，otherwise）标签`  实现，  而 `choose` 标签类似于Java 中的switch语句。\n\n通过一个案例来使用这些标签\n\n##### 3.5.3.1. 编写接口方法\n\n在 `BrandMapper` 接口中定义单条件查询的方法。\n\n```java\n/**\n  * 单条件动态查询\n  * @param brand\n  * @return\n  */\nList<Brand> selectByConditionSingle(Brand brand);\n```\n\n##### 3.5.3.2. 编写SQL语句\n\n在 `BrandMapper.xml` 映射配置文件中编写 `statement`，使用 `resultMap` 而不是使用 `resultType`\n\n```xml\n<select id="selectByConditionSingle" resultMap="brandResultMap">\n    select *\n    from tb_brand\n    <where>\n        <choose>\x3c!--相当于switch--\x3e\n            <when test="status != null">\x3c!--相当于case--\x3e\n                status = #{status}\n            </when>\n            <when test="companyName != null and companyName != \'\' ">\x3c!--相当于case--\x3e\n                company_name like #{companyName}\n            </when>\n            <when test="brandName != null and brandName != \'\'">\x3c!--相当于case--\x3e\n                brand_name like #{brandName}\n            </when>\n        </choose>\n    </where>\n</select>\n```\n\n##### 3.5.3.3. 编写测试方法\n\n在 `test/java` 下的 `com.itheima.mapper`  包下的 `MybatisTest类中` 定义测试方法\n\n```java\n@Test\npublic void testSelectByConditionSingle() throws IOException {\n    //接收参数\n    int status = 1;\n    String companyName = "华为";\n    String brandName = "华为";\n\n    // 处理参数\n    companyName = "%" + companyName + "%";\n    brandName = "%" + brandName + "%";\n\n    //封装对象\n    Brand brand = new Brand();\n    //brand.setStatus(status);\n    brand.setCompanyName(companyName);\n    //brand.setBrandName(brandName);\n\n    //1. 获取SqlSessionFactory\n    String resource = "mybatis-config.xml";\n    InputStream inputStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n    //2. 获取SqlSession对象\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    //3. 获取Mapper接口的代理对象\n    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);\n    //4. 执行方法\n    List<Brand> brands = brandMapper.selectByConditionSingle(brand);\n    System.out.println(brands);\n\n    //5. 释放资源\n    sqlSession.close();\n}\n```\n\n\n\n#### 3.5.4.获取插入数据的主键\n\n将映射配置文件里 `statement` 进行修改，如下\n\n```xml\n<insert id="add" useGeneratedKeys="true" keyProperty="id">\n    insert into tb_brand (brand_name, company_name, ordered, description, status)\n    values (#{brandName}, #{companyName}, #{ordered}, #{description}, #{status});\n</insert>\n```\n\n> 在 insert 标签上添加如下属性：\n>\n> * useGeneratedKeys：是够获取自动增长的主键值。true表示获取\n> * keyProperty  ：指定将获取到的主键值封装到哪儿个属性里\n\n#### 3.5.5.update\n\n在 `BrandMapper.xml` 映射配置文件中编写修改数据的 `statement`。\n\n```xml\n<update id="update">\n    update tb_brand\n    <set>\n        <if test="brandName != null and brandName != \'\'">\n            brand_name = #{brandName},\n        </if>\n        <if test="companyName != null and companyName != \'\'">\n            company_name = #{companyName},\n        </if>\n        <if test="ordered != null">\n            ordered = #{ordered},\n        </if>\n        <if test="description != null and description != \'\'">\n            description = #{description},\n        </if>\n        <if test="status != null">\n            status = #{status}\n        </if>\n    </set>\n    where id = #{id};\n</update>\n```\n\n> *set* 标签可以用于动态包含需要更新的列，忽略其它不更新的列。\n\n#### 3.5.6.批量删除\n\n在 `BrandMapper` 接口中定义删除多行数据的方法。\n\n```java\n/**\n  * 批量删除\n  */\nvoid deleteByIds(int[] ids);\n```\n\n> 参数是一个数组，数组中存储的是多条数据的id\n\n在 `BrandMapper.xml` 映射配置文件中编写删除多条数据的 `statement`。\n\n编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 `foreach` 标签供我们使用\n\n**foreach 标签**\n\n用来迭代任何可迭代的对象（如数组，集合）。\n\n* collection 属性：\n  * mybatis会将数组参数，封装为一个Map集合。\n    * 默认：array = 数组\n    * 使用@Param注解改变map集合的默认key的名称\n* item 属性：本次迭代获取到的元素。\n* separator 属性：集合项迭代之间的分隔符。`foreach` 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。\n* open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次\n* close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次\n\n```xml\n<delete id="deleteByIds">\n    delete from tb_brand where id\n    in\n    <foreach collection="array" item="id" separator="," open="(" close=")">\n        #{id}\n    </foreach>\n    ;\n</delete>\n```\n\n> 假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：\n>\n> ```sql\n> delete from tb_brand where id in (1,2,3);\n> ```\n\n**编写测试方法**\n\n在 `test/java` 下的 `com.itheima.mapper`  包下的 `MybatisTest类中` 定义测试方法\n\n```java\n@Test\npublic void testDeleteByIds() throws IOException {\n    //接收参数\n    int[] ids = {5,7,8};\n\n    //1. 获取SqlSessionFactory\n    String resource = "mybatis-config.xml";\n    InputStream inputStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n    //2. 获取SqlSession对象\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    //SqlSession sqlSession = sqlSessionFactory.openSession(true);\n    //3. 获取Mapper接口的代理对象\n    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);\n    //4. 执行方法\n    brandMapper.deleteByIds(ids);\n    //提交事务\n    sqlSession.commit();\n    //5. 释放资源\n    sqlSession.close();\n}\n```\n\n### 4.Mybatis参数传递\n\nMybatis 接口方法中可以接收各种各样的参数，如下：\n\n* 多个参数\n* 单个参数：单个参数又可以是如下类型\n  * POJO 类型\n  * Map 集合类型\n  * Collection 集合类型\n  * List 集合类型\n  * Array 类型\n  * 其他类型\n\n#### 4.1  多个参数\n\n如下面的代码，就是接收两个参数，而接收多个参数需要使用 `@Param` 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。\n\n```java\nUser select(@Param("username") String username,@Param("password") String password);\n```\n\n```xml\n<select id="select" resultType="user">\n\tselect *\n    from tb_user\n    where \n    \tusername=#{username}\n    \tand password=#{password}\n</select>\n```\n\n我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 `@Param` 注解时有以下命名规则：\n\n* 以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：\n\n  > map.put("arg0"，参数值1);\n  >\n  > map.put("arg1"，参数值2);\n\n* 以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：\n\n  > map.put("param1"，参数值1);\n  >\n  > map.put("param2"，参数值2);\n\n**代码验证：**\n\n* 在 `UserMapper` 接口中定义如下方法\n\n  ```java\n  User select(String username,String password);\n  ```\n\n* 在 `UserMapper.xml` 映射配置文件中定义SQL\n\n  ```xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{arg0}\n      \tand password=#{arg1}\n  </select>\n  ```\n\n  或者\n\n  ```xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{param1}\n      \tand password=#{param2}\n  </select>\n  ```\n\n  * 在映射配合文件的SQL语句中使用用 `arg` 开头的和 `param` 书写，代码的可读性会变的特别差，此时可以使用 `@Param` 注解。\n\n  在接口方法参数上使用 `@Param` 注解，Mybatis 会将 `arg` 开头的键名替换为对应注解的属性值。\n\n\n\n**代码验证：**\n\n* 在 `UserMapper` 接口中定义如下方法，在 `username` 参数前加上 `@Param` 注解\n\n  ```java\n  User select(@Param("username") String username, String password);\n  ```\n\n  Mybatis 在封装 Map 集合时，键名就会变成如下：\n\n  > map.put("username"，参数值1);\n  >\n  > map.put("arg1"，参数值2);\n  >\n  > map.put("param1"，参数值1);\n  >\n  > map.put("param2"，参数值2);\n\n* 在 `UserMapper.xml` 映射配置文件中定义SQL\n\n  ```xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{username}\n      \tand password=#{param2}\n  </select>\n  ```\n\n* 运行程序结果没有报错。而如果将 `#{}` 中的 `username` 还是写成  `arg0` \n\n  ```xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{arg0}\n      \tand password=#{param2}\n  </select>\n  ```\n\n* 运行程序则可以看到错误\n\n==结论：以后接口参数是多个时，在每个参数上都使用 `@Param` 注解。这样代码的可读性更高。==\n\n#### 4.2  单个参数\n\n* POJO 类型\n\n  直接使用。要求 `属性名` 和 `参数占位符名称` 一致\n\n* Map 集合类型\n\n  直接使用。要求 `map集合的键名` 和 `参数占位符名称` 一致\n\n* Collection 集合类型\n\n  Mybatis 会将集合封装到 map 集合中，如下：\n\n  > map.put("arg0"，collection集合);\n  >\n  > map.put("collection"，collection集合;\n\n  == 可以使用 `@Param` 注解替换map集合中默认的 arg 键名。==\n\n* List 集合类型\n\n  Mybatis 会将集合封装到 map 集合中，如下：\n\n  > map.put("arg0"，list集合);\n  >\n  > map.put("collection"，list集合);\n  >\n  > map.put("list"，list集合);\n\n  ==可以使用 `@Param` 注解替换map集合中默认的 arg 键名。==\n\n* Array 类型\n\n  Mybatis 会将集合封装到 map 集合中，如下：\n\n  > map.put("arg0"，数组);\n  >\n  > map.put("array"，数组);\n\n  ==可以使用 `@Param` 注解替换map集合中默认的 arg 键名。==\n\n* 其他类型\n\n  比如int类型，`参数占位符名称` 叫什么都可以。尽量做到见名知意\n\n### 5.注解实现CRUD\n\n使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发\n\n```java\n@Select(value = "select * from tb_user where id = #{id}")\npublic User select(int id);\n```\n\n> ==注意：==\n>\n> * 注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 `statement`\n\nMybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：\n\n* 查询 ：@Select\n* 添加 ：@Insert\n* 修改 ：@Update\n* 删除 ：@Delete\n\n## mybatis 注解相关\n\n### 日志\n```yaml\nlogging.level.路径=debug，eg：`logging.level.com.zzqa.amc.dao=debug`\n```\n\n\n### @Mapper注解：\n作用：在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类\n添加位置：接口类上面\n```java\n@Mapper\npublic interface UserDAO {\n//代码\n}\n```\n\n如果想要每个接口都要变成实现类，那么需要在每个接口类上加上@Mapper注解，比较麻烦，解决这个问题用@MapperScan\n\n### @MapperScan\n作用：指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类\n添加位置：是在Springboot启动类上面添加，\n```java\n@SpringBootApplication\n@MapperScan("com.位置.dao")\npublic class SpringbootMybatisDemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootMybatisDemoApplication.class, args);\n    }\n}\n```\n\n添加@MapperScan(“com.位置.dao”)注解以后，com.乌贼骨.dao包下面的接口类，在编译之后都会生成相应的实现类\n\n### 使用@MapperScan注解多个包\n（实际用的时候根据自己的包路径进行修改）\n```java\n@SpringBootApplication\n@MapperScan({"com.h1.demo","com.h2.user"})\npublic class App {\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n}\n```\n\n### 如果dao接口类没有在Spring Boot主程序可以扫描的包或者子包下面，可以使用如下方式进行配置：\n（没验证过，不确定能否使用，或许需要根据自己定义的包名进行修改路径）\n```java\n@Configuration//将想要的组件添加到容器中\n@MapperScan({"com.h1.*.mapper","org.h2.*.mapper"})\npublic class App {\n    // TODO 想要的操作\n}\n```\n\n### SqlSessionTemplate\nSqlSessionTemplate是MyBatis-Spring的核心。这个类负责管理MyBatis的SqlSession,调用MyBatis的SQL方法。SqlSessionTemplate是线程安全的，可以被多个DAO所共享使用。\n\n当调用SQL方法时，包含从映射器getMapper()方法返回的方法，SqlSessionTemplate将会保证使用的SqlSession是和当前Spring的事务相关的。此外，它管理session的生命周期，包含必要的关闭，提交或回滚操作。\n\nqlSessionTemplate实现了SqlSession，这就是说要对MyBatis的SqlSession进行简易替换。\n\nSqlSessionTemplate通常是被用来替代默认的MyBatis实现的DefaultSqlSession，因为它不能参与到Spring的事务中也不能被注入，因为它是线程不安全的。相同应用程序中两个类之间的转换可能会引起数据一致性的问题。\nSqlSessionTemplate对象可以使用SqlSessionFactory作为构造方法的参数来创建。\n\n## mybatis 遇到的相关bug\n\n# org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)\n绑定异常，没有写配置类\n\n```yaml\nmybatis:\n  mapper-locations: classpath:mapper/*.xml\n```\n'},{title:"netty 学习",headers:[{level:2,title:"基本使用",slug:"基本使用",link:"#基本使用",children:[]},{level:2,title:"不同 handler 的作用",slug:"不同-handler-的作用",link:"#不同-handler-的作用",children:[]}],path:"/posts/java/dependence/netty.html",pathLocale:"/",extraFields:"---\ntitle: netty 学习\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - dependence\n\ntag:\n  - java\n  - spring\n  - springboot\n  - netty\n\n---\n\nnetty 学习\n\x3c!-- more --\x3e\n# netty study\n\n\n## 基本使用\n\n在使用springboot的情况下，引入依赖\n\n```shell\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n</dependency>\n```\n\n1.实现 discard 协议。 如 example.netty.discard 中的代码实现。启动它，使用 telnet localhost 8080 连接发送消息。您就可以在服务器看到打印内容。 2.实现 echo 协议。 如\nexample.netty.echo 中的代码实现（在discard基础上修改）。然后 telnet localhost 8080 连接成功后，发送什么给服务端您都可以在客户端看见 3.实现 time 协议。 如\nexample.netty.time 中的代码实现（在echo基础上修改）。然后 telnet localhost 8080 连接成功后，控制台有打印，连接立即会断开。\n\n## 不同 handler 的作用\n\n1. LengthFieldBasedFrameDecoder\n\n   作用\n    * 解决粘包和拆包问题：\n        - 粘包：多个消息被合并成一个大的数据包发送。\n        - 拆包：一个完整的消息被拆分成多个小的数据包发送。\n    * 基于长度字段解析消息：\n        - 通过解析消息中的长度字段，确定每个消息的实际长度，从而正确地分割出一个个完整的消息帧。\n\n2. MessageToMessageCodec<ByteBuf, PacketHeader>\n\n   作用\n    * 编码：将 PacketHeader 对象编码为 ByteBuf，以便在网络中传输。\n    * 解码：将接收到的 ByteBuf 解码为 PacketHeader 对象，以便应用程序处理。\n\n"},{title:"NIO 基础",headers:[{level:2,title:"1. 三大组件",slug:"_1-三大组件",link:"#_1-三大组件",children:[{level:3,title:"1.1 Channel & Buffer",slug:"_1-1-channel-buffer",link:"#_1-1-channel-buffer",children:[]},{level:3,title:"1.2 Selector",slug:"_1-2-selector",link:"#_1-2-selector",children:[]}]},{level:2,title:"2. ByteBuffer",slug:"_2-bytebuffer",link:"#_2-bytebuffer",children:[{level:3,title:"2.1  ByteBuffer 正确使用姿势",slug:"_2-1-bytebuffer-正确使用姿势",link:"#_2-1-bytebuffer-正确使用姿势",children:[]},{level:3,title:"2.2 ByteBuffer 结构",slug:"_2-2-bytebuffer-结构",link:"#_2-2-bytebuffer-结构",children:[]},{level:3,title:"2.3 ByteBuffer 常见方法",slug:"_2-3-bytebuffer-常见方法",link:"#_2-3-bytebuffer-常见方法",children:[]},{level:3,title:"2.4 Scattering Reads",slug:"_2-4-scattering-reads",link:"#_2-4-scattering-reads",children:[]},{level:3,title:"2.5 Gathering Writes",slug:"_2-5-gathering-writes",link:"#_2-5-gathering-writes",children:[]},{level:3,title:"2.6 练习",slug:"_2-6-练习",link:"#_2-6-练习",children:[]}]},{level:2,title:"3. 文件编程",slug:"_3-文件编程",link:"#_3-文件编程",children:[{level:3,title:"3.1 FileChannel",slug:"_3-1-filechannel",link:"#_3-1-filechannel",children:[]},{level:3,title:"3.2 两个 Channel 传输数据",slug:"_3-2-两个-channel-传输数据",link:"#_3-2-两个-channel-传输数据",children:[]},{level:3,title:"3.3 Path",slug:"_3-3-path",link:"#_3-3-path",children:[]},{level:3,title:"3.4 Files",slug:"_3-4-files",link:"#_3-4-files",children:[]}]},{level:2,title:"4. 网络编程",slug:"_4-网络编程",link:"#_4-网络编程",children:[{level:3,title:"4.1 非阻塞 vs 阻塞",slug:"_4-1-非阻塞-vs-阻塞",link:"#_4-1-非阻塞-vs-阻塞",children:[]},{level:3,title:"4.2 Selector",slug:"_4-2-selector",link:"#_4-2-selector",children:[]},{level:3,title:"4.3 处理 accept 事件",slug:"_4-3-处理-accept-事件",link:"#_4-3-处理-accept-事件",children:[]},{level:3,title:"4.4 处理 read 事件",slug:"_4-4-处理-read-事件",link:"#_4-4-处理-read-事件",children:[]},{level:3,title:"4.5 处理 write 事件",slug:"_4-5-处理-write-事件",link:"#_4-5-处理-write-事件",children:[]},{level:3,title:"4.6 更进一步",slug:"_4-6-更进一步",link:"#_4-6-更进一步",children:[]},{level:3,title:"4.7 UDP",slug:"_4-7-udp",link:"#_4-7-udp",children:[]}]},{level:2,title:"5. NIO vs BIO",slug:"_5-nio-vs-bio",link:"#_5-nio-vs-bio",children:[{level:3,title:"5.1 stream vs channel",slug:"_5-1-stream-vs-channel",link:"#_5-1-stream-vs-channel",children:[]},{level:3,title:"5.2 IO 模型",slug:"_5-2-io-模型",link:"#_5-2-io-模型",children:[]},{level:3,title:"5.3 零拷贝",slug:"_5-3-零拷贝",link:"#_5-3-零拷贝",children:[]},{level:3,title:"5.3 AIO",slug:"_5-3-aio",link:"#_5-3-aio",children:[]}]}],path:"/posts/java/netty/Netty01-nio.html",pathLocale:"/",extraFields:'---\ntitle: NIO 基础\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2024-07-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - netty\n  - nio\n---\n\nnon-blocking io 非阻塞 IO\n\n\x3c!-- more --\x3e\n\n\x3c!-- \n# 一. NIO 基础\n\nnon-blocking io 非阻塞 IO --\x3e\n\n## 1. 三大组件\n\n### 1.1 Channel & Buffer\n\nchannel 有一点类似于 stream，它就是读写数据的**双向通道**，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\n\n```mermaid\ngraph LR\nchannel --\x3e buffer\nbuffer --\x3e channel\n```\n\n常见的 Channel 有\n\n* FileChannel\n* DatagramChannel\n* SocketChannel\n* ServerSocketChannel\n\n\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\n* ByteBuffer\n  * MappedByteBuffer\n  * DirectByteBuffer\n  * HeapByteBuffer\n* ShortBuffer\n* IntBuffer\n* LongBuffer\n* FloatBuffer\n* DoubleBuffer\n* CharBuffer\n\n\n\n### 1.2 Selector\n\nselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n\n#### 多线程版设计\n\n```mermaid\ngraph TD\nsubgraph 多线程版\nt1(thread) --\x3e s1(socket1)\nt2(thread) --\x3e s2(socket2)\nt3(thread) --\x3e s3(socket3)\nend\n```\n#### ⚠️ 多线程版缺点\n\n* 内存占用高\n* 线程上下文切换成本高\n* 只适合连接数少的场景\n\n\n\n\n\n\n\n#### 线程池版设计\n\n```mermaid\ngraph TD\nsubgraph 线程池版\nt4(thread) --\x3e s4(socket1)\nt5(thread) --\x3e s5(socket2)\nt4(thread) -.-> s6(socket3)\nt5(thread) -.-> s7(socket4)\nend\n```\n#### ⚠️ 线程池版缺点\n\n* 阻塞模式下，线程仅能处理一个 socket 连接\n* 仅适合短连接场景\n\n\n\n\n\n\n\n\n\n#### selector 版设计\n\nselector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --\x3e selector\nselector --\x3e c1(channel)\nselector --\x3e c2(channel)\nselector --\x3e c3(channel)\nend\n```\n\n\n\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n\n\n\n\n\n\n\n## 2. ByteBuffer\n\n有一普通文本文件 data.txt，内容为\n\n```\n1234567890abcd\n```\n\n使用 FileChannel 来读取文件内容\n\n```java\n@Slf4j\npublic class ChannelDemo1 {\n    public static void main(String[] args) {\n        try (RandomAccessFile file = new RandomAccessFile("helloword/data.txt", "rw")) {\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(10);\n            do {\n                // 向 buffer 写入\n                int len = channel.read(buffer);\n                log.debug("读到字节数：{}", len);\n                if (len == -1) {\n                    break;\n                }\n                // 切换 buffer 读模式\n                buffer.flip();\n                while(buffer.hasRemaining()) {\n                    log.debug("{}", (char)buffer.get());\n                }\n                // 切换 buffer 写模式\n                buffer.clear();\n            } while (true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n```\n\n\n\n### 2.1  ByteBuffer 正确使用姿势\n\n1. 向 buffer 写入数据，例如调用 channel.read(buffer)\n2. 调用 flip() 切换至**读模式**\n3. 从 buffer 读取数据，例如调用 buffer.get()\n4. 调用 clear() 或 compact() 切换至**写模式**\n5. 重复 1~4 步骤\n\n\n\n### 2.2 ByteBuffer 结构\n\nByteBuffer 有以下重要属性\n\n* capacity\n* position\n* limit\n\n一开始\n\n![](img/0021.png)\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![](img/0018.png)\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n![](img/0019.png)\n\n读取 4 个字节后，状态\n\n![](img/0020.png)\n\nclear 动作发生后，状态\n\n![](img/0021.png)\n\ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n![](img/0022.png)\n\n\n\n#### 💡 调试工具类\n\n```java\npublic class ByteBufferUtil {\n    private static final char[] BYTE2CHAR = new char[256];\n    private static final char[] HEXDUMP_TABLE = new char[256 * 4];\n    private static final String[] HEXPADDING = new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];\n    private static final String[] BYTE2HEX = new String[256];\n    private static final String[] BYTEPADDING = new String[16];\n\n    static {\n        final char[] DIGITS = "0123456789abcdef".toCharArray();\n        for (int i = 0; i < 256; i++) {\n            HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F];\n            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];\n        }\n\n        int i;\n\n        // Generate the lookup table for hex dump paddings\n        for (i = 0; i < HEXPADDING.length; i++) {\n            int padding = HEXPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding * 3);\n            for (int j = 0; j < padding; j++) {\n                buf.append("   ");\n            }\n            HEXPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) {\n            StringBuilder buf = new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, \'|\');\n            buf.append(\'|\');\n            HEXDUMP_ROWPREFIXES[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-hex-dump conversion\n        for (i = 0; i < BYTE2HEX.length; i++) {\n            BYTE2HEX[i] = \' \' + StringUtil.byteToHexStringPadded(i);\n        }\n\n        // Generate the lookup table for byte dump paddings\n        for (i = 0; i < BYTEPADDING.length; i++) {\n            int padding = BYTEPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding);\n            for (int j = 0; j < padding; j++) {\n                buf.append(\' \');\n            }\n            BYTEPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-char conversion\n        for (i = 0; i < BYTE2CHAR.length; i++) {\n            if (i <= 0x1f || i >= 0x7f) {\n                BYTE2CHAR[i] = \'.\';\n            } else {\n                BYTE2CHAR[i] = (char) i;\n            }\n        }\n    }\n\n    /**\n     * 打印所有内容\n     * @param buffer\n     */\n    public static void debugAll(ByteBuffer buffer) {\n        int oldlimit = buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin = new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println("+--------+-------------------- all ------------------------+----------------+");\n        System.out.printf("position: [%d], limit: [%d]\\n", buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    }\n\n    /**\n     * 打印可读取内容\n     * @param buffer\n     */\n    public static void debugRead(ByteBuffer buffer) {\n        StringBuilder builder = new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println("+--------+-------------------- read -----------------------+----------------+");\n        System.out.printf("position: [%d], limit: [%d]\\n", buffer.position(), buffer.limit());\n        System.out.println(builder);\n    }\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) {\n        if (isOutOfBounds(offset, length, buf.capacity())) {\n            throw new IndexOutOfBoundsException(\n                    "expected: " + "0 <= offset(" + offset + ") <= offset + length(" + length\n                            + ") <= " + "buf.capacity(" + buf.capacity() + \')\');\n        }\n        if (length == 0) {\n            return;\n        }\n        dump.append(\n                "         +-------------------------------------------------+" +\n                        NEWLINE + "         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |" +\n                        NEWLINE + "+--------+-------------------------------------------------+----------------+");\n\n        final int startIndex = offset;\n        final int fullRows = length >>> 4;\n        final int remainder = length & 0xF;\n\n        // Dump the rows which have 16 bytes.\n        for (int row = 0; row < fullRows; row++) {\n            int rowStartIndex = (row << 4) + startIndex;\n\n            // Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + 16;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(" |");\n\n            // ASCII dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(\'|\');\n        }\n\n        // Dump the last row which has less than 16 bytes.\n        if (remainder != 0) {\n            int rowStartIndex = (fullRows << 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + remainder;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(HEXPADDING[remainder]);\n            dump.append(" |");\n\n            // Ascii dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(BYTEPADDING[remainder]);\n            dump.append(\'|\');\n        }\n\n        dump.append(NEWLINE +\n                "+--------+-------------------------------------------------+----------------+");\n    }\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {\n        if (row < HEXDUMP_ROWPREFIXES.length) {\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        } else {\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, \'|\');\n            dump.append(\'|\');\n        }\n    }\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) {\n        return (short) (buffer.get(index) & 0xFF);\n    }\n}\n```\n\n\n\n### 2.3 ByteBuffer 常见方法\n\n#### 分配空间\n\n可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\n\n```java\nBytebuffer buf = ByteBuffer.allocate(16);\n```\n\n\n\n#### 向 buffer 写入数据\n\n有两种办法\n\n* 调用 channel 的 read 方法\n* 调用 buffer 自己的 put 方法\n\n```java\nint readBytes = channel.read(buf);\n```\n\n和\n\n```java\nbuf.put((byte)127);\n```\n\n\n\n#### 从 buffer 读取数据\n\n同样有两种办法\n\n* 调用 channel 的 write 方法\n* 调用 buffer 自己的 get 方法\n\n```java\nint writeBytes = channel.write(buf);\n```\n\n和\n\n```java\nbyte b = buf.get();\n```\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n* 可以调用 rewind 方法将 position 重新置为 0\n* 或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\n\n\n#### mark 和 reset\n\nmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n> **注意**\n>\n> rewind 和 flip 都会清除 mark 位置\n\n\n\n#### 字符串与 ByteBuffer 互转\n\n```java\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode("你好");\nByteBuffer buffer2 = Charset.forName("utf-8").encode("你好");\n\ndebug(buffer1);\ndebug(buffer2);\n\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());\nSystem.out.println(buffer3.toString());\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好\n```\n\n\n\n#### ⚠️ Buffer 的线程安全\n\n> Buffer 是**非线程安全的**\n\n\n\n### 2.4 Scattering Reads\n\n分散读取，有一个文本文件 3parts.txt\n\n```\nonetwothree\n```\n\n使用如下方式读取，可以将数据填充至多个 buffer\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile("helloword/3parts.txt", "rw")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer a = ByteBuffer.allocate(3);\n    ByteBuffer b = ByteBuffer.allocate(3);\n    ByteBuffer c = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]{a, b, c});\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n### 2.5 Gathering Writes\n\n使用如下方式写入，可以将多个 buffer 的数据填充至 channel\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile("helloword/3parts.txt", "rw")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer d = ByteBuffer.allocate(4);\n    ByteBuffer e = ByteBuffer.allocate(4);\n    channel.position(11);\n\n    d.put(new byte[]{\'f\', \'o\', \'u\', \'r\'});\n    e.put(new byte[]{\'f\', \'i\', \'v\', \'e\'});\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]{d, e});\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+\n```\n\n文件内容\n\n```\nonetwothreefourfive\n```\n\n\n\n### 2.6 练习\n\n网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\n* Hello,world\\n\n* I\'m zhangsan\\n\n* How are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\n* Hello,world\\nI\'m zhangsan\\nHo\n* w are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\n\n```java\npublic static void main(String[] args) {\n    ByteBuffer source = ByteBuffer.allocate(32);\n    //                     11            24\n    source.put("Hello,world\\nI\'m zhangsan\\nHo".getBytes());\n    split(source);\n\n    source.put("w are you?\\nhaha!\\n".getBytes());\n    split(source);\n}\n\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    int oldLimit = source.limit();\n    for (int i = 0; i < oldLimit; i++) {\n        if (source.get(i) == \'\\n\') {\n            System.out.println(i);\n            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());\n            // 0 ~ limit\n            source.limit(i + 1);\n            target.put(source); // 从source 读，向 target 写\n            debugAll(target);\n            source.limit(oldLimit);\n        }\n    }\n    source.compact();\n}\n```\n\n\n\n## 3. 文件编程\n\n### 3.1 FileChannel\n\n#### ⚠️ FileChannel 工作模式\n\n> FileChannel 只能工作在阻塞模式下\n\n\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n* 通过 FileInputStream 获取的 channel 只能读\n* 通过 FileOutputStream 获取的 channel 只能写\n* 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n* 这时读取会返回 -1 \n* 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n\n\n#### 强制写入\n\n操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n\n\n\n### 3.2 两个 Channel 传输数据\n\n```java\nString FROM = "helloword/data.txt";\nString TO = "helloword/to.txt";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println("transferTo 用时：" + (end - start) / 1000_000.0);\n```\n\n输出\n\n```\ntransferTo 用时：8.2011\n```\n\n\n\n超过 2g 大小的文件传输\n\n```java\npublic class TestFileChannelTransferTo {\n    public static void main(String[] args) {\n        try (\n                FileChannel from = new FileInputStream("data.txt").getChannel();\n                FileChannel to = new FileOutputStream("to.txt").getChannel();\n        ) {\n            // 效率高，底层会利用操作系统的零拷贝进行优化\n            long size = from.size();\n            // left 变量代表还剩余多少字节\n            for (long left = size; left > 0; ) {\n                System.out.println("position:" + (size - left) + " left:" + left);\n                left -= from.transferTo((size - left), left, to);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n实际传输一个超大文件\n\n```\nposition:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219\n```\n\n\n\n### 3.3 Path\n\njdk7 引入了 Path 和 Paths 类\n\n* Path 用来表示文件路径\n* Paths 是工具类，用来获取 Path 实例\n\n```java\nPath source = Paths.get("1.txt"); // 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source = Paths.get("d:\\\\1.txt"); // 绝对路径 代表了  d:\\1.txt\n\nPath source = Paths.get("d:/1.txt"); // 绝对路径 同样代表了  d:\\1.txt\n\nPath projects = Paths.get("d:\\\\data", "projects"); // 代表了  d:\\data\\projects\n```\n\n* `.` 代表了当前路径\n* `..` 代表了上一级路径\n\n例如目录结构如下\n\n```\nd:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b\n```\n\n代码\n\n```java\nPath path = Paths.get("d:\\\\data\\\\projects\\\\a\\\\..\\\\b");\nSystem.out.println(path);\nSystem.out.println(path.normalize()); // 正常化路径\n```\n\n会输出\n\n```\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n```\n\n\n\n### 3.4 Files\n\n检查文件是否存在\n\n```java\nPath path = Paths.get("helloword/data.txt");\nSystem.out.println(Files.exists(path));\n```\n\n\n\n创建一级目录\n\n```java\nPath path = Paths.get("helloword/d1");\nFiles.createDirectory(path);\n```\n\n* 如果目录已存在，会抛异常 FileAlreadyExistsException\n* 不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n\n\n创建多级目录用\n\n```java\nPath path = Paths.get("helloword/d1/d2");\nFiles.createDirectories(path);\n```\n\n\n\n拷贝文件\n\n```java\nPath source = Paths.get("helloword/data.txt");\nPath target = Paths.get("helloword/target.txt");\n\nFiles.copy(source, target);\n```\n\n* 如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\n\n```java\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n```\n\n\n\n移动文件\n\n```java\nPath source = Paths.get("helloword/data.txt");\nPath target = Paths.get("helloword/data.txt");\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n```\n\n* StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n\n\n删除文件\n\n```java\nPath target = Paths.get("helloword/target.txt");\n\nFiles.delete(target);\n```\n\n* 如果文件不存在，会抛异常 NoSuchFileException\n\n\n\n删除目录\n\n```java\nPath target = Paths.get("helloword/d1");\n\nFiles.delete(target);\n```\n\n* 如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\n\n\n遍历目录文件\n\n```java\npublic static void main(String[] args) throws IOException {\n    Path path = Paths.get("C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91");\n    AtomicInteger dirCount = new AtomicInteger();\n    AtomicInteger fileCount = new AtomicInteger();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(dir);\n            dirCount.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(file);\n            fileCount.incrementAndGet();\n            return super.visitFile(file, attrs);\n        }\n    });\n    System.out.println(dirCount); // 133\n    System.out.println(fileCount); // 1479\n}\n```\n\n\n\n统计 jar 的数目\n\n```java\nPath path = Paths.get("C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91");\nAtomicInteger fileCount = new AtomicInteger();\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        if (file.toFile().getName().endsWith(".jar")) {\n            fileCount.incrementAndGet();\n        }\n        return super.visitFile(file, attrs);\n    }\n});\nSystem.out.println(fileCount); // 724\n```\n\n\n\n删除多级目录\n\n```java\nPath path = Paths.get("d:\\\\a");\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        Files.delete(file);\n        return super.visitFile(file, attrs);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) \n        throws IOException {\n        Files.delete(dir);\n        return super.postVisitDirectory(dir, exc);\n    }\n});\n```\n\n\n\n#### ⚠️ 删除很危险\n\n> 删除是危险操作，确保要递归删除的文件夹没有重要内容\n\n\n\n拷贝多级目录\n\n```java\nlong start = System.currentTimeMillis();\nString source = "D:\\\\Snipaste-1.16.2-x64";\nString target = "D:\\\\Snipaste-1.16.2-x64aaa";\n\nFiles.walk(Paths.get(source)).forEach(path -> {\n    try {\n        String targetName = path.toString().replace(source, target);\n        // 是目录\n        if (Files.isDirectory(path)) {\n            Files.createDirectory(Paths.get(targetName));\n        }\n        // 是普通文件\n        else if (Files.isRegularFile(path)) {\n            Files.copy(path, Paths.get(targetName));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlong end = System.currentTimeMillis();\nSystem.out.println(end - start);\n```\n\n\n\n\n\n## 4. 网络编程\n\n### 4.1 非阻塞 vs 阻塞\n\n#### 阻塞\n\n* 阻塞模式下，相关方法都会导致线程暂停\n  * ServerSocketChannel.accept 会在没有连接建立时让线程暂停\n  * SocketChannel.read 会在没有数据可读时让线程暂停\n  * 阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n* 单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n* 但多线程下，有新的问题，体现在以下方面\n  * 32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n  * 可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n\n\n服务器端\n\n```java\n// 使用 nio 来理解阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\n\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug("connecting...");\n    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行\n    log.debug("connected... {}", sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        log.debug("before read... {}", channel);\n        channel.read(buffer); // 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug("after read...{}", channel);\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress("localhost", 8080));\nSystem.out.println("waiting...");\n```\n\n\n\n#### 非阻塞\n\n* 非阻塞模式下，相关方法都会不会让线程暂停\n  * 在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\n  * SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept \n  * 写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n* 但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\n* 数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\n\n\n\n服务器端，客户端代码不变\n\n```java\n// 使用 nio 来理解非阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false); // 非阻塞模式\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc != null) {\n        log.debug("connected... {}", sc);\n        sc.configureBlocking(false); // 非阻塞模式\n        channels.add(sc);\n    }\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read > 0) {\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug("after read...{}", channel);\n        }\n    }\n}\n```\n\n\n\n#### 多路复用\n\n单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\n\n* 多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\n* 如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n  * 有可连接事件时才去连接\n  * 有可读事件才去读取\n  * 有可写事件才去写入\n    * 限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n### 4.2 Selector\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --\x3e selector\nselector --\x3e c1(channel)\nselector --\x3e c2(channel)\nselector --\x3e c3(channel)\nend\n```\n\n\n\n好处\n\n* 一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n* 让这个线程能够被充分利用\n* 节约了线程的数量\n* 减少了线程上下文切换\n\n\n\n#### 创建\n\n```java\nSelector selector = Selector.open();\n```\n\n\n\n#### 绑定 Channel 事件\n\n也称之为注册事件，绑定的事件 selector 才会关心 \n\n```java\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, 绑定事件);\n```\n\n* channel 必须工作在非阻塞模式\n* FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n* 绑定的事件类型可以有\n  * connect - 客户端连接成功时触发\n  * accept - 服务器端成功接受连接时触发\n  * read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\n  * write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n\n\n#### 监听 Channel 事件\n\n可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n\n方法1，阻塞直到绑定事件发生\n\n```java\nint count = selector.select();\n```\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\n\n```java\nint count = selector.select(long timeout);\n```\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\n\n```java\nint count = selector.selectNow();\n```\n\n\n\n#### 💡 select 何时不阻塞\n\n> * 事件发生时\n>   * 客户端发起连接请求，会触发 accept 事件\n>   * 客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\n>   * channel 可写，会触发 write 事件\n>   * 在 linux 下 nio bug 发生时\n> * 调用 selector.wakeup()\n> * 调用 selector.close()\n> * selector 所在线程 interrupt\n\n\n\n### 4.3 处理 accept 事件\n\n客户端代码为\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket("localhost", 8080)) {\n            System.out.println(socket);\n            socket.getOutputStream().write("world".getBytes());\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n服务器端代码为\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug("select count: {}", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        log.debug("{}", sc);\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n#### 💡 事件发生后能否不处理\n\n> 事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n\n\n### 4.4 处理 read 事件\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug("select count: {}", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug("连接已建立: {}", sc);\n                    } else if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(128);\n                        int read = sc.read(buffer);\n                        if(read == -1) {\n                            key.cancel();\n                            sc.close();\n                        } else {\n                            buffer.flip();\n                            debug(buffer);\n                        }\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n开启两个客户端，修改一下发送文字，输出\n\n```\nsun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 为何要 iter.remove()\n\n> 因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n>\n> * 第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n> * 第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n\n\n#### 💡 cancel 的作用\n\n> cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\n\n\n\n#### ⚠️  不处理边界的问题\n\n以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss=new ServerSocket(9000);\n        while (true) {\n            Socket s = ss.accept();\n            InputStream in = s.getInputStream();\n            // 这里这么写，有没有问题\n            byte[] arr = new byte[4];\n            while(true) {\n                int read = in.read(arr);\n                // 这里这么写，有没有问题\n                if(read == -1) {\n                    break;\n                }\n                System.out.println(new String(arr, 0, read));\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket max = new Socket("localhost", 9000);\n        OutputStream out = max.getOutputStream();\n        out.write("hello".getBytes());\n        out.write("world".getBytes());\n        out.write("你好".getBytes());\n        max.close();\n    }\n}\n```\n\n输出\n\n```\nhell\nowor\nld�\n�好\n\n```\n\n为什么？\n\n\n\n#### 处理消息的边界\n\n![](img/0023.png)\n\n* 一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n* 另一种思路是按分隔符拆分，缺点是效率低\n* TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\n  * Http 1.1 是 TLV 格式\n  * Http 2.0 是 LTV 格式\n\n\n\n```mermaid\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 ->> s: 发送 01234567890abcdef3333\\r\ns ->> b1: 第一次 read 存入 01234567890abcdef\ns ->> b2: 扩容\nb1 ->> b2: 拷贝 01234567890abcdef\ns ->> b2: 第二次 read 存入 3333\\r\nb2 ->> b2: 01234567890abcdef3333\\r\n```\n\n服务器端\n\n```java\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    for (int i = 0; i < source.limit(); i++) {\n        // 找到一条完整消息\n        if (source.get(i) == \'\\n\') {\n            int length = i + 1 - source.position();\n            // 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            // 从 source 读，向 target 写\n            for (int j = 0; j < length; j++) {\n                target.put(source.get());\n            }\n            debugAll(target);\n        }\n    }\n    source.compact(); // 0123456789abcdef  position 16 limit 16\n}\n\npublic static void main(String[] args) throws IOException {\n    // 1. 创建 selector, 管理多个 channel\n    Selector selector = Selector.open();\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    // 2. 建立 selector 和 channel 的联系（注册）\n    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    // key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug("sscKey:{}", sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) {\n        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug("key: {}", key);\n            // 5. 区分事件类型\n            if (key.isAcceptable()) { // 如果是 accept\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment\n                // 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug("{}", sc);\n                log.debug("scKey:{}", scKey);\n            } else if (key.isReadable()) { // 如果是 read\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel\n                    // 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1\n                    if(read == -1) {\n                        key.cancel();\n                    } else {\n                        split(buffer);\n                        // 需要扩容\n                        if (buffer.position() == buffer.limit()) {\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); // 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        }\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress("localhost", 8080));\nSocketAddress address = sc.getLocalAddress();\n// sc.write(Charset.defaultCharset().encode("hello\\nworld\\n"));\nsc.write(Charset.defaultCharset().encode("0123\\n456789abcdef"));\nsc.write(Charset.defaultCharset().encode("0123456789abcdef3333\\n"));\nSystem.in.read();\n```\n\n\n\n\n\n#### ByteBuffer 大小分配\n\n* 每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\n* ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n  * 一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 [http://tutorials.jenkov.com/java-performance/resizable-array.html](http://tutorials.jenkov.com/java-performance/resizable-array.html)\n  * 另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\n\n\n\n\n\n### 4.5 处理 write 事件\n\n\n\n#### 一次无法写完例子\n\n* 非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n* 用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n  * 当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\n  * selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n  * 如果不取消，会每次可写均会触发 write 事件\n\n\n\n```java\npublic class WriteServer {\n\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector = Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) {\n            selector.select();\n\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    SocketChannel sc = ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);\n                    // 1. 向客户端发送内容\n                    StringBuilder sb = new StringBuilder();\n                    for (int i = 0; i < 3000000; i++) {\n                        sb.append("a");\n                    }\n                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());\n                    int write = sc.write(buffer);\n                    // 3. write 表示实际写了多少字节\n                    System.out.println("实际写入字节:" + write);\n                    // 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) {\n                        // read 1  write 4\n                        // 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        // 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    }\n                } else if (key.isWritable()) {\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    int write = sc.write(buffer);\n                    System.out.println("实际写入字节:" + write);\n                    if (!buffer.hasRemaining()) { // 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class WriteClient {\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        SocketChannel sc = SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress("localhost", 8080));\n        int count = 0;\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isConnectable()) {\n                    System.out.println(sc.finishConnect());\n                } else if (key.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);\n                    count += sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 write 为何要取消\n\n只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\n\n\n\n\n\n\n\n\n\n\n\n### 4.6 更进一步\n\n\n\n#### 💡 利用多线程优化\n\n> 现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n\n\n\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n\n分两组选择器\n\n* 单线程配一个选择器，专门处理 accept 事件\n* 创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件\n\n\n\n```java\npublic class ChannelDemo7 {\n    public static void main(String[] args) throws IOException {\n        new BossEventLoop().register();\n    }\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable {\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start = false;\n        AtomicInteger index = new AtomicInteger();\n\n        public void register() throws IOException {\n            if (!start) {\n                ServerSocketChannel ssc = ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss = Selector.open();\n                SelectionKey ssckey = ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers = initEventLoops();\n                new Thread(this, "boss").start();\n                log.debug("boss start...");\n                start = true;\n            }\n        }\n\n        public WorkerEventLoop[] initEventLoops() {\n//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];\n            for (int i = 0; i < workerEventLoops.length; i++) {\n                workerEventLoops[i] = new WorkerEventLoop(i);\n            }\n            return workerEventLoops;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    boss.select();\n                    Iterator<SelectionKey> iter = boss.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                            SocketChannel sc = c.accept();\n                            sc.configureBlocking(false);\n                            log.debug("{} connected", sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable {\n        private Selector worker;\n        private volatile boolean start = false;\n        private int index;\n\n        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();\n\n        public WorkerEventLoop(int index) {\n            this.index = index;\n        }\n\n        public void register(SocketChannel sc) throws IOException {\n            if (!start) {\n                worker = Selector.open();\n                new Thread(this, "worker-" + index).start();\n                start = true;\n            }\n            tasks.add(() -> {\n                try {\n                    SelectionKey sckey = sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            worker.wakeup();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    worker.select();\n                    Runnable task = tasks.poll();\n                    if (task != null) {\n                        task.run();\n                    }\n                    Set<SelectionKey> keys = worker.selectedKeys();\n                    Iterator<SelectionKey> iter = keys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(128);\n                            try {\n                                int read = sc.read(buffer);\n                                if (read == -1) {\n                                    key.cancel();\n                                    sc.close();\n                                } else {\n                                    buffer.flip();\n                                    log.debug("{} message:", sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            }\n                        }\n                        iter.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 如何拿到 cpu 个数\n\n> * Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\n> * 这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\n\n\n### 4.7 UDP\n\n* UDP 是无连接的，client 发送数据不会管 server 是否开启\n* server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\n\n首先启动服务器端\n\n```java\npublic class UdpServer {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            channel.socket().bind(new InetSocketAddress(9999));\n            System.out.println("waiting...");\n            ByteBuffer buffer = ByteBuffer.allocate(32);\n            channel.receive(buffer);\n            buffer.flip();\n            debug(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\nwaiting...\n```\n\n\n\n运行客户端\n\n```java\npublic class UdpClient {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            ByteBuffer buffer = StandardCharsets.UTF_8.encode("hello");\n            InetSocketAddress address = new InetSocketAddress("localhost", 9999);\n            channel.send(buffer, address);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n接下来服务器端输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n\n\n## 5. NIO vs BIO\n\n### 5.1 stream vs channel\n\n* stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\n* stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n* 二者均为全双工，即读写可以同时进行\n\n\n\n### 5.2 IO 模型\n\n同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\n\n* 同步：线程自己去获取结果（一个线程）\n* 异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\n\n\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n* 等待数据阶段\n* 复制数据阶段\n\n![](img/0033.png)\n\n* 阻塞 IO\n\n  ![](img/0039.png)\n\n* 非阻塞  IO\n\n  ![](img/0035.png)\n\n* 多路复用\n\n  ![](img/0038.png)\n\n* 信号驱动\n\n* 异步 IO\n\n  ![](img/0037.png)\n\n* 阻塞 IO vs 多路复用\n\n  ![](img/0034.png)\n\n  ![](img/0036.png)\n\n#### 🔖 参考\n\nUNIX 网络编程 - 卷 I\n\n\n\n### 5.3 零拷贝\n\n#### 传统 IO 问题\n\n传统的 IO 将一个文件通过 socket 写出\n\n```java\nFile f = new File("helloword/data.txt");\nRandomAccessFile file = new RandomAccessFile(file, "r");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);\n```\n\n内部工作流程是这样的：\n\n![](img/0024.png)\n\n1. java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的**用户态**切换至**内核态**，去调用操作系统（Kernel）的读能力，将数据读入**内核缓冲区**。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\n\n   > DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n2. 从**内核态**切换回**用户态**，将数据从**内核缓冲区**读入**用户缓冲区**（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n\n3. 调用 write 方法，这时将数据从**用户缓冲区**（byte[] buf）写入 **socket 缓冲区**，cpu 会参与拷贝\n\n4. 接下来要向网卡写数据，这项能力 java 又不具备，因此又得从**用户态**切换至**内核态**，调用操作系统的写能力，使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n* 用户态与内核态的切换发生了 3 次，这个操作比较重量级\n* 数据拷贝了共 4 次\n\n\n\n#### NIO 优化\n\n通过 DirectByteBuf \n\n* ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存\n* ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n![](img/0025.png)\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\n\n* 这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\n* java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\n  * DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\n  * 通过专门线程访问引用队列，根据虚引用释放堆外内存\n* 减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n\n\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\n\n![](img/0026.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 数据从**内核缓冲区**传输到 **socket 缓冲区**，cpu 会参与拷贝\n3. 最后使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n可以看到\n\n* 只发生了一次用户态与内核态的切换\n* 数据拷贝了 3 次\n\n\n\n进一步优化（linux 2.4）\n\n![](img/0027.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 只会将一些 offset 和 length 信息拷入 **socket 缓冲区**，几乎无消耗\n3. 使用 DMA 将 **内核缓冲区**的数据写入网卡，不会使用 cpu\n\n整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\n\n* 更少的用户态与内核态的切换\n* 不利用 cpu 计算，减少 cpu 缓存伪共享\n* 零拷贝适合小文件传输\n\n\n\n### 5.3 AIO\n\nAIO 用来解决数据复制阶段的阻塞问题\n\n* 同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n* 异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n> 异步模型需要底层操作系统（Kernel）提供支持\n>\n> * Windows 系统通过 IOCP 实现了真正的异步 IO\n> * Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n\n\n#### 文件 AIO\n\n先来看看 AsynchronousFileChannel\n\n```java\n@Slf4j\npublic class AioDemo1 {\n    public static void main(String[] args) throws IOException {\n        try{\n            AsynchronousFileChannel s = \n                AsynchronousFileChannel.open(\n                \tPaths.get("1.txt"), StandardOpenOption.READ);\n            ByteBuffer buffer = ByteBuffer.allocate(2);\n            log.debug("begin...");\n            s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    log.debug("read completed...{}", result);\n                    buffer.flip();\n                    debug(buffer);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    log.debug("read failed...");\n                }\n            });\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        log.debug("do other things...");\n        System.in.read();\n    }\n}\n```\n\n输出\n\n```\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n```\n\n可以看到\n\n* 响应文件读取成功的是另一个线程 Thread-5\n* 主线程并没有 IO 操作阻塞\n\n\n\n#### 💡 守护线程\n\n默认文件 AIO 使用的线程都是守护线程，所以最后要执行 `System.in.read()` 以避免守护线程意外结束\n\n\n\n#### 网络 AIO\n\n```java\npublic class AioServer {\n    public static void main(String[] args) throws IOException {\n        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    }\n\n    private static void closeChannel(AsynchronousSocketChannel sc) {\n        try {\n            System.out.printf("[%s] %s close\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            try {\n                if (result == -1) {\n                    closeChannel(sc);\n                    return;\n                }\n                System.out.printf("[%s] %s read\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            closeChannel(sc);\n            exc.printStackTrace();\n        }\n    }\n\n    private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) {\n                sc.write(attachment);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n            closeChannel(sc);\n        }\n    }\n\n    private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> {\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) {\n            this.ssc = ssc;\n        }\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) {\n            try {\n                System.out.printf("[%s] %s connected\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            // 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            // 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode("server hello!"), ByteBuffer.allocate(16), new WriteHandler(sc));\n            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            exc.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n'},{title:"Netty 入门",headers:[{level:2,title:"1. 概述",slug:"_1-概述",link:"#_1-概述",children:[{level:3,title:"1.1 Netty 是什么？",slug:"_1-1-netty-是什么",link:"#_1-1-netty-是什么",children:[]},{level:3,title:"1.2 Netty 的作者",slug:"_1-2-netty-的作者",link:"#_1-2-netty-的作者",children:[]},{level:3,title:"1.3 Netty 的地位",slug:"_1-3-netty-的地位",link:"#_1-3-netty-的地位",children:[]},{level:3,title:"1.4 Netty 的优势",slug:"_1-4-netty-的优势",link:"#_1-4-netty-的优势",children:[]}]},{level:2,title:"2. Hello World",slug:"_2-hello-world",link:"#_2-hello-world",children:[{level:3,title:"2.1 目标",slug:"_2-1-目标",link:"#_2-1-目标",children:[]},{level:3,title:"2.2 服务器端",slug:"_2-2-服务器端",link:"#_2-2-服务器端",children:[]},{level:3,title:"2.3 客户端",slug:"_2-3-客户端",link:"#_2-3-客户端",children:[]},{level:3,title:"2.4 流程梳理",slug:"_2-4-流程梳理",link:"#_2-4-流程梳理",children:[]}]},{level:2,title:"3. 组件",slug:"_3-组件",link:"#_3-组件",children:[{level:3,title:"3.1 EventLoop",slug:"_3-1-eventloop",link:"#_3-1-eventloop",children:[]},{level:3,title:"3.2 Channel",slug:"_3-2-channel",link:"#_3-2-channel",children:[]},{level:3,title:"3.3 Future & Promise",slug:"_3-3-future-promise",link:"#_3-3-future-promise",children:[]},{level:3,title:"3.4 Handler & Pipeline",slug:"_3-4-handler-pipeline",link:"#_3-4-handler-pipeline",children:[]},{level:3,title:"3.5 ByteBuf",slug:"_3-5-bytebuf",link:"#_3-5-bytebuf",children:[]}]},{level:2,title:"4. 双向通信",slug:"_4-双向通信",link:"#_4-双向通信",children:[{level:3,title:"4.1 练习",slug:"_4-1-练习",link:"#_4-1-练习",children:[]},{level:3,title:"💡 读和写的误解",slug:"💡-读和写的误解",link:"#💡-读和写的误解",children:[]}]}],path:"/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html",pathLocale:"/",extraFields:'---\ntitle: Netty 入门\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2024-07-24\nlastUpdated: true\norder: 2\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - netty\n---\n\nNetty 入门\n\n\x3c!-- more --\x3e\n\x3c!-- # 二. Netty 入门 --\x3e\n\n\n\n## 1. 概述\n\n### 1.1 Netty 是什么？\n\n```\nNetty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers & clients.\n```\n\nNetty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n\n\n\n### 1.2 Netty 的作者\n\n![](img/0005.png)\n\n他还是另一个著名网络应用框架 Mina 的重要贡献者\n\n\n\n### 1.3 Netty 的地位\n\nNetty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\n\n以下的框架都使用了 Netty，因为它们有网络通信需求！\n\n* Cassandra - nosql 数据库\n* Spark - 大数据分布式计算框架\n* Hadoop - 大数据分布式存储框架\n* RocketMQ - ali 开源的消息队列\n* ElasticSearch - 搜索引擎\n* gRPC - rpc 框架\n* Dubbo - rpc 框架\n* Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\n* Zookeeper - 分布式协调框架\n\n\n\n### 1.4 Netty 的优势\n\n* Netty vs NIO，工作量大，bug 多\n  * 需要自己构建协议\n  * 解决 TCP 传输问题，如粘包、半包\n  * epoll 空轮询导致 CPU 100%\n  * 对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal，ByteBuf => ByteBuffer\n* Netty vs 其它网络应用框架\n  * Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\n  * 久经考验，16年，Netty 版本\n    * 2.x 2004\n    * 3.x 2008\n    * 4.x 2013\n    * 5.x 已废弃（没有明显的性能提升，维护成本高）\n\n\n\n## 2. Hello World\n\n### 2.1 目标\n\n开发一个简单的服务器端和客户端\n\n* 客户端向服务器端发送 hello, world\n* 服务器仅接收，不返回\n\n\n\n加入依赖\n\n```xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.39.Final</version>\n</dependency>\n```\n\n\n\n\n\n### 2.2 服务器端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioServerSocketChannel.class) // 2\n    .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new StringDecoder()); // 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                    System.out.println(msg);\n                }\n            });\n        }\n    })\n    .bind(8080); // 4\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，可以简单理解为 `线程池 + Selector` 后面会详细展开\n\n* 2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\n\n  ![](img/0006.png)\n\n* 3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n\n* 4 处，ServerSocketChannel 绑定的监听端口\n\n* 5 处，SocketChannel 的处理器，解码 ByteBuf => String\n\n* 6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\n\n\n\n### 2.3 客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioSocketChannel.class) // 2\n    .handler(new ChannelInitializer<Channel>() { // 3\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder()); // 8\n        }\n    })\n    .connect("127.0.0.1", 8080) // 4\n    .sync() // 5\n    .channel() // 6\n    .writeAndFlush(new Date() + ": hello world!"); // 7\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，同 Server\n\n* 2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\n\n  ![](img/0007.png)\n\n* 3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n* 4 处，指定要连接的服务器和端口\n* 5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\n* 6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n* 7 处，写入消息并清空缓冲区\n* 8 处，消息会经过通道 handler 处理，这里是将 String => ByteBuf 发出\n* 数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\n\n\n\n### 2.4 流程梳理\n\n![](img/0040.png)\n\n#### 💡 提示\n\n> 一开始需要树立正确的观念\n>\n> * 把 channel 理解为数据的通道\n> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\n> * 把 handler 理解为数据的处理工序\n>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\n>   * handler 分 Inbound 和 Outbound 两类\n> * 把 eventLoop 理解为处理数据的工人\n>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\n>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\n>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\n\n\n\n## 3. 组件\n\n### 3.1 EventLoop\n\n事件循环对象\n\nEventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\n\n它的继承关系比较复杂\n\n* 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n* 另一条线是继承自 netty 自己的 OrderedEventExecutor，\n  * 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\n  * 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\n\n\n\n事件循环组\n\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n\n* 继承自 netty 自己的 EventExecutorGroup\n  * 实现了 Iterable 接口提供遍历 EventLoop 的能力\n  * 另有 next 方法获取集合中下一个 EventLoop\n\n\n\n以一个简单的实现为例：\n\n```java\n// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98\n```\n\n也可以使用 for 循环\n\n```java\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) {\n    System.out.println(eventLoop);\n}\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\n```\n\n\n\n#### 💡 优雅关闭\n\n优雅关闭 `shutdownGracefully` 方法。该方法会首先切换 `EventLoopGroup` 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n\n\n\n#### 演示 NioEventLoop 处理 io 事件\n\n服务器端两个 nio worker 工人\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    Channel channel = new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer<NioSocketChannel>() {\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception {\n                    System.out.println("init...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                }\n            })\n            .channel(NioSocketChannel.class).connect("localhost", 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes("wangwu".getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes("wangwu".getBytes()));\n```\n\n最后输出\n\n```\n22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         \n```\n\n可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定\n\n![](img/0042.png)\n\n\n\n再增加两个非 nio 工人\n\n```java\nDefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch)  {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(normalWorkers,"myhandler",\n              new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n输出\n\n```\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n```\n\n可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\n\n\n\n![](img/0041.png)\n\n\n\n#### 💡 handler 执行中如何换人？\n\n关键代码 `io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()`\n\n```java\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {\n    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);\n    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor = next.executor();\n    \n    // 是，直接调用\n    if (executor.inEventLoop()) {\n        next.invokeChannelRead(m);\n    } \n    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else {\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                next.invokeChannelRead(m);\n            }\n        });\n    }\n}\n```\n\n* 如果两个 handler 绑定的是同一个线程，那么就直接调用\n* 否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\n\n\n\n#### 演示 NioEventLoop 处理普通任务\n\nNioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug("server start...");\nThread.sleep(2000);\nnioWorkers.execute(()->{\n    log.debug("normal task...");\n});\n```\n\n输出\n\n```\n22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...\n```\n\n> 可以用来执行耗时较长的任务\n\n\n\n#### 演示 NioEventLoop 处理定时任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug("server start...");\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -> {\n    log.debug("running...");\n}, 0, 1, TimeUnit.SECONDS);\n```\n\n输出\n\n```\n22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...\n```\n\n> 可以用来执行定时任务\n\n\n\n### 3.2 Channel\n\nchannel 的主要作用\n\n* close() 可以用来关闭 channel\n* closeFuture() 用来处理 channel 的关闭\n  * sync 方法作用是同步等待 channel 关闭\n  * 而 addListener 方法是异步等待 channel 关闭\n* pipeline() 方法添加处理器\n* write() 方法将数据写入\n* writeAndFlush() 方法将数据写入并刷出\n\n\n\n#### ChannelFuture\n\n这时刚才的客户端代码\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + ": hello world!");\n```\n\n现在把它拆开来看\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080); // 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + ": hello world!");\n```\n\n* 1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\n\n**注意** connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象\n\n实验如下：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080);\n\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.sync(); // 2\nSystem.out.println(channelFuture.channel()); // 3\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x2e1884dd]`\n* 执行到 2 时，sync 方法是同步等待连接建立完成\n* 执行到 3 时，连接肯定建立了，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`\n\n除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080);\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.addListener((ChannelFutureListener) future -> {\n    System.out.println(future.channel()); // 2\n});\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x749124ba]`\n* ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 `[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]`\n\n\n\n#### CloseFuture\n\n```java\n@Slf4j\npublic class CloseFutureClient {\n    public static void main(String[] args) throws InterruptedException {\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture = new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override // 在连接建立后被调用\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                })\n                .connect(new InetSocketAddress("localhost", 8080));\n        Channel channel = channelFuture.sync().channel();\n        log.debug("{}", channel);\n        new Thread(()->{\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if ("q".equals(line)) {\n                    channel.close(); // close 异步操作 1s 之后\n//                    log.debug("处理关闭之后的操作"); // 不能在这里善后\n                    break;\n                }\n                channel.writeAndFlush(line);\n            }\n        }, "input").start();\n\n        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture = channel.closeFuture();\n        /*log.debug("waiting close...");\n        closeFuture.sync();\n        log.debug("处理关闭之后的操作");*/\n        closeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                log.debug("处理关闭之后的操作");\n                group.shutdownGracefully();\n            }\n        });\n    }\n}\n```\n\n\n\n\n\n#### 💡 异步提升的是什么\n\n* 有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\n\n* 还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\n\n\n\n\n\n思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：`4 * 8 * 3 = 96`\n\n![](img/0044.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\n\n![](img/0048.png)\n\n\n\n\n\n\n\n\n\n\n\n因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 `4 * 8 * 12` 效率几乎是原来的四倍\n\n![](img/0047.png)\n\n要点\n\n* 单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\n* 异步并没有缩短响应时间，反而有所增加\n* 合理进行任务拆分，也是利用异步的关键\n\n\n\n### 3.3 Future & Promise\n\n在异步处理时，经常用到这两个接口\n\n首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\n\n* jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\n* netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\n* netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\n\n| 功能/名称    | jdk Future                     | netty Future                                                 | Promise      |\n| ------------ | ------------------------------ | ------------------------------------------------------------ | ------------ |\n| cancel       | 取消任务                       | -                                                            | -            |\n| isCanceled   | 任务是否取消                   | -                                                            | -            |\n| isDone       | 任务是否完成，不能区分成功失败 | -                                                            | -            |\n| get          | 获取任务结果，阻塞等待         | -                                                            | -            |\n| getNow       | -                              | 获取任务结果，非阻塞，还未产生结果时返回 null                | -            |\n| await        | -                              | 等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断 | -            |\n| sync         | -                              | 等待任务结束，如果任务失败，抛出异常                         | -            |\n| isSuccess    | -                              | 判断任务是否成功                                             | -            |\n| cause        | -                              | 获取失败信息，非阻塞，如果没有失败，返回null                 | -            |\n| addLinstener | -                              | 添加回调，异步接收结果                                       | -            |\n| setSuccess   | -                              | -                                                            | 设置成功结果 |\n| setFailure   | -                              | -                                                            | 设置失败结果 |\n\n\n\n#### 例1\n\n同步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug("set success, {}",10);\n    promise.setSuccess(10);\n});\n\nlog.debug("start...");\nlog.debug("{}",promise.getNow()); // 还没有结果\nlog.debug("{}",promise.get());\n```\n\n输出\n\n```\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例2\n\n异步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n// 设置回调，异步接收结果\npromise.addListener(future -> {\n    // 这里的 future 就是上面的 promise\n    log.debug("{}",future.getNow());\n});\n\n// 等待 1000 后设置成功结果\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug("set success, {}",10);\n    promise.setSuccess(10);\n});\n\nlog.debug("start...");\n```\n\n输出\n\n```\n11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例3\n\n同步处理任务失败 - sync & get\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\n        DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n        eventExecutors.execute(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            RuntimeException e = new RuntimeException("error...");\n            log.debug("set failure, {}", e.toString());\n            promise.setFailure(e);\n        });\n\n        log.debug("start...");\n        log.debug("{}", promise.getNow());\n        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常\n```\n\n输出\n\n```\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread "main" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\n\n\n#### 例4\n\n同步处理任务失败 - await\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException("error...");\n    log.debug("set failure, {}", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug("start...");\nlog.debug("{}", promise.getNow());\npromise.await(); // 与 sync 和 get 区别在于，不会抛异常\nlog.debug("result {}", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n```\n\n输出\n\n```\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例5\n\n异步处理任务失败\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\npromise.addListener(future -> {\n    log.debug("result {}", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n});\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException("error...");\n    log.debug("set failure, {}", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug("start...");\n```\n\n输出\n\n```\n12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例6\n\nawait 死锁检查\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.submit(()->{\n    System.out.println("1");\n    try {\n        promise.await();\n        // 注意不能仅捕获 InterruptedException 异常\n        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    } catch (Exception e) { \n        e.printStackTrace();\n    }\n    System.out.println("2");\n});\neventExecutors.submit(()->{\n    System.out.println("3");\n    try {\n        promise.await();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println("4");\n});\n```\n\n输出\n\n```\n1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n```\n\n\n\n\n\n### 3.4 Handler & Pipeline\n\nChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline\n\n* 入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\n* 出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\n\n打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\n\n\n\n先搞清楚顺序，服务端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); // 1\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); // 2\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(3);\n                    ctx.channel().write(msg); // 3\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(4);\n                    ctx.write(msg, promise); // 4\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(5);\n                    ctx.write(msg, promise); // 5\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(6);\n                    ctx.write(msg, promise); // 6\n                }\n            });\n        }\n    })\n    .bind(8080);\n```\n\n客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080)\n    .addListener((ChannelFutureListener) future -> {\n        future.channel().writeAndFlush("hello,world");\n    });\n```\n\n服务器端打印：\n\n```\n1\n2\n3\n6\n5\n4\n```\n\n可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\n\n![](img/0008.png)\n\n* 入站处理器中，ctx.fireChannelRead(msg) 是 **调用下一个入站处理器**\n  * 如果注释掉 1 处代码，则仅会打印 1\n  * 如果注释掉 2 处代码，则仅会打印 1 2\n* 3 处的 ctx.channel().write(msg) 会 **从尾部开始触发** 后续出站处理器的执行\n  * 如果注释掉 3 处代码，则仅会打印 1 2 3\n* 类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 **触发上一个出站处理器**\n  * 如果注释掉 6 处代码，则仅会打印 1 2 3 6\n* ctx.channel().write(msg) vs ctx.write(msg)\n  * 都是触发出站处理器的执行\n  * ctx.channel().write(msg) 从尾部开始查找出站处理器\n  * ctx.write(msg) 是从当前节点找上一个出站处理器\n  * 3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\n  * 6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\n\n\n\n图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\n\n![](img/0009.png)\n\n\n\n### 3.5 ByteBuf\n\n是对字节数据的封装\n\n#### 1）创建\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);\n```\n\n上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\n\n输出\n\n```\nread index:0 write index:0 capacity:10\n```\n\n其中 log 方法参考如下\n\n```java\nprivate static void log(ByteBuf buffer) {\n    int length = buffer.readableBytes();\n    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;\n    StringBuilder buf = new StringBuilder(rows * 80 * 2)\n        .append("read index:").append(buffer.readerIndex())\n        .append(" write index:").append(buffer.writerIndex())\n        .append(" capacity:").append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n}\n```\n\n\n\n#### 2）直接内存 vs 堆内存\n\n可以使用下面的代码来创建池化基于堆的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);\n```\n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);\n```\n\n* 直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\n* 直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\n\n\n\n#### 3）池化 vs 非池化\n\n池化的最大意义在于可以重用 ByteBuf，优点有\n\n* 没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\n* 有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n* 高并发时，池化功能更节约内存，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n\n```java\n-Dio.netty.allocator.type={unpooled|pooled}\n```\n\n* 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n* 4.1 之前，池化功能还不成熟，默认是非池化实现\n\n\n\n#### 4）组成\n\nByteBuf 由四部分组成\n\n![](img/0010.png)\n\n最开始读写指针都在 0 位置\n\n\n\n#### 5）写入\n\n方法列表，省略一些不重要的方法\n\n| 方法签名                                                     | 含义                   | 备注                                        |\n| ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |\n| writeBoolean(boolean value)                                  | 写入 boolean 值        | 用一字节 01\\|00 代表 true\\|false            |\n| writeByte(int value)                                         | 写入 byte 值           |                                             |\n| writeShort(int value)                                        | 写入 short 值          |                                             |\n| writeInt(int value)                                          | 写入 int 值            | Big Endian，即 0x250，写入后 00 00 02 50    |\n| writeIntLE(int value)                                        | 写入 int 值            | Little Endian，即 0x250，写入后 50 02 00 00 |\n| writeLong(long value)                                        | 写入 long 值           |                                             |\n| writeChar(int value)                                         | 写入 char 值           |                                             |\n| writeFloat(float value)                                      | 写入 float 值          |                                             |\n| writeDouble(double value)                                    | 写入 double 值         |                                             |\n| writeBytes(ByteBuf src)                                      | 写入 netty 的 ByteBuf  |                                             |\n| writeBytes(byte[] src)                                       | 写入 byte[]            |                                             |\n| writeBytes(ByteBuffer src)                                   | 写入 nio 的 ByteBuffer |                                             |\n| int writeCharSequence(CharSequence sequence, Charset charset) | 写入字符串             |                                             |\n\n> 注意\n>\n> * 这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\n> * 网络传输，默认习惯是 Big Endian\n\n\n\n先写入 4 个字节\n\n```java\nbuffer.writeBytes(new byte[]{1, 2, 3, 4});\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n再写入一个 int 整数，也是 4 个字节\n\n```java\nbuffer.writeInt(5);\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n\n\n\n#### 6）扩容\n\n再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\n\n```java\nbuffer.writeInt(6);\nlog(buffer);\n```\n\n扩容规则是\n\n* 如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\n* 如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）\n* 扩容不能超过 max capacity 会报错\n\n结果是\n\n```\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 7）读取\n\n例如读了 4 次，每次一个字节\n\n```java\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);\n```\n\n读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\n\n```\n1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果需要重复读取 int 整数 5，怎么办？\n\n可以在 read 前先做个标记 mark\n\n```java\nbuffer.markReaderIndex();\nSystem.out.println(buffer.readInt());\nlog(buffer);\n```\n\n结果\n\n```\n5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时要重复读取的话，重置到标记位置 reset\n\n```java\nbuffer.resetReaderIndex();\nlog(buffer);\n```\n\n这时\n\n```\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\n\n\n\n#### 8）retain & release\n\n由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\n* UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\n* UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\n* PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\n\n\n\n> 回收内存的源码实现，请关注下面方法的不同实现\n>\n> `protected abstract void deallocate()`\n\n\n\nNetty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n* 每个 ByteBuf 对象的初始计数为 1\n* 调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n* 调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n* 当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\n\n\n\n谁来负责 release 呢？\n\n不是我们想象的（一般情况下）\n\n```java\nByteBuf buf = ...\ntry {\n    ...\n} finally {\n    buf.release();\n}\n```\n\n请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n\n基本规则是，**谁是最后使用者，谁负责 release**，详细分析如下\n\n* 起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n* 入站 ByteBuf 处理原则\n  * 对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\n  * 将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\n  * 如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\n  * 注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n  * 假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\n* 出站 ByteBuf 处理原则\n  * 出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\n* 异常处理原则\n  * 有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\n\n\n\nTailContext 释放未处理消息逻辑\n\n```java\n// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) {\n    try {\n        logger.debug(\n            "Discarded inbound message {} that reached at the tail of the pipeline. " +\n            "Please check your pipeline configuration.", msg);\n    } finally {\n        ReferenceCountUtil.release(msg);\n    }\n}\n```\n\n具体代码\n\n```java\n// io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) {\n    if (msg instanceof ReferenceCounted) {\n        return ((ReferenceCounted) msg).release();\n    }\n    return false;\n}\n```\n\n\n\n#### 9）slice\n\n【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n\n![](img/0011.png)\n\n例，原始 ByteBuf 进行一些初始操作\n\n```java\nByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]{1, 2, 3, 4});\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write\n\n```java\nByteBuf slice = origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果原始 ByteBuf 再次读操作（又读了一个字节）\n\n```java\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时的 slice 不受影响，因为它有独立的读写指针\n\n```java\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果 slice 的内容发生了更改\n\n```java\nslice.setByte(2, 5);\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\n\n```\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 10）duplicate\n\n【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\n\n![](img/0012.png)\n\n\n\n#### 11）copy\n\n会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\n\n\n\n#### 12）CompositeByteBuf\n\n【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\n\n有两个 ByteBuf 如下\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n```\n\n现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\n\n方法1：\n\n```java\nByteBuf buf3 = ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\n\n\n\n方法2：\n\n```java\nCompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);\n```\n\n结果是一样的\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\nCompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\n\n* 优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\n* 缺点，复杂了很多，多次操作会带来性能的损耗\n\n\n\n#### 13）Unpooled\n\nUnpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\n\n这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\n\n// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n也可以用来包装普通字节数组，底层也不会有拷贝操作\n\n```java\nByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6});\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));\n```\n\n输出\n\n```\nclass io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 ByteBuf 优势\n\n* 池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n* 读写指针分离，不需要像 ByteBuffer 一样切换读写模式\n* 可以自动扩容\n* 支持链式调用，使用更流畅\n* 很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\n\n\n\n## 4. 双向通信\n\n### 4.1 练习\n\n实现一个 echo server\n\n编写 server\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response = ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    // 思考：需要释放 buffer 吗\n                    // 思考：需要释放 response 吗\n                }\n            });\n        }\n    }).bind(8080);\n```\n\n编写 client\n\n```java\nNioEventLoopGroup group = new NioEventLoopGroup();\nChannel channel = new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 思考：需要释放 buffer 吗\n                }\n            });\n        }\n    }).connect("127.0.0.1", 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -> {\n    group.shutdownGracefully();\n});\n\nnew Thread(() -> {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n        String line = scanner.nextLine();\n        if ("q".equals(line)) {\n            channel.close();\n            break;\n        }\n        channel.writeAndFlush(line);\n    }\n}).start();\n```\n\n\n\n### 💡 读和写的误解\n\n\n\n我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在`A 到 B` 和 `B 到 A` 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\n\n\n\n例如\n\n```java\npublic class TestServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888);\n        Socket s = ss.accept();\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n客户端\n\n```java\npublic class TestClient {\n    public static void main(String[] args) throws IOException {\n        Socket s = new Socket("localhost", 8888);\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n'},{title:"Netty 进阶",headers:[{level:2,title:"1. 粘包与半包",slug:"_1-粘包与半包",link:"#_1-粘包与半包",children:[{level:3,title:"1.1 粘包现象",slug:"_1-1-粘包现象",link:"#_1-1-粘包现象",children:[]},{level:3,title:"1.2 半包现象",slug:"_1-2-半包现象",link:"#_1-2-半包现象",children:[]},{level:3,title:"1.3 现象分析",slug:"_1-3-现象分析",link:"#_1-3-现象分析",children:[]},{level:3,title:"1.4 解决方案",slug:"_1-4-解决方案",link:"#_1-4-解决方案",children:[]}]},{level:2,title:"2. 协议设计与解析",slug:"_2-协议设计与解析",link:"#_2-协议设计与解析",children:[{level:3,title:"2.1 为什么需要协议？",slug:"_2-1-为什么需要协议",link:"#_2-1-为什么需要协议",children:[]},{level:3,title:"2.2 redis 协议举例",slug:"_2-2-redis-协议举例",link:"#_2-2-redis-协议举例",children:[]},{level:3,title:"2.3 http 协议举例",slug:"_2-3-http-协议举例",link:"#_2-3-http-协议举例",children:[]},{level:3,title:"2.4 自定义协议要素",slug:"_2-4-自定义协议要素",link:"#_2-4-自定义协议要素",children:[]}]},{level:2,title:"3. 聊天室案例",slug:"_3-聊天室案例",link:"#_3-聊天室案例",children:[{level:3,title:"3.1 聊天室业务介绍",slug:"_3-1-聊天室业务介绍",link:"#_3-1-聊天室业务介绍",children:[]},{level:3,title:"3.2 聊天室业务-登录",slug:"_3-2-聊天室业务-登录",link:"#_3-2-聊天室业务-登录",children:[]},{level:3,title:"3.3 聊天室业务-单聊",slug:"_3-3-聊天室业务-单聊",link:"#_3-3-聊天室业务-单聊",children:[]},{level:3,title:"3.4 聊天室业务-群聊",slug:"_3-4-聊天室业务-群聊",link:"#_3-4-聊天室业务-群聊",children:[]},{level:3,title:"3.5 聊天室业务-退出",slug:"_3-5-聊天室业务-退出",link:"#_3-5-聊天室业务-退出",children:[]},{level:3,title:"3.6 聊天室业务-空闲检测",slug:"_3-6-聊天室业务-空闲检测",link:"#_3-6-聊天室业务-空闲检测",children:[]}]}],path:"/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html",pathLocale:"/",extraFields:'---\ntitle: Netty 进阶\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2024-07-24\nlastUpdated: true\norder: 3\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - netty\n---\n\nNetty 进阶\n\n\x3c!-- more --\x3e\n\x3c!-- # 三. Netty 进阶 --\x3e\n\n## 1. 粘包与半包\n\n### 1.1 粘包现象\n\n服务端代码\n\n```java\npublic class HelloWorldServer {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("connected {}", ctx.channel());\n                            super.channelActive(ctx);\n                        }\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("disconnect {}", ctx.channel());\n                            super.channelInactive(ctx);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = serverBootstrap.bind(8080);\n            log.debug("{} binding...", channelFuture.channel());\n            channelFuture.sync();\n            log.debug("{} bound...", channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug("stoped");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HelloWorldServer().start();\n    }\n}\n```\n\n客户端代码希望发送 10 个消息，每个消息是 16 字节\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            for (int i = 0; i < 10; i++) {\n                                ByteBuf buffer = ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                                ctx.writeAndFlush(buffer);\n                            }\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\n\n```\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE\n```\n\n\n\n### 1.2 半包现象\n\n客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\n\n```java\nByteBuf buffer = ctx.alloc().buffer();\nfor (int i = 0; i < 10; i++) {\n    buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n}\nctx.writeAndFlush(buffer);\n```\n\n为现象明显，服务端修改一下接收缓冲区，其它代码不变\n\n```java\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);\n```\n\n服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\n\n```\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n```\n\n> **注意**\n>\n> serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\n\n\n\n### 1.3 现象分析\n\n粘包\n\n* 现象，发送 abc def，接收 abcdef\n* 原因\n  * 应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\n  * 滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\n  * Nagle 算法：会造成粘包\n\n半包\n\n* 现象，发送 abcdef，接收 abc def\n* 原因\n  * 应用层：接收方 ByteBuf 小于实际发送数据量\n  * 滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\n  * MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\n\n\n本质是因为 TCP 是流式协议，消息无边界\n\n\n\n> 滑动窗口\n>\n> * TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\n>\n>   ![](img/0049.png)\n>\n> \n>\n> * 为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\n>\n>   ![](img/0051.png)\n>\n> * 窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\n>\n>   * 图中深色的部分即要发送的数据，高亮的部分即窗口\n>   * 窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\n>   * 如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\n>   * 接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\n>\n\n\n\n>  MSS 限制\n>\n>  * 链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\n>\n>   * 以太网的 MTU 是 1500\n>   * FDDI（光纤分布式数据接口）的 MTU 是 4352\n>   * 本地回环地址的 MTU 是 65535 - 本地测试不走网卡\n>\n>  * MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\n>\n>   * ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\n>   * TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\n>   * MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\n>\n>   <img src="img/0031.jpg" style="zoom:50%;" />\n\n\n\n> Nagle 算法\n>\n> * 即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由\n> * 该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送\n>   * 如果 SO_SNDBUF 的数据达到 MSS，则需要发送\n>   * 如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\n>   * 如果 TCP_NODELAY = true，则需要发送\n>   * 已发送的数据都收到 ack 时，则需要发送\n>   * 上述条件不满足，但发生超时（一般为 200ms）则需要发送\n>   * 除上述情况，延迟发送\n\n\n\n### 1.4 解决方案\n\n1. 短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\n2. 每一条消息采用固定长度，缺点浪费空间\n3. 每一条消息采用分隔符，例如 \\n，缺点需要转义\n4. 每一条消息分为 head 和 body，head 中包含 body 的长度\n\n\n\n#### 方法1，短链接\n\n以解决粘包为例\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        // 分 10 次发送\n        for (int i = 0; i < 10; i++) {\n            send();\n        }\n    }\n\n    private static void send() {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("conneted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                            ctx.writeAndFlush(buffer);\n                            // 发完即关\n                            ctx.close();\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("localhost", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n输出，略\n\n> 半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\n\n\n\n#### 方法2，固定长度\n\n让所有数据包长度固定（假设长度为 8 字节），服务器端加入\n\n```java\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));\n```\n\n客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            // 发送内容随机的数据包\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte[] bytes = new byte[8];\n                                for (int j = 0; j < r.nextInt(8); j++) {\n                                    bytes[j] = (byte) c;\n                                }\n                                c++;\n                                buffer.writeBytes(bytes);\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE\n```\n\n缺点是，数据包的大小不好把握\n\n* 长度定的太大，浪费\n* 长度定的太小，对某些数据包又显得不够\n\n\n\n#### 方法3，固定分隔符\n\n服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\n\n```java\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n```\n\n客户端在每条消息之后，加入 \\n 分隔符\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                for (int j = 1; j <= r.nextInt(16)+1; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                buffer.writeByte(10);\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE\n```\n\n缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\n\n\n\n#### 方法4，预设长度\n\n在发送消息前，先约定用定长字节表示接下来数据的长度\n\n```java\n// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));\n```\n\n客户端代码\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte length = (byte) (r.nextInt(16) + 1);\n                                // 先写入长度\n                                buffer.writeByte(length);\n                                // 再\n                                for (int j = 1; j <= length; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n客户端输出\n\n```\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE\n\n```\n\n\n\n## 2. 协议设计与解析\n\n### 2.1 为什么需要协议？\n\nTCP/IP 中消息传输基于流的方式，没有边界。\n\n协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\n\n例如：在网络上传输\n\n```\n下雨天留客天留我不留\n```\n\n是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\n\n一种解读\n\n```\n下雨天留客，天留，我不留\n```\n\n另一种解读\n\n```\n下雨天，留客天，留我不？留\n```\n\n\n\n如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\n\n``` \n定长字节表示内容长度 + 实际内容\n```\n\n例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\n\n```\n0f下雨天留客06天留09我不留\n```\n\n\n\n> 小故事\n>\n> 很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\n>\n> 年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\n>\n> 私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\n>\n> 双方唇枪舌战，你来我往，真个是不亦乐乎！\n>\n> 这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\n\n\n\n### 2.2 redis 协议举例\n\n```java\nNioEventLoopGroup worker = new NioEventLoopGroup();\nbyte[] LINE = {13, 10};\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                // 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) {\n                    set(ctx);\n                    get(ctx);\n                }\n                private void get(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes("*2".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("get".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("aaa".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n                private void set(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes("*3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("set".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("aaa".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("bbb".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    ByteBuf buf = (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                }\n            });\n        }\n    });\n    ChannelFuture channelFuture = bootstrap.connect("localhost", 6379).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error("client error", e);\n} finally {\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.3 http 协议举例\n\n```java\nNioEventLoopGroup boss = new NioEventLoopGroup();\nNioEventLoopGroup worker = new NioEventLoopGroup();\ntry {\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {\n                    // 获取请求\n                    log.debug(msg.uri());\n\n                    // 返回响应\n                    DefaultFullHttpResponse response =\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes = "<h1>Hello, world!</h1>".getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                    response.content().writeBytes(bytes);\n\n                    // 写回响应\n                    ctx.writeAndFlush(response);\n                }\n            });\n            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    log.debug("{}", msg.getClass());\n\n                    if (msg instanceof HttpRequest) { // 请求行，请求头\n\n                    } else if (msg instanceof HttpContent) { //请求体\n\n                    }\n                }\n            });*/\n        }\n    });\n    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error("server error", e);\n} finally {\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.4 自定义协议要素\n\n* 魔数，用来在第一时间判定是否是无效数据包\n* 版本号，可以支持协议的升级\n* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk\n* 指令类型，是登录、注册、单聊、群聊... 跟业务相关\n* 请求序号，为了双工通信，提供异步能力\n* 正文长度\n* 消息正文\n\n\n\n#### 编解码器\n\n根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\n\n```java\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec<Message> {\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug("{}", message);\n        out.add(message);\n    }\n}\n```\n\n测试\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n// encode\nLoginRequestMessage message = new LoginRequestMessage("zhangsan", "123", "张三");\n//        channel.writeOutbound(message);\n// decode\nByteBuf buf = ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 = buf.slice(0, 100);\nByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); // 引用计数 2\nchannel.writeInbound(s1); // release 1\nchannel.writeInbound(s2);\n```\n\n\n\n解读\n\n![](img/0013.png)\n\n\n\n#### 💡 什么时候可以加 @Sharable\n\n* 当 handler 不保存状态时，就可以安全地在多线程下被共享\n* 但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\n* 如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug("{}", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n## 3. 聊天室案例\n\n### 3.1 聊天室业务介绍\n\n```java\n/**\n * 用户管理接口\n */\npublic interface UserService {\n\n    /**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     */\n    boolean login(String username, String password);\n}\n```\n\n\n\n```java\n/**\n * 会话管理接口\n */\npublic interface Session {\n\n    /**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     */\n    void bind(Channel channel, String username);\n\n    /**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     */\n    void unbind(Channel channel);\n\n    /**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     */\n    Object getAttribute(Channel channel, String name);\n\n    /**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     */\n    void setAttribute(Channel channel, String name, Object value);\n\n    /**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     */\n    Channel getChannel(String username);\n}\n```\n\n\n\n```java\n/**\n * 聊天组会话管理接口\n */\npublic interface GroupSession {\n\n    /**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     */\n    Group createGroup(String name, Set<String> members);\n\n    /**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group joinMember(String name, String member);\n\n    /**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeMember(String name, String member);\n\n    /**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeGroup(String name);\n\n    /**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     */\n    Set<String> getMembers(String name);\n\n    /**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     */\n    List<Channel> getMembersChannel(String name);\n}\n```\n\n\n\n### 3.2 聊天室业务-登录\n\n```java\n@Slf4j\npublic class ChatServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n                            String username = msg.getUsername();\n                            String password = msg.getPassword();\n                            boolean login = UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) {\n                                message = new LoginResponseMessage(true, "登录成功");\n                            } else {\n                                message = new LoginResponseMessage(false, "用户名或密码不正确");\n                            }\n                            ctx.writeAndFlush(message);\n                        }\n                    });\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n```java\n@Slf4j\npublic class ChatClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);\n        AtomicBoolean LOGIN = new AtomicBoolean(false);\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n//                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast("client handler", new ChannelInboundHandlerAdapter() {\n                        // 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                            log.debug("msg: {}", msg);\n                            if ((msg instanceof LoginResponseMessage)) {\n                                LoginResponseMessage response = (LoginResponseMessage) msg;\n                                if (response.isSuccess()) {\n                                    // 如果登录成功\n                                    LOGIN.set(true);\n                                }\n                                // 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            }\n                        }\n\n                        // 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -> {\n                                Scanner scanner = new Scanner(System.in);\n                                System.out.println("请输入用户名:");\n                                String username = scanner.nextLine();\n                                System.out.println("请输入密码:");\n                                String password = scanner.nextLine();\n                                // 构造消息对象\n                                LoginRequestMessage message = new LoginRequestMessage(username, password);\n                                // 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println("等待后续操作...");\n                                try {\n                                    WAIT_FOR_LOGIN.await();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                                // 如果登录失败\n                                if (!LOGIN.get()) {\n                                    ctx.channel().close();\n                                    return;\n                                }\n                                while (true) {\n                                    System.out.println("==================================");\n                                    System.out.println("send [username] [content]");\n                                    System.out.println("gsend [group name] [content]");\n                                    System.out.println("gcreate [group name] [m1,m2,m3...]");\n                                    System.out.println("gmembers [group name]");\n                                    System.out.println("gjoin [group name]");\n                                    System.out.println("gquit [group name]");\n                                    System.out.println("quit");\n                                    System.out.println("==================================");\n                                    String command = scanner.nextLine();\n                                    String[] s = command.split(" ");\n                                    switch (s[0]){\n                                        case "send":\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case "gsend":\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case "gcreate":\n                                            Set<String> set = new HashSet<>(Arrays.asList(s[2].split(",")));\n                                            set.add(username); // 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case "gmembers":\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case "gjoin":\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case "gquit":\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case "quit":\n                                            ctx.channel().close();\n                                            return;\n                                    }\n                                }\n                            }, "system in").start();\n                        }\n                    });\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n### 3.3 聊天室业务-单聊\n\n服务器端将 handler 独立出来\n\n登录 handler\n\n```java\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n        String username = msg.getUsername();\n        String password = msg.getPassword();\n        boolean login = UserServiceFactory.getUserService().login(username, password);\n        LoginResponseMessage message;\n        if(login) {\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message = new LoginResponseMessage(true, "登录成功");\n        } else {\n            message = new LoginResponseMessage(false, "用户名或密码不正确");\n        }\n        ctx.writeAndFlush(message);\n    }\n}\n```\n\n单聊 handler\n\n```java\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception {\n        String to = msg.getTo();\n        Channel channel = SessionFactory.getSession().getChannel(to);\n        // 在线\n        if(channel != null) {\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n        // 不在线\n        else {\n            ctx.writeAndFlush(new ChatResponseMessage(false, "对方用户不存在或者不在线"));\n        }\n    }\n}\n```\n\n\n\n### 3.4 聊天室业务-群聊\n\n创建群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception {\n        String groupName = msg.getGroupName();\n        Set<String> members = msg.getMembers();\n        // 群管理器\n        GroupSession groupSession = GroupSessionFactory.getGroupSession();\n        Group group = groupSession.createGroup(groupName, members);\n        if (group == null) {\n            // 发生成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + "创建成功"));\n            // 发送拉群消息\n            List<Channel> channels = groupSession.getMembersChannel(groupName);\n            for (Channel channel : channels) {\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, "您已被拉入" + groupName));\n            }\n        } else {\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + "已经存在"));\n        }\n    }\n}\n```\n\n群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception {\n        List<Channel> channels = GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n    }\n}\n```\n\n加入群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群加入成功"));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群不存在"));\n        }\n    }\n}\n```\n\n退出群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, "已退出群" + msg.getGroupName()));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群不存在"));\n        }\n    }\n}\n```\n\n查看成员\n\n```java\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception {\n        Set<String> members = GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    }\n}\n```\n\n\n\n### 3.5 聊天室业务-退出\n\n```\n@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter {\n\n    // 当连接断开时触发 inactive 事件\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug("{} 已经断开", ctx.channel());\n    }\n\n\t// 当出现异常时触发\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug("{} 已经异常断开 异常是{}", ctx.channel(), cause.getMessage());\n    }\n}\n```\n\n\n\n### 3.6 聊天室业务-空闲检测\n\n\n\n#### 连接假死\n\n原因\n\n* 网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\n* 公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\n* 应用程序线程阻塞，无法进行数据读写\n\n问题\n\n* 假死的连接占用的资源不能自动释放\n* 向假死的连接发送数据，得到的反馈是发送超时\n\n服务器端解决\n\n* 怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了读空闲事件\n        if (event.state() == IdleState.READER_IDLE) {\n            log.debug("已经 5s 没有读到数据了");\n            ctx.channel().close();\n        }\n    }\n});\n```\n\n\n\n客户端定时心跳\n\n* 客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了写空闲事件\n        if (event.state() == IdleState.WRITER_IDLE) {\n            //                                log.debug("3s 没有写数据了，发送一个心跳包");\n            ctx.writeAndFlush(new PingMessage());\n        }\n    }\n});\n```\n\n\n\n\n\n'},{title:"优化与源码",headers:[{level:2,title:"1. 优化",slug:"_1-优化",link:"#_1-优化",children:[{level:3,title:"1.1 扩展序列化算法",slug:"_1-1-扩展序列化算法",link:"#_1-1-扩展序列化算法",children:[]},{level:3,title:"1.2 参数调优",slug:"_1-2-参数调优",link:"#_1-2-参数调优",children:[]},{level:3,title:"1.3 RPC 框架",slug:"_1-3-rpc-框架",link:"#_1-3-rpc-框架",children:[]}]},{level:2,title:"2. 源码分析",slug:"_2-源码分析",link:"#_2-源码分析",children:[{level:3,title:"2.1 启动剖析",slug:"_2-1-启动剖析",link:"#_2-1-启动剖析",children:[]},{level:3,title:"2.2 NioEventLoop 剖析",slug:"_2-2-nioeventloop-剖析",link:"#_2-2-nioeventloop-剖析",children:[]},{level:3,title:"2.3 accept 剖析",slug:"_2-3-accept-剖析",link:"#_2-3-accept-剖析",children:[]},{level:3,title:"2.4 read 剖析",slug:"_2-4-read-剖析",link:"#_2-4-read-剖析",children:[]}]}],path:"/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html",pathLocale:"/",extraFields:'---\ntitle: 优化与源码\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2024-07-24\nlastUpdated: true\norder: 4\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - netty\n---\n\n优化与源码\n\n\x3c!-- more --\x3e\n\n\x3c!-- # 四. 优化与源码 --\x3e\n\n## 1. 优化\n\n### 1.1 扩展序列化算法\n\n序列化，反序列化主要用在消息正文的转换上\n\n* 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\n* 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\n\n目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\n\n```java\n// 反序列化\nbyte[] body = new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message = (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n// 序列化\nByteArrayOutputStream out = new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes = out.toByteArray();\n```\n\n为了支持更多序列化算法，抽象一个 Serializer 接口\n\n```java\npublic interface Serializer {\n\n    // 反序列化方法\n    <T> T deserialize(Class<T> clazz, byte[] bytes);\n\n    // 序列化方法\n    <T> byte[] serialize(T object);\n\n}\n```\n\n提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\n\n```java\nenum SerializerAlgorithm implements Serializer {\n\t// Java 实现\n    Java {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            try {\n                ObjectInputStream in = \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object = in.readObject();\n                return (T) object;\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException("SerializerAlgorithm.Java 反序列化错误", e);\n            }\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            try {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            } catch (IOException e) {\n                throw new RuntimeException("SerializerAlgorithm.Java 序列化错误", e);\n            }\n        }\n    }, \n    // Json 实现(引入了 Gson 依赖)\n    Json {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);\n        }\n    };\n\n    // 需要从协议的字节中得到是哪种序列化算法\n    public static SerializerAlgorithm getByInt(int type) {\n        SerializerAlgorithm[] array = SerializerAlgorithm.values();\n        if (type < 0 || type > array.length - 1) {\n            throw new IllegalArgumentException("超过 SerializerAlgorithm 范围");\n        }\n        return array[type];\n    }\n}\n```\n\n\n\n增加配置类和配置文件\n\n```java\npublic abstract class Config {\n    static Properties properties;\n    static {\n        try (InputStream in = Config.class.getResourceAsStream("/application.properties")) {\n            properties = new Properties();\n            properties.load(in);\n        } catch (IOException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    public static int getServerPort() {\n        String value = properties.getProperty("server.port");\n        if(value == null) {\n            return 8080;\n        } else {\n            return Integer.parseInt(value);\n        }\n    }\n    public static Serializer.Algorithm getSerializerAlgorithm() {\n        String value = properties.getProperty("serializer.algorithm");\n        if(value == null) {\n            return Serializer.Algorithm.Java;\n        } else {\n            return Serializer.Algorithm.valueOf(value);\n        }\n    }\n}\n```\n\n\n\n配置文件\n\n```properties\nserializer.algorithm=Json\n```\n\n\n\n修改编解码器\n\n```java\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerAlgorithm = in.readByte(); // 0 或 1\n        byte messageType = in.readByte(); // 0,1,2...\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n\n        // 找到反序列化算法\n        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];\n        // 确定具体消息类型\n        Class<? extends Message> messageClass = Message.getMessageClass(messageType);\n        Message message = algorithm.deserialize(messageClass, bytes);\n//        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n//        log.debug("{}", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n其中确定具体消息类型，可以根据 `消息类型字节` 获取到对应的 `消息 class`\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    /**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     */\n    public static Class<? extends Message> getMessageClass(int messageType) {\n        return messageClasses.get(messageType);\n    }\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage = 0;\n    public static final int LoginResponseMessage = 1;\n    public static final int ChatRequestMessage = 2;\n    public static final int ChatResponseMessage = 3;\n    public static final int GroupCreateRequestMessage = 4;\n    public static final int GroupCreateResponseMessage = 5;\n    public static final int GroupJoinRequestMessage = 6;\n    public static final int GroupJoinResponseMessage = 7;\n    public static final int GroupQuitRequestMessage = 8;\n    public static final int GroupQuitResponseMessage = 9;\n    public static final int GroupChatRequestMessage = 10;\n    public static final int GroupChatResponseMessage = 11;\n    public static final int GroupMembersRequestMessage = 12;\n    public static final int GroupMembersResponseMessage = 13;\n    public static final int PingMessage = 14;\n    public static final int PongMessage = 15;\n    private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>();\n\n    static {\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    }\n}\n```\n\n\n\n### 1.2 参数调优\n\n#### 1）CONNECT_TIMEOUT_MILLIS\n\n* 属于 SocketChannal 参数\n* 用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\n\n* SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\n\n```java\n@Slf4j\npublic class TestConnectionTimeout {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future = bootstrap.connect("127.0.0.1", 8080);\n            future.sync().channel().closeFuture().sync(); // 断点1\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.debug("timeout");\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n另外源码部分 `io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect`\n\n```java\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    // Schedule connect timeout.\n    int connectTimeoutMillis = config().getConnectTimeoutMillis();\n    if (connectTimeoutMillis > 0) {\n        connectTimeoutFuture = eventLoop().schedule(new Runnable() {\n            @Override\n            public void run() {                \n                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause =\n                    new ConnectTimeoutException("connection timed out: " + remoteAddress); // 断点2\n                if (connectPromise != null && connectPromise.tryFailure(cause)) {\n                    close(voidPromise());\n                }\n            }\n        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\t// ...\n}\n```\n\n\n\n#### 2）SO_BACKLOG\n\n* 属于 ServerSocketChannal 参数\n\n```mermaid\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as syns queue\nparticipant aq as accept queue\n\ns ->> s : bind()\ns ->> s : listen()\nc ->> c : connect()\nc ->> s : 1. SYN\nNote left of c : SYN_SEND\ns ->> sq : put\nNote right of s : SYN_RCVD\ns ->> c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc ->> s : 3. ACK\nsq ->> aq : put\nNote right of s : ESTABLISHED\naq --\x3e> s : \ns ->> s : accept()\n```\n\n1. 第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\n2. 第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\n3. 第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\n\n其中\n\n* 在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\n\n* sync queue - 半连接队列\n  * 大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 `syncookies` 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n* accept queue - 全连接队列\n  * 其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\n  * 如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\n\n\n\nnetty 中\n\n可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小\n\n\n\n可以通过下面源码查看默认大小\n\n```java\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig {\n\n    private volatile int backlog = NetUtil.SOMAXCONN;\n    // ...\n}\n```\n\n\n\n课堂调试关键断点为：`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n\n\noio 中更容易说明，不用 debug 模式\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888, 2);\n        Socket accept = ss.accept();\n        System.out.println(accept);\n        System.in.read();\n    }\n}\n```\n\n客户端启动 4 个\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        try {\n            Socket s = new Socket();\n            System.out.println(new Date()+" connecting...");\n            s.connect(new InetSocketAddress("localhost", 8888),1000);\n            System.out.println(new Date()+" connected...");\n            s.getOutputStream().write(1);\n            System.in.read();\n        } catch (IOException e) {\n            System.out.println(new Date()+" connecting timeout...");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\n\n```java\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...\n```\n\n第 4 个客户端连接时\n\n```\nTue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out\n```\n\n\n\n\n\n#### 3）ulimit -n\n\n* 属于操作系统参数\n\n\n\n#### 4）TCP_NODELAY\n\n* 属于 SocketChannal 参数\n\n\n\n#### 5）SO_SNDBUF & SO_RCVBUF\n\n* SO_SNDBUF 属于 SocketChannal 参数\n* SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n\n\n\n#### 6）ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 用来分配 ByteBuf， ctx.alloc()\n\n\n\n#### 7）RCVBUF_ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 控制 netty 接收缓冲区大小\n* 负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\n\n\n\n### 1.3 RPC 框架\n\n#### 1）准备工作\n\n这些代码可以认为是现成的，无需从头编写练习\n\n为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    // 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;\n\n    static {\n        // ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    }\n\n}\n```\n\n请求消息\n\n```java\n@Getter\n@ToString(callSuper = true)\npublic class RpcRequestMessage extends Message {\n\n    /**\n     * 调用的接口全限定名，服务端根据它找到实现\n     */\n    private String interfaceName;\n    /**\n     * 调用接口中的方法名\n     */\n    private String methodName;\n    /**\n     * 方法返回类型\n     */\n    private Class<?> returnType;\n    /**\n     * 方法参数类型数组\n     */\n    private Class[] parameterTypes;\n    /**\n     * 方法参数值数组\n     */\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) {\n        super.setSequenceId(sequenceId);\n        this.interfaceName = interfaceName;\n        this.methodName = methodName;\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.parameterValue = parameterValue;\n    }\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_REQUEST;\n    }\n}\n```\n\n响应消息\n\n```java\n@Data\n@ToString(callSuper = true)\npublic class RpcResponseMessage extends Message {\n    /**\n     * 返回值\n     */\n    private Object returnValue;\n    /**\n     * 异常值\n     */\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    }\n}\n```\n\n服务器架子\n\n```java\n@Slf4j\npublic class RpcServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端架子\n\n```java\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的 service 获取\n\n```java\npublic class ServicesFactory {\n\n    static Properties properties;\n    static Map<Class<?>, Object> map = new ConcurrentHashMap<>();\n\n    static {\n        try (InputStream in = Config.class.getResourceAsStream("/application.properties")) {\n            properties = new Properties();\n            properties.load(in);\n            Set<String> names = properties.stringPropertyNames();\n            for (String name : names) {\n                if (name.endsWith("Service")) {\n                    Class<?> interfaceClass = Class.forName(name);\n                    Class<?> instanceClass = Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                }\n            }\n        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    public static <T> T getService(Class<T> interfaceClass) {\n        return (T) map.get(interfaceClass);\n    }\n}\n```\n\n相关配置 application.properties\n\n```\nserializer.algorithm=Json\ncn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl\n```\n\n\n\n#### 2）服务器 handler\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> {\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) {\n        RpcResponseMessage response = new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());\n        try {\n            // 获取真正的实现对象\n            HelloService service = (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            // 获取要调用的方法\n            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            // 调用方法\n            Object invoke = method.invoke(service, message.getParameterValue());\n            // 调用成功\n            response.setReturnValue(invoke);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 调用异常\n            response.setExceptionValue(e);\n        }\n        // 返回结果\n        ctx.writeAndFlush(response);\n    }\n}\n```\n\n\n\n\n\n#### 3）客户端代码第一版\n\n只发消息\n\n```java\n@Slf4j\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n\n            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    "cn.itcast.server.service.HelloService",\n                    "sayHello",\n                    String.class,\n                    new Class[]{String.class},\n                    new Object[]{"张三"}\n            )).addListener(promise -> {\n                if (!promise.isSuccess()) {\n                    Throwable cause = promise.cause();\n                    log.error("error", cause);\n                }\n            });\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n#### 4）客户端 handler 第一版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug("{}", msg);\n    }\n}\n```\n\n\n\n\n\n#### 5）客户端代码 第二版\n\n包括 channel 管理，代理，接收结果\n\n```java\n@Slf4j\npublic class RpcClientManager {\n\n\n    public static void main(String[] args) {\n        HelloService service = getProxyService(HelloService.class);\n        System.out.println(service.sayHello("zhangsan"));\n//        System.out.println(service.sayHello("lisi"));\n//        System.out.println(service.sayHello("wangwu"));\n    }\n\n    // 创建代理类\n    public static <T> T getProxyService(Class<T> serviceClass) {\n        ClassLoader loader = serviceClass.getClassLoader();\n        Class<?>[] interfaces = new Class[]{serviceClass};\n        //                                                            sayHello  "张三"\n        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> {\n            // 1. 将方法调用转换为 消息对象\n            int sequenceId = SequenceIdGenerator.nextId();\n            RpcRequestMessage msg = new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            // 2. 将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程\n            DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop());\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n//            promise.addListener(future -> {\n//                // 线程\n//            });\n\n            // 4. 等待 promise 结果\n            promise.await();\n            if(promise.isSuccess()) {\n                // 调用正常\n                return promise.getNow();\n            } else {\n                // 调用失败\n                throw new RuntimeException(promise.cause());\n            }\n        });\n        return (T) o;\n    }\n\n    private static Channel channel = null;\n    private static final Object LOCK = new Object();\n\n    // 获取唯一的 channel 对象\n    public static Channel getChannel() {\n        if (channel != null) {\n            return channel;\n        }\n        synchronized (LOCK) { //  t2\n            if (channel != null) { // t1\n                return channel;\n            }\n            initChannel();\n            return channel;\n        }\n    }\n\n    // 初始化 channel 方法\n    private static void initChannel() {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            }\n        });\n        try {\n            channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().addListener(future -> {\n                group.shutdownGracefully();\n            });\n        } catch (Exception e) {\n            log.error("client error", e);\n        }\n    }\n}\n```\n\n\n\n#### 6）客户端 handler 第二版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n\n    //                       序号      用来接收结果的 promise 对象\n    public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug("{}", msg);\n        // 拿到空的 promise\n        Promise<Object> promise = PROMISES.remove(msg.getSequenceId());\n        if (promise != null) {\n            Object returnValue = msg.getReturnValue();\n            Exception exceptionValue = msg.getExceptionValue();\n            if(exceptionValue != null) {\n                promise.setFailure(exceptionValue);\n            } else {\n                promise.setSuccess(returnValue);\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n## 2. 源码分析\n\n### 2.1 启动剖析\n\n我们就来看看 netty 中对下面的代码是怎样进行处理的\n\n```java\n//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector = Selector.open(); \n\n//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment = new NioServerSocketChannel();\n\n//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n//4 启动 nio boss 线程执行接下来的操作\n\n//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);\n\n//6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor\n\n//7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n//8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n```\n\n\n\n\n\n\n\n入口 `io.netty.bootstrap.ServerBootstrap#bind`\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind`\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n\t// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) {\n        return regFuture;\n    }\n\n    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    // 2.1 如果已经完成\n    if (regFuture.isDone()) {\n        ChannelPromise promise = channel.newPromise();\n        // 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    } \n    // 2.2 还没有完成\n    else {\n        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n        // 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                Throwable cause = future.cause();\n                if (cause != null) {\n                    // 处理异常...\n                    promise.setFailure(cause);\n                } else {\n                    promise.registered();\n\t\t\t\t\t// 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                }\n            }\n        });\n        return promise;\n    }\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#initAndRegister`\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    try {\n        channel = channelFactory.newChannel();\n        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    } catch (Throwable t) {\n        // 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    }\n\n    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) {\n        // 处理异常...\n    }\n    return regFuture;\n}\n```\n\n关键代码 `io.netty.bootstrap.ServerBootstrap#init`\n\n```java\n// 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception {\n    final Map<ChannelOption<?>, Object> options = options0();\n    synchronized (options) {\n        setChannelOptions(channel, options, logger);\n    }\n\n    final Map<AttributeKey<?>, Object> attrs = attrs0();\n    synchronized (attrs) {\n        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n            @SuppressWarnings("unchecked")\n            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n            channel.attr(key).set(e.getValue());\n        }\n    }\n\n    ChannelPipeline p = channel.pipeline();\n\n    final EventLoopGroup currentChildGroup = childGroup;\n    final ChannelHandler currentChildHandler = childHandler;\n    final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n    synchronized (childOptions) {\n        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));\n    }\n    synchronized (childAttrs) {\n        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));\n    }\n\t\n    // 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer<Channel>() {\n        @Override\n        public void initChannel(final Channel ch) throws Exception {\n            final ChannelPipeline pipeline = ch.pipeline();\n            ChannelHandler handler = config.handler();\n            if (handler != null) {\n                pipeline.addLast(handler);\n            }\n\n            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() {\n                @Override\n                public void run() {\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                }\n            });\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行\n            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            // 这行代码完成的事实是 main -> nio boss 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\n        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        // 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) {\n            if (firstRegistration) {\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        // Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n关键代码 `io.netty.channel.ChannelInitializer#initChannel`\n\n```java\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n    if (initMap.add(ctx)) { // Guard against re-entrance.\n        try {\n            // 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        } catch (Throwable cause) {\n            exceptionCaught(ctx, cause);\n        } finally {\n            // 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline = ctx.pipeline();\n            if (pipeline.context(this) != null) {\n                pipeline.remove(this);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind0`\n\n```java\n// 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) {\n\n    channel.eventLoop().execute(new Runnable() {\n        @Override\n        public void run() {\n            if (regFuture.isSuccess()) {\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                promise.setFailure(regFuture.cause());\n            }\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#bind`\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) {\n        return;\n    }\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&\n        localAddress instanceof InetSocketAddress &&\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&\n        !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {\n        // 记录日志...\n    }\n\n    boolean wasActive = isActive();\n    try {\n        // 3.3 执行端口绑定\n        doBind(localAddress);\n    } catch (Throwable t) {\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    }\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // 3.4 触发 active 事件\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n\n    safeSetSuccess(promise);\n}\n```\n\n3.3 关键代码 `io.netty.channel.socket.nio.NioServerSocketChannel#doBind`\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n```\n\n3.4 关键代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();\n}\n```\n\n关键代码 `io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps & readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.2 NioEventLoop 剖析\n\nNioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\n\n提交任务代码 `io.netty.util.concurrent.SingleThreadEventExecutor#execute`\n\n```java\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException("task");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) {\n        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) {\n            // 如果已经 shutdown，做拒绝逻辑，代码略...\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    }\n}\n```\n\n\n\n唤醒 select 阻塞线程`io.netty.channel.nio.NioEventLoop#wakeup`\n\n```java\n@Override\nprotected void wakeup(boolean inEventLoop) {\n    if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n        selector.wakeup();\n    }\n}\n```\n\n\n\n启动 EventLoop 主循环 `io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread`\n\n```java\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            // 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn("Unexpected exception from an event executor: ", t);\n            } finally {\n\t\t\t\t// 清理工作，代码略...\n            }\n        }\n    });\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#run` 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\n\n```java\nprotected void run() {\n    for (;;) {\n        try {\n            try {\n                // calculateStrategy 的逻辑如下：\n                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        // 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp = wakenUp.getAndSet(false);\n                        \n                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        // 下面的 select 方法不会阻塞\n                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        // 才能执行，让 select 方法无谓阻塞\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                }\n            } catch (IOException e) {\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // ioRatio 默认是 50\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // ioRatio 为 100 时，总是运行完所有非 IO 任务\n                    runAllTasks();\n                }\n            } else {                \n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // 记录 io 事件处理耗时\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    // 运行非 IO 任务，一旦超时会退出 runAllTasks\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n\n\n#### ⚠️ 注意\n\n> 这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\n>\n> * 由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\n> * 由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\n\n\n\n参考下图\n\n<img src="img/0032.png"  />\n\n\n\n`io.netty.channel.nio.NioEventLoop#select`\n\n```java\nprivate void select(boolean oldWakenUp) throws IOException {\n    Selector selector = this.selector;\n    try {\n        int selectCnt = 0;\n        long currentTimeNanos = System.nanoTime();\n        // 计算等待时间\n        // * 没有 scheduledTask，超时时间为 1s\n        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`\n        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) {\n            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;\n            // 如果超时，退出循环\n            if (timeoutMillis <= 0) {\n                if (selectCnt == 0) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                }\n                break;\n            }\n\n            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                selector.selectNow();\n                selectCnt = 1;\n                break;\n            }\n\n            // select 有限时阻塞\n            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%\n            int selectedKeys = selector.select(timeoutMillis);\n            // 计数加 1\n            selectCnt ++;\n\n            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环\n            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                break;\n            }\n            if (Thread.interrupted()) {\n               \t// 线程被打断，退出循环\n                // 记录日志\n                selectCnt = 1;\n                break;\n            }\n\n            long time = System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                // 如果超时，计数重置为 1，下次循环就会 break\n                selectCnt = 1;\n            } \n            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            // 这是为了解决 nio 空轮询 bug\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {\n                // 重建 selector\n                selector = selectRebuildSelector(selectCnt);\n                selectCnt = 1;\n                break;\n            }\n\n            currentTimeNanos = time;\n        }\n\n        if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) {\n            // 记录日志\n        }\n    } catch (CancelledKeyException e) {\n        // 记录日志\n    }\n}\n```\n\n\n\n处理 keys `io.netty.channel.nio.NioEventLoop#processSelectedKeys`\n\n```java\nprivate void processSelectedKeys() {\n    if (selectedKeys != null) {\n        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();\n    } else {\n        processSelectedKeysPlain(selector.selectedKeys());\n    }\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n    // 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) {\n        // 无效时处理...\n        return;\n    }\n\n    try {\n        int readyOps = k.readyOps();\n        // 连接事件\n        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n            int ops = k.interestOps();\n            ops &= ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        }\n\n        // 可写事件\n        if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n            ch.unsafe().forceFlush();\n        }\n\n        // 可读或可接入事件\n        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();\n        }\n    } catch (CancelledKeyException ignored) {\n        unsafe.close(unsafe.voidPromise());\n    }\n}\n```\n\n\n\n### 2.3 accept 剖析\n\nnio 中如下代码，在 netty 中的流程\n\n```java\n//1 阻塞直到事件发生\nselector.select();\n\nIterator<SelectionKey> iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) {    \n    //2 拿到一个事件\n    SelectionKey key = iter.next();\n    \n    //3 如果是 accept 事件\n    if (key.isAcceptable()) {\n        \n        //4 执行 accept\n        SocketChannel channel = serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        //5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n先来看可接入事件处理（accept）\n\n`io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read`\n\n```java\npublic void read() {\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config = config();\n    final ChannelPipeline pipeline = pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed = false;\n    Throwable exception = null;\n    try {\n        try {\n            do {\n\t\t\t\t// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf\n                // readBuf 是一个 ArrayList 用来缓存消息\n                int localRead = doReadMessages(readBuf);\n                if (localRead == 0) {\n                    break;\n                }\n                if (localRead < 0) {\n                    closed = true;\n                    break;\n                }\n\t\t\t\t// localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            } while (allocHandle.continueReading());\n        } catch (Throwable t) {\n            exception = t;\n        }\n\n        int size = readBuf.size();\n        for (int i = 0; i < size; i ++) {\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        }\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception != null) {\n            closed = closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        }\n\n        if (closed) {\n            inputShutdown = true;\n            if (isOpen()) {\n                close(voidPromise());\n            }\n        }\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n关键代码 `io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead`\n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // 这时的 msg 是 NioSocketChannel\n    final Channel child = (Channel) msg;\n\n    // NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    // 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n        child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n    }\n\n    try {\n        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}\n```\n\n\n\n又回到了熟悉的 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`  方法\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 这行代码完成的事实是 nio boss -> nio worker 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\t\t\n        // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        // 执行后就是 head -> logging handler -> my handler -> tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) {\n            if (firstRegistration) {\n                // 触发 pipeline 上 active 事件\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n\n\n回到了熟悉的代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n}\n```\n\n`io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\t// 这时候 interestOps 是 0\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps & readInterestOp) == 0) {\n        // 关注 read 事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.4 read 剖析\n\n再来看可读事件 `io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read`，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\n\n```java\npublic final void read() {\n    final ChannelConfig config = config();\n    if (shouldBreakReadReady(config)) {\n        clearReadPending();\n        return;\n    }\n    final ChannelPipeline pipeline = pipeline();\n    // io.netty.allocator.type 决定 allocator 的实现\n    final ByteBufAllocator allocator = config.getAllocator();\n    // 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            // 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() <= 0) {\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() < 0;\n                if (close) {\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } \n        // 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        // 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)`\n\n```java\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {\n    return \n           // 一般为 true\n           config.isAutoRead() &&\n           // respectMaybeMoreData 默认为 true\n           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&\n           // 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages < maxMessagePerRead &&\n           // 实际读到了数据\n           totalBytesRead > 0;\n}\n```\n\n\n\n'},{title:"spring 学习笔记",headers:[{level:2,title:"1.javaWeb的弊端",slug:"_1-javaweb的弊端",link:"#_1-javaweb的弊端",children:[]},{level:2,title:"2.IOC思想",slug:"_2-ioc思想",link:"#_2-ioc思想",children:[]},{level:2,title:"3.DI思想",slug:"_3-di思想",link:"#_3-di思想",children:[]},{level:2,title:"4.AOP 思想",slug:"_4-aop-思想",link:"#_4-aop-思想",children:[]},{level:2,title:"5.spring框架的诞生",slug:"_5-spring框架的诞生",link:"#_5-spring框架的诞生",children:[{level:3,title:"5.1.ApplicationContext快速入门",slug:"_5-1-applicationcontext快速入门",link:"#_5-1-applicationcontext快速入门",children:[]},{level:3,title:"5.2.BeanFactory与ApplicationContext的关系",slug:"_5-2-beanfactory与applicationcontext的关系",link:"#_5-2-beanfactory与applicationcontext的关系",children:[]}]},{level:2,title:"6.spring的配置详解",slug:"_6-spring的配置详解",link:"#_6-spring的配置详解",children:[{level:3,title:"6.1.Bean的基础配置",slug:"_6-1-bean的基础配置",link:"#_6-1-bean的基础配置",children:[]}]},{level:2,title:"web层解决方案-SpringMVC",slug:"web层解决方案-springmvc",link:"#web层解决方案-springmvc",children:[]}],path:"/posts/java/spring/spring.html",pathLocale:"/",extraFields:'---\ntitle: spring 学习笔记\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - spring\n\ntag:\n  - java\n  - spring\n  - springboot\n\n\n---\n\n上帝赋予java生命，spring赋予java生命的延续\n\x3c!-- more --\x3e\n# spring\n\n标签（空格分隔）： spring\n\n---\n\n上帝赋予java生命，spring赋予java生命的延续\n\n## 1.javaWeb的弊端\n有两个困惑：\n\n困惑一：层与层之间紧密耦合在了一起， 接口与具体实现紧密耦合在了一起；eg：调用其他类中的方法总是要new一个\n困惑二：通用的事务功能耦合在业务代码中，通用的日志功能耦合在业务代码中；eg：说白了也是对象，要new\n\n## 2.IOC思想\nIoC思想： Inversion of Control，翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。\n\n例如：原来在程序中手动的去 new UserServiceImpl()，手动的去new UserDaoImpl()，而根据IoC思想的指导，\n寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。\n\n谁去充当第三方角色呢？——>工厂设计模式，BeanFactory来充当第三方的角色，来产生Bean实例\n\nBeanFactory怎么知道产生哪些Bean实例呢？——>可以使用配置文件配置Bean的基本信息，BeanFactory根据配置文件来生产Bean实例\n\n```text\n程序 -> BeanFactory -> 配置文件 -> UserServiceImpl 和 UserDaoImpl\n```\n\n```java\npublic static void main(String[]args){\n    BeanFactory beanFactory = new BeanFactory("beans.xml");//获取配置文件\n    UserServie userService = (UserService)beanFactory.getBean("userService");//获取userService的对象实例    \n}\n```\n## 3.DI思想\nIOC的全称为（Inversion of Control），即“控制反转”；DI注入全称（Dependency Injection）依赖注入，二者是同一个事物的不同叫法，两者不是什么技术，而是一种设计思想。\n\n上面使用BeanFactory的方式已经实现的"控制反转"，将Bean的创建权交给了BeanFactory，如果我们想将\nUserDao的创建权也反转给BeanFactory，与此同时UserService内部还需要用到UserDao实例对象，那应该怎\n样操作呢？\n\n* 1.在程序中，通过BeanFactory获得UserService\n* 2.在程序中，通过BeanFactory获得UserDao\n* 3.在程序中，将UserDao设置给UserService\n\nxml配置文件如下：\n\n```xml\n\x3c!-- UserService配置 --\x3e\n<bean id="userService" class="com.study.UserServiceImpl"></bean>\n\x3c!-- UserDao配置 --\x3e\n<bean id="userDao" class="com.study.UserDaoImpl"></bean>\n```\n\n\n代码如下：\n\n```java\npublic static void main(String[]args){\n        //获取配置文件,创建工厂\n        BeanFactory beanFactory = new BeanFactory("beans.xml");\n        //获取userService的实例对象\n        UserServie userService = (UserService)beanFactory.getBean("userService");\n        //获得UserDao实例对象\n        UserDao userDao = (UserDao)beanFactroy.getBean("userDao");\n        //将UserDao设置给UserService\n        userService.setUserDao(userDao);\n}\n```\n\n但是上述UserService存在于BeanFactory中， UserDao也存在于BeanFactory中，可以在BeanFactory内部进行结合。\n\n这样的话要修改一下xml文件；\n```xml\n\x3c!-- UserDao配置 --\x3e\n<bean id="userDao" class="com.study.UserDaoImpl"></bean>\n\x3c!-- UserService配置 --\x3e\n<bean id="userService" class="com.study.UserServiceImpl">\n    <property name="userDao" ref="userDao"></property>\n</bean>\n```\n将UserDao在BeanFactory内部设置给UserService的过程叫做“注入”，而UserService需要依赖UserDao的注入才能正常工作，这个过程叫做“依赖注入”。\n\n\n解决困惑一：程序代码中不要手动new对象，第三方根据要求为程序提供需要的Bean对象。\n\n## 4.AOP 思想\nIoC和DI思想主要是解决前面我们的困惑一，困惑二还没有解决\n\n困惑二的解决方案是，借助于IoC思想，将Bean的创建权反转给BeanFactory，而BeanFactory生产的Bean是目标Bean的代理对象，这样就可以在代理对象中对目标对象方法进行相应的增强。\n\nAOP，Aspect Oriented Programming，切面编程思想，是对面向对象编程OOP的升华。OOP是纵向对一个\n事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。而AOP是横向的对不同事物的抽象，属\n性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程。\n\n可以理解一下，公共类或者动态代理。\n\n**三种思想的总结:**\n* IoC控制反转，是将程序创建Bean的权利反转给第三方；\n* DI依赖注入，某个完整Bean需要依赖于其他Bean（或属性）的注入；\n* AOP面向切面编程，用横向抽取方法（属性、对象等）思想，组装成一个功能性切面。\n\n\n困惑二解决：程序代码中不要手动new对象，第三方根据要求为程序提供需要的Bean对象的代理对象，代理对象内部动态结合业务和通用功能。\n\n## 5.spring框架的诞生\n以上思想落地框架：\nSpring框架的历史\n* Jsp 默默扛下所有；\n* MVC+三层架构分工明确，但开发成本及其高；\n* EJB 重量级框架出现，走出一个困境，有进入另一个困境；\n* Spring 春天来到，随之，SSH风生水起、称霸武林；\n* Spring 稳住江湖大哥位置，SSM开始上位；\n* Spring 本着“拿来主义”的思维快速发展，生态不断健全；\n* SpringBoot 又一里程碑崛起，把“约定大于配置“思想玩儿的炉火纯青；\n* SpringCloud 打包了微服务众多解决方案，应对互联网项目更加easy！\n\n### 5.1.ApplicationContext快速入门\nApplicationContext 称为Spring容器，内部封装了BeanFactory，比BeanFactory功能更丰富更强大，使用\nApplicationContext 进行开发时，xml配置文件的名称习惯写成applicationContext.xml\n\n```java\n//创建ApplicationContext,加载配置文件，实例化容器\nApplicationContext applicationContext = new ClassPathxmlApplicationContext(“applicationContext.xml");\n//根据beanName获得容器中的Bean实例\nUserService userService = (UserService) applicationContext.getBean("userService");\nSystem.out.println(userService);\n```\n\n### 5.2.BeanFactory与ApplicationContext的关系\n\n* BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为 Spring 容器；\n* ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；\n* Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系。\n* Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。\n* ApplicationContext除了继承了BeanFactory外，还继承了ApplicationEventPublisher（事件发布器）、 ResouresPatternResolver（资源解析器）、MessageSource（消息资源）等。但是ApplicationContext的核心功能还是BeanFactory。\n\n提现他们的继承关系：BeanFactory是核心接口，项目运行过程中肯定有具体实现参与，这个具体实现就是DefaultListableBeanFactory，而ApplicationContext内部维护的Beanfactory的实现类也是它\n\n**只在Spring基础环境下，常用的三个ApplicationContext作用如下：**\n\n| 实现类                             | 功能描述                                    |\n| ---------------------------------- | ------------------------------------------- |\n| ClassPathXmlApplicationContext     | 加载类路径下的xml配置的ApplicationContext   |\n| FileSystemXmlApplicationContext    | 加载磁盘路径下的xml配置的ApplicationContext |\n| AnnotationConfigApplicationContext | 加载注解配置类的ApplicationContext          |\n\n**在Spring的web环境下，常用的两个ApplicationContext作用如下：**\n\n| 实现类                             | 功能描述                                    |\n| ---------------------------------- | ------------------------------------------- |\n| XmlWebApplicationContext     | web环境下，加载类路径下的xml配置的ApplicationContext   |\n| AnnotationConfigWebApplicationContext    | web环境下，加载磁盘路径下的xml配置的ApplicationContext |\n\nPS：web环境下的这两个ApplicationContext，在学习Spring集成web时在进行讲解\n\n## 6.spring的配置详解\n\n| Xml配置方式                               | **功能描述**                                                 |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| `<bean id="" class="">`                     | Bean的id和全限定名配置                                       |\n| `<bean name=""> `                    | 通过name设置Bean的别名，通过别名也能直接获取到Bean实例       |\n| `<bean scope="">`                   | Bean的作用范围，BeanFactory作为容器时取值singleton和prototype |\n| `<bean lazy-init="">`                  | Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效    |\n| `<bean init-method="">`                 | Bean实例化后自动执行的初始化方法，method指定方法名           |\n| `<bean destroy-method="">`                | Bean实例销毁前的方法，method指定方法名                       |\n| `<bean autowire="byType">`               | 设置自动注入模式，常用的有按照类型byType，按照名字byName     |\n| `<bean factory-bean="" factory-method=""/>` | 指定哪个工厂Bean的哪个方法完成Bean的创建                     |\n\n\n\n\n\n### 6.1.Bean的基础配置\n\n1）Bean的基础配置\n\n例如：配置UserDaoImpl由Spring容器负责管理\n\n```xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>\n```\n\n此时存储到Spring容器（singleObjects单例池）中的Bean的beanName是userDao，值是UserDaoImpl对象，可以根据beanName获取Bean实例。\n\n```java\napplicationContext.getBean("userDao");\n```\n\n如果不配置id，则Spring会把当前Bean实例的全限定名作为beanName\n\n```java\napplicationContext.getBean("com.itheima.dao.impl.UserDaoImpl");\n```\n\n2）Bean的别名配置\n\n可以为当前Bean指定多个别名，根据别名也可以获得Bean对象\n\n```xml\n<bean id="userDao" name="aaa,bbb" class="com.itheima.dao.impl.UserDaoImpl"/>\n```\n\n此时多个名称都可以获得UserDaoImpl实例对象\n\n```java\napplicationContext.getBean("userDao");\napplicationContext.getBean("aaa");\napplicationContext.getBean("bbb");\n```\n\n3）Bean的范围配置\n\n默认情况下，单纯的Spring环境Bean的作用范围有两个：Singleton和Prototype\n\n* **singleton**：单例，默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中，每次getBean时都是从单例池中获取相同的Bean实例；\n\n* **prototype**：原型，Spring容器初始化时不会创建Bean实例，当调用getBean时才会实例化Bean，每次getBean都会创建一个新的Bean实例。\n\n\n\n3）Bean的范围配置\n\n当scope设置为**singleton**时，获得两次对象打印结果是一样的\n\n```xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" scope="singleton"/>\n```\n\n```java\nObject userDao = applicationContext.getBean("userDao");\nObject userDao2 = applicationContext.getBean("userDao");\nSystem.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@631330c\nSystem.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@631330c\n```\n\n通过断点调试，观察可以发现单例池中存在 userDao 实例\n\n当scope设置为**prototype**时，获得两次对象打印结果是不一样的\n\n```xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" scope="prototype"/>\n```\n\n```java\nObject userDao = applicationContext.getBean("userDao");\nObject userDao2 = applicationContext.getBean("userDao");\nSystem.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@4d50efb8\nSystem.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@7e2d773b\n```\n\n通过断点调试，观察可以发现单例池中不存在 userDao 实例，但是 userDao的信息已经被存储到\n\nbeanDefinitionMap中了\n\n4）Bean的延迟加载\n\n当lazy-init设置为true时为延迟加载，也就是当Spring容器创建的时候，不会立即创建Bean实例，等待用到时在创\n\n建Bean实例并存储到单例池中去，后续在使用该Bean直接从单例池获取即可，本质上该Bean还是单例的\n\n```xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" lazy-init="true"/>\n```\n\n\n\n## web层解决方案-SpringMVC\n\n\n\n\n\n'},{title:"spring面试题",headers:[{level:2,title:"IoC 和 DI 的关系？",slug:"ioc-和-di-的关系",link:"#ioc-和-di-的关系",children:[]}],path:"/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html",pathLocale:"/",extraFields:"---\ntitle: spring面试题\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\n\ntag:\n  - java\n  - spring\n  - springboot\n\n---\n\n上帝赋予java生命，spring赋予java生命的延续\n\x3c!-- more --\x3e\n# spring面试题\n\n标签（空格分隔）： spring\n\n---\n\n## IoC 和 DI 的关系？\n首先，先回答IoC和DI的是什么：\n* IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方\n* DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入\n\n其次，在回答IoC和DI的关系：\n* 第一种观点：IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系，认为不是一回事\n* 第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式\n\n\n"},{title:"springboot 工作中遇到的问题",headers:[{level:2,title:"pringboot的yml文件没有小叶子",slug:"pringboot的yml文件没有小叶子",link:"#pringboot的yml文件没有小叶子",children:[]},{level:2,title:"Failed to configure a DataSource: ‘url‘ attribute is not specified and no embedded datasource",slug:"failed-to-configure-a-datasource-url-attribute-is-not-specified-and-no-embedded-datasource",link:"#failed-to-configure-a-datasource-url-attribute-is-not-specified-and-no-embedded-datasource",children:[{level:3,title:"解决一：项目不需要连数据库",slug:"解决一-项目不需要连数据库",link:"#解决一-项目不需要连数据库",children:[]},{level:3,title:"解决二：项目需要连接数据库",slug:"解决二-项目需要连接数据库",link:"#解决二-项目需要连接数据库",children:[]},{level:3,title:"解决三：mysql版本问题",slug:"解决三-mysql版本问题",link:"#解决三-mysql版本问题",children:[]},{level:3,title:"解决四：项目没有加载到yml或者properties文件",slug:"解决四-项目没有加载到yml或者properties文件",link:"#解决四-项目没有加载到yml或者properties文件",children:[]},{level:3,title:"解决五：项目使用了springcloud+nacos系列",slug:"解决五-项目使用了springcloud-nacos系列",link:"#解决五-项目使用了springcloud-nacos系列",children:[]},{level:3,title:"test类dao层注册失败",slug:"test类dao层注册失败",link:"#test类dao层注册失败",children:[]},{level:3,title:"mybatis debug log startup",slug:"mybatis-debug-log-startup",link:"#mybatis-debug-log-startup",children:[]},{level:3,title:"@Autowired 和 @Resources 的区别",slug:"autowired-和-resources-的区别",link:"#autowired-和-resources-的区别",children:[]},{level:3,title:"logback 的使用",slug:"logback-的使用",link:"#logback-的使用",children:[]},{level:3,title:"logback-spring 这个只需要 引入lombok的依赖，@Slf4j的注解就能使用",slug:"logback-spring-这个只需要-引入lombok的依赖-slf4j的注解就能使用",link:"#logback-spring-这个只需要-引入lombok的依赖-slf4j的注解就能使用",children:[]},{level:3,title:"springboot 启动后 立即执行",slug:"springboot-启动后-立即执行",link:"#springboot-启动后-立即执行",children:[]}]},{level:2,title:"注解 @ConditionalOnProperty",slug:"注解-conditionalonproperty",link:"#注解-conditionalonproperty",children:[]},{level:2,title:"springboot jar端口号指定失效",slug:"springboot-jar端口号指定失效",link:"#springboot-jar端口号指定失效",children:[]},{level:2,title:"@ConfigurationProperties 注解",slug:"configurationproperties-注解",link:"#configurationproperties-注解",children:[{level:3,title:"前言",slug:"前言",link:"#前言",children:[]},{level:3,title:"概述",slug:"概述",link:"#概述",children:[]},{level:3,title:"源码解析",slug:"源码解析",link:"#源码解析",children:[]},{level:3,title:"案例分析",slug:"案例分析",link:"#案例分析",children:[]},{level:3,title:"使用DatabaseProperties",slug:"使用databaseproperties",link:"#使用databaseproperties",children:[]},{level:3,title:"应用场景案例",slug:"应用场景案例",link:"#应用场景案例",children:[]},{level:3,title:"核心类方法介绍",slug:"核心类方法介绍",link:"#核心类方法介绍",children:[]},{level:3,title:"测试用例",slug:"测试用例",link:"#测试用例",children:[]},{level:3,title:"ConfigPropertiesDemo类",slug:"configpropertiesdemo类",link:"#configpropertiesdemo类",children:[]},{level:3,title:"ConfigApp类",slug:"configapp类",link:"#configapp类",children:[]},{level:3,title:"DatabaseProperties类",slug:"databaseproperties类",link:"#databaseproperties类",children:[]},{level:3,title:"注意事项",slug:"注意事项",link:"#注意事项",children:[]},{level:3,title:"扩展",slug:"扩展",link:"#扩展",children:[]},{level:3,title:"小结",slug:"小结",link:"#小结",children:[]},{level:3,title:"总结",slug:"总结",link:"#总结",children:[]}]}],path:"/posts/java/springboot/workcondition.html",pathLocale:"/",extraFields:'\ufeff---\ntitle: springboot 工作中遇到的问题\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\n\ntag:\n  - java\n  - spring\n  - springboot\n\n---\n\n上帝赋予java生命，spring赋予java生命的延续\n\x3c!-- more --\x3e\n\n# springboot work condition\n\n标签（空格分隔）： springboot\n\n---\n\n## pringboot的yml文件没有小叶子\n\n进入project structure ——》\n\n## Failed to configure a DataSource: ‘url‘ attribute is not specified and no embedded datasource\n\n报错信息如下\n\n```shell\n***************************\nAPPLICATION FAILED TO START\n***************************\n \nDescription:\n \nFailed to configure a DataSource: \'url\' attribute is not specified and no embedded datasource could be configured.\n \nReason: Failed to determine a suitable driver class\n \n \nAction:\n \nConsider the following:\n    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).\n```\n\n### 解决一：项目不需要连数据库\n\n启动类加上如下注解\n\n```shell\n@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})\n```\n\n### 解决二：项目需要连接数据库\n\n配置yml文件，eg：\n\n```shell\n#在application.properties/或者application.yml文件中没有添加数据库配置信息.\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF-8&useSSL=false\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.jdbc.Driver\n```\n\n### 解决三：mysql版本问题\n\nmysql8以下的去除cj，更高版本的加上cj，eg：`driver-class-name: com.mysql.cj.jdbc.Driver`\n\n### 解决四：项目没有加载到yml或者properties文件\n\n特别是自己的pom打包是jar的项目，请查看自己的pom.xml文件中的packaging\n\n```\n<packaging>jar</packaging>\n```\n\n如果pom中指定使用jar，系统不会自动读取到yml或者properties文件的，需要我们手动配置pom.xml。\n\n```xml\n\x3c!--build放在</dependencies>标签的后面，主要加入的是resources标签 --\x3e\n\x3c!--resources标签可以告诉系统启动的时候能够读取到这些后缀的文件 --\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.yml</include>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.yml</include>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>lib</directory>\n            <includes>\n                <include>**/*.jar</include>\n            </includes>\n        </resource>\n    </resources>\n</build>\n```\n\n### 解决五：项目使用了springcloud+nacos系列\n\n需要配置启用了那个配置文件\n\n### test类dao层注册失败\n\n测试类加上如下代码\n\n```shell\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = \'启动类\'.class)\n```\n\n### mybatis debug log startup\n\n```shell\n#在properties 文件中添加\nlogging.level.com.example.datatransport.dao=debug\n```\n\n### @Autowired 和 @Resources 的区别\n\n```shell\n@Autowired\n来源：@Autowired 是Spring框架提供的注解。\n工作方式：默认情况下，@Autowired 按照类型（byType）来装配。如果存在多个相同类型的bean，那么Spring会抛出异常，除非其中一个被标记为首选（使用@Primary注解）或通过@Qualifier指定具体的bean名称。\n使用场景：适用于需要根据类型匹配bean的情况，当有多个相同类型的bean时，可以结合@Qualifier使用以精确指定要装配的bean。\n@Resource\n来源：@Resource 是Java标准的一部分，由JSR-250规范定义，因此它不仅可以在Spring环境中使用，也可以在其他支持该规范的容器中使用。\n工作方式：默认情况下，@Resource 按照名称（byName）来装配。如果指定了名称，则会按照该名称查找bean；如果没有指定名称，那么会使用字段名作为默认名称来查找bean。如果找不到相应名称的bean，那么会退回到按类型装配。\n使用场景：适用于需要根据名称匹配bean的情况，或者希望代码更加独立于特定框架（如Spring），因为它是一个Java标准注解。\n总结\n如果你的项目严格遵循Spring框架，且主要关注类型安全，那么@Autowired可能是一个更好的选择。\n如果你需要跨不同Java容器的兼容性，或者更倾向于基于名称的装配，那么@Resource可能更适合你。\n在实际开发中，选择哪个注解取决于项目的具体需求和个人偏好。不过，通常推荐在一个项目中保持一致性，避免混合使用不同的注解风格，以减少潜在的混淆和维护成本。\n```\n\n### logback 的使用\n\n1.导入依赖：\n\n```shell\n \x3c!-- Logback Core --\x3e\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>1.2.11</version> \x3c!-- 选择合适的版本 --\x3e\n        </dependency>\n\n        \x3c!-- Logback Classic (用于替代 SLF4J 的实现) --\x3e\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.rxtx</groupId>\n            <artifactId>rxtx</artifactId>\n            <version>2.1.7</version>\n        </dependency>\n```\n\n2.配置xml文件:logback.xml 放置在 resources 下\n\n```xml\n\n<configuration>\n\n\n    \x3c!-- 控制台日志输出 --\x3e\n    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5level) %white(-) %-15(%yellow([%10.20thread]))\n                %-55(%cyan(%.32logger{30}:%L)) %highlight(- %msg%n)\n            </pattern>\n        </encoder>\n    </appender>\n\n    \x3c!-- 普通应用日志文件输出 --\x3e\n    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        <file>logs/app.log</file>\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 按日期滚动日志文件 --\x3e\n            <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>\n            <maxHistory>30</maxHistory> \x3c!-- 保留30天的日志 --\x3e\n            <totalSizeCap>1GB</totalSizeCap>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5level) %white(-) %-15(%yellow([%10.20thread]))\n                %-55(%cyan(%.32logger{30}:%L)) %highlight(- %msg%n)\n            </pattern>\n        </encoder>\n    </appender>\n\n\n    \x3c!-- 定义全局的日志级别 --\x3e\n    <root level="INFO">\n        <appender-ref ref="STDOUT"/>\n        <appender-ref ref="FILE"/>\n    </root>\n\n</configuration>\n\n```\n\n3.调用\n```shell\n// 注意依赖引入错误会没有效果\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nprivate static final Logger log = LoggerFactory.getLogger(XXX.class);\n```\n\n### logback-spring 这个只需要 引入lombok的依赖，@Slf4j的注解就能使用\n1.引入 lombok 依赖\n2.创建logback-spring.xml文件，输入一下内容\n```xml\n\x3c!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --\x3e\n\x3c!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --\x3e\n\x3c!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --\x3e\n\x3c!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --\x3e\n\x3c!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration scan="true" scanPeriod="60 seconds" debug="false">\n    \x3c!-- 动态日志级别 --\x3e\n    \x3c!--  <jmxConfigurator/>--\x3e\n    \x3c!-- 定义日志文件 输出位置 --\x3e\n\n    <springProperty scope="context" name="logPath" source="logging.file.path" defaultValue="./log"/>\n    <property name="log.path" value="${logPath}/log/"/>\n    \x3c!-- 日志最大的历史 30天 --\x3e\n    <property name="maxHistory" value="10"/>\n    \x3c!-- 设置日志输出格式 --\x3e\n    <property name="CONSOLE_LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-})  [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)"/>\n    <property name="LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] ${LOG_LEVEL_PATTERN:-%5p} ${PID:-}  [%thread] [%logger{50} - %method:%line] - %msg%n"/>\n\n    \x3c!-- ConsoleAppender 控制台输出日志 --\x3e\n    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>INFO</level>\n        </filter>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n\n    \x3c!-- INFO级别日志 appender --\x3e\n    <appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!--记录的日志文件的路径及文件名--\x3e\n        <file>${log.path}/info.log</file>\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>INFO</level>\n        </filter>\n        \x3c!--日志记录器的滚动策略，按日期，按大小记录--\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">\n            <fileNamePattern>${log.path}/%d{yyyy-MM,aux}/info.%d{yyyy-MM-dd}.%i.log.zip</fileNamePattern>\n            <maxFileSize>100MB</maxFileSize>\n            <totalSizeCap>1GB</totalSizeCap>\n            <maxHistory>10</maxHistory>\n            <cleanHistoryOnStart>true</cleanHistoryOnStart>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${LOG_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--\n      <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n      以及指定<appender>。<logger>仅有一个name属性，\n      一个可选的level和一个可选的addtivity属性。\n      name:用来指定受此logger约束的某一个包或者具体的某一个类。\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n            还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n            如果未设置此属性，那么当前logger将会继承上级的级别。\n      addtivity:是否向上级logger传递打印信息。默认是true。\n      <logger name="org.springframework.web" level="info"/>\n      <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!-- 4  最终的策略：\n                     基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)--\x3e\n    \x3c!-- root级别 DEBUG --\x3e\n    <root>\n        \x3c!-- 打印debug级别日志及以上级别日志 --\x3e\n        <level value="Info"/>\n        \x3c!-- 控制台输出 --\x3e\n        <appender-ref ref="console"/>\n        \x3c!-- 文件输出 --\x3e\n        <appender-ref ref="INFO"/>\n        \x3c!--    <appender-ref ref="DEBUG"/>--\x3e\n        \x3c!--    <appender-ref ref="TRACE"/>--\x3e\n    </root>\n    \x3c!--  &lt;!&ndash;不同业务打印到指定文件&ndash;&gt;--\x3e\n    \x3c!--  <logger name="byte" additivity="false" level="INFO">--\x3e\n    \x3c!--    <appender-ref ref="DELETE_INFO"/>--\x3e\n    \x3c!--  </logger>--\x3e\n    \x3c!--  &lt;!&ndash;  &lt;!&ndash;不同业务打印到指定文件&ndash;&gt;&ndash;&gt;--\x3e\n    \x3c!--  &lt;!&ndash; 生产环境, 指定某包日志为warn级 &ndash;&gt;--\x3e\n    \x3c!--  <logger name="org.springframework.jdbc.core.JdbcTemplate" level="info"/>--\x3e\n    \x3c!-- 特定某个类打印info日志, 比如application启动成功后的提示语 --\x3e\n</configuration>\n```\n\n3.实际用例：\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n\x3c!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\x3e\n\x3c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\x3e\n\x3c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。\n                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration  scan="true" scanPeriod="10 seconds">\n    <contextName>logback-spring</contextName>\n\n    \x3c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\x3e\n    <property name="logging.path" value="./logs" />\n\n    \x3c!--0. 日志格式和颜色渲染 --\x3e\n    \x3c!-- 彩色日志依赖的渲染类 --\x3e\n    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />\n    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />\n    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />\n    \x3c!-- 彩色日志格式 --\x3e\n\x3c!--    <property name="CONSOLE_LOG_PATTERN" value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(-&#45;&#45;){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>--\x3e\n    <property name="CONSOLE_LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-})  [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)"/>\n    <property name="LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] ${LOG_LEVEL_PATTERN:-%5p} ${PID:-}  [%thread] [%logger{50} - %method:%line] - %msg%n"/>\n\n    \x3c!--1. 输出到控制台--\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>debug</level>\n        </filter>\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            \x3c!-- 设置字符集 --\x3e\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--2. 输出到文档--\x3e\n    \x3c!-- 2.1 level为 DEBUG 日志，时间滚动输出  --\x3e\n    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_debug.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 日志归档 --\x3e\n            <fileNamePattern>${logging.path}/web-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录debug级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>debug</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.2 level为 INFO 日志，时间滚动输出  --\x3e\n    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_info.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 每天日志归档路径以及格式 --\x3e\n            <fileNamePattern>${logging.path}/web-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录info级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>info</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.3 level为 WARN 日志，时间滚动输出  --\x3e\n    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_warn.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录warn级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>warn</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.4 level为 ERROR 日志，时间滚动输出  --\x3e\n    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_error.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录ERROR级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>ERROR</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!--\n        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n        以及指定<appender>。<logger>仅有一个name属性，\n        一个可选的level和一个可选的addtivity属性。\n        name:用来指定受此logger约束的某一个包或者具体的某一个类。\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n              如果未设置此属性，那么当前logger将会继承上级的级别。\n        addtivity:是否向上级logger传递打印信息。默认是true。\n        <logger name="org.springframework.web" level="info"/>\n        <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!--过滤掉spring和mybatis的一些无用的DEBUG信息--\x3e\n    <logger name="org.springframework" level="INFO"></logger>\n    <logger name="org.mybatis" level="INFO"></logger>\n    <logger name="org.apache.zookeeper" level="INFO"></logger>\n\n    \x3c!-- 4. 最终的策略 --\x3e\n    \x3c!-- 4.1 开发环境:打印控制台--\x3e\n    <springProfile name="dev">\n        <logger name="com.example.datatransport" level="debug"/>\x3c!-- 修改此处扫描包名 --\x3e\n    </springProfile>\n\n    <root level="info">\n        <appender-ref ref="CONSOLE" />\n        <appender-ref ref="DEBUG_FILE" />\n        <appender-ref ref="INFO_FILE" />\n        <appender-ref ref="WARN_FILE" />\n        <appender-ref ref="ERROR_FILE" />\n    </root>\n\n\x3c!--    4.2 生产环境:输出到文档--\x3e\n    <springProfile name="pro">\n        <root level="info">\n            <appender-ref ref="CONSOLE" />\n            <appender-ref ref="DEBUG_FILE" />\n\x3c!--            <appender-ref ref="INFO_FILE" />--\x3e\n            <appender-ref ref="ERROR_FILE" />\n            <appender-ref ref="WARN_FILE" />\n        </root>\n    </springProfile>\n</configuration>\n\n```\n### springboot 启动后 立即执行\n1.必须的spring托管，没有则添加@Component，然后 implements CommandLineRunner 接口 重写 run 方法既可\n\n2.在 Spring Boot 应用程序中，ApplicationRunner 是一个接口，用于在应用程序启动完成后执行一些初始化任务。它提供了一个 run 方法，该方法在 SpringApplication.run 方法执行完毕后被调用。ApplicationRunner 接口的主要作用是在应用程序启动时执行一些自定义的逻辑。\n\n上述两个的区别为：\nApplicationRunner：提供了 ApplicationArguments 对象，可以更方便地访问命令行参数。\nCommandLineRunner：提供了 String[] 数组，包含所有的命令行参数。\n\n\n## 注解 @ConditionalOnProperty\n\n作用 @ConditionalOnProperty 注解的主要作用是：\n\n* 根据配置属性的存在与否：如果配置属性存在，则加载相应的 Bean 或配置类。\n* 根据配置属性的值：如果配置属性的值符合预期，则加载相应的 Bean 或配置类。\n\neg:@ConditionalOnProperty(name = "cs2290.version", havingValue = "1")\n\n\n\n## springboot jar端口号指定失效\n原因：没有引入springboot的web依赖\n\neg：\n```xml\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n </dependency>\n```\n\n## @ConfigurationProperties 注解\nmark from : https://cloud.tencent.com/developer/article/2443870\n### 前言\n在Spring Boot框架中，@ConfigurationProperties注解提供了一种将外部配置（如application.properties或application.yml文件中的属性）绑定到Java对象的便捷方式。这种机制简化了配置管理，使得配置的变更更加灵活和动态。\n### 概述\n@ConfigurationProperties注解用于将配置文件中的属性绑定到一个组件的Bean上。它通常与@Component、@Service或@Configuration注解一起使用，以创建一个持有配置属性的Bean。\n### 源码解析\n@ConfigurationProperties注解的实现依赖于Spring Boot的ConfigurationPropertiesBindingPostProcessor后处理器。该后处理器在容器启动时扫描带有@ConfigurationProperties注解的Bean，并自动将配置属性绑定到Bean的字段上。\n### 案例分析\n假设我们的应用需要连接到数据库，我们可以在application.properties中设置数据库连接属性，并使用@ConfigurationProperties注解将这些属性绑定到一个配置类：\napplication.properties\n```properties\n# application.properties\ndatabase.url=jdbc:mysql://localhost:3306/mydb\ndatabase.username=root\ndatabase.password=secret\n```\nDatabaseProperties类\n```java\n@Component\n@ConfigurationProperties(prefix = "database")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n\n    // getters and setters\n}\n```\n1.@Component注解：DatabaseProperties类通过@Component注解被标记为一个Spring管理的组件，这意味着Spring容器会将其作为一个Bean进行管理。\n2.@ConfigurationProperties注解：@ConfigurationProperties注解用于将外部配置文件中的属性绑定到这个类的字段上。prefix = "database"属性指定了配置文件中相关属性的前缀，这样Spring就会自动查找以database开头的属性，并将它们映射到这个类的相应字段。\n3.字段定义：类中定义了三个私有字段url、username和password，这些字段将被用于存储配置文件中的值。\n4.Getters和Setters：虽然代码中没有显示，但是通常这些字段会有对应的公共getter和setter方法。这是JavaBean的标准实践，使得字段可以通过getter方法读取和通过setter方法修改。\n绑定过程\n当Spring容器启动时，它会查找带有@ConfigurationProperties注解的Bean，并尝试将配置文件中定义的属性绑定到这些Bean的字段上。在这个例子中，database.url、database.username和database.password将分别绑定到DatabaseProperties类的url、username和password字段。\n\n注意：\n1.java里面的大小写对应properties里面的“-”，eg：orderId -> order-id\n\n### 使用DatabaseProperties\n一旦DatabaseProperties Bean被创建并填充了配置值，你可以在应用程序的其他部分通过依赖注入使用这个Bean，例如在数据访问对象（DAO）或服务层中使用数据库连接信息。\neg:\n```java\n@Service\npublic class MyService {\n    private final DatabaseProperties databaseProperties;\n\n    @Autowired\n    public MyService(DatabaseProperties databaseProperties) {\n        this.databaseProperties = databaseProperties;\n    }\n\n    public void performDatabaseOperation() {\n        // 使用 databaseProperties.getUrl(), databaseProperties.getUsername(), databaseProperties.getPassword()\n    }\n}\n```\n在这个服务层的例子中，MyService通过构造函数注入了DatabaseProperties Bean，并可以在其方法中使用数据库连接信息。\n\n注意事项\n* 确保application.properties文件位于Spring Boot应用程序的src/main/resources目录下，或者Spring应用程序的类路径下的/config包中。\n* 属性名称必须遵循Spring的绑定规则，即字段名称和属性名称之间需要保持一致性（考虑下划线和驼峰命名的转换）。\n* 使用@ConfigurationProperties注解的类应该被标记为@Component，以便Spring容器可以自动检测并注册它。\n### 应用场景案例\n在微服务架构中，服务间的配置可能需要动态调整，如服务的端口号、连接的数据库等。使用@ConfigurationProperties可以轻松实现这些配置的动态绑定和更新。\n\n优缺点分析\n优点：\n\n* 解耦：将配置属性与业务逻辑解耦，提高代码的可维护性。\n* 灵活性：支持配置的动态更新，便于适应不同的部署环境。\n缺点：\n\n* 复杂性：对于复杂的配置结构，可能需要额外的处理逻辑。\n* 性能考虑：在某些情况下，频繁的配置更新可能会带来性能开销。\n\n### 核心类方法介绍\n@ConfigurationProperties注解的核心属性是prefix，它定义了配置文件中相关属性的前缀。此外，@PropertySource注解可以用于指定配置文件的位置。\n\n### 测试用例\n以下是一个简单的测试用例，演示如何使用@ConfigurationProperties注解：\n```java\npublic class ConfigPropertiesDemo {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        context.register(ConfigApp.class);\n        context.refresh();\n\n        DatabaseProperties dbProps = context.getBean(DatabaseProperties.class);\n        System.out.println("Database URL: " + dbProps.getUrl());\n    }\n}\n\n@Configuration\n@PropertySource("classpath:db.properties")\npublic class ConfigApp {\n    @Bean\n    @ConfigurationProperties(prefix = "database")\n    public DatabaseProperties databaseProperties() {\n        return new DatabaseProperties();\n    }\n}\n\n@Component\n@ConfigurationProperties(prefix = "database")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n\n    // getters and setters\n}\n```\n\n针对如上示例代码，这里我给大家详细的代码剖析下，以便于帮助大家理解的更为透彻，帮助大家早日掌握。\n\n这段代码演示了如何在Spring应用程序中使用@ConfigurationProperties注解和@PropertySource注解来加载外部配置文件，并将其属性绑定到一个组件的字段上。以下是对代码的详细解释和分析：\n\n### ConfigPropertiesDemo类\n1.创建AnnotationConfigApplicationContext实例：创建了一个AnnotationConfigApplicationContext实例，它将被用来管理Spring的Bean。\n\n2.注册ConfigApp配置类：通过context.register(ConfigApp.class)将ConfigApp类注册到Spring容器中。ConfigApp类使用@Configuration注解标记，表明它是一个配置类。\n\n3.刷新容器：调用context.refresh()方法初始化Spring容器，这会触发Bean的创建、依赖注入、执行@PostConstruct注解的方法等。\n\n4.获取DatabaseProperties Bean：通过context.getBean(DatabaseProperties.class)获取DatabaseProperties类型的Bean，并打印其URL属性。\n\n### ConfigApp类\n1.@Configuration注解：ConfigApp类通过@Configuration注解标记，表明它是一个配置类，可以定义Bean和导入其他配置。\n\n2.@PropertySource注解：@PropertySource("classpath:db.properties")注解指定了外部配置文件的路径。这里假设db.properties文件位于类路径下。\n\n3.数据库属性Bean：定义了一个databaseProperties Bean，使用@ConfigurationProperties(prefix = "database")注解，将外部配置文件中以database为前缀的属性绑定到DatabaseProperties类的字段上。\n\n### DatabaseProperties类\n1.@Component注解：DatabaseProperties类通过@Component注解标记，表明它是一个Spring管理的组件。\n\n2.@ConfigurationProperties注解：@ConfigurationProperties(prefix = "database")注解用于将外部配置文件中的属性绑定到这个类的字段上。prefix = "database"属性指定了配置文件中相关属性的前缀。\n\n3.字段定义：类中定义了三个私有字段url、username和password，这些字段将被用于存储配置文件中的值。\n\n4.Getters和Setters：虽然代码中没有显示，但通常这些字段会有对应的公共getter和setter方法，这是JavaBean的标准实践。\n\n### 注意事项\n确保db.properties文件位于类路径下，例如src/main/resources目录。\n属性名称必须遵循Spring的绑定规则，即字段名称和属性名称之间需要保持一致性（考虑下划线和驼峰命名的转换）。\n使用@ConfigurationProperties注解的类应该被标记为@Component，以便Spring容器可以自动检测并注册它。\n\n### 扩展\n在实际开发中，你可能还需要添加异常处理逻辑，以处理配置文件加载或属性绑定过程中可能出现的任何问题。此外，对于更复杂的应用程序，可能需要配置更多的Spring组件，如数据源、事务管理器等。\n\n通过这种方式，开发者可以清晰地组织代码，提高代码的可维护性和可测试性。\n\n### 小结\n@ConfigurationProperties注解是Spring Boot中用于简化配置管理的强大工具。通过本文的学习，我们了解到如何使用@ConfigurationProperties注解来绑定配置文件中的属性到Java对象，并探讨了其在实际开发中的应用。\n\n### 总结\n@ConfigurationProperties注解是Spring Boot配置管理的关键工具之一。它通过提供一种声明式的方式来绑定配置属性，极大地简化了配置的管理和使用。开发者在使用时需要注意配置结构的复杂性，并根据实际需求合理使用。通过本文的深入分析和实践，我们希望能够帮助开发者更好地利用@ConfigurationProperties，构建灵活、可维护的Spring Boot应用程序。'},{title:"HTTP tomcat Servlet 基础知识",headers:[{level:2,title:"1，Web概述",slug:"_1-web概述",link:"#_1-web概述",children:[{level:3,title:"1.1 Web和JavaWeb的概念",slug:"_1-1-web和javaweb的概念",link:"#_1-1-web和javaweb的概念",children:[]},{level:3,title:"1.2 JavaWeb技术栈",slug:"_1-2-javaweb技术栈",link:"#_1-2-javaweb技术栈",children:[]}]},{level:2,title:"2, HTTP",slug:"_2-http",link:"#_2-http",children:[{level:3,title:"2.1 简介",slug:"_2-1-简介",link:"#_2-1-简介",children:[]},{level:3,title:"2.2 请求数据格式",slug:"_2-2-请求数据格式",link:"#_2-2-请求数据格式",children:[]},{level:3,title:"2.3 响应数据格式",slug:"_2-3-响应数据格式",link:"#_2-3-响应数据格式",children:[]}]},{level:2,title:"3, Tomcat",slug:"_3-tomcat",link:"#_3-tomcat",children:[{level:3,title:"3.1 简介",slug:"_3-1-简介",link:"#_3-1-简介",children:[]},{level:3,title:"3.2 基本使用",slug:"_3-2-基本使用",link:"#_3-2-基本使用",children:[]},{level:3,title:"3.3 Maven创建Web项目",slug:"_3-3-maven创建web项目",link:"#_3-3-maven创建web项目",children:[]},{level:3,title:"3.4 IDEA使用Tomcat",slug:"_3-4-idea使用tomcat",link:"#_3-4-idea使用tomcat",children:[]}]},{level:2,title:"4， Servlet",slug:"_4-servlet",link:"#_4-servlet",children:[{level:3,title:"4.1 简介",slug:"_4-1-简介",link:"#_4-1-简介",children:[]},{level:3,title:"4.2 快速入门",slug:"_4-2-快速入门",link:"#_4-2-快速入门",children:[]},{level:3,title:"4.3 执行流程",slug:"_4-3-执行流程",link:"#_4-3-执行流程",children:[]},{level:3,title:"4.4 生命周期",slug:"_4-4-生命周期",link:"#_4-4-生命周期",children:[]},{level:3,title:"4.5 方法介绍",slug:"_4-5-方法介绍",link:"#_4-5-方法介绍",children:[]},{level:3,title:"4.6 体系结构",slug:"_4-6-体系结构",link:"#_4-6-体系结构",children:[]},{level:3,title:"4.7 urlPattern配置",slug:"_4-7-urlpattern配置",link:"#_4-7-urlpattern配置",children:[]}]}],path:"/posts/java/web/HTTP_Tomcat_Servlet.html",pathLocale:"/",extraFields:'---\ntitle: HTTP tomcat Servlet 基础知识\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - javaweb\n  - http\n  - tomcat\n  - servlet\n---\n\nHTTP tomcat Servlet 基础知识\n\n\x3c!-- more --\x3e\n\n**今日目标：**\n\n> * 了解JavaWeb开发的技术栈\n> * 理解HTTP协议和HTTP请求与响应数据的格式\n> * 掌握Tomcat的使用\n> * 掌握在IDEA中使用Tomcat插件\n> * 理解Servlet的执行流程和生命周期\n> * 掌握Servlet的使用和相关配置\n\n## 1，Web概述\n\n### 1.1 Web和JavaWeb的概念\n\n==Web是全球广域网，也称为万维网(www)，能够通过浏览器访问的网站。==\n在我们日常的生活中，经常会使用浏览器去访问`百度`、`京东`、`传智官网`等这些网站，这些网站统称为Web网站。\n我们知道了什么是Web，那么JavaWeb又是什么呢？顾名思义==JavaWeb就是用Java技术来解决相关web互联网领域的技术栈。==\n等学习完JavaWeb之后，同学们就可以使用Java语言开发我们上述所说的网站。而国内很多大型网站公司也是首选Java语言来解决web互联网相关的问题。那都有哪些公司的系统是使用Java语言的呢?\n\n使用Java语言开发互联网系统是有很多技术栈需要大家了解，具体都有哪些呢?\n\n### 1.2 JavaWeb技术栈\n\n了解JavaWeb技术栈之前，有一个很重要的概念要介绍。\n\n#### 1.2.1 B/S架构\n\n什么是B/S架构?\nB/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。可以通过下面的流程回想下我们平常的上网过程:\n\n* 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容\n* 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的\n* 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容\n* 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。\n  了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢?\n\n#### 1.2.2 静态资源\n\n* 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。\n* 我们之前已经学过前端网页制作`三剑客`(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。\n* 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果:\n  \n  `张三`登录以后在网页的右上角看到的是 `张三`，而`李四`登录以后看到的则是`李四`。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。\n\n#### 1.2.3 动态资源\n\n* 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。\n* 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。\n* 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入`用户名`和`密码`,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢?\n  \n\n#### 1.2.4 数据库\n\n* 数据库主要负责存储数据。\n* 整个Web的访问过程就如下所示:\n  (1)浏览器发送一个请求到服务端，去请求所需要的相关资源;\n  (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;\n  (3)在Java代码可以进行业务处理也可以从数据库中读取数据;\n  (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;\n  (5)服务端将静态资源响应给浏览器;\n  (6)浏览器将这些资源进行解析;\n  (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。\n  在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢?\n\n#### 1.2.5 HTTP协议\n\n* HTTP协议:主要定义通信规则\n* 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。\n\n#### 1.2.6 Web服务器\n\n* Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据\n* 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器\n* Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器\n\n到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。\n\n## 2, HTTP\n\n### 2.1 简介\n\n**HTTP概念**\n\nHyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间==数据传输的规则==。\n\n* 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。\n* 如果想知道具体的格式，可以打开浏览器，点击`F12`打开开发者工具，点击`Network`来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示:\n\n\n\n> 注意:在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除。\n\n==所以学习HTTP主要就是学习请求和响应数据的具体格式内容。==\n\n**HTTP协议特点**\n\nHTTP协议有它自己的一些特点，分别是:\n\n* 基于TCP协议: 面向连接，安全\n\n  TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。\n\n* 基于请求-响应模型的:一次请求对应一次响应\n\n  请求和响应是一一对应关系\n\n* HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的\n\n  无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，\n\n    * 缺点:多次请求间不能共享数据\n    * 优点:速度快\n\n  请求之间无法共享数据会引发的问题，如:\n\n    * 京东购物，`加入购物车`和`去购物车结算`是两次请求，\n    * HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品\n    * 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据\n\n  具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用`会话技术(Cookie、Session)`来解决这个问题。具体如何来做，我们后面会详细讲到。刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?\n\n### 2.2 请求数据格式\n\n#### 2.2.1 格式介绍\n\n请求数据总共分为三部分内容，分别是==请求行==、==请求头==、==请求体==\n\n* 请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本]\n\n  请求方式有七种,最常用的是GET和POST\n\n* 请求头: 第二行开始，格式为key: value形式\n\n  请求头中会包含若干个属性，常见的HTTP请求头有:\n\n  ```\n  Host: 表示请求的主机名\n  User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；\n  Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；\n  Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\n  Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。\n  ```\n\n  ==这些数据有什么用处?==\n\n  举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如:\n\n    * 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果\n    * 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果\n    * 这就是我们常说的浏览器兼容问题\n\n* 请求体: POST请求的最后一部分，存储请求参数\n\n  \n\n  如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了:\n\n    * GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中\n    * GET请求请求参数大小有限制，POST没有\n\n**小结**:\n\n1. 请求数据中包含三部分内容，分别是请求行、请求头和请求体\n\n2. POST请求数据在请求体中，GET请求数据在请求行上\n\n### 2.3 响应数据格式\n\n#### 2.3.1 格式介绍\n\n响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体==\n\n* 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]\n\n* 响应头：第二行开始，格式为key：value形式\n\n  响应头中会包含若干个属性，常见的HTTP响应头有:\n\n  ```\n  Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；\n  Content-Length：表示该响应内容的长度（字节数）；\n  Content-Encoding：表示该响应压缩算法，例如gzip；\n  Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒\n  ```\n\n* 响应体： 最后一部分。存放响应数据\n\n\n#### 2.3.2 响应状态码\n\n参考: 资料/1.HTTP/《响应状态码.md》\n\n关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握:\n\n* 200  ok 客户端请求成功\n* 404  Not Found 请求资源不存在\n* 500 Internal Server Error 服务端发生不可预期的错误\n\n#### 2.3.3 自定义服务器\n\n有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是`ServerSocket`和`Socket`\n\n```java\npackage com.itheima;\n\nimport sun.misc.IOUtils;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\n/*\n    自定义服务器\n */\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8080); // 监听指定端口\n        System.out.println("server is running...");\n        while (true){\n            Socket sock = ss.accept();\n            System.out.println("connected from " + sock.getRemoteSocketAddress());\n            Thread t = new Handler(sock);\n            t.start();\n        }\n    }\n}\n\nclass Handler extends Thread {\n    Socket sock;\n\n    public Handler(Socket sock) {\n        this.sock = sock;\n    }\n\n    public void run() {\n        try (InputStream input = this.sock.getInputStream()) {\n            try (OutputStream output = this.sock.getOutputStream()) {\n                handle(input, output);\n            }\n        } catch (Exception e) {\n            try {\n                this.sock.close();\n            } catch (IOException ioe) {\n            }\n            System.out.println("client disconnected.");\n        }\n    }\n\n    private void handle(InputStream input, OutputStream output) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));\n        // 读取HTTP请求:\n        boolean requestOk = false;\n        String first = reader.readLine();\n        if (first.startsWith("GET / HTTP/1.")) {\n            requestOk = true;\n        }\n        for (;;) {\n            String header = reader.readLine();\n            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕\n                break;\n            }\n            System.out.println(header);\n        }\n        System.out.println(requestOk ? "Response OK" : "Response Error");\n        if (!requestOk) {\n            // 发送错误响应:\n            writer.write("HTTP/1.0 404 Not Found\\r\\n");\n            writer.write("Content-Length: 0\\r\\n");\n            writer.write("\\r\\n");\n            writer.flush();\n        } else {\n            // 发送成功响应:\n\n            //读取html文件，转换为字符串\n            BufferedReader br = new BufferedReader(new FileReader("http/html/a.html"));\n            StringBuilder data = new StringBuilder();\n            String line = null;\n            while ((line = br.readLine()) != null){\n                data.append(line);\n            }\n            br.close();\n            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;\n\n            writer.write("HTTP/1.1 200 OK\\r\\n");\n            writer.write("Connection: keep-alive\\r\\n");\n            writer.write("Content-Type: text/html\\r\\n");\n            writer.write("Content-Length: " + length + "\\r\\n");\n            writer.write("\\r\\n"); // 空行标识Header和Body的分隔\n            writer.write(data.toString());\n            writer.flush();\n        }\n    }\n}\n```\n\n上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat==\n\n**小结**\n\n1. 响应数据中包含三部分内容，分别是响应行、响应头和响应体\n\n2. 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误\n\n## 3, Tomcat\n\n### 3.1 简介\n\n#### 3.1.1 什么是Web服务器\n\nWeb服务器是一个应用程序（==软件==），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是"提供网上信息浏览服务"。\n\nWeb服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。\n\n**Web服务器软件使用步骤**\n\n* 准备静态资源\n* 下载安装Web服务器软件\n* 将静态资源部署到Web服务器上\n* 启动Web服务器使用浏览器访问对应的资源\n\n上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:\n\n\n\n\n\nTomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:\n\n1. 简介: 初步认识下Tomcat\n\n2. 基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作\n\n3. IDEA中如何创建Maven Web项目\n\n4. IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式\n\n首选我们来认识下Tomcat。\n\n**Tomcat**\n\nTomcat的相关概念:\n\n* Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。\n\n* 概念中提到了JavaEE规范，那什么又是JavaEE规范呢?\n\n  JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。\n\n* 因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。\n\n* Tomcat的官网: https://tomcat.apache.org/ 从官网上可以下载对应的版本进行使用。\n\n**小结**\n\n通过这一节的学习，我们需要掌握以下内容:\n\n1. Web服务器的作用\n\n> 封装HTTP协议操作，简化开发\n>\n> 可以将Web项目部署到服务器中，对外提供网上浏览服务\n\n2. Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。\n\n### 3.2 基本使用\n\nTomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。\n\n#### 3.2.2 安装\n\nTomcat是绿色版,直接解压即可\n\n* 在D盘的software目录下，将`apache-tomcat-8.5.68-windows-x64.zip`进行解压缩，会得到一个`apache-tomcat-8.5.68`的目录，Tomcat就已经安装成功。\n\n  ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。\n\n* 打开`apache-tomcat-8.5.68`目录就能看到如下目录结构，每个目录中包含的内容需要认识下,\n\n  bin:目录下有两类文件，一种是以`.bat`结尾的，是Windows系统的可执行文件，一种是以`.sh`结尾的，是Linux系统的可执行文件。\n\n  webapps:就是以后项目部署的目录\n\n  到此，Tomcat的安装就已经完成。\n\n#### 3.2.3 卸载\n\n卸载比较简单，可以直接删除目录即可\n\n#### 3.2.4 启动\n\n双击: bin\\startup.bat\n\n\n\n启动后，通过浏览器访问 `http://localhost:8080`能看到Apache Tomcat的内容就说明Tomcat已经启动成功。\n\n\n\n==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties\n\n将UTF-8改为GBK\n\n#### 3.2.5 关闭\n\n关闭有三种方式\n\n* 直接x掉运行窗口:强制关闭[不建议]\n* bin\\shutdown.bat：正常关闭\n* ctrl+c： 正常关闭\n\n#### 3.2.6 配置\n\n**修改端口**\n\n* Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml\n\n\n\n> 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。\n\n**启动时可能出现的错误**\n\n* Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误\n\n  `Address already in use:bind\n\n* Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置\n\n\n\n#### 3.2.7 部署\n\n* Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。\n\n    * 将 `资料/2. Tomcat/hello` 目录拷贝到Tomcat的webapps目录下\n\n    * 通过浏览器访问`http://localhost/hello/a.html`，能看到下面的内容就说明项目已经部署成功。\n\n      但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢?\n\n* 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件\n\n    * 将 `资料/2. Tomcat/haha.war`目录拷贝到Tomcat的webapps目录下\n\n    * Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录\n\n    * 通过浏览器访问`http://localhost/haha/a.html`，能看到下面的内容就说明项目已经部署成功。\n\n\n至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。\n\n### 3.3 Maven创建Web项目\n\n介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢?\n\n在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么?\n\n#### 3.3.1 Web项目结构\n\nWeb项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下:\n\n* Maven Web项目结构: 开发中的项目\n\n* 开发完成部署的Web项目\n\n    * 开发项目通过执行Maven打包命令==package==,可以获取到部署的Web项目目录\n    * 编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下\n    * pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下\n\n#### 3.3.2 创建Maven Web项目\n\n介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架\n\n**使用骨架**\n\n> 具体的步骤包含:\n>\n> 1.创建Maven项目\n>\n> 2.选择使用Web项目骨架\n>\n> 3.输入Maven项目坐标创建项目\n>\n> 4.确认Maven相关的配置信息后，完成项目创建\n>\n> 5.删除pom.xml中多余内容\n>\n> 6.补齐Maven Web项目缺失的目录结构\n\n1. 创建Maven项目\n\n2. 选择使用Web项目骨架\n\n3. 输入Maven项目坐标创建项目\n\n4. 确认Maven相关的配置信息后，完成项目创建\n\n5. 删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别\n\n6. 补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐.\n\n\n\n\n**不使用骨架**\n\n>具体的步骤包含:\n>\n>1.创建Maven项目\n>\n>2.选择不使用Web项目骨架\n>\n>3.输入Maven项目坐标创建项目\n>\n>4.在pom.xml设置打包方式为war\n>\n>5.补齐Maven Web项目缺失webapp的目录结构\n>\n>6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构\n\n1. 创建Maven项目\n\n2. 选择不使用Web项目骨架\n\n3. 输入Maven项目坐标创建项目\n\n4. 在pom.xml设置打包方式为war,默认是不写代表打包方式为jar\n\n5. 补齐Maven Web项目缺失webapp的目录结构,在project structure 里面的facet 里面，选择一个web 点击Web resource directories，双击下面。\n\n6. 补齐Maven Web项目缺失WEB-INF/web.xml的目录结构，在5的地方有一个+号，加一个web.xml 文件\n\n7. 补充完后，最终的项目结构如下:\n\n上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。\n\n**小结**\n\n1.掌握Maven Web项目的目录结构\n\n2.掌握使用骨架的方式创建Maven Web项目\n\n> 3.掌握不使用骨架的方式创建Maven Web项目\n\n### 3.4 IDEA使用Tomcat\n\n* Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。\n* 然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的\n* 如何在IDEA中能快速使用Tomcat呢?\n\n在IDEA中集成使用Tomcat有两种方式，分别是==集成本地Tomcat==和==Tomcat Maven插件==\n\n#### 3.4.1 集成本地Tomcat\n\n目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤\n\n1. 打开添加本地Tomcat的面板\n\n2. 指定本地Tomcat的具体路径\n\n3. 修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80\n\n4. 将开发项目部署项目到Tomcat中\n\n   扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别?\n\n    * war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上\n\n    * war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上\n    * war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容\n    * war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署\n    * 建议大家都选war模式进行部署，更符合项目部署的实际情况\n   \n5. 部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面\n\n6. 启动成功后，可以通过浏览器进行访问测试\n\n7. 最终的注意事项\n\n\n\n\n至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。\n\n#### 3.4.2 Tomcat Maven插件\n\n在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是:\n\n1. 在pom.xml中添加Tomcat插件\n\n   ```xml\n   <build>\n       <plugins>\n       \t\x3c!--Tomcat插件 --\x3e\n           <plugin>\n               <groupId>org.apache.tomcat.maven</groupId>\n               <artifactId>tomcat7-maven-plugin</artifactId>\n               <version>2.2</version>\n           </plugin>\n       </plugins>\n   </build>\n   ```\n\n2. 使用Maven Helper插件快速启动项目，选中项目，右键--\x3eRun Maven --\x3e tomcat7:run\n\n==注意:==\n\n* 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File --\x3e Settings --\x3e Plugins --\x3e Maven Helper ---\x3e Install,安装完后按照提示重启IDEA，就可以看到了。\n\n* Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用\n* 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml\n\n```xml\n<build>\n    <plugins>\n    \t\x3c!--Tomcat插件 --\x3e\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <version>2.2</version>\n            <configuration>\n            \t<port>80</port>\x3c!--访问端口号 --\x3e\n                \x3c!--项目访问路径\n\t\t\t\t\t未配置访问路径: http://localhost:80/tomcat-demo2/a.html\n\t\t\t\t\t配置/后访问路径: http://localhost:80/a.html\n\t\t\t\t\t如果配置成 /hello,访问路径会变成什么?\n\t\t\t\t\t\t答案: http://localhost:80/hello/a.html\n\t\t\t\t--\x3e\n                <path>/</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n**小结**\n\n通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。\n\n## 4， Servlet\n\n### 4.1 简介\n\n* Servlet是JavaWeb最为核心的内容，它是Java提供的一门==动态==web资源开发技术。\n\n* 使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。\n\n* Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet\n\n\n介绍完Servlet是什么以后，接下来我们就按照`快速入门`->`执行流程`->`生命周期`->`体系结构`->`urlPattern配置`->`XML配置`的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。\n\n### 4.2 快速入门\n\n==需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。==\n\n具体的实现步骤为:\n\n1. 创建Web项目`web-demo`，导入Servlet依赖坐标\n\n```xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    \x3c!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --\x3e\n    <scope>provided</scope>\n</dependency>\n```\n\n2. 创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话\n\n```java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet {\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println("servlet hello world~");\n    }\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}\n```\n\n3. 配置:在类上使用@WebServlet注解，配置该Servlet的访问路径\n\n```java\n@WebServlet("/demo1")\n```\n\n4. 访问:启动Tomcat,浏览器中输入URL地址访问该Servlet\n\n```\nhttp://localhost:8080/web-demo/demo1\n```\n\n5. 器访问后，在控制台会打印`servlet hello world~` 说明servlet程序已经成功运行。\n\n至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。\n\n### 4.3 执行流程\n\nServlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了`servlet hello world~`这句话呢?\n\n要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。\n\n* 浏览器发出`http://localhost:8080/web-demo/demo1`请求，从请求中可以解析出三部分内容，分别是`localhost:8080`、`web-demo`、`demo1`\n    * 根据`localhost:8080`可以找到要访问的Tomcat Web服务器\n    * 根据`web-demo`可以找到部署在Tomcat服务器上的web-demo项目\n    * 根据`demo1`可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配\n* 找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法\n    * ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用\n    * service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互\n\n**小结**\n\n介绍完Servlet的执行流程，需要大家掌握两个问题：\n\n1. Servlet由谁创建?Servlet方法由谁调用?\n\n> Servlet由web服务器创建，Servlet方法由web服务器调用\n\n2. 服务器怎么知道Servlet中一定有service方法?\n\n> 因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法\n\n### 4.4 生命周期\n\n介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。\n\n接下来咱们再来思考一个问题:==Tomcat什么时候创建的Servlet对象?==\n\n要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。\n\n* 生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。\n\n* Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：\n\n    1. ==加载和实例化==：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象\n\n  ```xml\n  默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n  \n  @WebServlet(urlPatterns = "/demo1",loadOnStartup = 1)\n  loadOnstartup的取值有两类情况\n  \t（1）负整数:第一次访问时创建Servlet对象\n  \t（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n  ```\n\n    2. ==初始化==：在Servlet实例化之后，容器将调用Servlet的==init()==方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只==调用一次==\n    3. ==请求处理==：==每次==请求Servlet时，Servlet容器都会调用Servlet的==service()==方法对请求进行处理\n    4. ==服务终止==：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的==destroy()==方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收\n\n* 通过案例演示下上述的生命周期\n\n  ```java\n  package com.itheima.web;\n  \n  import javax.servlet.*;\n  import javax.servlet.annotation.WebServlet;\n  import java.io.IOException;\n  /**\n  * Servlet生命周期方法\n  */\n  @WebServlet(urlPatterns = "/demo2",loadOnStartup = 1)\n  public class ServletDemo2 implements Servlet {\n  \n      /**\n       *  初始化方法\n       *  1.调用时机：默认情况下，Servlet被第一次访问时，调用\n       *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用\n       *  2.调用次数: 1次\n       * @param config\n       * @throws ServletException\n       */\n      public void init(ServletConfig config) throws ServletException {\n          System.out.println("init...");\n      }\n  \n      /**\n       * 提供服务\n       * 1.调用时机:每一次Servlet被访问时，调用\n       * 2.调用次数: 多次\n       * @param req\n       * @param res\n       * @throws ServletException\n       * @throws IOException\n       */\n      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n          System.out.println("servlet hello world~");\n      }\n  \n      /**\n       * 销毁方法\n       * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用\n       * 2.调用次数: 1次\n       */\n      public void destroy() {\n          System.out.println("destroy...");\n      }\n      public ServletConfig getServletConfig() {\n          return null;\n      }\n  \n      public String getServletInfo() {\n          return null;\n      }\n  \n  \n  }\n  ```\n\n  ==注意:如何才能让Servlet中的destroy方法被执行？==\n\n在Terminal命令行中，先使用`mvn tomcat7:run`启动，然后再使用`ctrl+c`关闭tomcat\n\n**小结**\n\n这节中需要掌握的内容是:\n\n1. Servlet对象在什么时候被创建的?\n\n> 默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns = "/demo2",loadOnStartup = 1)的loadOnStartup 修改成在服务器启动的时候创建。\n\n2. Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次?\n\n>涉及到三个方法，分别是 init()、service()、destroy()\n>\n>init方法在Servlet对象被创建的时候执行，只执行1次\n>\n>service方法在Servlet被访问的时候调用，每访问1次就调用1次\n>\n>destroy方法在Servlet对象被销毁的时候调用，只执行1次\n\n### 4.5 方法介绍\n\nServlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？\n\n我们先来回顾下前面讲的三个方法，分别是:\n\n* 初始化方法，在Servlet被创建时执行，只执行一次\n\n```java\nvoid init(ServletConfig config) \n```\n\n* 提供服务方法， 每次Servlet被访问，都会调用该方法\n\n```java\nvoid service(ServletRequest req, ServletResponse res)\n```\n\n* 销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet\n\n```java\nvoid destroy() \n```\n\n剩下的两个方法是:\n\n* 获取Servlet信息\n\n```java\nString getServletInfo() \n//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() {\n    return "";\n}\n```\n\n* 获取ServletConfig对象\n\n```java\nServletConfig getServletConfig()\n```\n\nServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作?\n\n```java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n/**\n * Servlet方法介绍\n */\n@WebServlet(urlPatterns = "/demo3",loadOnStartup = 1)\npublic class ServletDemo3 implements Servlet {\n\n    private ServletConfig servletConfig;\n    /**\n     *  初始化方法\n     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用\n     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用\n     *  2.调用次数: 1次\n     * @param config\n     * @throws ServletException\n     */\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n        System.out.println("init...");\n    }\n    public ServletConfig getServletConfig() {\n        return servletConfig;\n    }\n    \n    /**\n     * 提供服务\n     * 1.调用时机:每一次Servlet被访问时，调用\n     * 2.调用次数: 多次\n     * @param req\n     * @param res\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        System.out.println("servlet hello world~");\n    }\n\n    /**\n     * 销毁方法\n     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用\n     * 2.调用次数: 1次\n     */\n    public void destroy() {\n        System.out.println("destroy...");\n    }\n    \n    public String getServletInfo() {\n        return "";\n    }\n}\n```\n\ngetServletInfo()和getServletConfig()这两个方法使用的不是很多，大家了解下。\n\n### 4.6 体系结构\n\n通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢?\n\n要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解:\n\n因为我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承==HttpServlet==\n\n具体的编写格式如下:\n\n```java\n@WebServlet("/demo4")\npublic class ServletDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //TODO GET 请求方式处理逻辑\n        System.out.println("get...");\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //TODO Post 请求方式处理逻辑\n        System.out.println("post...");\n    }\n}\n```\n\n* 要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送`http://localhost:8080/web-demo/demo4`,就能看到doGet方法被执行了\n* 要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个`a.html`页面，内容如下:\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n    <form action="/web-demo/demo4" method="post">\n        <input name="username"/><input type="submit"/>\n    </form>\n</body>\n</html>\n```\n\n启动测试，即可看到doPost方法被执行了。\n\nServlet的简化编写就介绍完了，接着需要思考两个问题:\n\n1. HttpServlet中为什么要根据请求方式的不同，调用不同的方法?\n2. 如何调用?\n\n针对问题一，我们需要回顾之前的知识点==前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中==，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么?\n\n```java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n\n@WebServlet("/demo5")\npublic class ServletDemo5 implements Servlet {\n\n    public void init(ServletConfig config) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        //如何调用?\n        //获取请求方式，根据不同的请求方式进行不同的业务处理\n        HttpServletRequest request = (HttpServletRequest)req;\n       //1. 获取请求方式\n        String method = request.getMethod();\n        //2. 判断\n        if("GET".equals(method)){\n            // get方式的处理逻辑\n        }else if("POST".equals(method)){\n            // post方式的处理逻辑\n        }\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}\n\n```\n\n要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。\n\n```java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class MyHttpServlet implements Servlet {\n    public void init(ServletConfig config) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        HttpServletRequest request = (HttpServletRequest)req;\n        //1. 获取请求方式\n        String method = request.getMethod();\n        //2. 判断\n        if("GET".equals(method)){\n            // get方式的处理逻辑\n            doGet(req,res);\n        }else if("POST".equals(method)){\n            // post方式的处理逻辑\n            doPost(req,res);\n        }\n    }\n\n    protected void doPost(ServletRequest req, ServletResponse res) {\n    }\n\n    protected void doGet(ServletRequest req, ServletResponse res) {\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}\n\n```\n\n有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造\n\n```java\n@WebServlet("/demo5")\npublic class ServletDemo5 extends MyHttpServlet {\n\n    @Override\n    protected void doGet(ServletRequest req, ServletResponse res) {\n        System.out.println("get...");\n    }\n\n    @Override\n    protected void doPost(ServletRequest req, ServletResponse res) {\n        System.out.println("post...");\n    }\n}\n\n```\n\n将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。\n\n类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索`service()`方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。\n\n```java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException\n    {\n        String method = req.getMethod();\n\n        if (method.equals(METHOD_GET)) {\n            long lastModified = getLastModified(req);\n            if (lastModified == -1) {\n                // servlet doesn\'t support if-modified-since, no reason\n                // to go through further expensive logic\n                doGet(req, resp);\n            } else {\n                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n                if (ifModifiedSince < lastModified) {\n                    // If the servlet mod time is later, call doGet()\n                    // Round down to the nearest second for a proper compare\n                    // A ifModifiedSince of -1 will always be less\n                    maybeSetLastModified(resp, lastModified);\n                    doGet(req, resp);\n                } else {\n                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                }\n            }\n\n        } else if (method.equals(METHOD_HEAD)) {\n            long lastModified = getLastModified(req);\n            maybeSetLastModified(resp, lastModified);\n            doHead(req, resp);\n\n        } else if (method.equals(METHOD_POST)) {\n            doPost(req, resp);\n            \n        } else if (method.equals(METHOD_PUT)) {\n            doPut(req, resp);\n            \n        } else if (method.equals(METHOD_DELETE)) {\n            doDelete(req, resp);\n            \n        } else if (method.equals(METHOD_OPTIONS)) {\n            doOptions(req,resp);\n            \n        } else if (method.equals(METHOD_TRACE)) {\n            doTrace(req,resp);\n            \n        } else {\n            //\n            // Note that this means NO servlet supports whatever\n            // method was requested, anywhere on this server.\n            //\n\n            String errMsg = lStrings.getString("http.method_not_implemented");\n            Object[] errArgs = new Object[1];\n            errArgs[0] = method;\n            errMsg = MessageFormat.format(errMsg, errArgs);\n            \n            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n        }\n    }\n```\n\n**小结**\n\n通过这一节的学习，要掌握:\n\n1. HttpServlet的使用步骤\n\n> 继承HttpServlet\n>\n> 重写doGet和doPost方法\n\n2. HttpServlet原理\n\n> 获取请求方式，并根据不同的请求方式，调用不同的doXxx方法\n\n### 4.7 urlPattern配置\n\nServlet类编写好后，要想被访问到，就需要配置其访问路径（==urlPattern==）\n\n* 一个Servlet,可以配置多个urlPattern\n\n  ```java\npackage com.itheima.web;\n  \n  import javax.servlet.ServletRequest;\n  import javax.servlet.ServletResponse;\n  import javax.servlet.annotation.WebServlet;\n  \n  /**\n  * urlPattern: 一个Servlet可以配置多个访问路径\n  */\n  @WebServlet(urlPatterns = {"/demo7","/demo8"})\n  public class ServletDemo7 extends MyHttpServlet {\n  \n      @Override\n      protected void doGet(ServletRequest req, ServletResponse res) {\n          \n          System.out.println("demo7 get...");\n      }\n      @Override\n      protected void doPost(ServletRequest req, ServletResponse res) {\n      }\n  }\n  ```\n  \n  在浏览器上输入`http://localhost:8080/web-demo/demo7`,`http://localhost:8080/web-demo/demo8`这两个地址都能访问到ServletDemo7的doGet方法。\n\n* ==urlPattern配置规则==\n\n    * 精确匹配\n\n      ```java\n    /**\n       * UrlPattern:\n       * * 精确匹配\n       */\n      @WebServlet(urlPatterns = "/user/select")\n      public class ServletDemo8 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo8 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }\n      ```\n      \n      访问路径`http://localhost:8080/web-demo/user/select`\n\n    * 目录匹配\n\n      ```java\n    package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 目录匹配: /user/*\n       */\n      @WebServlet(urlPatterns = "/user/*")\n      public class ServletDemo9 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo9 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }\n      ```\n      \n      访问路径`http://localhost:8080/web-demo/user/任意`\n    \n      ==思考:==\n\n        1. 访问路径`http://localhost:8080/web-demo/user`是否能访问到demo9的doGet方法?\n      2. 访问路径`http://localhost:8080/web-demo/user/a/b`是否能访问到demo9的doGet方法?\n        3. 访问路径`http://localhost:8080/web-demo/user/select`是否能访问到demo9还是demo8的doGet方法?\n      \n      答案是: 能、能、demo8，进而我们可以得到的结论是`/user/*`中的`/*`代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。\n    \n    * 扩展名匹配\n\n      ```java\n    package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 扩展名匹配: *.do\n       */\n      @WebServlet(urlPatterns = "*.do")\n      public class ServletDemo10 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo10 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }\n      ```\n      \n      访问路径`http://localhost:8080/web-demo/任意.do`\n    \n      ==注意==:\n    \n        1. 如果路径配置的不是扩展名，那么在路径的前面就必须要加`/`否则会报错\n\n        2. 如果路径配置的是`*.do`,那么在*.do的前面不能加`/`,否则会报错\n\n    * 任意匹配\n\n      ```java\n      package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 任意匹配： /\n       */\n      @WebServlet(urlPatterns = "/")\n      public class ServletDemo11 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo11 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }\n      ```\n      \n      访问路径`http://localhost:8080/demo-web/任意`\n    \n      ```java\n      package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 任意匹配： /*\n       */\n      @WebServlet(urlPatterns = "/*")\n      public class ServletDemo12 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo12 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }\n      \n      ```\n      \n      访问路径`http://localhost:8080/demo-web/任意\n    \n      ==注意:==`/`和`/*`的区别?\n    \n        1. 当我们的项目中的Servlet配置了 "/",会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet\n    \n        2. 当我们的项目中配置了"/*",意味着匹配任意访问路径\n    \n        3. DefaultServlet是用来处理静态资源，如果配置了"/"会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问\n\n**小结**\n\n1. urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配\n\n2. 五种配置的优先级为 精确匹配 > 目录匹配> 扩展名匹配 > /* > / ,无需记，以最终运行结果为准。\n\n### 4.8 XML配置\n\n前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。\n\n对于XML的配置步骤有两步:\n\n* 编写Servlet类\n\n```java\npackage com.itheima.web;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebServlet;\n\npublic class ServletDemo13 extends MyHttpServlet {\n\n    @Override\n    protected void doGet(ServletRequest req, ServletResponse res) {\n\n        System.out.println("demo13 get...");\n    }\n    @Override\n    protected void doPost(ServletRequest req, ServletResponse res) {\n    }\n}\n```\n\n* 在web.xml中配置该Servlet\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n    \n    \n    \n    \x3c!-- \n        Servlet 全类名\n    --\x3e\n    <servlet>\n        \x3c!-- servlet的名称，名字任意--\x3e\n        <servlet-name>demo13</servlet-name>\n        \x3c!--servlet的类全名--\x3e\n        <servlet-class>com.itheima.web.ServletDemo13</servlet-class>\n    </servlet>\n\n    \x3c!-- \n        Servlet 访问路径\n    --\x3e\n    <servlet-mapping>\n        \x3c!-- servlet的名称，要和上面的名称一致--\x3e\n        <servlet-name>demo13</servlet-name>\n        \x3c!-- servlet的访问路径--\x3e\n        <url-pattern>/demo13</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。\n\n\n\n'},{title:"Request&Response 的基本使用",headers:[{level:2,title:"1，Request和Response的概述",slug:"_1-request和response的概述",link:"#_1-request和response的概述",children:[]},{level:2,title:"2，Request对象",slug:"_2-request对象",link:"#_2-request对象",children:[{level:3,title:"2.1 Request继承体系",slug:"_2-1-request继承体系",link:"#_2-1-request继承体系",children:[]},{level:3,title:"2.2 Request获取请求数据",slug:"_2-2-request获取请求数据",link:"#_2-2-request获取请求数据",children:[]},{level:3,title:"2.4 请求参数中文乱码问题",slug:"_2-4-请求参数中文乱码问题",link:"#_2-4-请求参数中文乱码问题",children:[]},{level:3,title:"2.5 Request请求转发",slug:"_2-5-request请求转发",link:"#_2-5-request请求转发",children:[]}]},{level:2,title:"3，Response对象",slug:"_3-response对象",link:"#_3-response对象",children:[{level:3,title:"3.1 Response设置响应数据功能介绍",slug:"_3-1-response设置响应数据功能介绍",link:"#_3-1-response设置响应数据功能介绍",children:[]},{level:3,title:"3.2 Respones请求重定向",slug:"_3-2-respones请求重定向",link:"#_3-2-respones请求重定向",children:[]},{level:3,title:"3.3 路径问题",slug:"_3-3-路径问题",link:"#_3-3-路径问题",children:[]},{level:3,title:"3.4 Response响应字符数据",slug:"_3-4-response响应字符数据",link:"#_3-4-response响应字符数据",children:[]},{level:3,title:"3.3 Response响应字节数据",slug:"_3-3-response响应字节数据",link:"#_3-3-response响应字节数据",children:[]}]},{level:2,title:"4，用户注册登录案例",slug:"_4-用户注册登录案例",link:"#_4-用户注册登录案例",children:[{level:3,title:"4.1 用户登录",slug:"_4-1-用户登录",link:"#_4-1-用户登录",children:[]},{level:3,title:"4.2 用户注册",slug:"_4-2-用户注册",link:"#_4-2-用户注册",children:[]},{level:3,title:"4.3 SqlSessionFactory工具类抽取",slug:"_4-3-sqlsessionfactory工具类抽取",link:"#_4-3-sqlsessionfactory工具类抽取",children:[]}]}],path:"/posts/java/web/Request_Response.html",pathLocale:"/",extraFields:'---\ntitle: Request&Response 的基本使用\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - javaweb\n  - Request\n  - Response\n---\n\nRequest&Response 基础知识\n\n\x3c!-- more --\x3e\n# Request&Response\n\n**今日目标**\n\n>* 掌握Request对象的概念与使用\n>* 掌握Response对象的概念与使用\n>* 能够完成用户登录注册案例的实现\n>* 能够完成SqlSessionFactory工具类的抽取\n\n## 1，Request和Response的概述\n\n==Request是请求对象，Response是响应对象。==这两个对象在我们使用Servlet的时候有看到\n\n此时，我们就需要思考一个问题request和response这两个参数的作用是什么?\n\n* request:==获取==请求数据\n    * 浏览器会发送HTTP请求到后台服务器[Tomcat]\n    * HTTP的请求中会包含很多请求数据[请求行+请求头+请求体]\n    * 后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中\n    * 所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数\n    * 获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务\n* response:==设置==响应数据\n    * 业务处理完后，后台就需要给前端返回业务处理的结果即响应数据\n    * 把响应数据封装到response对象中\n    * 后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果\n    * 浏览器最终解析结果，把内容展示在浏览器给用户浏览\n\n对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。\n\n```java\n@WebServlet("/demo3")\npublic class ServletDemo3 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //使用request对象 获取请求数据\n        String name = request.getParameter("name");//url?name=zhangsan\n\n        //使用response对象 设置响应数据\n        response.setHeader("content-type","text/html;charset=utf-8");\n        response.getWriter().write("<h1>"+name+",欢迎您！</h1>");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("Post...");\n    }\n}\n```\n\n启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容:\n\n**小结**\n\n在这节中，我们主要认识了下request对象和reponse对象:\n\n* request对象是用来封装请求数据的对象\n* response对象是用来封装响应数据的对象\n\n目前我们只知道这两个对象是用来干什么的，那么它们具体是如何实现的，就需要我们继续深入的学习。接下来，就先从Request对象来学习,主要学习下面这些内容:\n\n* request继承体系\n\n* request获取请求参数\n* request请求转发\n\n## 2，Request对象\n\n### 2.1 Request继承体系\n\n在学习这节内容之前，我们先思考一个问题，前面在介绍Request和Reponse对象的时候，比较细心的同学可能已经发现：\n\n* 当我们的Servlet类实现的是Servlet接口的时候，service方法中的参数是ServletRequest和ServletResponse\n* 当我们的Servlet类继承的是HttpServlet类的时候，doGet和doPost方法中的参数就变成HttpServletRequest和HttpServletReponse\n\n那么，\n\n* ServletRequest和HttpServletRequest的关系是什么?\n* request对象是有谁来创建的?\n* request提供了哪些API,这些API从哪里查?\n\n首先，我们先来看下Request的继承体系:\n\nServletRequest和HttpServletRequest都是Java提供的，ServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象，这个时候就引发了一个问题:\n\n**方法里面的参数是如何创建的呢？**\n\n答：实际上就是调用的子类（不是接口）\n\n这个时候，我们就需要用到Request继承体系中的`RequestFacade`:\n\n* 该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。\n* Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建\n* 要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法\n\n对于上述结论，要想验证，可以编写一个Servlet，在方法中把request对象打印下，就能看到最终的对象是不是RequestFacade,代码如下:\n\n```java\n@WebServlet("/demo2")\npublic class ServletDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(request);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}\n```\n\n启动服务器，运行访问`http://localhost:8080/request-demo/demo2`,得到运行结果:\n\n**小结**\n\n* Request的继承体系为ServletRequest--\x3eHttpServletRequest--\x3eRequestFacade\n* Tomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法\n* 使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明\n\n### 2.2 Request获取请求数据\n\nHTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取?\n\n#### 2.2.1 获取请求行数据\n\n请求行包含三块内容，分别是`请求方式`、`请求资源路径`、`HTTP协议及版本`\n\neg:**GET/request-demo/req1?username=zhangsan HTTP/1.1**\n\n对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:\n\n* 获取请求方式: `GET`\n\n```\nString getMethod()\n```\n\n* 获取虚拟目录(项目访问路径): `/request-demo`\n\n```\nString getContextPath()\n```\n\n* 获取URL(统一资源定位符): `http://localhost:8080/request-demo/req1`\n\n```\nStringBuffer getRequestURL()\n```\n\n* 获取URI(统一资源标识符): `/request-demo/req1`\n\n```\nString getRequestURI()\n```\n\n* 获取请求参数(GET方式): `username=zhangsan&password=123`\n\n```\nString getQueryString()\n```\n\n介绍完上述方法后，咱们通过代码把上述方法都使用下:\n\n```java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // String getMethod()：获取请求方式： GET\n        String method = req.getMethod();\n        System.out.println(method);//GET\n        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo\n        String contextPath = req.getContextPath();\n        System.out.println(contextPath);\n        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1\n        StringBuffer url = req.getRequestURL();\n        System.out.println(url.toString());\n        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1\n        String uri = req.getRequestURI();\n        System.out.println(uri);\n        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan\n        String queryString = req.getQueryString();\n        System.out.println(queryString);\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}\n```\n\n启动服务器，访问`http://localhost:8080/request-demo/req1?username=zhangsan&passwrod=123`，获取的结果.\n\n#### 2.2.2 获取请求头数据\n\n对于请求头的数据，格式为`key: value`如下:\n\n```xml\nuser-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.63\n```\n\n\n\n所以根据请求头名称获取对应值的方法为:\n\n```\nString getHeader(String name)\n```\n\n接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用\n\n```java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求头: user-agent: 浏览器的版本信息\n        String agent = req.getHeader("user-agent");\n\t\tSystem.out.println(agent);\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}\n\n```\n\n重新启动服务器后，`http://localhost:8080/request-demo/req1?username=zhangsan&passwrod=123`，获取的结果。\n\n#### 2.2.3 获取请求体数据\n\n浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:\n\n`username=zhangsan&passwrod=123`\n\n对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是:\n\n* 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法\n\n```\nServletInputStream getInputStream()\n该方法可以获取字节\n```\n\n* 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法\n\n```\nBufferedReader getReader()\n```\n\n接下来，大家需要思考，要想获取到请求体的内容该如何实现?\n\n>具体实现的步骤如下:\n>\n>1.准备一个页面，在页面中添加form表单,用来发送post请求\n>\n>2.在Servlet的doPost方法中获取请求体数据\n>\n>3.在doPost方法中使用request的getReader()或者getInputStream()来获取\n>\n>4.访问测试\n\n1. 在项目的webapp目录下添加一个html页面，名称为：`req.html`\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n\x3c!-- \n    action:form表单提交的请求地址\n    method:请求方式，指定为post\n--\x3e\n<form action="/request-demo/req1" method="post">\n    <input type="text" name="username">\n    <input type="password" name="password">\n    <input type="submit">\n</form>\n</body>\n</html>\n```\n\n2. 在Servlet的doPost方法中获取数据\n\n```java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //在此处获取请求体中的数据\n    }\n}\n```\n\n3. 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取\n\n```java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n         //获取post 请求体：请求参数\n        //1. 获取字符输入流\n        BufferedReader br = req.getReader();\n        //2. 读取数据\n        String line = br.readLine();\n        System.out.println(line);\n    }\n}\n```\n\n==注意==\n\nBufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。\n\n4. 启动服务器，通过浏览器访问`http://localhost:8080/request-demo/req.html`\n\n点击`提交`按钮后，就可以在控制台看到前端所发送的请求数据\n\n**小结**\n\nHTTP请求数据中包含了`请求行`、`请求头`和`请求体`，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值:\n\n* 请求行\n    * getMethod()获取请求方式\n    * getContextPath()获取项目访问路径\n    * getRequestURL()获取请求URL\n    * getRequestURI()获取请求URI\n    * getQueryString()获取GET请求方式的请求参数\n* 请求头\n    * getHeader(String name)根据请求头名称获取其对应的值\n* 请求体\n    * 注意: ==浏览器发送的POST请求才有请求体==\n    * 如果是纯文本数据:getReader()\n    * 如果是字节数据如文件数据:getInputStream()\n\n#### 2.2.4 获取请求参数的通用方式\n\n在学习下面内容之前，我们先提出两个问题:\n\n* 什么是请求参数?\n* 请求参数和请求数据的关系是什么?\n\n1.什么是请求参数?\n\n为了能更好的回答上述两个问题，我们拿用户登录的例子来说明\n\n1.1 想要登录网址，需要进入登录页面\n\n1.2 在登录页面输入用户名和密码\n\n1.3 将用户名和密码提交到后台\n\n1.4 后台校验用户名和密码是否正确\n\n1.5 如果正确，则正常登录，如果不正确，则提示用户名或密码错误\n\n上述例子中，用户名和密码其实就是我们所说的请求参数。\n\n2.什么是请求数据?\n\n请求数据则是包含请求行、请求头和请求体的所有数据\n\n3.请求参数和请求数据的关系是什么?\n\n3.1 请求参数是请求数据中的部分内容\n\n3.2 如果是GET请求，请求参数在请求行中\n\n3.3 如果是POST请求，请求参数一般在请求体中\n\n对于请求参数的获取,常用的有以下两种:\n\n* GET方式:\n\n```\nString getQueryString()\n```\n\n* POST方式:\n\n```\nBufferedReader getReader();\n```\n\n有了上述的知识储备，我们来实现一个案例需求:\n\n（1）发送一个GET请求并携带用户名，后台接收后打印到控制台\n\n（2）发送一个POST请求并携带用户名，后台接收后打印到控制台\n\n此处大家需要注意的是GET请求和POST请求接收参数的方式不一样，具体实现的代码如下:\n\n```java\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        String result = req.getQueryString();\n        System.out.println(result);\n\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        BufferedReader br = req.getReader();\n        String result = br.readLine();\n        System.out.println(result);\n    }\n}\n```\n\n* 对于上述的代码，会存在什么问题呢?\n\n答：出现了除服代码\n\n* 如何解决上述重复代码的问题呢?\n\n答：在doPost()中：只写：this.doGet(req,resp);\n\n\n\n当然，也可以在doGet中调用doPost,在doPost中完成参数的获取和打印,另外需要注意的是，doGet和doPost方法都必须存在，不能删除任意一个。\n\n==GET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢?==\n\n要想实现，我们就需要==思考==:\n\nGET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种==统一==获取请求参数的方式，从而==统一==doGet和doPost方法内的代码?\n\n解决方案一:\n\n```java\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求方式\n        String method = req.getMethod();\n        //获取请求参数\n        String params = "";\n        if("GET".equals(method)){\n            params = req.getQueryString();\n        }else if("POST".equals(method)){\n            BufferedReader reader = req.getReader();\n            params = reader.readLine();\n        }\n        //将请求参数进行打印控制台\n        System.out.println(params);\n      \n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doGet(req,resp);\n    }\n}\n```\n\n使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用\n\n解决方案二:\n\nrequest对象已经将上述获取请求参数的方法进行了封装，并且request提供的方法实现的功能更强大，以后只需要调用request提供的方法即可，在request的方法中都实现了哪些操作?\n\n(1)根据不同的请求方式获取请求参数，获取的内容如下:\n\nusername=zhangsan&passwrod=123\n\n(2)把获取到的内容进行分割，内容如下:\n\nusername=zhangsan，passwrod=123\n\n(3)把分割后端数据，存入到一个Map集合中:\n\n**注意**:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。\n\n基于上述理论，request对象为我们提供了如下方法:\n\n* 获取所有参数Map集合\n\n```\nMap<String,String[]> getParameterMap()\n```\n\n* 根据名称获取参数值（数组）\n\n```\nString[] getParameterValues(String name)\n```\n\n* 根据名称获取参数值(单个值)\n\n```\nString getParameter(String name)\n```\n\n接下来，我们通过案例来把上述的三个方法进行实例演示:\n\n1.修改req.html页面，添加爱好选项，爱好可以同时选多个\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/request-demo/req2" method="get">\n    <input type="text" name="username"><br>\n    <input type="password" name="password"><br>\n    <input type="checkbox" name="hobby" value="1"> 游泳\n    <input type="checkbox" name="hobby" value="2"> 爬山 <br>\n    <input type="submit">\n\n</form>\n</body>\n</html>\n```\n\n2.在Servlet代码中获取页面传递GET请求的参数值\n\n2.1获取GET方式的所有请求参数\n\n```java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        System.out.println("get....");\n        //1. 获取所有参数的Map集合\n        Map<String, String[]> map = req.getParameterMap();\n        for (String key : map.keySet()) {\n            // username:zhangsan lisi\n            System.out.print(key+":");\n\n            //获取值\n            String[] values = map.get(key);\n            for (String value : values) {\n                System.out.print(value + " ");\n            }\n\n            System.out.println();\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}\n```\n\n获取的结果\n\n2.2获取GET请求参数中的爱好，结果是数组值\n\n```java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        //...\n        System.out.println("------------");\n        String[] hobbies = req.getParameterValues("hobby");\n        for (String hobby : hobbies) {\n            System.out.println(hobby);\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}\n```\n\n\n\n2.3获取GET请求参数中的用户名和密码，结果是单个值\n\n```java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        //...\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n        System.out.println(username);\n        System.out.println(password);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}\n```\n\n3.在Servlet代码中获取页面传递POST请求的参数值\n\n3.1将req.html页面form表单的提交方式改成post\n\n3.2将doGet方法中的内容复制到doPost方法中即可\n\n**小结**\n\n* req.getParameter()方法使用的频率会比较高\n\n* 以后我们再写代码的时候，就只需要按照如下格式来编写:\n\n```\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n       //采用request提供的获取请求参数的通用方式来获取请求参数\n       //编写其他的业务代码...\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doGet(req,resp);\n    }\n}\n```\n\n\n\n### 2.4 请求参数中文乱码问题\n\n问题展示:\n\n(1)将req.html页面的请求方式修改为get\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/request-demo/req2" method="get">\n    <input type="text" name="username"><br>\n    <input type="password" name="password"><br>\n    <input type="checkbox" name="hobby" value="1"> 游泳\n    <input type="checkbox" name="hobby" value="2"> 爬山 <br>\n    <input type="submit">\n\n</form>\n</body>\n</html>\n```\n\n(2)在Servlet方法中获取参数，并打印\n\n```java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n       //1. 获取username\n       String username = request.getParameter("username");\n       System.out.println(username);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n（3）启动服务器，页面上输入中文参数\n\n（4）查看控制台打印内容\n\n（5）把req.html页面的请求方式改成post,再次发送请求和中文参数\n\n（6）查看控制台打印内容，依然为乱码\n\n通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？\n\n#### 2.4.1 POST请求解决方案\n\n* 分析出现中文乱码的原因：\n    * POST的请求参数是通过request的getReader()来获取流中的数据\n    * TOMCAT在获取流的时候采用的编码是ISO-8859-1\n    * ISO-8859-1编码是不支持中文的，所以会出现乱码\n* 解决方案：\n    * 页面设置的编码格式为UTF-8\n    * 把TOMCAT在获取流数据之前的编码设置为UTF-8\n    * 通过request.setCharacterEncoding("UTF-8")设置编码,UTF-8也可以写成小写\n\n修改后的代码为:\n\n```java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 解决乱码: POST getReader()\n        //设置字符输入流的编码，设置的字符集要和页面保持一致\n        request.setCharacterEncoding("UTF-8");\n       //2. 获取username\n       String username = request.getParameter("username");\n       System.out.println(username);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n重新发送POST请求，就会在控制台看到正常展示的中文结果。\n\n至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。\n\n#### 2.4.2 GET请求解决方案\n\n刚才提到一个问题是`POST请求的中文乱码解决方案为什么不适用GET请求？`\n\n* GET请求获取请求参数的方式是`request.getQueryString()`\n* POST请求获取请求参数的方式是`request.getReader()`\n* request.setCharacterEncoding("utf-8")是设置request处理流的编码\n* getQueryString方法并没有通过流的方式获取数据\n\n所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢?\n\n1. 首先我们需要先分析下GET请求出现乱码的原因:\n\n(1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat)\n\n(2)浏览器在发送HTTP的过程中会对中文数据进行URL==编码==\n\n(3)在进行URL编码的时候会采用页面`<meta>`标签指定的UTF-8的方式进行编码，`张三`编码后的结果为`%E5%BC%A0%E4%B8%89`\n\n(4)后台服务器(Tomcat)接收到`%E5%BC%A0%E4%B8%89`后会默认按照`ISO-8859-1`进行URL==解码==\n\n(5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。\n\n思考: 如果把`req.html`页面的`<meta>`标签的charset属性改成`ISO-8859-1`,后台不做操作，能解决中文乱码问题么?\n\n答案是否定的，因为`ISO-8859-1`本身是不支持中文展示的，所以改了<meta>标签的charset属性后，会导致页面上的中文内容都无法正常展示。\n\n分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是==URL编码==和==URL解码==，什么是URL编码，什么又是URL解码呢?\n\n**URL编码**\n\n这块知识我们只需要了解下即可,具体编码过程分两步，分别是:\n\n(1)将字符串按照编码方式转为二进制\n\n(2)每个字节转为2个16进制数并在前边加上%\n\n`张三`按照UTF-8的方式转换成二进制的结果为:\n\n```\n1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001\n```\n\n这个结果是如何计算的?\n\n使用`http://www.mytju.com/classcode/tools/encode_utf8.asp`，输入`张三`\n\n\n\n就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果:\n\n在计算的十六进制结果中，每两位前面加一个%,就可以获取到`%E5%BC%A0%E4%B8%89`。\n\n当然你从上面所提供的网站中就已经能看到编码16进制的结果了:\n\n但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码:\n\n编码:\n\n```java\njava.net.URLEncoder.encode("需要被编码的内容","字符集(UTF-8)")\n```\n\n解码:\n\n```java\njava.net.URLDecoder.decode("需要被解码的内容","字符集(UTF-8)")\n```\n\n接下来咱们对`张三`来进行编码和解码\n\n```\npublic class URLDemo {\n\n  public static void main(String[] args) throws UnsupportedEncodingException {\n        String username = "张三";\n        //1. URL编码\n        String encode = URLEncoder.encode(username, "utf-8");\n        System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89\n\n       //2. URL解码\n       //String decode = URLDecoder.decode(encode, "utf-8");//打印:张三\n       String decode = URLDecoder.decode(encode, "ISO-8859-1");//打印:`å¼ ä¸ `\n       System.out.println(decode);\n    }\n}\n\n```\n\n到这，我们就可以分析出GET请求中文参数出现乱码的原因了，\n\n* 浏览器把中文参数按照`UTF-8`进行URL编码\n* Tomcat对获取到的内容进行了`ISO-8859-1`的URL解码\n* 在控制台就会出现类上`å¼ ä¸`的乱码，最后一位是个空格\n\n2. 清楚了出现乱码的原因，接下来我们就需要想办法进行解决\n\n\n\n* 在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的`%E5%BC%A0%E4%B8%89`是一致的\n\n* 那他们对应的二进制值也是一样的，为:\n\n    * ```\n    1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001\n\n    ```\n\n* 为所以我们可以考虑把`å¼ ä¸`转换成字节，在把字节转换成`张三`，在转换的过程中是它们的编码一致，就可以解决中文乱码问题。\n\n具体的实现步骤为:\n\n>1.按照ISO-8859-1编码获取乱码`å¼ ä¸`对应的字节数组\n>\n>2.按照UTF-8编码获取字节数组对应的字符串\n\n实现代码如下:\n\n```\npublic class URLDemo {\n\n  public static void main(String[] args) throws UnsupportedEncodingException {\n        String username = "张三";\n        //1. URL编码\n        String encode = URLEncoder.encode(username, "utf-8");\n        System.out.println(encode);\n        //2. URL解码\n        String decode = URLDecoder.decode(encode, "ISO-8859-1");\n\n        System.out.println(decode); //此处打印的是对应的乱码数据\n\n        //3. 转换为字节数据,编码\n        byte[] bytes = decode.getBytes("ISO-8859-1");\n        for (byte b : bytes) {\n            System.out.print(b + " ");\n        }\n\t\t//此处打印的是:-27 -68 -96 -28 -72 -119\n        //4. 将字节数组转为字符串，解码\n        String s = new String(bytes, "utf-8");\n        System.out.println(s); //此处打印的是张三\n    }\n}\n```\n\n**说明**:在第18行中打印的数据是`-27 -68 -96 -28 -72 -119`和`张三`转换成的二进制数据`1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001`为什么不一样呢？\n\n其实打印出来的是十进制数据，我们只需要使用计算机换算下就能得到他们的对应关系\n\n至此对于GET请求中文乱码的解决方案，我们就已经分析完了，最后在代码中去实现下:\n\n```java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 解决乱码：POST，getReader()\n        //request.setCharacterEncoding("UTF-8");//设置字符输入流的编码\n\n        //2. 获取username\n        String username = request.getParameter("username");\n        System.out.println("解决乱码前："+username);\n\n        //3. GET,获取参数的方式：getQueryString\n        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1\n       /* //3.1 先对乱码数据进行编码：转为字节数组\n        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);\n        //3.2 字节数组解码\n        username = new String(bytes, StandardCharsets.UTF_8);*/\n\n        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);\n\n        System.out.println("解决乱码后："+username);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n**注意**\n\n* 把`request.setCharacterEncoding("UTF-8")`代码注释掉后，会发现GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了\n* 只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。\n\n另外需要说明一点的是==Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8==\n\n**小结**\n\n1. 中文乱码解决方案\n\n* POST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题\n\n  GET请求在Tomcat8.0以后的版本就不会出现了\n\n* POST请求解决方案是:设置输入流的编码\n\n  ```\n  request.setCharacterEncoding("UTF-8");\n  注意:设置的字符集要和页面保持一致\n  ```\n\n* 通用方式（GET/POST）：需要先解码，再编码\n\n  ```\n  new String(username.getBytes("ISO-8859-1"),"UTF-8");\n  ```\n\n2. URL编码实现方式:\n\n* 编码:\n\n  ```\n  URLEncoder.encode(str,"UTF-8");\n  ```\n\n* 解码:\n\n  ```\n  URLDecoder.decode(s,"ISO-8859-1");\n  ```\n\n### 2.5 Request请求转发\n\n1. ==请求转发(forward):一种在服务器内部的资源跳转方式。==\n\n(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求\n\n(2)资源A处理完请求后将请求发给资源B\n\n(3)资源B处理完后将结果响应给浏览器\n\n(4)请求从资源A到资源B的过程就叫==请求转发==\n\n2. 请求转发的实现方式:\n\n```\nreq.getRequestDispatcher("资源B路径").forward(req,resp);\n```\n\n具体如何来使用，我们先来看下需求:\n\n针对上述需求，具体的实现步骤为:\n\n>1.创建一个RequestDemo5类，接收/req5的请求，在doGet方法中打印`demo5`\n>\n>2.创建一个RequestDemo6类，接收/req6的请求，在doGet方法中打印`demo6`\n>\n>3.在RequestDemo5的方法中使用\n>\n>​\treq.getRequestDispatcher("/req6").forward(req,resp)进行请求转发\n>\n>4.启动测试\n\n(1)创建RequestDemo5类\n\n```java\n/**\n * 请求转发\n */\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(2)创建RequestDemo6类\n\n```java\n/**\n * 请求转发\n */\n@WebServlet("/req6")\npublic class RequestDemo6 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo6...");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(3)在RequestDemo5的doGet方法中进行请求转发\n\n```java\n/**\n * 请求转发\n */\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n        //请求转发\n        request.getRequestDispatcher("/req6").forward(request,response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(4)启动测试\n\n访问`http://localhost:8080/request-demo/req5`,就可以在控制台看到如下内容:\n\n说明请求已经转发到了`/req6`\n\n3. 请求转发资源间共享数据:使用Request对象\n\n此处主要解决的问题是把请求从`/req5`转发到`/req6`的时候，如何传递数据给`/req6`。\n\n需要使用request对象提供的三个方法:\n\n* 存储数据到request域[范围,数据是存储在request对象]中\n\n```\nvoid setAttribute(String name,Object o);\n```\n\n* 根据key获取值\n\n```\nObject getAttribute(String name);\n```\n\n* 根据key删除该键值对\n\n```\nvoid removeAttribute(String name);\n```\n\n接着上个需求来:\n\n> 1.在RequestDemo5的doGet方法中转发请求之前，将数据存入request域对象中\n>\n> 2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台\n>\n> 3.启动访问测试\n\n(1)修改RequestDemo5中的方法\n\n```java\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n        //存储数据\n        request.setAttribute("msg","hello");\n        //请求转发\n        request.getRequestDispatcher("/req6").forward(request,response);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(2)修改RequestDemo6中的方法\n\n```java\n/**\n * 请求转发\n */\n@WebServlet("/req6")\npublic class RequestDemo6 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo6...");\n        //获取数据\n        Object msg = request.getAttribute("msg");\n        System.out.println(msg);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(3)启动测试\n\n访问`http://localhost:8080/request-demo/req5`,就可以在控制台看到如下内容:\n\n```shell\ndemo5...\ndemo6...\nhello\n```\n\n\n\n此时就可以实现在转发多个资源之间共享数据。\n\n4. 请求转发的特点\n\n* 浏览器地址栏路径不发生变化\n\n  虽然后台从`/req5`转发到`/req6`,但是浏览器的地址一直是`/req5`,未发生变化\n\n* 只能转发到当前服务器的内部资源\n\n  不能从一个服务器通过转发访问另一台服务器\n\n* 一次请求，可以在转发资源间使用request共享数据\n\n  虽然后台从`/req5`转发到`/req6`，但是这个==只有一次请求==\n\n## 3，Response对象\n\n前面讲解完Request对象\n\n* Request:使用request对象来==获取==请求数据\n\n* Response:使用response对象来==设置==响应数据\n\nReponse的继承体系和Request的继承体系也非常相似:\n\n介绍完Response的相关体系结构后，接下来对于Response我们需要学习如下内容:\n\n* Response设置响应数据的功能介绍\n* Response完成重定向\n* Response响应字符数据\n* Response响应字节数据\n\n### 3.1 Response设置响应数据功能介绍\n\nHTTP响应数据总共分为三部分内容，分别是==响应行、响应头、响应体==，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置?\n\n1. 响应行\n\n对于响应头，比较常用的就是设置响应状态码:\n\n```\nvoid setStatus(int sc);\n```\n\n2. 响应头\n\n```shell\ncontent-type: application/json\n```\n\n设置响应头键值对：\n\n```\nvoid setHeader(String name,String value);\n```\n\n3. 响应体\n\n对于响应体，是通过字符、字节输出流的方式往浏览器写，\n\n获取字符输出流:\n\n```\nPrintWriter getWriter();\n```\n\n获取字节输出流\n\n```\nServletOutputStream getOutputStream();\n```\n\n介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。\n\n### 3.2 Respones请求重定向\n\n1. ==Response重定向(redirect):一种资源跳转方式。==\n\n(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求\n\n(2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径\n\n(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B\n\n(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫==重定向==\n\n2. 重定向的实现方式:\n\n```\nresp.setStatus(302);\nresp.setHeader("location","资源B的访问路径");\n```\n\n具体如何来使用，我们先来看下需求:\n\n针对上述需求，具体的实现步骤为:\n\n> 1.创建一个ResponseDemo1类，接收/resp1的请求，在doGet方法中打印`resp1....`\n>\n> 2.创建一个ResponseDemo2类，接收/resp2的请求，在doGet方法中打印`resp2....`\n>\n> 3.在ResponseDemo1的方法中使用\n>\n> ​\tresponse.setStatus(302);\n>\n> ​\tresponse.setHeader("Location","/request-demo/resp2") 来给前端响应结果数据\n>\n> 4.启动测试\n\n(1)创建ResponseDemo1类\n\n```java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(2)创建ResponseDemo2类\n\n```java\n@WebServlet("/resp2")\npublic class ResponseDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp2....");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(3)在ResponseDemo1的doGet方法中给前端响应数据\n\n```java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n        //重定向\n        //1.设置响应状态码 302\n        response.setStatus(302);\n        //2. 设置响应头 Location\n        response.setHeader("Location","/request-demo/resp2");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n(4)启动测试\n\n访问`http://localhost:8080/request-demo/resp1`,就可以在控制台看到.\n\n说明`/resp1`和`/resp2`都被访问到了。到这重定向就已经完成了。\n\n虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为:\n\n```\nresposne.sendRedirect("/request-demo/resp2")\n```\n\n所以第3步中的代码就可以简化为：\n\n```java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n        //重定向\n        resposne.sendRedirect("/request-demo/resp2")；\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n3. 重定向的特点\n\n* 浏览器地址栏路径发送变化\n\n  当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化\n\n* 可以重定向到任何位置的资源(服务内容、外部均可)\n\n  因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。\n\n* 两次请求，不能在多个资源使用request共享数据\n\n  因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据\n\n介绍完==请求重定向==和==请求转发==以后，接下来需要把这两个放在一块对比下:\n\n| 重定向特点                                         | 请求转发特点                                |\n| -------------------------------------------------- | ------------------------------------------- |\n| 浏览器地址栏路径发生变化                           | 浏览器地址栏路径不发生变化                  |\n| 可以重定向到任意位置的资源(服务器外部、内部都可以) | 只能转发到当前服务器的内部资源              |\n| 两次请求，不能再多个资源使用request共享数据        | 一次请求，可以转发资源间使用request共享数据 |\n\n以后到底用哪个，还是需要根据具体的业务来决定。\n\n### 3.3 路径问题\n\n1. 问题1：转发的时候路径上没有加`/request-demo`而重定向加了，那么到底什么时候需要加，什么时候不需要加呢?\n\n其实判断的依据很简单，只需要记住下面的规则即可:\n\n* 浏览器使用:需要加虚拟目录(项目访问路径)\n* 服务端使用:不需要加虚拟目录\n\n对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录\n\n对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。\n\n掌握了这个规则，接下来就通过一些练习来强化下知识的学习:\n\n* `<a href=\'路劲\'>`\n* `<form action=\'路径\'>`\n* req.getRequestDispatcher("路径")\n* resp.sendRedirect("路径")\n\n答案:\n\n```\n1.超链接，从浏览器发送，需要加\n2.表单，从浏览器发送，需要加\n3.转发，是从服务器内部跳转，不需要加\n4.重定向，是由浏览器进行跳转，需要加。\n```\n\n2. 问题2：在重定向的代码中，`/request-demo`是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?\n\n答案也比较简单，我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下:\n\n```java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n\n        //简化方式完成重定向\n        //动态获取虚拟目录\n        String contextPath = request.getContextPath();\n        response.sendRedirect(contextPath+"/resp2");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。\n\n### 3.4 Response响应字符数据\n\n要想将字符数据写回到浏览器，我们需要两个步骤:\n\n* 通过Response对象获取字符输出流： PrintWriter writer = resp.getWriter();\n\n* 通过字符输出流写数据: writer.write("aaa");\n\n接下来，我们实现通过些案例把响应字符数据给实际应用下:\n\n1. 返回一个简单的字符串`aaa`\n\n```java\n/**\n * 响应字符数据：设置字符数据的响应体\n */\n@WebServlet("/resp3")\npublic class ResponseDemo3 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType("text/html;charset=utf-8");\n        //1. 获取字符输出流\n        PrintWriter writer = response.getWriter();\n\t\t writer.write("aaa");\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n2. 返回一串html字符串，并且能被浏览器解析\n\n```\nPrintWriter writer = response.getWriter();\n//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签\nresponse.setHeader("content-type","text/html");\nwriter.write("<h1>aaa</h1>");\n```\n\n==注意:==一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。\n\n3. 返回一个中文的字符串`你好`，需要注意设置响应数据的编码为`utf-8`\n\n```\n//设置响应的数据格式及数据的编码\nresponse.setContentType("text/html;charset=utf-8");\nwriter.write("你好");\n```\n\n### 3.3 Response响应字节数据\n\n要想将字节数据写回到浏览器，我们需要两个步骤:\n\n- 通过Response对象获取字节输出流：ServletOutputStream outputStream = resp.getOutputStream();\n\n- 通过字节输出流写数据: outputStream.write(字节数据);\n\n接下来，我们实现通过些案例把响应字符数据给实际应用下:\n\n1. 返回一个图片文件到浏览器\n\n```java\n/**\n * 响应字节数据：设置字节数据的响应体\n */\n@WebServlet("/resp4")\npublic class ResponseDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 读取文件\n        FileInputStream fis = new FileInputStream("d://a.jpg");\n        //2. 获取response字节输出流\n        ServletOutputStream os = response.getOutputStream();\n        //3. 完成流的copy\n        byte[] buff = new byte[1024];\n        int len = 0;\n        while ((len = fis.read(buff))!= -1){\n            os.write(buff,0,len);\n        }\n        fis.close();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是:\n\n(1)pom.xml添加依赖\n\n```xml\n<dependency>\n    <groupId>commons-io</groupId>\n    <artifactId>commons-io</artifactId>\n    <version>2.6</version>\n</dependency>\n```\n\n(2)调用工具类方法\n\n```\n//fis:输入流\n//os:输出流\nIOUtils.copy(fis,os);\n```\n\n优化后的代码:\n\n```java\n/**\n * 响应字节数据：设置字节数据的响应体\n */\n@WebServlet("/resp4")\npublic class ResponseDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 读取文件\n        FileInputStream fis = new FileInputStream("d://a.jpg");\n        //2. 获取response字节输出流\n        ServletOutputStream os = response.getOutputStream();\n        //3. 完成流的copy\n      \tIOUtils.copy(fis,os);\n        fis.close();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n## 4，用户注册登录案例\n\n接下来我们通过两个比较常见的案例，一个是==注册==，一个是==登录==来对今天学习的内容进行一个实战演练，首先来实现用户登录。\n\n### 4.1 用户登录\n\n#### 4.1.1 需求分析\n\n1. 用户在登录页面输入用户名和密码，提交请求给LoginServlet\n2. 在LoginServlet中接收请求和数据[用户名和密码]\n3. 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表\n4. 将查询的结果封装到User对象中进行返回\n5. 在LoginServlet中判断返回的User对象是否为null\n6. 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回"登录失败"数据给前端\n7. 如果不为null,则说明用户存在并且密码正确，则登录成功，返回"登录成功"数据给前端\n\n#### 4.1.2 环境准备\n\n1.在项目的pom.xml导入Mybatis和Mysql驱动坐标\n\n```xml\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.5</version>\n</dependency>\n\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.34</version>\n</dependency>\n```\n\n2.创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    \x3c!--起别名--\x3e\n    <typeAliases>\n        <package name="com.itheima.pojo"/>\n    </typeAliases>\n\n    <environments default="development">\n        <environment id="development">\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                <property name="driver" value="com.mysql.jdbc.Driver"/>\n                \x3c!--\n                    useSSL:关闭SSL安全连接 性能更高\n                    useServerPrepStmts:开启预编译功能\n                    &amp; 等同于 & ,xml配置文件中不能直接写 &符号\n                --\x3e\n                <property name="url" value="jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true"/>\n                <property name="username" value="root"/>\n                <property name="password" value="1234"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        \x3c!--扫描mapper--\x3e\n        <package name="com.itheima.mapper"/>\n    </mappers>\n</configuration>\n```\n\n创建UserMapper接口\n\n```java\npublic interface UserMapper {\n\n}\n```\n\n==注意：在resources下创建UserMapper.xml的目录时，要使用/分割==\n\n至此我们所需要的环境就都已经准备好了，具体该如何实现?\n\n#### 4.1.3 代码实现\n\n1. 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法\n\n```java\n/**\n     * 根据用户名和密码查询用户对象\n     * @param username\n     * @param password\n     * @return\n     */\n    @Select("select * from tb_user where username = #{username} and password = #{password}")\n    User select(@Param("username") String username,@Param("password")  String password);\n```\n\n**说明**\n\n@Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。\n\n2. 修改loign.html\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <title>login</title>\n    <link href="css/login.css" rel="stylesheet">\n</head>\n\n<body>\n<div id="loginDiv">\n    <form action="/request-demo/loginServlet" method="post" id="form">\n        <h1 id="loginMsg">LOGIN IN</h1>\n        <p>Username:<input id="username" name="username" type="text"></p>\n\n        <p>Password:<input id="password" name="password" type="password"></p>\n\n        <div id="subDiv">\n            <input type="submit" class="button" value="login up">\n            <input type="reset" class="button" value="reset">&nbsp;&nbsp;&nbsp;\n            <a href="register.html">没有账号？点击注册</a>\n        </div>\n    </form>\n</div>\n\n</body>\n</html>\n```\n\n3. 编写LoginServlet\n\n```java\n@WebServlet("/loginServlet")\npublic class LoginServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 接收用户名和密码\n        String username = request.getParameter("username");\n        String password = request.getParameter("password");\n\n        //2. 调用MyBatis完成查询\n        //2.1 获取SqlSessionFactory对象\n        String resource = "mybatis-config.xml";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        //2.2 获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //2.3 获取Mapper\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        //2.4 调用方法\n        User user = userMapper.select(username, password);\n        //2.5 释放资源\n        sqlSession.close();\n\n\n        //获取字符输出流，并设置content type\n        response.setContentType("text/html;charset=utf-8");\n        PrintWriter writer = response.getWriter();\n        //3. 判断user释放为null\n        if(user != null){\n            // 登陆成功\n            writer.write("登陆成功");\n        }else {\n            // 登陆失败\n            writer.write("登陆失败");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n4. 启动服务器测试\n\n4.1 如果用户名和密码输入错误，则成功\n\n4.2 如果用户名和密码输入正确，则失败\n\n至此用户的登录功能就已经完成了~\n\n### 4.2 用户注册\n\n#### 4.2.1 需求分析\n\n1. 用户在注册页面输入用户名和密码，提交请求给RegisterServlet\n2. 在RegisterServlet中接收请求和数据[用户名和密码]\n3. 在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表\n4. 将查询的结果封装到User对象中进行返回\n5. 在RegisterServlet中判断返回的User对象是否为null\n6. 如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户\n7. 如果不为null,则说明用户不可以，返回"用户名已存在"数据给前端\n\n#### 4.2.2 代码编写\n\n1. 编写UserMapper提供根据用户名查询用户数据方法和添加用户方法\n\n```java\n/**\n* 根据用户名查询用户对象\n* @param username\n* @return\n*/\n@Select("select * from tb_user where username = #{username}")\nUser selectByUsername(String username);\n\n/**\n* 添加用户\n* @param user\n*/\n@Insert("insert into tb_user values(null,#{username},#{password})")\nvoid add(User user);\n```\n\n2. 修改register.html\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>欢迎注册</title>\n    <link href="css/register.css" rel="stylesheet">\n</head>\n<body>\n\n<div class="form-div">\n    <div class="reg-content">\n        <h1>欢迎注册</h1>\n        <span>已有帐号？</span> <a href="login.html">登录</a>\n    </div>\n    <form id="reg-form" action="/request-demo/registerServlet" method="post">\n\n        <table>\n\n            <tr>\n                <td>用户名</td>\n                <td class="inputs">\n                    <input name="username" type="text" id="username">\n                    <br>\n                    <span id="username_err" class="err_msg" style="display: none">用户名不太受欢迎</span>\n                </td>\n\n            </tr>\n\n            <tr>\n                <td>密码</td>\n                <td class="inputs">\n                    <input name="password" type="password" id="password">\n                    <br>\n                    <span id="password_err" class="err_msg" style="display: none">密码格式有误</span>\n                </td>\n            </tr>\n\n        </table>\n\n        <div class="buttons">\n            <input value="注 册" type="submit" id="reg_btn">\n        </div>\n        <br class="clear">\n    </form>\n\n</div>\n</body>\n</html>\n```\n\n3. 创建RegisterServlet类\n\n```java\n@WebServlet("/registerServlet")\npublic class RegisterServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 接收用户数据\n        String username = request.getParameter("username");\n        String password = request.getParameter("password");\n\n        //封装用户对象\n        User user = new User();\n        user.setUsername(username);\n        user.setPassword(password);\n\n        //2. 调用mapper 根据用户名查询用户对象\n        //2.1 获取SqlSessionFactory对象\n        String resource = "mybatis-config.xml";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        //2.2 获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //2.3 获取Mapper\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n\n        //2.4 调用方法\n        User u = userMapper.selectByUsername(username);\n\n        //3. 判断用户对象释放为null\n        if( u == null){\n            // 用户名不存在，添加用户\n            userMapper.add(user);\n\n            // 提交事务\n            sqlSession.commit();\n            // 释放资源\n            sqlSession.close();\n        }else {\n            // 用户名存在，给出提示信息\n            response.setContentType("text/html;charset=utf-8");\n            response.getWriter().write("用户名已存在");\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n```\n\n4. 启动服务器进行测试\n\n4.1 如果测试成功，则在数据库中就能查看到新注册的数据\n\n4.2 如果用户已经存在，则在页面上展示 `用户名已存在` 的提示信息\n\n### 4.3 SqlSessionFactory工具类抽取\n\n上面两个功能已经实现，但是在写Servlet的时候，因为需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下\n\n```java\nString resource = "mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new \n\tSqlSessionFactoryBuilder().build(inputStream);\n```\n\n有了这些重复代码就会造成一些问题:\n\n* 重复代码不利于后期的维护\n* SqlSessionFactory工厂类进行重复创建\n    * 就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。\n\n那如何来优化呢？\n\n* 代码重复可以抽取工具类\n* 对指定代码只需要执行一次可以使用静态代码块\n\n有了这两个方向后，代码具体该如何编写?\n\n```java\npublic class SqlSessionFactoryUtils {\n\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static {\n        //静态代码块会随着类的加载而自动执行，且只执行一次\n        try {\n            String resource = "mybatis-config.xml";\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static SqlSessionFactory getSqlSessionFactory(){\n        return sqlSessionFactory;\n    }\n}\n```\n\n工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用\n\n```java\nSqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory();\n```\n\n这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。'},{title:"jdbc 的基本使用",headers:[{level:2,title:"1，JDBC概述",slug:"_1-jdbc概述",link:"#_1-jdbc概述",children:[{level:3,title:"1.1  JDBC概念",slug:"_1-1-jdbc概念",link:"#_1-1-jdbc概念",children:[]},{level:3,title:"1.2  JDBC本质",slug:"_1-2-jdbc本质",link:"#_1-2-jdbc本质",children:[]},{level:3,title:"1.3  JDBC好处",slug:"_1-3-jdbc好处",link:"#_1-3-jdbc好处",children:[]}]},{level:2,title:"2，JDBC快速入门",slug:"_2-jdbc快速入门",link:"#_2-jdbc快速入门",children:[{level:3,title:"2.1  编写代码步骤",slug:"_2-1-编写代码步骤",link:"#_2-1-编写代码步骤",children:[]},{level:3,title:"2.2  具体操作",slug:"_2-2-具体操作",link:"#_2-2-具体操作",children:[]}]},{level:2,title:"3，JDBC API详解",slug:"_3-jdbc-api详解",link:"#_3-jdbc-api详解",children:[{level:3,title:"3.1  DriverManager",slug:"_3-1-drivermanager",link:"#_3-1-drivermanager",children:[]},{level:3,title:"3.2  Connection",slug:"_3-2-connection",link:"#_3-2-connection",children:[]},{level:3,title:"3.3  Statement",slug:"_3-3-statement",link:"#_3-3-statement",children:[]},{level:3,title:"3.4  ResultSet",slug:"_3-4-resultset",link:"#_3-4-resultset",children:[]},{level:3,title:"3.5  案例",slug:"_3-5-案例",link:"#_3-5-案例",children:[]},{level:3,title:"3.6  PreparedStatement",slug:"_3-6-preparedstatement",link:"#_3-6-preparedstatement",children:[]}]},{level:2,title:"4，数据库连接池",slug:"_4-数据库连接池",link:"#_4-数据库连接池",children:[{level:3,title:"4.1  数据库连接池简介",slug:"_4-1-数据库连接池简介",link:"#_4-1-数据库连接池简介",children:[]},{level:3,title:"4.2  数据库连接池实现",slug:"_4-2-数据库连接池实现",link:"#_4-2-数据库连接池实现",children:[]},{level:3,title:"4.3  Driud使用",slug:"_4-3-driud使用",link:"#_4-3-driud使用",children:[]}]}],path:"/posts/java/web/jdbc.html",pathLocale:"/",extraFields:'---\ntitle: jdbc 的基本使用\nicon: pen-to-square\ndate: 2023-06-01\nlastUpdated: true\ncategory:\n  - java\ntag:\n  - javaweb\n  - jdbc\n---\n\njdbc 基础使用\n\n\x3c!-- more --\x3e\n**目标**\n\n> * 掌握JDBC的的CRUD\n> * 理解JDBC中各个对象的作用\n> * 掌握Druid的使用\n\n## 1，JDBC概述\n\n在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。\n\n### 1.1  JDBC概念\n\n> JDBC   就是使用Java语言操作关系型数据库的一套API\n>\n> 全称：( Java DataBase Connectivity ) Java 数据库连接\n\n我们开发的同一套Java代码是无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现细节都不一样。如果这样，问题就很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线时公司最终选用oracle数据库，我们就需要对代码进行大批量修改，这显然并不是我们想看到的。我们要做到的是同一套Java代码操作不同的关系型数据库，而此时sun公司就指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出。\n\n### 1.2  JDBC本质\n\n* 官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口\n* 各个数据库厂商去实现这套接口，提供数据库驱动jar包\n* 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类\n\n### 1.3  JDBC好处\n\n* 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发\n* 可随时替换底层数据库，访问数据库的Java代码基本不变\n\n以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包:`mysql-connector-java-5.1.48.jar`。\n\n\n## 2，JDBC快速入门\n\n先来看看通过Java操作数据库的流程\n\n第一步：编写Java代码\n\n第二步：Java代码将SQL发送到MySQL服务端\n\n第三步：MySQL服务端接收到SQL语句并执行该SQL语句\n\n第四步：将SQL语句执行的结果返回给Java代码\n\n### 2.1  编写代码步骤\n\n* 创建工程，导入驱动jar包\n\n\n* 注册驱动\n\n  ```sql\n  Class.forName("com.mysql.jdbc.Driver");\n  ```\n\n* 获取连接\n\n  ```sql\n  Connection conn = DriverManager.getConnection(url, username, password);\n  ```\n\n  Java代码需要发送SQL给MySQL服务端，就需要先建立连接\n\n* 定义SQL语句\n\n  ```sql\n  String sql =  "update…" ;\n  ```\n\n* 获取执行SQL对象\n\n  执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象\n\n  ```sql\n  Statement stmt = conn.createStatement();\n  ```\n\n* 执行SQL\n\n  ```sql\n  stmt.executeUpdate(sql);  \n  ```\n\n* 处理返回结果\n\n* 释放资源\n\n### 2.2  具体操作\n\n* 创建新的空的项目\n\n* 定义项目的名称，并指定位置\n\n* 对项目进行设置，JDK版本、编译版本\n\n* 创建模块，指定模块的名称及位置\n\n* 导入驱动包\n\n  将mysql的驱动包放在模块下的lib目录（随意命名）下，并将该jar包添加为库文件:右键->Add as Library\n\n\n* 在添加为库文件的时候，有如下三个选项\n    * Global Library  ： 全局有效\n    * Project Library :   项目有效\n    * Module Library ： 模块有效\n\n\n* 在src下创建类\n\n* 编写代码如下\n\n```java\n/**\n * JDBC快速入门\n */\npublic class JDBCDemo {\n\n    public static void main(String[] args) throws Exception {\n        //1. 注册驱动\n        //Class.forName("com.mysql.jdbc.Driver");\n        //2. 获取连接\n        String url = "jdbc:mysql://127.0.0.1:3306/db1";\n        String username = "root";\n        String password = "1234";\n        Connection conn = DriverManager.getConnection(url, username, password);\n        //3. 定义sql\n        String sql = "update account set money = 2000 where id = 1";\n        //4. 获取执行sql的对象 Statement\n        Statement stmt = conn.createStatement();\n        //5. 执行sql\n        int count = stmt.executeUpdate(sql);//受影响的行数\n        //6. 处理结果\n        System.out.println(count);\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    }\n}\n```\n\n\n\n## 3，JDBC API详解\n\n### 3.1  DriverManager\n\nDriverManager（驱动管理类）作用：\n\n* 注册驱动\n```java\n/*\n * 向驱动程序管理器注册给定的驱动程序。新加载的驱动程序类应调用方法 registerDriver，以使驱动程序管理器知道自身。\n * 如果驱动程序当前已注册，则不执行任何操作。参数：驱动程序 – 要注册到驱动程序管理器的新 JDBC 驱动程序\n * 抛出：SQLException – 如果发生数据库访问错误 空指针异常 – 如果驱动程序为空\n */\npublic static synchronized void registerDriver(java.sql.Driver driver)\n        throws SQLException {\n\n        registerDriver(driver, null);\n        }\n```\n\n  registerDriver方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现\n\n  ```sql\n  Class.forName("com.mysql.jdbc.Driver");\n  ```\n\n  我们查询MySQL提供的Driver类，看它是如何实现的，源码如下：\n\n ```java\nstatic {\n        try {\n            DriverManager.registerDriver(new Driver());\n        } catch (SQLException var1) {\n            throw new RuntimeException("Can\'t register driver!");\n        }\n    }\n```\n\n  在该类中的静态代码块中已经执行了 `DriverManager` 对象的 `registerDriver()` 方法进行驱动的注册了，那么我们只需要加载 `Driver` 类，该静态代码块就会执行。而 `Class.forName("com.mysql.jdbc.Driver");` 就可以加载 `Driver` 类。\n\n  > ==提示：==\n  >\n  > * MySQL 5之后的驱动包，可以省略注册驱动的步骤\n  > * 自动加载 jar 包中META-INF/services/java.sql.Driver文件中的驱动类\n\n* 获取数据库连接\n\n源码如下：\n```java\n @CallerSensitive\n    public static Connection getConnection(String url,\n        String user, String password) throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n\n        if (user != null) {\n            info.put("user", user);\n        }\n        if (password != null) {\n            info.put("password", password);\n        }\n\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }\n```\n\n  参数说明：\n\n    * url ： 连接路径\n\n      > 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&参数键值对2…\n      >\n      > 示例：jdbc:mysql://127.0.0.1:3306/db1\n      >\n      > ==细节：==\n      >\n      > * 如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称?参数键值对\n      >\n      > * 配置 useSSL=false 参数，禁用安全连接方式，解决警告提示\n\n    * user ：用户名\n\n    * poassword ：密码\n\n### 3.2  Connection\n\nConnection（数据库连接对象）作用：\n\n* 获取执行 SQL 的对象\n* 管理事务\n\n#### 3.2.1  获取执行对象\n\n* 普通执行SQL对象\n\n  ```sql\n  Statement createStatement()\n  ```\n\n  入门案例中就是通过该方法获取的执行对象。\n\n* 预编译SQL的执行SQL对象：防止SQL注入\n\n  ```sql\n  PreparedStatement  prepareStatement(sql)\n  ```\n\n  通过这种方式获取的 `PreparedStatement` SQL语句执行对象是我们一会重点要进行讲解的，它可以防止SQL注入。\n\n* 执行存储过程的对象\n\n  ```sql\n  CallableStatement prepareCall(sql)\n  ```\n\n  通过这种方式获取的 `CallableStatement` 执行对象是用来执行存储过程的，而存储过程在MySQL中不常用，所以这个我们将不进行讲解。\n\n#### 3.2.2  事务管理\n\n先回顾一下MySQL事务管理的操作：\n\n* 开启事务 ： BEGIN; 或者 START TRANSACTION;\n* 提交事务 ： COMMIT;\n* 回滚事务 ： ROLLBACK;\n\n> MySQL默认是自动提交事务\n\n接下来学习JDBC事务管理的方法。\n\nConnection几口中定义了3个对应的方法：\n\n* 开启事务\n\n```java\n/*\n * 将此连接的自动提交模式设置为给定状态。如果连接处于自动提交模式，则其所有 SQL 语句将作为单个事务执行和提交。\n * 否则，其 SQL 语句将分组到通过调用方法提交或方法回滚而终止的事务中。\n * 默认情况下，新连接处于自动提交模式。提交在语句完成时发生。\n * 语句完成的时间取决于 SQL 语句的类型：对于 DML 语句（如插入、更新或删除）和 DDL 语句，语句在完成执行后立即完成。\n * 对于 Select 语句，当关联的结果集关闭时，该语句即为完成。\n * 对于 CallableStatement 对象或返回多个结果的语句，当所有关联的结果集都已关闭，并且已检索所有更新计数和输出参数时，该语句即为完成。\n * 注意：如果在事务期间调用此方法并且更改了自动提交模式，则会提交事务。如果调用了 setAutoCommit 并且未更改自动提交模式，则该调用为无操作。\n * 参数：自动提交 – true 以启用自动提交模式;假以禁用它 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用 setAutoCommit（true），或者在关闭的连接上调用此方法 另请参阅：getAutoCommit\n */\nvoid setAutoCommit(boolean autoCommit) throws SQLException;\n```\n\n  参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为为false。\n\n* 提交事务\n```java\n/*\n * 使自上次提交回滚以来所做的所有更改永久化，并释放此 Connection 对象当前持有的任何数据库锁。\n * 仅当禁用自动提交模式时，才应使用此方法。\n * 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用此方法，\n * 如果在关闭的连接上调用此方法或此连接对象处于自动提交模式 另请参阅：设置自动提交\n */\n void commit() throws SQLException;\n```\n\n* 回滚事务\n\n```java\n/*\n * 撤消在当前事务中所做的所有更改，并释放此 Connection 对象当前持有的任何数据库锁。\n * 仅当禁用自动提交模式时，才应使用此方法。\n * 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用此方法，在关闭的连接上调用此方法，或者此连接对象处于自动提交模式 另请参阅：setAutoCommit\n */\n void rollback() throws SQLException;\n```\n\n具体代码实现如下：\n\n```java\n/**\n * JDBC API 详解：Connection\n */\npublic class JDBCDemo3_Connection {\n\n    public static void main(String[] args) throws Exception {\n        //1. 注册驱动\n        //Class.forName("com.mysql.jdbc.Driver");\n        //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url = "jdbc:mysql:///db1?useSSL=false";\n        String username = "root";\n        String password = "1234";\n        Connection conn = DriverManager.getConnection(url, username, password);\n        //3. 定义sql\n        String sql1 = "update account set money = 3000 where id = 1";\n        String sql2 = "update account set money = 3000 where id = 2";\n        //4. 获取执行sql的对象 Statement\n        Statement stmt = conn.createStatement();\n\n        try {\n            // ============开启事务==========\n            conn.setAutoCommit(false);\n            //5. 执行sql\n            int count1 = stmt.executeUpdate(sql1);//受影响的行数\n            //6. 处理结果\n            System.out.println(count1);\n            int i = 3/0;\n            //5. 执行sql\n            int count2 = stmt.executeUpdate(sql2);//受影响的行数\n            //6. 处理结果\n            System.out.println(count2);\n\n            // ============提交事务==========\n            //程序运行到此处，说明没有出现任何问题，则需求提交事务\n            conn.commit();\n        } catch (Exception e) {\n            // ============回滚事务==========\n            //程序在出现异常时会执行到这个地方，此时就需要回滚事务\n            conn.rollback();\n            e.printStackTrace();\n        }\n\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    }\n}\n```\n\n### 3.3  Statement\n\n#### 3.3.1  概述\n\nStatement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。\n\n* 执行DDL、DML语句\n\n```java\n/*\n * 执行给定的 SQL 语句，该语句可以是 INSERT、UPDATE 或 DELETE 语句，也可以是不返回任何内容的 SQL 语句，例如 SQL DDL 语句。\n * 注意：此方法不能在 PreparedStatement 或 CallableStatement（已调用语句）上调用。\n * 参数：sql – SQL 数据操作语言 （DML） 语句，例如 INSERT、UPDATE 或 DELETE;或不返回任何内容的 SQL 语句，例如 DDL 语句。\n * 返回：（1） SQL 数据操作语言 （DML） 语句的行计数或 （2） 0 对于不返回任何内容的 SQL 语句 \n * 抛出：SQLTimeoutException – 当驱动程序确定已超出 setQueryTimeout 方法指定的超时值，\n * 并且至少尝试取消当前正在运行的语句 SQLException – 如果发生数据库访问错误， 此方法在闭合语句上调用，\n * 给定的 SQL 语句生成一个 ResultSet 对象，该方法在 PreparedStatement 或 CallableStatement 上调用\n */\nint executeUpdate(String sql) throws SQLException;\n```\n\n\n\n\n* 执行DQL语句\n\n```java\n/*\n * 执行给定的 SQL 语句，该语句返回单个结果集对象。\n * 注意：此方法不能在 PreparedStatement 或 CallableStatement（已调用语句）上调用。\n * 参数：sql – 要发送到数据库的 SQL 语句，通常是静态 SQL SELECT 语句 \n * 返回：一个 ResultSet 对象，其中包含给定查询生成的数据;\n * 永不空抛出： SQLTimeoutException – 当驱动程序确定已超出 setQueryTimeout 方法指定的超时值，并且至少尝试取消当前运行的语句 \n * SQLException – 如果发生数据库访问错误，则在关闭语句上调用此方法，给定的 SQL 语句生成除单个 ResultSet 对象以外的任何内容， \n * 该方法在 PreparedStatement 或 CallableStatement 上调用\n */\nResultSet executeQuery(String sql) throws SQLException;\n```\n\n  该方法涉及到了 `ResultSet` 对象，而这个对象我们还没有学习，一会再重点讲解。\n\n\n\n#### 3.3.2  代码实现\n\n* 执行DML语句\n\n  ```java\n  /**\n    * 执行DML语句\n    * @throws Exception\n    */\n  @Test\n  public void testDML() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n      //3. 定义sql\n      String sql = "update account set money = 3000 where id = 1";\n      //4. 获取执行sql的对象 Statement\n      Statement stmt = conn.createStatement();\n      //5. 执行sql\n      int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数\n      //6. 处理结果\n      //System.out.println(count);\n      if(count > 0){\n          System.out.println("修改成功~");\n      }else{\n          System.out.println("修改失败~");\n      }\n      //7. 释放资源\n      stmt.close();\n      conn.close();\n  }\n  ```\n\n* 执行DDL语句\n\n  ```java\n  /**\n    * 执行DDL语句\n    * @throws Exception\n    */\n  @Test\n  public void testDDL() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n      //3. 定义sql\n      String sql = "drop database db2";\n      //4. 获取执行sql的对象 Statement\n      Statement stmt = conn.createStatement();\n      //5. 执行sql\n      int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0\n      //6. 处理结果\n      System.out.println(count);\n  \n      //7. 释放资源\n      stmt.close();\n      conn.close();\n  }\n  ```\n\n  > 注意：\n  >\n  > * 以后开发很少使用java代码操作DDL语句\n\n### 3.4  ResultSet\n\n#### 3.4.1  概述\n\nResultSet（结果集对象）作用：\n\n* ==封装了SQL查询语句的结果。==\n\n而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：\n\n```java\nResultSet  executeQuery(sql);//执行DQL 语句，返回 ResultSet 对象\n```\n\n那么我们就需要从 `ResultSet` 对象中获取我们想要的数据。`ResultSet` 对象提供了操作查询结果数据的方法，如下：\n\n> boolean  next()\n>\n> * 将光标从当前位置向前移动一行\n> * 判断当前行是否为有效行\n>\n> 方法返回值说明：\n>\n> * true  ： 有效航，当前行有数据\n> * false ： 无效行，当前行没有数据\n\n> xxx  getXxx(参数)：获取数据\n>\n> * xxx : 数据类型；如： int getInt(参数) ；String getString(参数)\n> * 参数\n    >   * int类型的参数：列的编号，从1开始\n>   * String类型的参数： 列的名称\n\n如下图为执行SQL语句后的结果\n\n|     id     |         name        |money|\n| :-----------: | -------------: | :------------- |\n| 1| 张三| 3000 |\n|       2     |      李四 | 1000           |\n|       4      |           王五 | 2000              |\n\n一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 `next()` 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 `getInt("id")` 获取当前行id字段的值，也可以通过 `getString("name")` 获取当前行name字段的值。如果想获取下一行的数据，继续调用 `next()`  方法，以此类推。\n\n#### 3.4.2  代码实现\n\n```java\n/**\n  * 执行DQL\n  * @throws Exception\n  */\n@Test\npublic void testResultSet() throws  Exception {\n    //1. 注册驱动\n    //Class.forName("com.mysql.jdbc.Driver");\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n    //3. 定义sql\n    String sql = "select * from account";\n    //4. 获取statement对象\n    Statement stmt = conn.createStatement();\n    //5. 执行sql\n    ResultSet rs = stmt.executeQuery(sql);\n    //6. 处理结果， 遍历rs中的所有数据\n    /* // 6.1 光标向下移动一行，并且判断当前行是否有数据\n        while (rs.next()){\n            //6.2 获取数据  getXxx()\n            int id = rs.getInt(1);\n            String name = rs.getString(2);\n            double money = rs.getDouble(3);\n\n            System.out.println(id);\n            System.out.println(name);\n            System.out.println(money);\n\n            System.out.println("--------------");\n\n        }*/\n    // 6.1 光标向下移动一行，并且判断当前行是否有数据\n    while (rs.next()){\n        //6.2 获取数据  getXxx()\n        int id = rs.getInt("id");\n        String name = rs.getString("name");\n        double money = rs.getDouble("money");\n\n        System.out.println(id);\n        System.out.println(name);\n        System.out.println(money);\n\n        System.out.println("--------------");\n    }\n\n    //7. 释放资源\n    rs.close();\n    stmt.close();\n    conn.close();\n}\n```\n\n### 3.5  案例\n\n* 需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中\n\n\n* 代码实现\n\n  ```java\n  /**\n    * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中\n    * 1. 定义实体类Account\n    * 2. 查询数据，封装到Account对象中\n    * 3. 将Account对象存入ArrayList集合中\n    */\n  @Test\n  public void testResultSet2() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n  \n      //3. 定义sql\n      String sql = "select * from account";\n  \n      //4. 获取statement对象\n      Statement stmt = conn.createStatement();\n  \n      //5. 执行sql\n      ResultSet rs = stmt.executeQuery(sql);\n  \n      // 创建集合\n      List<Account> list = new ArrayList<>();\n     \n      // 6.1 光标向下移动一行，并且判断当前行是否有数据\n      while (rs.next()){\n          Account account = new Account();\n  \n          //6.2 获取数据  getXxx()\n          int id = rs.getInt("id");\n          String name = rs.getString("name");\n          double money = rs.getDouble("money");\n  \n          //赋值\n          account.setId(id);\n          account.setName(name);\n          account.setMoney(money);\n  \n          // 存入集合\n          list.add(account);\n      }\n  \n      System.out.println(list);\n  \n      //7. 释放资源\n      rs.close();\n      stmt.close();\n      conn.close();\n  }\n  ```\n\n\n\n### 3.6  PreparedStatement\n\n> PreparedStatement作用：\n>\n> * 预编译SQL语句并执行：预防SQL注入问题\n\n对上面的作用中SQL注入问题大家肯定不理解。那我们先对SQL注入进行说明.\n\n#### 3.6.1  SQL注入\n\n> SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。\n\n `application.properties` 文件中的用户名和密码，文件内容如下：\n\n```properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&useUnicode=true&characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=1234\n```\n\n在MySQL中创建名为 `test` 的数据库\n\n```sql\ncreate database test;\n```\n\n登陆输入密码时候\n\n用户名随意写，密码写成 `\' or \'1\' =\'1`\n就有类似的sql语句\n```sql\nselect count() from t_user where name = \'name\' and password = \'\'or\'1\' = \'1\';\n```\n\n就会登陆成功\n\n这就是SQL注入漏洞，也是很危险的。当然现在市面上的系统都不会存在这种问题了，所以大家也不要尝试用这种方式去试其他的系统。\n\n那么该如何解决呢？这里就可以将SQL执行对象 `Statement` 换成 `PreparedStatement` 对象。\n\n#### 3.6.2  代码模拟SQL注入问题\n\n```java\n@Test\npublic void testLogin() throws  Exception {\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    // 接收用户输入 用户名和密码\n    String name = "sjdljfld";\n    String pwd = "\' or \'1\' = \'1";\n    String sql = "select * from tb_user where username = \'"+name+"\' and password = \'"+pwd+"\'";\n    // 获取stmt对象\n    Statement stmt = conn.createStatement();\n    // 执行sql\n    ResultSet rs = stmt.executeQuery(sql);\n    // 判断登录是否成功\n    if(rs.next()){\n        System.out.println("登录成功~");\n    }else{\n        System.out.println("登录失败~");\n    }\n\n    //7. 释放资源\n    rs.close();\n    stmt.close();\n    conn.close();\n}\n```\n\n上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下\n\n```sql\nselect * from tb_user where username = \'sjdljfld\' and password = \'\'or \'1\' = \'1\'\n```\n\n从上面语句可以看出条件 `username = \'sjdljfld\' and password = \'\'` 不管是否满足，而 `or` 后面的 `\'1\' = \'1\'` 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。\n\n接下来我们来学习PreparedStatement对象.\n\n#### 3.6.3  PreparedStatement概述\n\n> PreparedStatement作用：\n>\n> * 预编译SQL语句并执行：预防SQL注入问题\n\n* 获取 PreparedStatement 对象\n\n  ```java\n  // SQL语句中的参数值，使用？占位符替代\n  String sql = "select * from user where username = ? and password = ?";\n  // 通过Connection对象获取，并传入对应的sql语句\n  PreparedStatement pstmt = conn.prepareStatement(sql);\n  ```\n\n* 设置参数值\n\n  上面的sql语句中参数使用 ? 进行占位，在之前肯定要设置这些 ?  的值。\n\n  > PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值\n  >\n  > * Xxx：数据类型 ； 如 setInt (参数1，参数2)\n  >\n  > * 参数：\n      >\n      >   * 参数1： ？的位置编号，从1 开始\n  >\n  >   * 参数2： ？的值\n\n* 执行SQL语句\n\n  > executeUpdate();  执行DDL语句和DML语句\n  >\n  > executeQuery();  执行DQL语句\n  >\n  > ==注意：==\n  >\n  > * 调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。\n\n#### 3.6.4  使用PreparedStatement改进\n\n```java\n @Test\npublic void testPreparedStatement() throws  Exception {\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    // 接收用户输入 用户名和密码\n    String name = "zhangsan";\n    String pwd = "\' or \'1\' = \'1";\n\n    // 定义sql\n    String sql = "select * from tb_user where username = ? and password = ?";\n    // 获取pstmt对象\n    PreparedStatement pstmt = conn.prepareStatement(sql);\n    // 设置？的值\n    pstmt.setString(1,name);\n    pstmt.setString(2,pwd);\n    // 执行sql\n    ResultSet rs = pstmt.executeQuery();\n    // 判断登录是否成功\n    if(rs.next()){\n        System.out.println("登录成功~");\n    }else{\n        System.out.println("登录失败~");\n    }\n    //7. 释放资源\n    rs.close();\n    pstmt.close();\n    conn.close();\n}\n```\n\n执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：\n\n```sql\nselect * from tb_user where username = \'sjdljfld\' and password = \'\\\'or \\\'1\\\' = \\\'1\'\n```\n\n\n\n#### 3.6.5  PreparedStatement原理\n\n> PreparedStatement 好处：\n>\n> * 预编译SQL，性能更高\n> * 防止SQL注入：==将敏感字符进行转义==\n\n\n* 将sql语句发送到MySQL服务器端\n\n* MySQL服务端会对sql语句进行如下操作\n\n    * 检查SQL语句\n\n      检查SQL语句的语法是否正确。\n\n    * 编译SQL语句。将SQL语句编译成可执行的函数。\n\n      检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。\n\n    * 执行SQL语句\n\n接下来我们通过查询日志来看一下原理。\n\n* 开启预编译功能\n\n  在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。\n\n  ```sql\n  useServerPrepStmts=true\n  ```\n\n* 配置MySQL执行日志（重启mysql服务后生效）\n\n  在mysql配置文件（my.ini）中添加如下配置\n\n  ```\n  log-output=FILE\n  general-log=1\n  general_log_file="D:\\mysql.log"\n  slow-query-log=1\n  slow_query_log_file="D:\\mysql_slow.log"\n  long_query_time=2\n  ```\n\n* java测试代码如下：\n\n  ```java\n   /**\n     * PreparedStatement原理\n     * @throws Exception\n     */\n  @Test\n  public void testPreparedStatement2() throws  Exception {\n  \n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      // useServerPrepStmts=true 参数开启预编译功能\n      String url = "jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n  \n      // 接收用户输入 用户名和密码\n      String name = "zhangsan";\n      String pwd = "\' or \'1\' = \'1";\n  \n      // 定义sql\n      String sql = "select * from tb_user where username = ? and password = ?";\n  \n      // 获取pstmt对象\n      PreparedStatement pstmt = conn.prepareStatement(sql);\n  \n      Thread.sleep(10000);\n      // 设置？的值\n      pstmt.setString(1,name);\n      pstmt.setString(2,pwd);\n      ResultSet rs = null;\n      // 执行sql\n      rs = pstmt.executeQuery();\n  \n      // 设置？的值\n      pstmt.setString(1,"aaa");\n      pstmt.setString(2,"bbb");\n      // 执行sql\n      rs = pstmt.executeQuery();\n  \n      // 判断登录是否成功\n      if(rs.next()){\n          System.out.println("登录成功~");\n      }else{\n          System.out.println("登录失败~");\n      }\n  \n      //7. 释放资源\n      rs.close();\n      pstmt.close();\n      conn.close();\n  }\n  ```\n\n\n\n> ==小结：==\n>\n> * 在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）\n> * 执行时就不用再进行这些步骤了，速度更快\n> * 如果sql模板一样，则只需要进行一次检查、编译\n\n## 4，数据库连接池\n\n### 4.1  数据库连接池简介\n\n> * 数据库连接池是个容器，负责分配、管理数据库连接(Connection)\n>\n> * 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；\n>\n> * 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n> * 好处\n    >   * 资源重用\n>   * 提升系统响应速度\n>   * 避免数据库连接遗漏\n\n之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。\n\n而数据库使用了数据库连接池后，就能达到Connection对象的复用\n\n连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。\n\n### 4.2  数据库连接池实现\n\n* 标准接口：==DataSource==\n\n  官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：\n\n  ```java\n  Connection getConnection()\n  ```\n\n  那么以后就不需要通过 `DriverManager` 对象获取 `Connection` 对象，而是通过连接池（DataSource）获取 `Connection` 对象。\n\n* 常见的数据库连接池\n\n    * DBCP\n    * C3P0\n    * Druid\n\n  我们现在使用更多的是Druid，它的性能比其他两个会好一些。\n\n* Druid（德鲁伊）\n\n    * Druid连接池是阿里巴巴开源的数据库连接池项目\n\n    * 功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n### 4.3  Driud使用\n\n> * 导入jar包 druid-1.1.12.jar\n> * 定义配置文件\n> * 加载配置文件\n> * 获取数据库连接池对象\n> * 获取连接\n\n现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件\n\n现在都是用maven\n\n编写配置文件如下：\n\n```properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=1234\n# 初始化连接数量\ninitialSize=5\n# 最大连接数\nmaxActive=10\n# 最大等待时间\nmaxWait=3000\n```\n\n使用druid的代码如下：\n\n```java\n/**\n * Druid数据库连接池演示\n */\npublic class DruidDemo {\n\n    public static void main(String[] args) throws Exception {\n        //1.导入jar包\n        //2.定义配置文件\n        //3. 加载配置文件\n        Properties prop = new Properties();\n        prop.load(new FileInputStream("jdbc-demo/src/druid.properties"));\n        //4. 获取连接池对象\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n\n        //5. 获取数据库连接 Connection\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection); //获取到了连接后就可以继续做其他操作了\n\n        //System.out.println(System.getProperty("user.dir"));\n    }\n}\n```\n'},{title:"django 使用过程中发生的问题",headers:[{level:2,title:"django  为何 只允许127.0.0.1 访问服务，电脑的实际ip确不行",slug:"django-为何-只允许127-0-0-1-访问服务-电脑的实际ip确不行",link:"#django-为何-只允许127-0-0-1-访问服务-电脑的实际ip确不行",children:[{level:3,title:"1. 修改ALLOWED_HOSTS设置：",slug:"_1-修改allowed-hosts设置",link:"#_1-修改allowed-hosts设置",children:[]},{level:3,title:"2. 运行Django服务时指定监听地址：",slug:"_2-运行django服务时指定监听地址",link:"#_2-运行django服务时指定监听地址",children:[]},{level:3,title:"3. 防火墙和网络设置：",slug:"_3-防火墙和网络设置",link:"#_3-防火墙和网络设置",children:[]},{level:3,title:"4. DNS和主机名：",slug:"_4-dns和主机名",link:"#_4-dns和主机名",children:[]}]}],path:"/posts/python/django/djangoWork.html",pathLocale:"/",extraFields:"---\ntitle: django 使用过程中发生的问题\nicon: pen-to-square\ndate: 2024-05-29\nlastUpdated: true\ncategory:\n  - python\ntag:\n  - djgango\n---\n\n在工作中遇到了 django  框架，记录一些使用过程中遇到的问题\n\n\x3c!-- more --\x3e\n\n## django  为何 只允许127.0.0.1 访问服务，电脑的实际ip确不行\n\nDjango服务默认只允许从127.0.0.1（也被称为本地回环地址或localhost）访问，这通常是因为Django的设置文件中ALLOWED_HOSTS配置的限制。为了允许电脑的实际IP地址访问Django服务，需要进行以下几步操作：\n\n### 1. 修改ALLOWED_HOSTS设置：\nDjango的settings.py文件中有一个ALLOWED_HOSTS配置，它指定了哪些主机名或IP地址可以访问Django服务。默认情况下，它可能只包含['localhost']或['127.0.0.1']。要允许电脑的实际IP地址访问，你需要将ALLOWED_HOSTS修改为包含你的实际IP地址，或者设置为['*']（注意：'*'允许所有IP地址访问，但出于安全考虑，通常不推荐在生产环境中使用）。\n例如：\n\n```python\nALLOWED_HOSTS = ['你的实际IP地址']  # 只允许指定IP访问  \n# 或者  \nALLOWED_HOSTS = ['*']  # 允许所有IP访问（不推荐用于生产环境）\n```\n### 2. 运行Django服务时指定监听地址：\n当你使用python manage.py runserver命令启动Django开发服务器时，默认情况下它只会监听127.0.0.1（localhost）。如果你想让Django服务监听你的电脑的实际IP地址，你需要指定一个不同的地址，如0.0.0.0，这会让Django服务监听所有可用的网络接口。\n例如：\n\n```bash\npython manage.py runserver 0.0.0.0:8000\n````\n这样，Django服务就会监听所有可用的IP地址，并通过端口8000提供服务。\n### 3. 防火墙和网络设置：\n如果你的电脑上有防火墙或网络访问控制设置，确保它们允许从你的实际IP地址到Django服务的访问。你可能需要配置防火墙规则或路由器设置来允许流量通过。\n### 4. DNS和主机名：\n如果你尝试通过域名或主机名访问Django服务而不是直接通过IP地址，你还需要确保DNS设置正确，并且主机名可以被解析为你的电脑的实际IP地址。\n总结来说，Django默认只允许从127.0.0.1访问是因为ALLOWED_HOSTS设置的限制。要允许从电脑的实际IP地址访问，你需要修改ALLOWED_HOSTS设置，并在运行Django服务时指定监听地址。同时，确保防火墙和网络设置允许从你的实际IP地址到Django服务的访问。\n\n\n\n\n\n"},{title:"Java入门",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",link:"#_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",link:"#_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",link:"#_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",link:"#_1-3-常用cmd命令",children:[]},{level:3,title:"1.4 CMD练习",slug:"_1-4-cmd练习",link:"#_1-4-cmd练习",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",link:"#_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",link:"#_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",link:"#_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",link:"#_1-2下载和安装",children:[]},{level:3,title:"1.3 HelloWorld小案例",slug:"_1-3-helloworld小案例",link:"#_1-3-helloworld小案例",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",link:"#_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",link:"#_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Notepad++",slug:"_1-6-notepad",link:"#_1-6-notepad",children:[]},{level:3,title:"1.7 Java语言的发展",slug:"_1-7-java语言的发展",link:"#_1-7-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",link:"#_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",link:"#_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",link:"#_1-10-jre和jdk",children:[]}]}],path:"/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",pathLocale:"/",extraFields:'---\ntitle: Java入门\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nJava入门介绍，编写hello world\n\n\x3c!-- more --\x3e\n\n\n## 1. 人机交互\n\n### 1.1 什么是cmd？\n\n就是在windows操作系统中，利用命令行的方式去操作计算机。\n\n我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。\n\n### 1.2 如何打开CMD窗口？\n\n1. 按下快捷键：win + R。\n\n\t\t此时会出现运行窗口。\n\n2. 在运行窗口中输出cmd\n3. 输出回车。\n\n解惑：\n\n​\tcmd默认操作C盘下的users文件夹下的XXX文件夹。（XXX就是计算机名）\n\n ![image-20210923091350952](assets\\cmd.png)\n\n### 1.3 常用CMD命令\n\n 扩展一个小点：\n\n​\t在很多资料中都说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。\n\n​\t而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些。\n\n常见的CMD命令如下：\n\n| 操作               | 说明                              |\n| ------------------ | --------------------------------- |\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\n| dir                | 查看当前路径下的内容。            |\n| cd 目录            | 进入单级目录。cd itheima          |\n| cd ..              | 回退到上一级目录。                |\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\n| cd \\               | 回退到盘符目录。                  |\n| cls                | 清屏。                            |\n| exit               | 退出命令提示符窗口。              |\n\n### 1.4 CMD练习\n\n需求：\n\n  利用cmd命令打开自己电脑上的QQ。\n\n完成步骤：\n\n```java\n1,确定自己电脑上的QQ安装在哪里\n2,启动cmd\n3,进入到启动程序QQ.exe所在的路径。\n4,输出qq.exe加回车表示启动qq。\n```\n\n解惑：\n\n​\t在windows操作系统当中，文件名或者文件夹名是忽略大小写的。\n\n### 1.5 环境变量\n\n作用：\n\n​\t如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。\n\n​\t在启动软件的时候，操作系统会先在当前路径下找，如果在当前路径没有，再到环境变量的路径中去找。如果都找不到就提示无法启动。\n\n步骤：\n\n- 右键我的电脑，选择属性。\n- 点击左侧的高级系统设置\n- 选择高级，再点击下面的环境变量。\n- 找系统变量里面的PATH\n- 把软件的完整路径，配置到PATH当中就可以了。\n- （可做可不做）就是把自己配置的路径，移动到最上面。\n\n图解示例如下：\n\n第一步：右键点击我的电脑并选择属性。\n\n（如果无法出现第二步界面，可以打开我的电脑之后右键点击空白处）\n\n![image-20210923091350952](assets\\1.png)\n\n第二步：点击高级系统设置。\n\n​\t ![image-20210923091350952](assets\\2.png)\n\n第三步：选择高级，再点击下面的环境变量。\n\n ![image-20210923091350952](assets\\3.png)\n\n\n\n第四步：找系统变量里面的PATH\n\n ![image-20210923091350952](assets\\4.png)\n\n第五步：点击新建，把软件的完整路径，配置到PATH当中，再点击确定即可。\n\n第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。\n\n移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。\n\n ![image-20210923091350952](assets\\5.png)\n\n## 2. Java概述\n\n### 1.1 Java是什么？\n\n语言：人与人交流沟通的表达方式\n\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\n\nJava是一门非常火的计算机语言。（也叫做编程语言）\n\n我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了\n\n### 1.2下载和安装\n\n#### 1.2.1 下载\n\n通过官方网站获取JDK\n\n[http://www.oracle.com](http://www.oracle.com/)\n\n**注意1**：针对不同的操作系统，需要下载对应版本的JDK。\n\n**注意2**：\n\n​\t如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。\n\n​\t因为Java从9版本开始，就已经不提供32位版本的安装包了。\n\n#### 1.2.2 安装\n\n​\t傻瓜式安装，下一步即可。默认的安装路径是在C:\\Program Files下。\n\n建议：\n\n- 安装路径不要有中文，不要有空格等一些特殊的符号。\n- 以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。\n\n#### 1.2.3 JDK的安装目录介绍\n\n| 目录名称 | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\n| include  | 该路径下存放了一些平台特定的头文件。                         |\n| jmods    | 该路径下存放了JDK的各种模块。                                |\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\n\n### 1.3 HelloWorld小案例\n\n​\tHelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。\n\n#### 2.3.1 Java程序开发运行流程\n\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\n\n#### 2.3.2 HelloWorld案例的编写\n\n1. 新建文本文档文件，修改名称为HelloWorld.java。\n\n**注意**：后缀名为java的才是java文件。\n\n2. 用记事本打开HelloWorld.java文件，输写程序内容。\n\n**注意**：代码要跟我编写的完全保持一致。\n\n```java\npublic class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("HelloWorld");\n\t}\n}\n```\n\n3. 保存\n\n**注意**：未保存的文件在左上角会有*符号标记\n\n4. 编译文件。编译后会产生一个class文件。\n\n   java文件：程序员自己编写的代码。\n\n   class文件：交给计算机执行的文件。\n\n5. 运行代码\n\n   **注意**：运行的是编译之后的class文件。\n\n> 用到两个命令：\n>\n> ​\tjavac + 文件名 + 后缀名 （就是编译java文件）\n>\n> ​\tjava + 文件名（运行编译之后的class文件）\n\n### 1.4 HelloWorld案例常见问题\n\n#### 1.4.1 BUG\n\n​\t在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\n\n#### 1.4.2 BUG的解决\n\n1. 具备识别BUG的能力：多看\n2. 具备分析BUG的能力：多思考，多查资料\n3. 具备解决BUG的能力：多尝试，多总结\n\n#### 1.4.3 HelloWorld常见问题\n\n1、非法字符问题。Java中的符号都是英文格式的。\n\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\n\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\n\n4、编译命令后的java文件名需要带文件后缀.java\n\n5、运行命令后的class文件名（类名）不带文件后缀.class\n\n...\n\n#### 常见错误代码1：\n\n```java\npublicclass HelloWorld{\n    public static void main(String[] args){\n        System.out.println("HelloWorld");\n    }\n}\n```\n\n问题：\n\n​\tpublic和class之间缺少一个空格。\n\n技巧：一般来讲在单词之间的空格是不能省略的。\n\n​\t如果是单词和符号之间的空格是可以省略的。\n\n#### 常见错误代码2：\n\n```java\npublic class HelloWorld{\n    public static void main(String[] args){\n        system.out.println("HelloWorld");\n    }\n}\n```\n\n问题：\n\n​\tsystem首字母必须大写。\n\n技巧：\n\n​\tJava代码中，是严格区分大小写的。\n\n​\t所以该大写的地方一定要大写，该小写的地方一定要小写。多多练习。\n\n#### 常见错误代码3：\n\n```java\npublic class HelloWorld{\n    public static void main(String[] args){\n        System.out.println(HelloWorld);\n    }\n}\n```\n\n问题：\n\n​\t第三行代码中的HelloWorld必须用双引号引起来，否则就会出现问题。\n\n#### 常见错误代码4：\n\n```java\npublic class HelloWorld{\n    public static void main(String[] args){\n        System.out.println("HelloWorld")；\n    }\n}\n```\n\n问题：\n\n​\t在以后代码当中，所有的标点符号必须是英文状态下的。\n\n技巧：\n\n​\t可以在输入法中进行对应的设置。\n\n### 1.5 环境变量\n\n#### 1.5.1 为什么配置环境变量\n\n​\t开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。\n\n注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。\n\n#### 1.5.2配置方式\n\n![image-20210923091654365](assets/image-20210923091654365.png)\n\n\n\n以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。\n\n①**JAVA_HOME**：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）\n\n![image-20210923091710450](assets/image-20210923091710450.png)\n\n②**Path**：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置\n\n![image-20210923091721035](assets/image-20210923091721035.png)\n\n\n\n#### 1.5.3win10的bug\n\n当电脑重启之后，环境变量失效了。表示操作系统不支持自定义的环境变量。\n\n步骤：\n\n- 还是要配置JAVA_HOME给以后的相关软件去使用\n\n- 我们可以把java和javac的完整路径配置到PATH当中。\n\n  E:\\develop\\JDK\\bin\n\n### 1.6 Notepad++\n\n#### 1.6.1下载\n\n​\t打开百度，搜索一下notepad++就可以了。\n\n#### 1.6.2 安装\n\n傻瓜式安装，直接点击下一步就可以了。\n\n​\t对安装路径有两个小建议：\n\n- 路径不要有中文，不要有空格，不要有一些特殊符号\n- 建议最好把所有的跟开发相关的软件都放在一起，方便管理。\n\n#### 1.6.3 设置\n\n​\t右键点击java文件，选择edit with notepad++。\n\n​\t点击设置，再点击首选项。在弹出的页面当中，左侧选择新建，中间选择Java，右侧选择ANSI。\n\n#### 1.6.4 练习\n\n​\t利用notepad++去编写一个HelloWorld并能成功编译和运行。\n\n### 1.7 Java语言的发展\n\n三个版本：\n\n* Java5.0：这是Java的第一个大版本更新。\n* Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。\n* Java15.0：这个是学习使用的版本。\n\n解惑：\n\n​\t我们学的跟工作中使用的版本不太一样啊。会不会影响以后工作呢？\n\n向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。\n\n举例：\n\n用8版本开发的代码，用11版本能运行吗？必须可以的。\n\n用11版本开发的代码，用8版本能运行吗？不一定。\n\n如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。\n\n如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。\n\n### 1.8 Java的三大平台\n\n​\tJavaSE、JavaME、JavaEE\n\n#### 1.8.1 JavaSE\n\n​\t是其他两个版本的基础。\n\n#### 1.8.2 JavaME\n\n​\tJava语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。\n\n​\t其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。\n\n​\t但是，安卓也是可以用Java来开发的。\n\n#### 1.8.3 JavaEE\n\n​\t用于Web方向的网站开发。（主要从事后台服务器的开发）\n\n​\t在服务器领域，Java是当之无愧的龙头老大。\n\n### 1.9 Java的主要特性\n\n- 面向对象\n- 安全性\n- 多线程\n- 简单易用\n- 开源\n- 跨平台\n\n#### 1.9.1 Java语言跨平台的原理\n\n- 操作系统本身其实是不认识Java语言的。\n- 但是针对于不同的操作系统，Java提供了不同的虚拟机。\n\n虚拟机会把Java语言翻译成操作系统能看得懂的语言。\n\n![image-20210923091350952](assets\\image-20210923091350952.png)\n\n### 1.10 JRE和JDK\n\n![image-20210923091544110](assets\\image-20210923091544110.png)\n\nJVM（Java Virtual Machine），Java虚拟机\n\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\n\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\n\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\n'},{title:"Java基础概念",headers:[{level:2,title:"1. 注释",slug:"_1-注释",link:"#_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",link:"#使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",link:"#注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",link:"#_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",link:"#_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",link:"#_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",link:"#_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",link:"#区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",link:"#_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",link:"#_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",link:"#_4-2-变量的定义格式",children:[]},{level:3,title:"4.3 变量的练习",slug:"_4-3-变量的练习",link:"#_4-3-变量的练习",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",link:"#_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",link:"#_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",link:"#_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",link:"#_5-3-定义8种基本数据类型变量",children:[]},{level:3,title:"5.4 练习1",slug:"_5-4-练习1",link:"#_5-4-练习1",children:[]},{level:3,title:"5.5 练习2",slug:"_5-5-练习2",link:"#_5-5-练习2",children:[]},{level:3,title:"5.6 练习3",slug:"_5-6-练习3",link:"#_5-6-练习3",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",link:"#_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",link:"#_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",link:"#_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",link:"#_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",link:"#_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",link:"#阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",link:"#_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",link:"#_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",link:"#_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",link:"#_8-2-idea的下载和安装",children:[]},{level:3,title:"8.3 IDEA中层级结构介绍",slug:"_8-3-idea中层级结构介绍",link:"#_8-3-idea中层级结构介绍",children:[]},{level:3,title:"8.4 IDEA中的第一个代码",slug:"_8-4-idea中的第一个代码",link:"#_8-4-idea中的第一个代码",children:[]},{level:3,title:"8.5 IDEA中类的相关操作",slug:"_8-5-idea中类的相关操作",link:"#_8-5-idea中类的相关操作",children:[]},{level:3,title:"8.6 IDEA中模块的相关操作",slug:"_8-6-idea中模块的相关操作",link:"#_8-6-idea中模块的相关操作",children:[]},{level:3,title:"8.7 IDEA中项目的相关操作",slug:"_8-7-idea中项目的相关操作",link:"#_8-7-idea中项目的相关操作",children:[]}]}],path:"/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",pathLocale:"/",extraFields:'---\ntitle: Java基础概念\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nJava基础概念学习\n\n\x3c!-- more --\x3e\n\n## 1. 注释\n\n​\t注释是对代码的解释和说明文字。\n\nJava中的注释分为三种：\n\n* 单行注释：\n\n~~~java\n// 这是单行注释文字\n~~~\n\n* 多行注释：\n\n~~~java\n/*\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/\n注意：多行注释不能嵌套使用。\n~~~\n\n* 文档注释（暂时用不到）：\n\n```java\n/**\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/\n```\n\n### 使用的技巧\n\n​\t如果我们要对代码进行解释，那么就可以使用注释。\n\n​\t当注释的内容比较少，一行就写完了，可以用单行注释。\n\n​\t如果注释的内容比较多，需要写在多行，那么可以使用多行注释。\n\n### 注意点\n\n​\t注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。\n\n​\t所以，不管在注释当中写什么内容，都不会影响代码运行的结果。\n\n## 2. 关键字\n\n### 2.1 概念\n\n​\t被Java赋予了特定含义的英文单词。\n\n​\t当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。\n\n注意：关键字很多，不用刻意去记。\n\n| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |\n| -------------- | ---------------- | ------------- | -------------- | ---------- |\n| **case**       | **catch**        | **char**      | **class**      | **const**  |\n| **continue**   | **default**      | **do**        | **double**     | **else**   |\n| **enum**       | **extends**      | **final**     | **finally**    | **float**  |\n| **for**        | **goto**         | **if**        | **implements** | **import** |\n| **instanceof** | **int**          | **interface** | **long**       | **native** |\n| **new**        | **package**      | **private**   | **protected**  | **public** |\n| **return**     | **strictfp**     | **short**     | **static**     | **super**  |\n| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |\n| **transient**  | **try**          | **void**      | **volatile**   | **while**  |\n\n### 2.2 第一个关键字class\n\n​\t表示定义一个类。创建一个类。\n\n类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。\n\nclass后面跟随的就是这个类的名字，简称：类名。\n\n在类名后面会有一对大括号，表示这个类的内容。\n\n举例：\n\n```java\npublic class HelloWorld{\n    \n   \n}\n```\n\n解释：class表示定义类。\n\n​\t类名：HelloWorld\n\n​\tHelloWorld后面的大括号表示这个类的范围。\n\n## 3. 字面量\n\n作用：告诉程序员，数据在程序中的书写格式。\n\n| **字面量类型** | **说明**                                  | **程序中的写法**           |\n| -------------- | ----------------------------------------- | -------------------------- |\n| 整数           | 不带小数的数字                            | 666，-88                   |\n| 小数           | 带小数的数字                              | 13.14，-5.21               |\n| 字符           | 必须使用单引号，有且仅能一个字符          | ‘A’，‘0’，   ‘我’          |\n| 字符串         | 必须使用双引号，内容可有可无              | “HelloWorld”，“黑马程序员” |\n| 布尔值         | 布尔值，表示真假，只有两个值：true，false | true 、false               |\n| 空值           | 一个特殊的值，空值                        | 值是：null                 |\n\n~~~java\npublic class Demo {\n    public static void main(String[] args) {\n        System.out.println(10); // 输出一个整数\n        System.out.println(5.5); // 输出一个小数\n        System.out.println(\'a\'); // 输出一个字符\n        System.out.println(true); // 输出boolean值true\n        System.out.println("欢迎来到黑马程序员"); // 输出字符串\n    }\n}\n~~~\n\n### 区分技巧\n\n1. 不带小数点的数字都是整数类型的字面量。\n2. 只要带了小数点，那么就是小数类型的字面量。\n3. 只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。\n4. 字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。\n5. 字符类型的字面量只有两个值，true、false。\n6. 空类型的字面量只有一个值，null。\n\n## 4. 变量\n\n### 4.1 什么是变量？\n\n​\t变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。\n\n### 4.2 变量的定义格式\n\n​\t数据类型 变量名 = 数据值；\n\n#### 4.2.1 格式详解\n\n​\t数据类型：限定了变量当中能存储什么类型的数据。\n\n​\t\t\t   如果要存10，那么数据类型就需要写整数类型。\n\n​\t\t\t   如果要存10.0，那么数据类型就需要写小数类型。\n\n​\t变量名：其实就是这个容器的名字。\n\n​\t\t\t当以后想要使用变量里面的数据时，直接使用变量名就可以了。\n\n​\t数据值：真正存储在容器中的数据。\n\n​\t分号：表示语句的结束，就跟以前写作文时候的句号是一样的。\n\n#### 4.2.2 常用的数据类型\n\n​\t整数：int\n\n​\t小数：（浮点数）double\n\n​\t其他数据类型稍后讲解\n\n举例：\n\n```java\npublic class VariableDemo{\n\tpublic static void main(String[] args){\n\t\t//定义一个整数类型的变量\n\t\t//数据类型 变量名 = 数据值;\n\t\tint a = 16;\n\t\tSystem.out.println(a);//16\n\t\t\n\t\t//定义一个小数类型的变量\n\t\tdouble b = 10.1;\n\t\tSystem.out.println(b);//10.1\n\t}\n}\n```\n\n#### 4.2.3 变量的注意事项\n\n- 变量名不能重复\n- 在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。\n- 变量在使用之前必须要赋值。\n\n案例：\n\n```java\npublic class VariableDemo2{\n\tpublic static void main(String[] args){\n\t\t//1.变量名不允许重复\n\t\t//int a = 10;\n\t\t//int a = 20;\n\t\t//System.out.println(a);\n\t\t\n\t\t//2.一条语句可以定义多个变量\n\t\t//了解。\n\t\t//int a = 10, b = 20, c = 20,d = 20;\n\t\t//System.out.println(a);//?\n\t\t//System.out.println(b);//?\n\t\t\n\t\t\n\t\t//3.变量在使用之前必须要赋值\n\t\tint a = 30;\n\t\tSystem.out.println(a);\n\t}\n}\n```\n\n### 4.3 变量的练习\n\n​\t需求：说出公交车到终点站之后，车上一共有多少乘客？\n\n​\t\t    一开始没有乘客。\n\n​\t\t   第一站：上去一位乘客，没有下来乘客。\n\n​\t\t   第二站：上去两位乘客，下来一位乘客。\n\n​\t\t   第三站：上去两位乘客，下来一位乘客。\n\n​\t\t   第四站：没有上去乘客，下来一位乘客。\n\n​\t\t   第五站：上去一位乘客，没有下来乘客。\n\n​\t\t   问：到了终点站之后，车上一共多少乘客？\n\n​\t代码解析：\n\n```java\npublic class VariableTest1{\n\t//主入口\n\tpublic static void main(String[] args){\n\t\t//一开始没有乘客。\n\t\tint count = 0;\n\t\t//第一站：上去一位乘客\n\t\t//在原有的基础上 + 1\n\t\tcount = count + 1;\n\t\t//System.out.println(count);\n\t\t//第二站：上去两位乘客，下来一位乘客\n\t\tcount = count + 2 - 1; \n\t\t//第三站：上去两位乘客，下来一位乘客\n\t\tcount = count + 2 - 1;\n\t\t//第四站：下来一位乘客\n\t\tcount = count - 1;\n\t\t//第五站：上去一位乘客\n\t\tcount = count + 1;\n\t\t//请问：到了终点站，车上一共几位乘客。\n\t\tSystem.out.println(count);//3\n\t}\n}\n```\n\n## 5. 数据类型\n\n### 5.1 Java语言数据类型的分类\n\n- 基本数据类型\n- 引用数据类型（面向对象的时候再深入学习）\n\n### 5.2 基本数据类型的四类八种\n\n| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |\n| :------: | :-----: | :------: | :---------------------------------------: |\n|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |\n|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |\n|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |\n|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |\n|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |\n|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |\n|   字符   |  char   |    2     |                  0-65535                  |\n|   布尔   | boolean |    1     |                true，false                |\n\n#### 说明\n\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\n\n​\t在java中整数默认是int类型，浮点数默认是double类型。\n\n#### 需要记忆以下几点\n\nbyte类型的取值范围：\n\n​\t-128 ~ 127\n\nint类型的大概取值范围：\n\n​\t-21亿多  ~ 21亿多\n\n整数类型和小数类型的取值范围大小关系：\n\n​\tdouble > float > long > int > short > byte\n\n最为常用的数据类型选择：\n\n- 在定义变量的时候，要根据实际的情况来选择不同类型的变量。\n\n  比如：人的年龄，可以选择byte类型。\n\n  比如：地球的年龄，可以选择long类型。\n\n- 如果整数类型中，不太确定范围，那么默认使用int类型。\n\n- 如果小数类型中，不太确定范围，那么默认使用double类型。\n\n- 如果要定义字符类型的变量，那么使用char\n\n- 如果要定义布尔类型的变量，那么使用boolean\n\n### 5.3 定义8种基本数据类型变量\n\n```java\npublic class VariableDemo3{\n    public static void main(String[] args){\n        //1.定义byte类型的变量\n        //数据类型 变量名 = 数据值;\n        byte a = 10;\n        System.out.println(a);\n\n        //2.定义short类型的变量\n        short b = 20;\n        System.out.println(b);\n\n        //3.定义int类型的变量\n        int c = 30;\n        System.out.println(c);\n\n        //4.定义long类型的变量\n        long d = 123456789123456789L;\n        System.out.println(d);\n\n        //5.定义float类型的变量\n        float e = 10.1F;\n        System.out.println(e);\n\n        //6.定义double类型的变量\n        double f = 20.3;\n        System.out.println(f);\n\n        //7.定义char类型的变量\n        char g = \'a\';\n        System.out.println(g);\n\n        //8.定义boolean类型的变量\n        boolean h = true;\n        System.out.println(h);\n\n    }\n}\n```\n\n#### **注意点**\n\n- 如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。\n- 如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。\n- 如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）\n- 如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）\n\n### 5.4 练习1\n\n需求：定义5个变量记录老师的信息并打印\n\n代码示例：\n\n```java\npublic class VariableTest1{\n\tpublic static void main(String[] args){\n\t\t//1.定义字符串类型的变量记录老师的姓名\n\t\tString name = "黑马谢广坤";\n\t\t//2.定义整数类型的变量记录老师的年龄\n\t\tint age = 18;\n\t\t//3.定义字符类型的变量记录老师的性别\n\t\tchar gender = \'男\';\n\t\t//4.定义小数类型的变量记录老师的身高\n\t\tdouble height = 180.1;\n\t\t//5.定义布尔类型的变量记录老师的婚姻状况\n\t\tboolean flag = true;\n\t\t\n\t\t//输出5个变量的值\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(age);\n\t\tSystem.out.println(gender);\n\t\tSystem.out.println(height);\n\t\tSystem.out.println(flag);\n\t\t\n\t}\n}\n```\n\n### 5.5 练习2\n\n需求：将（电影名称，主演，年份，评分）四个信息选择不同类型的变量，随后打印出来。\n\n 代码示例：\n\n```java\npublic class VariableTest2{\n\tpublic static void main(String[] args){\n\t\t//1.定义字符串变量记录电影的名称\n\t\tString movie = "送初恋回家";\n\t\t//2.定义三个变量记录主演的名字\n\t\tString name1 = "刘鑫";\n\t\tString name2 = "张雨提";\n\t\tString name3 = "高媛";\n\t\t//3. 定义整数类型的变量记录年龄的年份\n\t\tint year = 2020;\n\t\t//4.定义小数类型的变量记录电影的评分\n\t\tdouble score = 9.0;\n\t\t\n\t\t//打印变量的信息\n\t\tSystem.out.println(movie);\n\t\tSystem.out.println(name1);\n\t\tSystem.out.println(name2);\n\t\tSystem.out.println(name3);\n\t\tSystem.out.println(year);\n\t\tSystem.out.println(score);\n\t\t\n\t}\n}\n```\n\n### 5.6 练习3\n\n需求：选择其中一部手机，将（手机价格，手机品牌）两个信息选择不同类型的变量，随后打印出来。 \n\n 代码示例：\n\n```java\npublic class VariableTest3{\n\tpublic static void main(String[] args){\n\t\t//1.定义小数类型的变量记录手机的价格\n\t\tdouble price = 5299.0;\n\t\t\n\t\t//2.定义字符串类型的变量记录手机的品牌\n\t\tString brand = "华为";\n\t\t\n\t\t//输出变量记录的值\n\t\tSystem.out.println(price);\n\t\tSystem.out.println(brand);\n\t}\n}\n```\n\n## 6. 标识符\n\n业内大多数程序员都在遵守阿里巴巴的命名规则。\n访问地址：https://developer.aliyun.com/ebook/386\n\n### 6.1 硬性要求：\n\n​\t必须要这么做，否则代码会报错。\n\n- 必须由数字、字母、下划线_、美元符号$组成。\n- 数字不能开头\n- 不能是关键字\n- 区分大小写的。\n\n### 6.2 软件建议：\n\n​\t如果不这么做，代码不会报错，但是会让代码显得比较low。\n\n### 6.2.1 小驼峰命名法\n\n适用于变量名和方法名\n\n* 如果是一个单词，那么全部小写，比如：name\n\n* 如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge\n\n### 6.2.2 大驼峰命名法\n\n适用于类名\n\n* 如果是一个单词，那么首字母大写。比如：Demo、Test。\n\n* 如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld\n\n不管起什么名字，都要做到见名知意。\n\n### 阿里巴巴命名规范细节：\n\n1. 尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。\n\n   正确：alibaba、hangzhou、nanjing\n\n   错误：jiage、dazhe\n\n2. 平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。\n\n   错误：_name\n\n   正确：name\n\n## 7. 键盘录入\n\n​\t键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。\n\n使用步骤：\n\n第一步：\n\n​\t导包：其实就是表示先找到Scanner这个类在哪。\n\n第二步：\n\n​\t创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。\n\n第三步：\n\n​\t接收数据：也是真正干活的代码。\n\n代码示例：\n\n```java\n//导包，其实就是先找到Scanner这个类在哪\nimport java.util.Scanner;\npublic class ScannerDemo1{\n\tpublic static void main(String[] args){\n\t\t//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。\n\t\tScanner sc = new Scanner(System.in);\n\t\t//3.接收数据\n\t\t//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了\n\t\tSystem.out.println("请输入一个数字");\n\t\tint i = sc.nextInt();\n\t\tSystem.out.println(i);\n\t}\n}\n```\n\n## 8. IDEA\n\n### 8.1 IDEA概述\n\n​\tIDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。\n\n**集成环境：**\n\n​\t把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。\n\n### 8.2 IDEA的下载和安装\n\n#### 8.2.1 下载\n\n​\t可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea\n\n​\t也可以通过百度网盘下载（此idea安装方法需查看里面的txt文件）：\n\t通过网盘分享的文件：IDEA 2022.1.3\n\t链接: https://pan.baidu.com/s/1XIn1P2SwL10NqucPOgbsgA?pwd=5rsi 提取码: 5rsi\n\n#### 8.2.2 安装\n\n- 到资料文件夹中，双击安装包。\n- 点击next，准备安装\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%851.png)\n\n- 点击Browse修改安装路径。\n\n  修改完毕点击next\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%852.png)\n\n- 勾选64-bit launcher。表示在桌面新建一个64位的快捷方式。\n\n  其他的不要勾选。\n\n  点击next。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%854.png)\n\n- 点击Install，准备安装。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%855.png)\n\n- 等进度条读取完毕之后，会有最终界面提示。\n\n  点击finish即可。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%856.png)\n\n- 第一次启动会询问，是否导入一些设置。\n\n  选择第二个不导入，保持默认设置，再点击OK。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%857.png)\n\n- 选择背景主题\n\n  左边是黑色背景。右边是白色背景。\n\n  这个可以根据自己的喜好来选择。\n\n  选择完毕点击右下角的next\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%858.png)\n\n- 在本界面让我们购买idea。\n\n  因为我们是学习阶段，所以可以使用免费使用30天。\n\n  点击第一排第二个。Evaluate for free\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%859.png)\n\n- 点击蓝色的Evaluate，就可以开始免费试用30天了。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%8510.png)\n\n- 当看到这个界面，就表示idea已经成功安装完毕\n\n  可以点击右上角关闭。\n\n![计算机发展](img/idea%E5%AE%89%E8%A3%8511.png)\n\n### 8.3 IDEA中层级结构介绍\n\n#### 8.3.1 结构分类\n\n- project（项目、工程）\n- module（模块）\n- package（包）\n- class（类）\n\n#### 8.3.2 结构介绍\n\n​\t为了让大家更好的吸收，package这一层级，我们后面再学习，先学习最基础的project、module、class。\n\n##### project（项目、工程）\n\n​\t淘宝、京东、黑马程序员网站都属于一个个项目，IDEA中就是一个个的Project。\n\n##### module（模块）\n\n​\t在一个项目中，可以存放多个模块，不同的模块可以存放项目中不同的业务功能代码。在黑马程序员的官方网站中，至少包含了以下模块：\n\n- 论坛模块\n- 报名、咨询模块\n\n为了更好的管理代码，我们会把代码分别放在两个模块中存放。\n\n##### package（包）\n\n​\t一个模块中又有很多的业务，以黑马程序员官方网站的论坛模块为例，至少包含了以下不同的业务。\n\n- 发帖\n- 评论\n\n为了把这些业务区分的更加清楚，就会用包来管理这些不同的业务。\n\n##### class（类）\n\n​\t就是真正写代码的地方。\n\n#### 8.3.3 小结\n\n- 层级关系\n\n  ​\tproject - module - package - class\n\n- 包含数量\n\n  ​\tproject中可以创建多个module\n  ​\tmodule中可以创建多个package\n  ​\tpackage中可以创建多个class\n\n  ​\t这些结构的划分，是为了方便管理类文件的。\n\n### 8.4 IDEA中的第一个代码\n\n##### 8.4.1 操作步骤\n\n- 创建Project 项目\n- 创建Module 模块\n- 创建class   类\n- 在类中编写代码\n- 完成编译运行\n\n##### 8.4.2 分步图解\n\n- 双击启动图标\n\n  ![计算机发展](img/idea%E4%BD%BF%E7%94%A81.png)\n\n- 首先要新建一个项目\n\n  点击creat new project\n\n  ![计算机发展](img/idea1.png)\n\n- 我们要从0开始写代码，所以新建一个空的什么都没有的项目。\n\n  点击左下方的Empty Project\n\n  再点击右下角的next\n\n![计算机发展](img/idea2.png)\n\n- 输入项目的名称\n\n  输入项目的存放路径\n\n![计算机发展](img/idea3.png)\n\n- 点击ok。idea会帮助我们在本地创建一个项目文件夹\n\n![计算机发展](img/idea4.png)\n\n- 点击Module，准备新建一个模块\n\n![计算机发展](img/idea5.png)\n\n- 点击+\n\n  再点击New Module\n\n![计算机发展](img/idea6.png)\n\n- 我们要编写Java代码，所以要新建一个Java模块。\n\n  点击Java\n\n  再点击右下角的next\n\n![计算机发展](img/idea7.png)\n\n- 输入模块的名称\n\n  再点击右下角的Next\n\n![计算机发展](img/idea8.png)\n\n- 成功新建一个模块之后，中间就会出现刚刚新建的模块\n\n  点击右下角的OK\n\n![计算机发展](img/idea9.png)\n\n- 回到主界面\n\n  展开刚刚新建的模块\n\n  右键点击src，选择New，选择Java Class\n\n![计算机发展](img/idea10.png)\n\n- 输入类名\n\n  再按回车\n\n![计算机发展](img/idea11.png)\n\n- 由于字体比较小\n\n  所以，我们要设置一下字体。\n\n  点击File，选择Setting。\n\n![计算机发展](img/idea12.png)\n\n- 搜索一下font\n\n  在右边可以输入Size的数值来调节代码字体的大小。\n\n  设置完毕后点击右下角的OK\n\n![计算机发展](img/idea13.png)\n\n- 编写代码\n\n![计算机发展](img/idea14.png)\n\n- 运行代码\n\n  右键空白处，点击Run\n\n![计算机发展](img/idea15.png)\n\n\n\n- 最下面会弹出控制台。\n\n  所有输出语句中的内容，都会在控制台上展示。\n\n![计算机发展](img/idea16.png)\n\n### 8.5 IDEA中类的相关操作\n\n#### 8.5.1 类的相关操作\n\n- 新建类文件\n- 删除类文件\n- 修改类文件\n\n#### 8.5.2 新建类文件\n\n- 所有的Java代码都会写在src文件夹当中。\n\n  所以，右键点击src，选择new，点击Java Class\n\n  ![计算机发展](img/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n- 输入类名，再按回车\n\n  ![计算机发展](img/%E6%96%B0%E5%BB%BA%E7%B1%BB2.png)\n\n- 新建完毕\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E7%B1%BB3.png)\n\n#### 8.5.3 修改类名\n\n- 右键点击想要修改的文件\n\n  点击Refactor\n\n  再点击Rename\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%90%8D1.png)\n\n- 输入想要修改的名字\n\n  输入完毕点击下面的Refactor\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%90%8D2.png)\n\n- 文件名和类名均已修改成功\n\n  ![计算机发展](img/%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%90%8D3.png)\n\n#### 8.5.4 删除类文件\n\n- 想要删除哪个文件，就右键点击该文件\n\n  选择Delete即可\n\n![计算机发展](img/%E5%88%A0%E9%99%A4%E7%B1%BB%E6%96%87%E4%BB%B61.png)\n\n- 在弹出的界面中点击OK，确定删除\n\n![计算机发展](img/%E5%88%A0%E9%99%A4%E7%B1%BB%E6%96%87%E4%BB%B62.png)\n\n> 小贴士：\n>\n> 此时删除是不走回收站的，直接从硬盘中删掉了。\n\n### 8.6 IDEA中模块的相关操作\n\n#### 8.6.1 模块的相关操作\n\n- 新建模块\n- 删除模块\n- 修改模块\n- 导入模块\n\n#### 8.6.2 新建模块\n\n- 点击File，选择Project Structure\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%971.png)\n\n- 选择Module\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%972.png)\n\n- 点击+\n\n  选择New Module\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%973.png)\n\n- 要创建一个Java模块，所以选择第一个Java\n\n  点击右下角的Next\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%974.png)\n\n- 输入模块的名称\n\n  点击右下角的Finish\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%975.png)\n\n- 成功新建完毕之后，在中间空白区域就出现了刚刚新建的模块\n\n  点击右下角的OK\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%976.png)\n\n- 在主界面中，也会出现刚刚新建的模块\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E6%A8%A1%E5%9D%977.png)\n\n#### 8.6.3 删除模块\n\n- 右键点击模块\n\n  选择Remove Module\n\n![计算机发展](img/%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%971.png)\n\n- 选择Remove，表示确定删除\n\n![计算机发展](img/%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%972.png)\n\n- 此时发现，在IDEA列表页面，删除的模块已经不在了。\n\n![计算机发展](img/%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%973.png)\n\n> 小贴士：\n>\n> 此时删除仅仅是从IDEA列表中的删除，在本地硬盘中还是存在的。\n\n#### 8.6.4 修改模块\n\n- 右键点击模块名\n\n  选择Refactor\n\n  再选择Rename\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9D%97%E5%90%8D1.png)\n\n- 选择第三个修改模块名和本地文件夹名\n\n  点击OK\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9D%97%E5%90%8D3.png)\n\n- 输入要修改的新的模块名\n\n  输入完毕点击Refactor\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9D%97%E5%90%8D4.png)\n\n- 回到主界面，就发现模块名和文件夹名都已经修改完毕\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9D%97%E5%90%8D5.png)\n\n\n\n#### 8.6.5 导入模块\n\n- 点击File，选择Project Structure\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%971.png)\n\n- 选择Module\n\n  点击+\n\n  选择Import Module\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%972.png)\n\n- 从本地硬盘中选择要导入的模块\n\n  再点击OK\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%973.png)\n\n- 不断点击Next\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%974.png)\n\n- 如果中间出现提示框，则点击Overwrite\n\n  然后继续点击右下角的Next\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%975.png)\n\n- 一直点到finish为止\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%976.png)\n\n- 成功导入后，在中间位置就会出现导入的模块信息\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%977.png)\n\n- 在主界面中也会出现导入的模块信息\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%978.png)\n\n\n\n- 展开模块点击模块中的Java文件，会发现代码报错。\n\n  是因为导入模块跟JDK没有关联导致。\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%979.png)\n\n\n\n- 可以点击右上角的Setup SDK\n\n  再选择已经安装的JDK版本即可\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%9710.png)\n\n- 导入完毕之后，代码就恢复正常不会报错了\n\n![计算机发展](img/%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%9711.png)\n\n### 8.7 IDEA中项目的相关操作\n\n#### 8.7.1 项目的相关操作\n\n- 关闭项目\n- 打开项目\n- 修改项目\n- 新建项目\n\n#### 8.7.2 关闭项目\n\n- 点击File，选择Close Project即可\n\n![计算机发展](img/%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE1.png)\n\n- 刚刚操作的项目就已经关闭了\n\n  左侧是项目列表，如果要再次打开该项目，直接点击即可。\n\n  右侧有create new project，可以再建一个新的项目\n\n![计算机发展](img/%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE2.png)\n\n- 鼠标放在项目上，后面会出现一个叉。\n\n  如果点击了这里的叉，会在IDEA的列表中删除。不会删除本地硬盘上的项目。\n\n![计算机发展](img/%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE3.png)\n\n#### 8.7.3 打开项目\n\n- 在本界面还可以打开本地已经存在的项目\n\n  点击Open or Import\n\n![计算机发展](img/%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE1.png)\n\n- 选择要打开的项目\n\n  点击OK\n\n![计算机发展](img/%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE2.png)\n\n- 项目就被打开了。\n\n![计算机发展](img/%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE3.png)\n\n#### 8.7.4 修改项目\n\n- 点击File，选择Project Structure\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE1.png)\n\n- 在这个界面，默认是Module\n\n  所以，要先点击Project\n\n  在右侧页面中，输入新的项目名称\n\n  修改JDK版本和编译版本都变成JDK14\n\n  再点击OK\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE2.png)\n\n- 此时发现，项目名称已经修改完毕\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE3.png)\n\n- 但是本地文件夹的名字还没有修改\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE4.png)\n\n- 需要先关闭当前项目\n\n![计算机发展](img/%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE1.png)\n\n- 点击项目后面的叉，从列表中移除项目\n\n![计算机发展](img/%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE3.png)\n\n- 到本地硬盘中手动修改文件夹的名称\n\n ![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE5.png)\n\n- 点击Open or Import重新打开项目\n\n![计算机发展](img/%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE1.png)\n\n- 选择修改之后的项目\n\n  点击OK\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE6.png)\n\n- 此时会发现，项目名称和本地硬盘文件夹的名称都已经修改完毕了\n\n![计算机发展](img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE7.png)\n\n#### 8.7.5 新建项目\n\n- 点击File\n\n  选择New\n\n  点击Project\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE1.png)\n\n- 同样还是创建一个什么都没有的空项目\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE2.png)\n\n- 输入项目的名称\n\n  点击右下角的finish\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE3.png)\n\n- IDEA循环是否需要帮我们在本地创建一个新的文件夹\n\n  点击OK\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE4.png)\n\n- 询问是在本窗口打开还是在一个新的窗口打开。\n\n  可以点击New Window，在一个新的窗口打开。\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE5.png)\n\n- 此时就出现了两个窗口，在一个新的窗口打开了新的项目\n\n![计算机发展](img/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE6.png)\n\n\n\n\n\n\n\n'},{title:"运算符和表达式",headers:[{level:2,title:"1.运算符和表达式概括",slug:"_1-运算符和表达式概括",link:"#_1-运算符和表达式概括",children:[{level:3,title:"运算符：",slug:"运算符",link:"#运算符",children:[]},{level:3,title:"表达式：",slug:"表达式",link:"#表达式",children:[]}]},{level:2,title:"2.算术运算符",slug:"_2-算术运算符",link:"#_2-算术运算符",children:[{level:3,title:"练习：数值拆分",slug:"练习-数值拆分",link:"#练习-数值拆分",children:[]}]},{level:2,title:"3.隐式转换",slug:"_3-隐式转换",link:"#_3-隐式转换",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]},{level:3,title:"简单记忆：",slug:"简单记忆",link:"#简单记忆",children:[]},{level:3,title:"两种提升规则：",slug:"两种提升规则",link:"#两种提升规则",children:[]},{level:3,title:"取值范围从小到大的关系：",slug:"取值范围从小到大的关系",link:"#取值范围从小到大的关系",children:[]}]},{level:2,title:"4.隐式转换的练习",slug:"_4-隐式转换的练习",link:"#_4-隐式转换的练习",children:[{level:3,title:"案例一：",slug:"案例一",link:"#案例一",children:[]},{level:3,title:"案例二：",slug:"案例二",link:"#案例二",children:[]},{level:3,title:"案例三：",slug:"案例三",link:"#案例三",children:[]},{level:3,title:"案例四：",slug:"案例四",link:"#案例四",children:[]},{level:3,title:"案例五：",slug:"案例五",link:"#案例五",children:[]},{level:3,title:"案例六：",slug:"案例六",link:"#案例六",children:[]}]},{level:2,title:"5.强制转换",slug:"_5-强制转换",link:"#_5-强制转换",children:[{level:3,title:"概念：",slug:"概念-1",link:"#概念-1",children:[]},{level:3,title:"书写格式：",slug:"书写格式",link:"#书写格式",children:[]}]},{level:2,title:"6.字符串的+操作",slug:"_6-字符串的-操作",link:"#_6-字符串的-操作",children:[{level:3,title:"核心技巧：",slug:"核心技巧",link:"#核心技巧",children:[]}]},{level:2,title:"7.字符串相加的练习：",slug:"_7-字符串相加的练习",link:"#_7-字符串相加的练习",children:[]},{level:2,title:"8.字符的+操作",slug:"_8-字符的-操作",link:"#_8-字符的-操作",children:[{level:3,title:"规则：",slug:"规则",link:"#规则",children:[]},{level:3,title:"案例：",slug:"案例",link:"#案例",children:[]}]},{level:2,title:"9.算术运算符的总结",slug:"_9-算术运算符的总结",link:"#_9-算术运算符的总结",children:[]},{level:2,title:"10.自增自减运算符",slug:"_10-自增自减运算符",link:"#_10-自增自减运算符",children:[{level:3,title:"分类：",slug:"分类",link:"#分类",children:[]},{level:3,title:"使用方式：",slug:"使用方式",link:"#使用方式",children:[]},{level:3,title:"注意点：",slug:"注意点",link:"#注意点",children:[]},{level:3,title:"案例：",slug:"案例-1",link:"#案例-1",children:[]},{level:3,title:"自增自减运算符的应用场景：",slug:"自增自减运算符的应用场景",link:"#自增自减运算符的应用场景",children:[]}]},{level:2,title:"11.赋值运算符",slug:"_11-赋值运算符",link:"#_11-赋值运算符",children:[]},{level:2,title:"12.扩展赋值运算符",slug:"_12-扩展赋值运算符",link:"#_12-扩展赋值运算符",children:[{level:3,title:"分类：",slug:"分类-1",link:"#分类-1",children:[]},{level:3,title:"运算规则：",slug:"运算规则",link:"#运算规则",children:[]},{level:3,title:"案例：",slug:"案例-2",link:"#案例-2",children:[]},{level:3,title:"注意点：",slug:"注意点-1",link:"#注意点-1",children:[]}]},{level:2,title:"13.关系运算符",slug:"_13-关系运算符",link:"#_13-关系运算符",children:[{level:3,title:"分类：",slug:"分类-2",link:"#分类-2",children:[]},{level:3,title:"注意点：",slug:"注意点-2",link:"#注意点-2",children:[]}]},{level:2,title:"14.逻辑运算符",slug:"_14-逻辑运算符",link:"#_14-逻辑运算符",children:[{level:3,title:"& 和 | 的使用：",slug:"和-的使用",link:"#和-的使用",children:[]},{level:3,title:"使用场景：",slug:"使用场景",link:"#使用场景",children:[]},{level:3,title:"^（异或）的使用：",slug:"异或-的使用",link:"#异或-的使用",children:[]},{level:3,title:"!（取反）的使用：",slug:"取反-的使用",link:"#取反-的使用",children:[]}]},{level:2,title:"15.短路逻辑运算符",slug:"_15-短路逻辑运算符",link:"#_15-短路逻辑运算符",children:[{level:3,title:"&&：",slug:"",link:"#",children:[]},{level:3,title:"||：",slug:"-1",link:"#-1",children:[]},{level:3,title:"逻辑核心：",slug:"逻辑核心",link:"#逻辑核心",children:[]},{level:3,title:"举例：",slug:"举例",link:"#举例",children:[]},{level:3,title:"总结：",slug:"总结",link:"#总结",children:[]},{level:3,title:"建议：",slug:"建议",link:"#建议",children:[]}]},{level:2,title:"16.三元运算符",slug:"_16-三元运算符",link:"#_16-三元运算符",children:[{level:3,title:"格式：",slug:"格式",link:"#格式",children:[]},{level:3,title:"计算规则：",slug:"计算规则",link:"#计算规则",children:[]},{level:3,title:"注意点：",slug:"注意点-3",link:"#注意点-3",children:[]},{level:3,title:"案例：",slug:"案例-3",link:"#案例-3",children:[]}]},{level:2,title:"17.练习1-两只老虎",slug:"_17-练习1-两只老虎",link:"#_17-练习1-两只老虎",children:[]},{level:2,title:"18.练习2-求三个数的最大值",slug:"_18-练习2-求三个数的最大值",link:"#_18-练习2-求三个数的最大值",children:[]},{level:2,title:"19.运算符的优先级",slug:"_19-运算符的优先级",link:"#_19-运算符的优先级",children:[]}],path:"/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:'---\ntitle: 运算符和表达式\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n运算符和表达式记录\n\n\x3c!-- more --\x3e\n## 1.运算符和表达式概括\n\n### 运算符：\n\n​\t就是对常量或者变量进行操作的符号。\n\n​\t比如： +  -  *  / \n\n### 表达式：\n\n​\t用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。\n\n​\t比如：a + b 这个整体就是表达式。\n\n​\t而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。\n\n## 2.算术运算符\n\n分类：\n\n```java\n+ - * / %\n```\n\n运算特点：\n\n```java\n+ - * :跟小学数学中一模一样没有任何区别.\n```\n\n```java\n/：\n1.整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。\n2.小数直接参与运算，得到的结果有可能是不精确的。\n案例：\nSystem.out.println( 10 / 3);//3\nSystem.out.println(10.0 / 3);//3.3333333333333335\n```\n\n```java\n%：取模、取余。\n   他做的也是除法运算，只不过获取的是余数而已。\n案例：\nSystem.out.println(10 % 2);//0\nSystem.out.println(10 % 3);//1\n应用场景：\n//可以利用取模来判断一个数是奇数还是偶数\nSystem.out.println(15 % 2);//1  奇数\n```\n\n### 练习：数值拆分\n\n需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台\n\n代码示例：\n\n```java\n//1.键盘录入一个三位数\n//导包 --- 创建对象 --- 接收数据\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个三位数");\nint number = sc.nextInt();//123\n\n//2.获取这个三位数的个位、十位、百位并打印出来\n//公式：\n//针对于任意的一个数而言\n//个位： 数字 % 10\nint ones = number % 10;\n//十位： 数字 / 10 % 10\nint tens = number / 10 % 10;\n//百位： 数字 / 100 % 10\nint hundreds = number / 100  % 10;\n\n//输出结果\nSystem.out.println(ones);\nSystem.out.println(tens);\nSystem.out.println(hundreds);\n```\n\n公式：\n\n​\t获取任意一个数上每一位数。\n\n个位：数字 % 10\n\n十位：数字 / 10 % 10\n\n百位：数字 / 100 % 10\n\n千位：数字 / 1000 % 10\n\n。。。以此类推。。。\n\n## 3.隐式转换\n\n### 概念：\n\n​\t也叫自动类型提升。\n\n​\t就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。\n\n### 简单记忆：\n\n​\t就是小的给大的，可以直接给。\n\n### 两种提升规则：\n\n* 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。\n* byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。\n\n### 取值范围从小到大的关系：\n\n​\tbyte short int long float double\n\n## 4.隐式转换的练习\n\n请看下面案例是否有误，如果有问题，请说出原因，如果没有问题，请说出运算过程和运算结果\n\n### 案例一：\n\n```java\ndouble d = 10;\nSystem.out.println(d);//10.0\n```\n\n解释：\n\n​\t10是整数，整数默认是int类型的。\n\n​\t而在取值范围的顺序中：byte short int long float double\n\n​\t在赋值的时候把一个int类型的赋值给了一个double类型的。把一个小的赋值给一个大的是可以直接给的。\n\n\n\n### 案例二：\n\n```java\nbyte b = 100;\nint i = b;//可以成功赋值\n```\n\n解释：\n\n​\t因为byte的取值范围是小的，int的取值范围是大的，在底层进行了隐式转换，不需要我们额外写代码单独实现，是可以直接赋值。\n\n\n\n### 案例三：\n\n```java\nint i = 10;\nlong n = 20L;\n??? result = i + n;\n问变量result是什么类型的？\n```\n\n解释：\n\n​\t变量i是int类型的，变量n是long类型的。\n\n​\t而在取值范围的顺序中：byte short int long float double\n\n​\t变量i里面的值会自动提升为long类型的，最终的结果其实就是两个long相加，那么最终的result是long类型的。\n\n### 案例四：\n\n```java\nint i = 10;\nlong n = 100L;\ndouble d = 20.0;\n??? result = i + n + d;\n问变量result是什么类型的？\n```\n\n解释：\n\n​\t变量i是int类型，变量n是long类型，变量d是double类型。\n\n​\t而在取值范围的顺序中：byte short int long float double\n\n​\t所以变量i和变量n里面的值在参与运算的时候，都会进行类型提升，变成double。\n\n​\t最终其实就是三个double进行相加，那么最终的结果就是double类型的。\n\n\n\n\n\n### 案例五：\n\n```java\nbyte b1 = 10;\nbyte b2 = 20;\n??? result = b1 + b2;//int\n问变量result是什么类型的？\n```\n\n解释：\n\n​\t因为b1和b2都是byte类型的。所以在参与计算的时候，变量b1和变量b2里面的值都会自动提升为int类型的。最终其实就是两个int类型的相加，最终结果也是int类型的。\n\n\n\n### 案例六：\n\n```java\nbyte b = 10;\nshort s = 20;\nlong n = 100L;\n??? result = b + s + n;\n问变量result是什么类型的？long\n```\n\n解释：\n\n​\t变量b是byte类型的，变量s是short类型的，变量n是long类型的。\n\n​\tbyte，short，char类型的变量在参与运算的时候，变量里面的值会直接先提升为int。\n\n第一步：变量b和变量s里面的值会先提升为int参与运算。\n\n​\t\tint + int + long\n\n第二步：而long类型的取值范围是大于int的取值范围的。\n\n​\t\t所以变量b和变量s里面的值会再次提升为long。\n\n​\t\tlong + long + long。\n\n所以最终结果是long类型的。\n\n## 5.强制转换\n\n### 概念：\n\n​\t如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。\n\n​\t如果一定要这么干，就需要加入强制转换。\n\n### 书写格式：\n\n​\t目标数据类型 变量名 = （目标数据类型）被强转的数据；\n\n简单理解：\n\n​\t要转成什么类型的，那么就在小括号中写什么类型就可以了。\n\n案例：\n\n```java\npublic class OperatorDemo2 {\n    public static void main(String[] args) {\n        double a = 12.3;\n        int b = (int) a;\n        System.out.println(b);//12\n    }\n}\n```\n\n注意点：\n\n​\t强制转换有可能会导致数据发生错误。（数据的精度丢失）\n\n## 6.字符串的+操作\n\n### 核心技巧：\n\n* 当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。\n* 当连续进行+操作时，从左到右逐个执行的。\n\n## 7.字符串相加的练习：\n\n案例1：\n\n```java\n1 + "abc" + 1\n```\n\n结果："1abc1"\n\n解释：\n\n​\t第一步： 1 + "abc"。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"1abc"\n\n​\t第二步：  "1abc" + 1。这个过程中，有字符串参与的，所以做的也是拼接操作，产生一个新的字符串"1abc1"\n\n\n\n案例2：\n\n```java\n1 + 2 + "abc" + 2 + 1\n```\n\n结果：“3abc21”\n\n解释：\n\n​\t第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。\n\n​\t第二步：3 + "abc"。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"3abc"。\n\n​\t第三步："3abc" + 2。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"3abc2"。\n\n​\t第四步："3abc2" + 1。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串“3abc21”\n\n\n\n案例3：\n\n```java\nString name = "黑默丁格";\nSystem.out.println("我的名字是" + name);\n```\n\n结果： 我的名字是黑默丁格\n\n解释：当字符串跟变量相加的时候，实际上是跟变量里面的值进行拼接。\n\n## 8.字符的+操作\n\n### 规则：\n\n​\t当+操作中出现了字符，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。\n\n### 案例：\n\n```java\nchar c = \'a\';\nint result = c + 0;\nSystem.out.println(result);//97\n```\n\nASCII码表中：\n\n​\t\'a\'   -----    97\n\n​\t\'A\'   -----    65\n\n## 9.算术运算符的总结\n\n分类：\n\n```java\n+ - * / %  这些操作跟小学数学几乎是一模一样的。\n```\n\n注意点：\n\n* / 和 % 的区别：他们两个都是做除法运算，/取结果的商。% 取结果的余数。\n* 整数操作只能得到整数，如果想要得到小数，必须有浮点数参与运算。\n\n算术运算符的高级用法：\n\n是以+为例进行的讲解，其余减法，乘法，除法的运算规则也是一样的。\n\n特例：字符串只有+操作，没有其他操作。\n\n## 10.自增自减运算符\n\n### 分类：\n\n```java\n++  自增运算符\n--  自减运算符\n```\n\n++：就是把变量里面的值+1\n\n--：就是把变量里面的值-1\n\n### 使用方式：\n\n* 放在变量的前面，我们叫做先++。 比如：++a\n* 放在变量的后面，我们叫做后++。 比如：a++\n\n### 注意点：\n\n​\t不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。\n\n### 案例：\n\n```java\n//++\nint a = 10;\na++;//就是让变量a里面的值 + 1\nSystem.out.println(a);//11\n++a;//就是让变量a里面的值 + 1\nSystem.out.println(a);//12\n```\n\n### 自增自减运算符的应用场景：\n\n某些情况下，变量需要进行加1或者减1的时候使用。\n\n比如：过生日多一岁，就用到了自增运算符。\n\n比如：购物商场中，选择商品数量，也用到了自增或者自减运算符。\n\n比如：统计很多数据中，有多少个数据满足要求，也用到了自增运算符。\n\n## 11.赋值运算符\n\n最为常用的：\t=\n\n运算过程：就是把等号右边的结果赋值给左边的变量\n\n案例：\n\n```java\npublic class OperatorDemo6 {\n    public static void main(String[] args) {\n        //1.最为简单的赋值运算符用法\n        int a = 10;//就是把10赋值给变量a\n        System.out.println(a);\n\n        //2.如果等号右边需要进行计算。\n        int b = 20;\n        int c = a + b;//先计算等号右边的，把计算的结果赋值给左边的变量\n        System.out.println(c);\n\n        //3.特殊的用法\n        a = a + 10;//先计算等号右边的，把计算的结果赋值给左边的变量\n        System.out.println(a);//20\n    }\n}\n```\n\n## 12.扩展赋值运算符\n\n### 分类：\n\n​\t+=、-=、*=、/=、%=\n\n### 运算规则：\n\n​\t就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。\n\n### 案例：\n\n```java\npublic class OperatorDemo7 {\n    public static void main(String[] args) {\n        //扩展赋值运算符\n        int a = 10;\n        int b = 20;\n        a += b;//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响\n        // 相当于 a = a + b;\n        System.out.println(a);//30\n        System.out.println(b);//20\n    }\n}\n```\n\n### 注意点：\n\n​\t扩展的赋值运算符中隐层还包含了一个强制转换。\n\n以+=为例。\n\na += b ;实际上相当于 a = (byte)(a + b);\n\n```java\npublic class OperatorDemo8 {\n    public static void main(String[] args) {\n        byte a = 10;\n        byte b = 20;\n        //a += b;\n        a = (byte)(a + b);\n        System.out.println(a);//30\n    }\n}\n```\n\n## 13.关系运算符\n\n又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。\n\n### 分类：\n\n| 符号 | 解释                                                         |\n| ---- | ------------------------------------------------------------ |\n| ==   | 就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false |\n| !=   | 就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false |\n| >    | 就是判断左边是否大于右边，如果成立就是true，如果不成立就是false |\n| >=   | 就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false |\n| <    | 就是判断左边是否小于右边，如果成立就是true，如果不成立就是false |\n| <=   | 就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false |\n\n### 注意点：\n\n* 关系运算符最终的结果一定是布尔类型的。要么是true，要么是false\n* 在写==的时候，千万不要写成=\n\n## 14.逻辑运算符\n\n### & 和 | 的使用：\n\n&：逻辑与（而且）\n\n​\t两边都为真，结果才是真，只要有一个为假，那么结果就是假。\n\n|：逻辑或（或者）\n\n​\t两边都为假，结果才是假，只要有一个为真，那么结果就是真。\n\n代码示例：\n\n```java\n// &  //两边都是真，结果才是真。\nSystem.out.println(true & true);//true\nSystem.out.println(false & false);//false\nSystem.out.println(true & false);//false\nSystem.out.println(false & true);//false\n\nSystem.out.println("===================================");\n\n// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。\nSystem.out.println(true | true);//true\nSystem.out.println(false | false);//false\nSystem.out.println(true | false);//true\nSystem.out.println(false | true);//true\n```\n\n### 使用场景：\n\n​\t根据固定的场景，来选择使用&还是使用|\n\n* 用户登录。\n\n  用户名输入正确  & 密码输入正确\n\n  因为只有用户名和密码同时都正确了，那么才能成功登录，只要有一个失败了都不行。\n\n  使用技巧：\n\n  ​\t当我们需要同时满足左边和右边两种情况时，可以使用且\n\n* 丈母娘选女婿\n\n  丈母娘：女婿啊，你要么买个房子，要么买辆车。就可以把我的小棉袄穿走了。\n\n  买个房子 | 买辆车\n\n  两个条件中，只要满足其中一个，就可以穿走小棉袄了。\n\n  使用技巧：\n\n  ​\t当两种条件只要满足其中一个的时候，可以使用或\n\n### ^（异或）的使用：\n\n​\t在以后用的不多，了解一下即可。\n\n计算规则：如果两边相同，结果为false，如果两边不同，结果为true\n\n代码示例：\n\n```java\n//^   //左右不相同，结果才是true，左右相同结果就是false\nSystem.out.println(true ^ true);//false\nSystem.out.println(false ^ false);//false\nSystem.out.println(true ^ false);//true\nSystem.out.println(false ^ true);//true\n```\n\n### !（取反）的使用：\n\n​\t是取反，也叫做非。\n\n计算规则：false取反就是true，true取反就是false\n\n温馨提示：**取反最多只用一个。**\n\n代码示例：\n\n```java\nSystem.out.println(!false);//true\nSystem.out.println(!true);//false\n\nSystem.out.println(!!false);//注意点：取反最多只用一个。\n```\n\n## 15.短路逻辑运算符\n\n分类：  &&   ||\n\n### &&：\n\n​\t运算结果跟&是一模一样的，只不过具有短路效果。\n\n### ||：\n\n​\t运算结果跟|是一模一样的。只不过具有短路效果。\n\n### 逻辑核心：\n\n​\t当左边不能确定整个表达式的结果，右边才会执行。\n\n​\t当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。\n\n### 举例：\n\n* 用户登录案例\n\n  用户名正确  & 密码正确\n\n  如果使用一个&，不管用户名是否正确都会去验证密码。\n\n思考：\n\n​\t如果用户名输入正确了，那么我们再判断密码是否正确，是符合业务逻辑的。\n\n​\t但是如果用户名输入错误了，那么现在还有必要去比较密码吗？没有不要了。\n\n​\t如果使用一个&，那么左边和右边不管什么情况下，都会执行。\n\n\n\n​\t用户名正确  &&  密码正确\n\n​\t如果用户名输入正确了，那么才会验证密码是否输入正确。\n\n​\t如果用户名输入错误了，那么就不会再去验证密码是否正确，最终的结果直接为false。从而提高了程序运行的效率。\n\n* 丈母娘选女婿\n\n  有房 |  有车\n\n  首先先看看有没有房，发现有，然后再去看看有没有车。\n\n思考：\n\n​\t既然都有房子，干嘛还要去看车呢？多此一举。\n\n​\t有房 ||  有车\n\n​\t首先先看看有没有房，如果有，那么右边就不执行了。最终的结果直接为true。\n\n​\t如果没有房子，才会去看右边有没有车。\n\n### 总结：\n\n​\t&& 和 & 、||和|的运行结果都是一模一样的。\n\n​\t但是短路逻辑运算符可以提高程序的运行效率。\n\n### 建议：\n\n​\t最为常用： &&   ||   ！\n\n## 16.三元运算符\n\n又叫做：三元表达式或者问号冒号表达式。\n\n### 格式：\n\n​\t关系表达式 ？ 表达式1 ：表达式2 ；\n\n### 计算规则：\n\n* 计算关系表达式的值。\n* 如果关系表达式的值为真，那么执行表达式1。\n* 如果关系表达式的值为假，那么执行表达式2。\n\n### 注意点：\n\n​\t三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。\n\n### 案例：\n\n```java\npublic class OperatorDemo12 {\n    public static void main(String[] args) {\n        //需求：求两个数的较大值\n        int a = 10;\n        int b = 20;\n\n        //格式：关系表达式 ？ 表达式1 ： 表达式2 ；\n        //注意点：\n        //三元运算符的最终结果一定要被使用。\n        //要么赋值给一个变量，要么直接输出。\n       int max =  a > b ? a : b ;\n        System.out.println(max);\n\n\n        System.out.println(a > b ? a : b);\n    }\n}\n```\n\n## 17.练习1-两只老虎\n\n需求：\n\n​\t动物园里有两只老虎，两只老虎的体重分别为通过键盘录入获得，\n\n​\t请用程序实现判断两只老虎的体重是否相同。\n\n代码示例：\n\n```java\n//1.获取两只老虎的体重\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入第一只老虎的体重");\nint weight1 = sc.nextInt();\nSystem.out.println("请输入第二只老虎的体重");\nint weight2 = sc.nextInt();\n\n//2.利用三元运算符求出最终结果\nString result = weight1 == weight2 ? "相同" : "不相同";\nSystem.out.println(result);\n```\n\n## 18.练习2-求三个数的最大值\n\n需求：\n\n​\t一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm。\n\n​\t请用程序实现获取这三个和尚的最高身高。\n\n代码示例：\n\n```java\n//1.定义三个变量记录和尚的身高\nint height1 = 150;\nint height2 = 210;\nint height3 = 165;\n\n//2.利用三元运算符求出两个数中的较大值。\nint temp = height1 > height2 ? height1 : height2;\n\n//3.求出最终的结果\nint max = temp > height3 ? temp : height3;\n\nSystem.out.println(max);\n```\n\n## 19.运算符的优先级\n\n在Java中涉及了很多的运算符，每一种运算符都有各自的优先级。但是这些优先级不需要记忆。\n\n咱们只要知道其中一点：\n\n​\t小括号优先于所有。\n\n\n\n\n\n\n\n\n\n'},{title:"流程控制语句",headers:[{level:2,title:"第一章 流程控制语句",slug:"第一章-流程控制语句",link:"#第一章-流程控制语句",children:[{level:3,title:"1.1 流程控制语句分类",slug:"_1-1-流程控制语句分类",link:"#_1-1-流程控制语句分类",children:[]},{level:3,title:"1.2 顺序结构",slug:"_1-2-顺序结构",link:"#_1-2-顺序结构",children:[]}]},{level:2,title:"第二章 判断语句：if语句",slug:"第二章-判断语句-if语句",link:"#第二章-判断语句-if语句",children:[{level:3,title:"2.1 if语句格式1",slug:"_2-1-if语句格式1",link:"#_2-1-if语句格式1",children:[]},{level:3,title:"2.2 if语句格式2",slug:"_2-2-if语句格式2",link:"#_2-2-if语句格式2",children:[]},{level:3,title:"2.3 if语句格式3",slug:"_2-3-if语句格式3",link:"#_2-3-if语句格式3",children:[]}]},{level:2,title:"第三章 switch语句",slug:"第三章-switch语句",link:"#第三章-switch语句",children:[{level:3,title:"3.1 格式",slug:"_3-1-格式",link:"#_3-1-格式",children:[]},{level:3,title:"3.2 执行流程：",slug:"_3-2-执行流程",link:"#_3-2-执行流程",children:[]},{level:3,title:"3.3 switch的扩展知识：",slug:"_3-3-switch的扩展知识",link:"#_3-3-switch的扩展知识",children:[]}]},{level:2,title:"第四章 循环结构",slug:"第四章-循环结构",link:"#第四章-循环结构",children:[{level:3,title:"4.1 for循环结构（掌握）",slug:"_4-1-for循环结构-掌握",link:"#_4-1-for循环结构-掌握",children:[]},{level:3,title:"4.2 while循环",slug:"_4-2-while循环",link:"#_4-2-while循环",children:[]},{level:3,title:"4.3 do...while循环",slug:"_4-3-do-while循环",link:"#_4-3-do-while循环",children:[]},{level:3,title:"4.4 三种格式的区别：",slug:"_4-4-三种格式的区别",link:"#_4-4-三种格式的区别",children:[]}]}],path:"/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",pathLocale:"/",extraFields:'---\ntitle: 流程控制语句\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n流程控制语句\n\n\x3c!-- more --\x3e\n\n## 第一章 流程控制语句\n\n在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。\n\n### 1.1 流程控制语句分类\n\n​\t顺序结构\n\n​\t判断和选择结构(if, switch)\n\n​\t循环结构(for, while, do…while)\n\n### 1.2 顺序结构\n\n顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\n\n顺序结构执行流程图：\n\n![1545615769372](img\\1545615769372.png)\n\n## 第二章 判断语句：if语句\n\n### 2.1 if语句格式1\n\n```java\n格式：\nif (关系表达式) {\n    语句体;\t\n}\n```\n\n执行流程：\n\n①首先计算关系表达式的值\n\n②如果关系表达式的值为true就执行语句体\n\n③如果关系表达式的值为false就不执行语句体\n\n④继续执行后面的语句内容\n\n![1545616039363](img\\1545616039363.png)\n\n示例：\n\n```java\npublic class IfDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("开始");\t\n\t\t//定义两个变量\n\t\tint a = 10;\n\t\tint b = 20;\t\n\t\t//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b\n\t\tif(a == b) {\n\t\t\tSystem.out.println("a等于b");\n\t\t}\t\t\n\t\t//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c\n\t\tint c = 10;\n\t\tif(a == c) {\n\t\t\tSystem.out.println("a等于c");\n\t\t}\t\t\n\t\tSystem.out.println("结束");\n\t}\n}\n```\n\n#### 练习1：老丈人选女婿\n\n需求：\n\n​\t键盘录入女婿的酒量，如果大于2斤，老丈人给出回应，否则没有任何回应\n\n代码示例：\n\n```java\n//分析：\n//1.键盘录入女婿的酒量\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入女婿的酒量");\nint wine = sc.nextInt();//5\n//2.对酒量进行一个判断即可\nif(wine > 2) {\n    System.out.println("不错哟，小伙子！");\n}\n```\n\n#### 练习2：考试奖励\n\n需求：\n\n​\t键盘录入一个整数，表示小明的考试名次，如果名次为1，小红可以当小明的女朋有了。\n\n代码示例：\n\n```java\n//分析：\n//1.键盘录入一个整数，表示小明的考试名次\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入小明的名次");\nint rank = sc.nextInt();\n//2.对小明的考试成绩进行判断即可\nif(rank == 1){\n    System.out.println("小红成为了小明的女朋友");\n}\n```\n\n#### 第一种格式的细节：\n\n1. 如果我们要对一个布尔类型的变量进行判断，不要写==，直接把变量写在小括号中即可。\n\n2. 如果大括号中的语句体只有一条，那么大括号可以省略不写\n\n   如果大括号省略了，那么if只能控制距离他最近的那一条语句。\n\n   **建议：**自己不要去写，如果别人这么写了，你要能看懂即可。\n\n### 2.2 if语句格式2\n\n```java\n格式：\nif (关系表达式) {\n    语句体1;\t\n} else {\n    语句体2;\t\n}\n```\n\n执行流程：\n\n①首先计算关系表达式的值\n\n②如果关系表达式的值为true就执行语句体1\n\n③如果关系表达式的值为false就执行语句体2\n\n④继续执行后面的语句内容\n\n![1545616221283](img\\1545616221283.png)\n\n示例：\n\n```java\npublic class IfDemo02 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("开始");\t\t\n\t\t//定义两个变量\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b\n\t\tif(a > b) {\n\t\t\tSystem.out.println("a的值大于b");\n\t\t} else {\n\t\t\tSystem.out.println("a的值不大于b");\n\t\t}\t\t\n\t\tSystem.out.println("结束");\n\t}\n}\n```\n\n#### 练习1：吃饭\n\n需求：\n\n​\t    键盘录入一个整数，表示身上的钱。\n\n​            如果大于等于100块，就是网红餐厅。\n\n​            否则，就吃经济实惠的沙县小吃。\n\n代码示例：\n\n```java\n//分析：\n//1.键盘录入一个整数。表示身上的钱。\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个整数表示身上的钱");\nint money = sc.nextInt();\n//2.对钱进行判断\nif(money >= 100){\n    System.out.println("吃网红餐厅");\n}else{\n    System.out.println("福建大酒店");\n}\n```\n\n#### 练习2：影院选座\n\n需求：\n\n​\t在实际开发中，电影院选座也会使用到if判断。\n\n​\t假设某影院售卖了100张票，票的序号为1~100。\n\n​\t其中奇数票号坐左侧，偶数票号坐右侧。\n\n​\t键盘录入一个整数表示电影票的票号。\n\n​\t根据不同情况，给出不同的提示：\n\n​\t\t如果票号为奇数，那么打印坐左边。\n\n​\t\t如果票号为偶数，那么打印坐右边。\n\n代码示例：\n\n```java\n//分析：\n//1.键盘录入票号\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入票号");\nint ticket = sc.nextInt();\nif(ticket >= 1 && ticket <= 100){\n    //合法\n    //2.对票号进行判断\n    if (ticket % 2 == 0) {\n        //偶数\n        System.out.println("坐右边");\n    } else {\n        //奇数\n        System.out.println("坐左边");\n    }\n}else{\n    //票号不合法\n    System.out.println("票号不合法");\n}\n```\n\n### 2.3 if语句格式3\n\n```java\n格式：\nif (关系表达式1) {\n    语句体1;\t\n} else if (关系表达式2) {\n    语句体2;\t\n} \n…\nelse {\n    语句体n+1;\n}\n```\n\n执行流程：\n\n①首先计算关系表达式1的值\n\n②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\n\n③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\n\n④…\n\n⑤如果没有任何关系表达式为true，就执行语句体n+1。\n\n![1545616667104](img\\1545616667104.png)\n\n#### 练习1：考试奖励\n\n需求：\n\n​\t小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，\n\n假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。\n\n分析：\n\n​\t①小明的考试成绩未知，可以使用键盘录入的方式获取值\n\n​\t②由于奖励种类较多，属于多种判断，采用if...else...if格式实现\n\n​\t③为每种判断设置对应的条件\n\n​\t④为每种判断设置对应的奖励\n\n代码示例：\n\n```java\n//95~100 自行车一辆\n//90~94   游乐场玩一天\n//80 ~ 89 变形金刚一个\n//80 以下  胖揍一顿\n\n//1.键盘录入一个值表示小明的分数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入小明的成绩");\nint score = sc.nextInt();\n//2.对分数的有效性进行判断\nif(score >= 0 && score <= 100){\n    //有效的分数\n    //3.对小明的分数进行判断，不同情况执行不同的代码\n    if(score >= 95 && score <= 100){\n        System.out.println("送自行车一辆");\n    }else if(score >= 90 && score <= 94){\n        System.out.println("游乐场玩一天");\n    }else if(score >= 80 && score <= 89){\n        System.out.println("变形金刚一个");\n    }else{\n        System.out.println("胖揍一顿");\n    }\n}else{\n    //无效的分数\n    System.out.println("分数不合法");\n}\n```\n\n## 第三章 switch语句\n\n### 3.1 格式\n\n```java\nswitch (表达式) {\n\tcase 1:\n\t\t语句体1;\n\t\tbreak;\n\tcase 2:\n\t\t语句体2;\n\t\tbreak;\n\t...\n\tdefault:\n\t\t语句体n+1;\n\t\tbreak;\n}\n```\n\n### 3.2 **执行流程：**\n\n- 首先计算出表达式的值 \n- 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 \n- 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 \n\n#### 练习：运动计划\n\n- 需求：键盘录入星期数，显示今天的减肥活动。\n\n  周一：跑步  \n\n  周二：游泳  \n\n  周三：慢走  \n\n  周四：动感单车\n\n  周五：拳击  \n\n  周六：爬山  \n\n  周日：好好吃一顿\n\n- 代码示例：\n\n```java\npackage a01switch选择语句;\n\nimport java.util.Scanner;\n\npublic class SwitchDemo2 {\n    public static void main(String[] args) {\n        //1.键盘录入一个整数表示星期\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个整数表示星期");\n        int week = sc.nextInt();\n\n        //2.书写一个switch语句去跟week进行匹配\n        switch (week){\n            case 1:\n                System.out.println("跑步");\n                break;\n            case 2:\n                System.out.println("游泳");\n                break;\n            case 3:\n                System.out.println("慢走");\n                break;\n            case 4:\n                System.out.println("动感单车");\n                break;\n            case 5:\n                System.out.println("拳击");\n                break;\n            case 6:\n                System.out.println("爬山");\n                break;\n            case 7:\n                System.out.println("好好吃一顿");\n                break;\n            default:\n                System.out.println("输入错误，没有这个星期");\n                break;\n        }\n    }\n}\n```\n\n### 3.3 switch的扩展知识：\n\n- default的位置和省略情况\n\n  default可以放在任意位置，也可以省略\n\n- case穿透\n\n  不写break会引发case穿透现象\n\n- switch在JDK12的新特性\n\n```java\nint number = 10;\nswitch (number) {\n    case 1 -> System.out.println("一");\n    case 2 -> System.out.println("二");\n    case 3 -> System.out.println("三");\n    default -> System.out.println("其他");\n}\n```\n\n- switch和if第三种格式各自的使用场景\n\n当我们需要对一个范围进行判断的时候，用if的第三种格式\n\n当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句\n\n比如：\n\n​\t小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。\n\n​\t如果是星期，月份，客服电话中0~9的功能选择就可以用switch\n\n#### 练习：休息日和工作日\n\n需求：键盘录入星期数，输出工作日、休息日。\n\n(1-5) 工作日，(6-7)休息日。\n\n代码示例：\n\n```java\n//分析：\n//1.键盘录入星期数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入星期");\nint week = sc.nextInt();//3\n//2.利用switch进行匹配\n----------------------------------------------------\n利用case穿透简化代码\nswitch (week){\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        System.out.println("工作日");\n        break;\n    case 6:\n    case 7:\n        System.out.println("休息日");\n        break;\n    default:\n        System.out.println("没有这个星期");\n        break;\n}\n----------------------------------------------------\n利用JDK12简化代码书写\nswitch (week) {\n    case 1, 2, 3, 4, 5 -> System.out.println("工作日");\n    case 6, 7 -> System.out.println("休息日");\n    default -> System.out.println("没有这个星期");\n}\n```\n\n## 第四章 循环结构\n\n### 4.1 for循环结构（掌握）\n\n​\t循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 \n\n#### 4.1.1 for循环格式：\n\n```java\nfor (初始化语句;条件判断语句;条件控制语句) {\n\t循环体语句;\n}\n```\n\n**格式解释：**\n\n- 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样\n- 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去\n- 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情\n- 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去\n\n**执行流程：**\n\n①执行初始化语句\n\n②执行条件判断语句，看其结果是true还是false\n\n​             如果是false，循环结束\n\n​             如果是true，继续执行\n\n③执行循环体语句\n\n④执行条件控制语句\n\n⑤回到②继续\n\n**for循环书写技巧：**\n\n- 确定循环的开始条件\n- 确定循环的结束条件\n- 确定循环要重复执行的代码\n\n代码示例：\n\n```java\n//1.确定循环的开始条件\n//2.确定循环的结束条件\n//3.确定要重复执行的代码\n\n//需求：打印5次HelloWorld\n//开始条件：1\n//结束条件：5\n//重复代码：打印语句\n\nfor (int i = 1; i <= 5; i++) {\n    System.out.println("HelloWorld");\n}\n```\n\n##### for循环练习-输出数据\n\n- 需求：在控制台输出1-5和5-1的数据 \n- 示例代码：\n\n```java\npublic class ForTest01 {\n    public static void main(String[] args) {\n\t\t//需求：输出数据1-5\n        for(int i=1; i<=5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t\tSystem.out.println("--------");\n\t\t//需求：输出数据5-1\n\t\tfor(int i=5; i>=1; i--) {\n\t\t\tSystem.out.println(i);\n\t\t}\n    }\n}\n```\n\n\n\n##### for循环练习-求和\n\n- 需求：求1-5之间的数据和，并把求和结果在控制台输出  \n- 示例代码：\n\n```java\npublic class ForTest02 {\n    public static void main(String[] args) {\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n\t\tint sum = 0;\n\t\t//从1开始到5结束的数据，使用循环结构完成\n\t\tfor(int i=1; i<=5; i++) {\n\t\t\t//将反复进行的事情写入循环结构内部\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\n\t\t\tsum = sum + i;\n\t\t\t/*\n\t\t\t\tsum += i;\tsum = sum + i;\n\t\t\t\t第一次：sum = sum + i = 0 + 1 = 1;\n\t\t\t\t第二次：sum = sum + i = 1 + 2 = 3;\n\t\t\t\t第三次：sum = sum + i = 3 + 3 = 6;\n\t\t\t\t第四次：sum = sum + i = 6 + 4 = 10;\n\t\t\t\t第五次：sum = sum + i = 10 + 5 = 15;\n\t\t\t*/\n\t\t}\n\t\t//当循环执行完毕时，将最终数据打印出来\n\t\tSystem.out.println("1-5之间的数据和是：" + sum);\n    }\n}\n```\n\n- 本题要点：\n  - 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量\n  - 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的\n\n##### for循环练习-求偶数和\n\n- 需求：求1-100之间的偶数和，并把求和结果在控制台输出 }\n- 示例代码：\n\n```java\npublic class ForTest03 {\n    public static void main(String[] args) {\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n\t\tint sum = 0;\n\t\t//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\n\t\tfor(int i=1; i<=100; i++) {\n\t\t\t//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\n\t\t\tif(i%2 == 0) {\n                //sum += i；\n\t\t\t\tsum = sum + i;\n\t\t\t}\n\t\t}\n\t\t//当循环执行完毕时，将最终数据打印出来\n\t\tSystem.out.println("1-100之间的偶数和是：" + sum);\n    }\n}\n```\n\n##### for循环练习-统计次数\n\n需求：\n\n​\t  键盘录入两个数字，表示一个范围。\n\n​           统计这个范围中。\n\n​           既能被3整除，又能被5整除数字有多少个？\n\n代码示例：\n\n```java\n\n```\n\n### 4.2 while循环\n\n#### 4.2.1 格式：\n\n```java\n初始化语句;\nwhile(条件判断语句){\n\t循环体;\n\t条件控制语句;\n}\n```\n\n##### 练习1：打印5次HelloWorld\n\n```java\nint i = 1;\nwhile(i <= 5){\n    System.out.println("HelloWorld");\n    i++;\n}\nSystem.out.println(i);\n```\n\n##### 练习2：珠穆朗玛峰\n\n```java\n//1.定义一个变量表示珠穆朗玛峰的高度\nint height = 8844430;\n//2.定义一个变量表示纸张的厚度\ndouble paper = 0.1;\n\n//定义一个计数器（变量），用来统计折叠的次数\nint count = 0;\n\n//3.循环折叠纸张\n//只有纸张的厚度 < 穆朗玛峰的高度 循环才继续，否则循环就停止\n//坑：只有判断为真，循环才会继续\nwhile(paper < height){\n    //折叠纸张\n    paper = paper * 2;\n    count++;\n}\n\n//4.打印一下纸张的厚度\nSystem.out.println(count);//27\n```\n\n### 4.3 do...while循环\n\n本知识点了解即可\n\n格式：\n\n```java\n初始化语句;\ndo{\n    循环体;\n    条件控制语句;\n}while(条件判断语句);\n```\n\n特点：\n\n​\t先执行，再判断。\n\n### 4.4 三种格式的区别：\n\n​\tfor和while循环，是先判断，再执行。\n\n​\tdo...while是先执行，再判断。\n\n​\t当知道循环次数或者循环范围的时候，用for循环。\n\n​\t当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。'},{title:"循环高级",headers:[{level:2,title:"1.无限循环",slug:"_1-无限循环",link:"#_1-无限循环",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]},{level:3,title:"for格式：",slug:"for格式",link:"#for格式",children:[]},{level:3,title:"while格式：",slug:"while格式",link:"#while格式",children:[]},{level:3,title:"do...while格式：",slug:"do-while格式",link:"#do-while格式",children:[]},{level:3,title:"无限循环的注意事项：",slug:"无限循环的注意事项",link:"#无限循环的注意事项",children:[]}]},{level:2,title:"2.条件控制语句",slug:"_2-条件控制语句",link:"#_2-条件控制语句",children:[{level:3,title:"break:",slug:"break",link:"#break",children:[]},{level:3,title:"continue:",slug:"continue",link:"#continue",children:[]}]},{level:2,title:"3. Random",slug:"_3-random",link:"#_3-random",children:[{level:3,title:"使用步骤：",slug:"使用步骤",link:"#使用步骤",children:[]}]},{level:2,title:"4. 逢七过",slug:"_4-逢七过",link:"#_4-逢七过",children:[]},{level:2,title:"5. 平方根",slug:"_5-平方根",link:"#_5-平方根",children:[]},{level:2,title:"6.判断是否为质数",slug:"_6-判断是否为质数",link:"#_6-判断是否为质数",children:[]},{level:2,title:"7. 猜数字小游戏",slug:"_7-猜数字小游戏",link:"#_7-猜数字小游戏",children:[]}],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html",pathLocale:"/",extraFields:'---\ntitle: 循环高级\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n循环高级\n\n\x3c!-- more --\x3e\n\n## 1.无限循环\n\n### 概念：\n\n​\t又叫死循环。循环一直停不下来。\n\n### for格式：\n\n```java\nfor(;;){\n    System.out.println("循环执行一直在打印内容");\n}\n```\n\n解释：\n\n初始化语句可以空着不写，表示循环之前不定义任何的控制变量。\n\n条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。\n\n条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。\n\n### while格式：\n\n```java\nwhile(true){\n    System.out.println("循环执行一直在打印内容");\n}\n```\n\n解释：\n\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\n\n### do...while格式：\n\n```java\ndo{\n    System.out.println("循环执行一直在打印内容");\n}while(true);\n```\n\n解释：\n\n​\t小括号里面就不能省略了，true一定要写出来，否则代码会报错。\n\n### 无限循环的注意事项：\n\n* 最为常用的格式：while\n* 无限循环下面不能再写其他代码了，因为永远执行不到。\n\n## 2.条件控制语句\n\n* break\n* continue\n\n### break:\n\n​\t不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。\n\n代码示例：\n\n```java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    System.out.println("在吃第" + i + "个包子");\n    //2.吃完第三个的时候就不吃了\n    if(i == 3){\n        break;//结束整个循环。\n    }\n}\n```\n\n### continue:\n\n​\t不能单独存在的。只能存在于循环当中。\n\n​\t表示：跳过本次循环，继续执行下次循环。\n\n代码示例：\n\n```java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    //2.第3个包子有虫子就跳过，继续吃下面的包子\n    if(i == 3){\n        //跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。\n        continue;\n    }\n    System.out.println("在吃第" + i + "个包子");\n}\n```\n\n## 3. Random\n\nRandom跟Scanner一样，也是Java提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。\n\n### 使用步骤：\n\n1. 导包\n\n```java\nimport java.util.Random;\n导包的动作必须出现在类定义的上边。\n```\n\n2. 创建对象\n\n```java\nRandom r = new Random ();\n上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。\n```\n\n3. 生成随机数\n\n```java\nint number = r.nextInt(随机数的范围);\n上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。\n随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10)\n```\n\n代码示例：\n\n```java\n//1.导包\nimport java.util.Random;\n\npublic class RandomDemo1 {\n    public static void main(String[] args) {\n        //2.创建对象\n        Random r = new Random();\n        //3.生成随机数\n        int number = r.nextInt(100);//包左不包右，包头不包尾\n        //0 ~ 99\n        System.out.println(number);\n\n    }\n}\n```\n\n## 4. 逢七过\n\n需求：\n\n​\t朋友聚会的时候可能会玩一个游戏：逢7过 \n\n​\t游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过\n\n​\t使用程序在控制台打印出1-100之间的满足逢七必过规则的数据 \n\n举例：\n\n​\t1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 ...\n\n代码示例：\n\n```java\n/*朋友聚会的时候可能会玩一个游戏：逢7过\n        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过\n        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/\n//分析：\n//个位7  十位7   7倍数\n//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....\n//69 过 过 过 过 过 过... 80\n//1.得到1~100之间的每一个数字\n//开始：1\n//结束：100\nfor (int i = 1; i <= 100; i++) {\n    //2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字\n    if(i % 10 == 7 || i / 10 % 10 == 7  ||  i % 7 == 0){\n        System.out.println("过");\n        continue;\n    }\n    System.out.println(i);\n}\n```\n\n## 5. 平方根\n\n需求：\n\n​\t键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。结果只保留整数部分 ，小数部分将被舍去 。\n\n代码示例：\n\n```java\n/*需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。\n        结果只保留整数部分 ，小数部分将被舍去 。*/\n\n\n//分析：\n//平方根   16的平方根4\n//         4的平方根2\n\n\n// 10\n// 1 * 1 = 1 < 10\n// 2 * 2 = 4 < 10\n// 3 * 3 = 9 < 10\n// 4 * 4 = 16 > 10\n//推断：10的平方根是在3~4之间。\n\n\n// 20\n// 1 * 1 = 1 < 20\n// 2 * 2 = 4 < 20\n// 3 * 3 = 9 < 20\n// 4 * 4 = 16 < 20\n// 5 * 5 = 25 > 20\n//推断：20的平方根是在4~5之间。\n\n\n//在代码当中\n//从1开始循环，拿着数字的平方跟原来的数字进行比较\n//如果小于的，那么继续往后判断\n//如果相等，那么当前数字就是平方根\n//如果大于的，那么前一个数字就是平方跟的整数部分\n\n\n//1.键盘录入一个整数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个整数");\nint number = sc.nextInt();\n//2.从1开始循环判断\n//开始：1 结束: number\nfor (int i = 1; i <= number; i++) {\n    //用i * i 再跟number进行比较\n    if(i * i == number){\n        System.out.println(i + "就是" + number + "的平方根");\n        //一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。\n        break;\n    }else if(i * i > number){\n        System.out.println((i - 1) + "就是" + number + "平方根的整数部分");\n        break;\n    }\n}\n```\n\n## 6.判断是否为质数\n\n需求：\n\n​\t键盘录入一个正整数 x ，判断该整数是否为一个质数。 \n\n代码示例：\n\n```java\n//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。\n\n//质数：\n//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数\n//7 = 1 * 7 质数\n//8 = 1 * 8  2 * 4 合数\n\n\n//分析：\n//1.键盘录入一个正整数\n//number\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个正整数");\nint number = sc.nextInt();//9\n\n//定义一个变量，表示标记\n//标记着number是否为一个质数\n//true： 是一个质数\n//false : 不是一个质数\n\n//表示最初就认为number是一个质数\nboolean flag = true;\n\n\n//2.判断\n//写一个循环，从2开始判断，一直判断到number-1为止\n//看这个范围之内，有没有数字可以被number整除\nfor (int i = 2; i < number; i++) {\n    //i 依次表示这个范围之内的每一个数字\n    //看number是否能被i整除就可以了\n    if(number % i == 0){// 9 % 2 = 1\n        flag = false;\n        //System.out.println(number + "不是一个质数");\n        break;\n    }/*else{\n                System.out.println(number + "是一个质数");\n            }*/\n}\n\n//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了\n//此时才能断定number是一个质数\nif(flag){\n    System.out.println(number + "是一个质数");\n}else{\n    System.out.println(number + "不是一个质数");\n}\n```\n\n## 7. 猜数字小游戏\n\n需求：\n\n​\t程序自动生成一个1-100之间的随机数，在代码中使用键盘录入去猜出这个数字是多少？\n\n要求：\n\n​\t使用循环猜，一直猜中为止。\n\n思路分析：\n\n1. 生成一个1-100之间的随机数\n2. 使用键盘录入去猜出这个数字是多少\n3. 把反复猜的代码写在循环中\n\n代码示例：\n\n```java\n//1.生成一个1-100之间的随机数\nRandom r = new Random();\nint number = r.nextInt(100) + 1;// 0 ~ 99 + 1 --- 1 ~ 100\nSystem.out.println(number);\n\n//2.使用键盘录入去猜出这个数字是多少？\nScanner sc = new Scanner(System.in);\nwhile(true){\n    System.out.println("请输入一个整数");\n    int guessNumber = sc.nextInt();\n    //3.比较\n    if(guessNumber > number){\n        System.out.println("您猜的数字大了");\n    }else if(guessNumber < number){\n        System.out.println("您猜的数字小了");\n    }else{\n        System.out.println("恭喜你，猜中了");\n        break;\n    }\n}\n```\n'},{title:"数组",headers:[{level:2,title:"1.数组",slug:"_1-数组",link:"#_1-数组",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]}]},{level:2,title:"2.数组的定义",slug:"_2-数组的定义",link:"#_2-数组的定义",children:[{level:3,title:"格式一：",slug:"格式一",link:"#格式一",children:[]},{level:3,title:"格式二：",slug:"格式二",link:"#格式二",children:[]},{level:3,title:"详解：",slug:"详解",link:"#详解",children:[]},{level:3,title:"注意点：",slug:"注意点",link:"#注意点",children:[]}]},{level:2,title:"3.数组的静态初始化",slug:"_3-数组的静态初始化",link:"#_3-数组的静态初始化",children:[{level:3,title:"完整格式：",slug:"完整格式",link:"#完整格式",children:[]},{level:3,title:"格式详解：",slug:"格式详解",link:"#格式详解",children:[]},{level:3,title:"注意点：",slug:"注意点-1",link:"#注意点-1",children:[]},{level:3,title:"简化格式:",slug:"简化格式",link:"#简化格式",children:[]},{level:3,title:"练习1：",slug:"练习1",link:"#练习1",children:[]},{level:3,title:"练习2：",slug:"练习2",link:"#练习2",children:[]},{level:3,title:"练习3：",slug:"练习3",link:"#练习3",children:[]}]},{level:2,title:"4.地址值",slug:"_4-地址值",link:"#_4-地址值",children:[]},{level:2,title:"5.数组元素访问",slug:"_5-数组元素访问",link:"#_5-数组元素访问",children:[{level:3,title:"格式：",slug:"格式",link:"#格式",children:[]},{level:3,title:"作用：",slug:"作用",link:"#作用",children:[]},{level:3,title:"代码示例：",slug:"代码示例",link:"#代码示例",children:[]}]},{level:2,title:"6.索引",slug:"_6-索引",link:"#_6-索引",children:[{level:3,title:"索引的特点：",slug:"索引的特点",link:"#索引的特点",children:[]}]},{level:2,title:"7.数组的遍历",slug:"_7-数组的遍历",link:"#_7-数组的遍历",children:[]},{level:2,title:"8.数组的动态初始化",slug:"_8-数组的动态初始化",link:"#_8-数组的动态初始化",children:[{level:3,title:"格式：",slug:"格式-1",link:"#格式-1",children:[]},{level:3,title:"举例：",slug:"举例",link:"#举例",children:[]},{level:3,title:"数组的默认初始化值：",slug:"数组的默认初始化值",link:"#数组的默认初始化值",children:[]}]},{level:2,title:"9.数组两种初始化方式的区别",slug:"_9-数组两种初始化方式的区别",link:"#_9-数组两种初始化方式的区别",children:[{level:3,title:"使用场景：",slug:"使用场景",link:"#使用场景",children:[]},{level:3,title:"举例：",slug:"举例-1",link:"#举例-1",children:[]}]},{level:2,title:"10.数组常见问题",slug:"_10-数组常见问题",link:"#_10-数组常见问题",children:[]},{level:2,title:"11.数组的练习",slug:"_11-数组的练习",link:"#_11-数组的练习",children:[{level:3,title:"练习1：求和",slug:"练习1-求和",link:"#练习1-求和",children:[]},{level:3,title:"练习2：统计个数",slug:"练习2-统计个数",link:"#练习2-统计个数",children:[]},{level:3,title:"练习3：变化数据",slug:"练习3-变化数据",link:"#练习3-变化数据",children:[]},{level:3,title:"练习4：求最值",slug:"练习4-求最值",link:"#练习4-求最值",children:[]},{level:3,title:"练习5：统计个数",slug:"练习5-统计个数",link:"#练习5-统计个数",children:[]},{level:3,title:"练习6：交换数据",slug:"练习6-交换数据",link:"#练习6-交换数据",children:[]},{level:3,title:"练习7：打乱数据",slug:"练习7-打乱数据",link:"#练习7-打乱数据",children:[]}]}],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",pathLocale:"/",extraFields:'---\ntitle: 数组\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n数组\n\n\x3c!-- more --\x3e\n## 1.数组\n\n### 概念：\n\n​\t指的是一种容器，可以同来存储同种数据类型的多个值。\n\n​\t但是数组容器在存储数据的时候，需要结合隐式转换考虑。\n\n比如：\n\n​\t定义了一个int类型的数组。那么boolean。double类型的数据是不能存到这个数组中的，\n\n​\t但是byte类型，short类型，int类型的数据是可以存到这个数组里面的。\n\n建议：\n\n​\t容器的类，和存储的数据类型保持一致。\n\n举例：\n\n​\t整数1 2 3 4 56 就可以使用int类型的数组来存储。\n\n​\t小数1.1 1.2 1.3 1.4 就可以使用double类型的数组来存储。\n\n​\t字符串"aaa"  "bbb"  "ccc" 就可以使用String类型的数组来存储。\n\n## 2.数组的定义\n\n### 格式一：\n\n​\t数据类型 [] 数组名\n\n比如：int [] array\n\n### 格式二：\n\n​\t数据类型  数组名 []\n\n比如： int array []\n\n### 详解：\n\n数据类型：限定了数组以后能存什么类型的数据。\n\n方括号：表示现在定义的是一个数组。\n\n数组名：就是一个名字而已，方便以后使用。\n\n### 注意点：\n\n​\t方法括号跟数组名，谁写在前面，谁写在后面都是一样的。\n\n​\t平时习惯性使用第一种方式。\n\n## 3.数组的静态初始化\n\n### 完整格式：\n\n​\t数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};\n\n比如：\n\n​\tint[] arr = new int[]{11,22,33};\n\n​\tdouble[] arr = new double[]{1.1,1.2,1.3};\n\n### 格式详解：\n\n​\t数据类型：限定了数组以后能存什么类型的数据。\n\n​\t方括号：表示现在定义的是一个数组。\n\n​\t数组名：其实就是名字而已，方便以后使用，在起名字的时候遵循小驼峰命名法。\n\n​\t\t\tarr   namesArr\n\n​\tnew：就是给数组在内存中开辟了一个空间。\n\n​\t数据类型：限定了数组以后能存什么类型的数据。\n\n​\t\t\t  前面和后面的数据类型一定要保持一致。\n\n​\t\t\tint[] arr = new double[]{11,22,33};//错误写法\n\n​\t方括号：表示现在定义的是一个数组。\n\n​\t大括号：表示数组里面的元素。元素也就是存入到数组中的数据。\n\n​\t\t\t多个元素之间，一定要用逗号隔开。\n\n### 注意点：\n\n* 等号前后的数据类型必须保持一致。\n* 数组一旦创建之后，长度不能发生变化。\n\n### 简化格式:\n\n​\t数据类型[] 数组名 = {元素1，元素2，元素3，元素4...};\n\n比如：\n\n​\tint[] array = {1,2,3,4,5};\n\n​\tdouble[] array = {1.1,1.2,1.3};\n\n### 练习1：\n\n定义数组存储5个学生的年龄。\n\n```java\n1.给数组限定什么类型？ int\n2.利用静态初始化完成创建并添加元素\nint[] agesArr = new int[]{18,19,20,21,22};\nint[] agesArr = {18,19,20,21,22};\n```\n\n### 练习2：\n\n定义数组存储3个学生的姓名。\n\n```java\n1.给数组限定什么类型？ String\n2.利用静态初始化完成创建并添加元素\nString[] namesArr = new String[]{"zhangsan","lisi","wangwu"};\nString[] namesArr = {"zhangsan","lisi","wangwu"};\n```\n\n### 练习3：\n\n定义数组存储4个学生的身高。\n\n```java\n1.给数组限定什么类型？ double\n2.利用静态初始化完成创建并添加元素\ndouble[] heightsArr = new double[]{1.85,1.82,1.78,1.65};\ndouble[] heightsArr = {1.85,1.82,1.78,1.65};\n```\n\n## 4.地址值\n\n```java\nint[] arr = {1,2,3,4,5};\nSystem.out.println(arr);//[I@6d03e736\n\ndouble[] arr2 = {1.1,2.2,3.3};\nSystem.out.println(arr2);//[D@568db2f2\n```\n\n打印数组的时候，实际出现的是数组的地址值。\n\n数组的地址值：就表示数组在内存中的位置。\n\n以[I@6d03e736为例：\n\n[ ：表示现在打印的是一个数组。\n\nI：表示现在打印的数组是int类型的。\n\n@：仅仅是一个间隔符号而已。\n\n6d03e736：就是数组在内存中真正的地址值。（十六进制的）\n\n但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值。\n\n地址值对于我们来京，作用不大，简单了解。\n\n## 5.数组元素访问\n\n### 格式：\n\n​\t数组名[索引];\n\n### 作用：\n\n* 获取数组中对应索引上的值\n\n* 修改数组中对应索引上的值\n\n  一旦修改之后，原来的值就会被覆盖了。\n\n### 代码示例：\n\n```java\npublic class ArrDemo2 {\n    /*\n\n        数组中元素访问的格式：\n                数组名[索引];\n\n         作用：\n            1.获取指定索引上对应的元素\n            2.修改指定索引上对应的元素\n\n\n    */\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5};\n       //需求1：获取arr数组中，3索引上的值\n        int number = arr[3];\n        System.out.println(number);\n        System.out.println(arr[3]);\n\n       //需求2：将arr数组中，3索引上的值修改为10\n            arr[3] = 10;\n        System.out.println("修改之后为:" + arr[3]);\n\n    }\n}\n```\n\n## 6.索引\n\n​\t也叫角标、下标\n\n​\t就是数组容器中每一个小格子对应的编号。\n\n### 索引的特点：\n\n* 索引一定是从0开始的。\n* 连续不间断。\n* 逐个+1增长。\n\n## 7.数组的遍历\n\n遍历：就是把数组里面所有的内容一个一个全部取出来。\n\n数组的长度：数组名.length;\n\n通用代码：\n\n```java\nfor(int i = 0; i < arr.length; i++){\n    //在循环的过程中，i依次表示数组中的每一个索引\n    sout(arr[i]);//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。\n}\n```\n\n## 8.数组的动态初始化\n\n### 格式：\n\n​\t数据类型[] 数组名 = new 数据类型[数组的长度];\n\n### 举例：\n\n```java\n//1.定义一个数组，存3个人的年龄，年龄未知\nint[] agesArr = new int[3];\n\n\n//2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。\nint[] scoresArr = new int[10];\n```\n\n### 数组的默认初始化值：\n\n整数类型：0\n\n小数类型：0.0\n\n布尔类型：false\n\n字符类型：\'\\u0000\'\n\n引用类型：null\n\n## 9.数组两种初始化方式的区别\n\n静态初始化：int[] arr = {1,2,3,4,5};\n\n动态初始化：int[] arr = new int[3];\n\n静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。\n\n动态初始化：手动指定数组长度，由系统给出默认初始化值。\n\n### 使用场景：\n\n只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。\n\n已经明确了要操作的所有数据，推荐使用静态初始化。\n\n### 举例：\n\n* 使用数组来存储键盘录入的5个整数。\n\n  int[] arr = new int[5];\n\n* 将全班的学生成绩存入数组中，已知学生成绩为：66,77,88,99,100\n\n  int[] arr = new int[5];\n\n  arr[0] = 66;\n\n  arr[1] = 77;\n\n  ... 虽然可以实现，但是太麻烦了。\n\n  建议使用静态初始化：int[] arr = {66,77,88,99,100};\n\n## 10.数组常见问题\n\n当访问了数组中不存在的索引，就会引发索引越界异常。\n\n避免：\n\n​\t针对于任意一个数组，索引的范围：\n   \t最小索引：0\n   \t最大索引：数组的长度 - 1\n           \t\t    数组名.length - 1\n\n```java\npublic class ArrDemo6 {\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5,5,5,5,5};\n        //用索引来访问数组中的元素\n        System.out.println(arr[1]);\n        System.out.println(arr[10]);//ArrayIndexOutOfBoundsException\n\n    }\n}\n```\n\n## 11.数组的练习\n\n### 练习1：求和\n\n需求：定义一个数组，存储1,2,3,4,5\n\n遍历数组得到每一个元素，求数组里面所有的数据和\n\n代码示例：\n\n```java\n/*定义一个数组，存储1,2,3,4,5\n        遍历数组得到每一个元素，求数组里面所有的数据和*/\n\n\n//分析：\n//1.定义一个数组，并添加数据1,2,3,4,5\nint[] arr = {1,2,3,4,5};\n\n//求和变量\nint sum = 0;\n//2.遍历数组得到每一个数据，累加求和\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    sum = sum + arr[i];\n}\n\n//当循环结束之后，sum的值就是累加之后的结果\nSystem.out.println(sum);\n```\n\n### 练习2：统计个数\n\n需求：定义一个数组，存储1,2,3,4,5,6,7,8,9,10\n\n遍历数组得到每一个元素，统计数组里面一共有多少个能被3整除的数字\n\n代码示例：\n\n```java\n//分析：\n//1.定义一个数组 存储1,2,3,4,5,6,7,8,9,10\nint[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n//定义一个变量，用来统计次数\nint count = 0;\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 表示数组里面的每一个索引\n    //arr[i] 表示数组里面的每一个元素\n    //3.判断当前的元素是否为3的倍数，如果是那么统计变量就需要自增一次。\n    if(arr[i] % 3 == 0){\n        // System.out.println(arr[i]);\n        count++;\n    }\n}\n//当循环结束之后，就表示数组里面所有的数字都判断完毕了，直接打印count即可\nSystem.out.println("数组中能被3整除的数字有" + count + "个");\n```\n\n### 练习3：变化数据\n\n需求：\n\n定义一个数组，存储1,2,3,4,5,6,7,8,9,10\n\n遍历数组得到每一个元素。\n\n要求：\n\n1，如果是奇数，则将当前数字扩大两倍\n\n2，如果是偶数，则将当前数字变成二分之一\n\n代码示例：\n\n```java\n//分析：\n//1.定义一个数组，存1,2,3,4,5,6,7,8,9,10\nint[] arr = {1,2,3,4,5,6,7,8,9,10};\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    //3.对每一个元素进行判断\n    if(arr[i] % 2 == 0){\n        //偶数 变成二分之一\n        arr[i] = arr[i] / 2;\n    }else{\n        //奇数 扩大两倍\n        arr[i] = arr[i] * 2;\n    }\n}\n\n//遍历数组\n//一个循环尽量只做一件事情。\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}\n```\n\n### 练习4：求最值\n\n需求：求数组中的最大值\n\n代码示例：\n\n```java\n//定义数组求最大值：33,5,22,44,55\n\n//扩展问题：\n//1.根据求最大值的思路，自己改写一下求最小智\n//2.为什么max要记录为arr[0],默认值不能为0吗？\n//不能写0\n//max的初始化值一定要是数组中的值。\n//3.循环中开始条件一定是0吗？\n//循环的开始条件如果为0，那么第一次循环的时候是自己跟自己比了一下，对结果没有任何影响，但是效率偏低\n//为了提高效率，减少一次循环的次数，循环开始条件可以写1.\n\n\n//1.定义数组用来存储5个值\nint[] arr = {33,5,22,44,55};\n//2.定义一个变量max用来存储最大值\n//临时认为0索引的数据是最大的\nint max = arr[0];\n//3.循环获取数组中的每一个元素\n//拿着每一个元素跟max进行比较\nfor (int i = 1; i < arr.length; i++) {\n    //i 索引  arr[i] 元素\n    if(arr[i] > max){\n        max = arr[i];\n    }\n}\n//4.当循环结束之后，max记录的就是数组中的最大值\nSystem.out.println(max);//55\n```\n\n### 练习5：统计个数\n\n需求：生成10个1~100之间的随机数存入数组。\n\n1）求出所有数据的和\n\n2）求所有数据的平均数\n\n3）统计有多少个数据比平均值小\n\n代码示例：\n\n```java\n//分析：\n//1.定义数组\nint[] arr = new int[10];\n//2.把随机数存入到数组当中\nRandom r = new Random();\n\nfor (int i = 0; i < arr.length; i++) {\n    //每循环一次，就会生成一个新的随机数\n    int number = r.nextInt(100) + 1;\n    //把生成的随机数添加的数组当中\n    //数组名[索引] = 数据;\n    arr[i] = number;\n}\n\n\n// 1）求出所有数据的和\n//定义求和变量\nint sum = 0;\nfor (int i = 0; i < arr.length; i++) {\n    //循环得到每一个元素\n    //并把元素累加到sum当中\n    sum = sum + arr[i];\n}\nSystem.out.println("数组中所有数据的和为：" + sum);\n\n\n//2）求所有数据的平均数\nint avg = sum / arr.length;\nSystem.out.println("数组中平均数为：" + avg);\n\n\n\n//3）统计有多少个数据比平均值小\nint count = 0;\nfor (int i = 0; i < arr.length; i++) {\n    if(arr[i] < avg){\n        count++;\n    }\n}\n\n//当循环结束之后，就表示我已经找到了所有的比平均数小的数据\nSystem.out.println("在数组中，一共有" + count + "个数据，比平均数小");\n\n\n\n//遍历数组，验证答案\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}\n```\n\n### 练习6：交换数据\n\n需求：定义一个数组，存入1,2,3,4,5。按照要求交换索引对应的元素。\n\n交换前：1,2,3,4,5\n\n交换后：5,2,3,4,1\n\n代码示例：\n\n```java\n//1.定义数组存储数据\nint[] arr = {1,2,3,4,5};\n//2.利用循环去交换数据\nfor(int i = 0,j = arr.length - 1; i < j; i++,j--){\n    //交换变量i和变量j指向的元素\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n//当循环结束之后，那么数组中的数据就实现了头尾交换\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}\n```\n\n### 练习7：打乱数据 \n\n需求：定义一个数组，存入1~5。要求打乱数组中所有数据的顺序。\n\n代码示例：\n\n```java\n//1.定义数组存储1~5\nint[] arr = {1, 2, 3, 4, 5};\n//2.循环遍历数组，从0索引开始打乱数据的顺序\nRandom r = new Random();\nfor (int i = 0; i < arr.length; i++) {\n    //生成一个随机索引\n    int randomIndex = r.nextInt(arr.length);\n    //拿着随机索引指向的元素 跟 i 指向的元素进行交换\n    int temp = arr[i];\n    arr[i] = arr[randomIndex];\n    arr[randomIndex] = temp;\n}\n//当循环结束之后，那么数组中所有的数据已经打乱顺序了\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}\n```\n\n'},{title:"方法概述",headers:[{level:2,title:"1. 方法概述",slug:"_1-方法概述",link:"#_1-方法概述",children:[{level:3,title:"1.1 方法的概念",slug:"_1-1-方法的概念",link:"#_1-1-方法的概念",children:[]}]},{level:2,title:"2. 方法的定义和调用",slug:"_2-方法的定义和调用",link:"#_2-方法的定义和调用",children:[{level:3,title:"2.1 无参数方法定义和调用",slug:"_2-1-无参数方法定义和调用",link:"#_2-1-无参数方法定义和调用",children:[]},{level:3,title:"2.3 无参数方法的练习",slug:"_2-3-无参数方法的练习",link:"#_2-3-无参数方法的练习",children:[]}]},{level:2,title:"3. 带参数方法定义和调用",slug:"_3-带参数方法定义和调用",link:"#_3-带参数方法定义和调用",children:[{level:3,title:"3.1 带参数方法定义和调用",slug:"_3-1-带参数方法定义和调用",link:"#_3-1-带参数方法定义和调用",children:[]},{level:3,title:"3.2 形参和实参",slug:"_3-2-形参和实参",link:"#_3-2-形参和实参",children:[]},{level:3,title:"3.3 带参数方法练习",slug:"_3-3-带参数方法练习",link:"#_3-3-带参数方法练习",children:[]}]},{level:2,title:"4. 带返回值方法的定义和调用",slug:"_4-带返回值方法的定义和调用",link:"#_4-带返回值方法的定义和调用",children:[{level:3,title:"4.1 带返回值方法定义和调用",slug:"_4-1-带返回值方法定义和调用",link:"#_4-1-带返回值方法定义和调用",children:[]},{level:3,title:"4.2 带返回值方法练习1",slug:"_4-2-带返回值方法练习1",link:"#_4-2-带返回值方法练习1",children:[]},{level:3,title:"4.3 带返回值方法练习2",slug:"_4-3-带返回值方法练习2",link:"#_4-3-带返回值方法练习2",children:[]},{level:3,title:"4.4 带返回值方法练习3",slug:"_4-4-带返回值方法练习3",link:"#_4-4-带返回值方法练习3",children:[]}]},{level:2,title:"5. 方法的注意事项",slug:"_5-方法的注意事项",link:"#_5-方法的注意事项",children:[{level:3,title:"5.1 方法的注意事项",slug:"_5-1-方法的注意事项",link:"#_5-1-方法的注意事项",children:[]},{level:3,title:"5.2 方法的通用格式",slug:"_5-2-方法的通用格式",link:"#_5-2-方法的通用格式",children:[]}]},{level:2,title:"6. 方法重载",slug:"_6-方法重载",link:"#_6-方法重载",children:[{level:3,title:"6.1 方法重载",slug:"_6-1-方法重载",link:"#_6-1-方法重载",children:[]},{level:3,title:"6.2 方法重载练习",slug:"_6-2-方法重载练习",link:"#_6-2-方法重载练习",children:[]},{level:3,title:"7.3 数组遍历",slug:"_7-3-数组遍历",link:"#_7-3-数组遍历",children:[]},{level:3,title:"7.4 数组最大值",slug:"_7-4-数组最大值",link:"#_7-4-数组最大值",children:[]},{level:3,title:"7.6 获取索引",slug:"_7-6-获取索引",link:"#_7-6-获取索引",children:[]}]}],path:"/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html",pathLocale:"/",extraFields:'---\ntitle: 方法概述\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n方法概述\n\n\x3c!-- more --\x3e\n## 1. 方法概述\n\n### 1.1 方法的概念\n\n​\t方法（method）是程序中最小的执行单元\n\n* 注意：\n  * 方法必须先创建才可以使用，该过程成为方法定义\n  * 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用\n\n## 2. 方法的定义和调用\n\n### 2.1 无参数方法定义和调用\n\n* 定义格式：\n\n  ```java\n  public static void 方法名 (   ) {\n  \t// 方法体;\n  }\n  ```\n\n* 范例：\n\n  ```java\n  public static void method (    ) {\n  \t// 方法体;\n  }\n  ```\n\n* 调用格式：\n\n  ```java\n  方法名();\n  ```\n\n* 范例：\n\n  ```java\n  method();\n  ```\n\n* 注意：\n\n  ​\t方法必须先定义，后调用，否则程序将报错\n\n### 2.3 无参数方法的练习\n\n* 需求：设计一个方法用于打印两个数中的较大数 \n* 思路：\n  * ①定义一个方法，用于打印两个数字中的较大数，例如getMax() \n  * ②方法中定义两个变量，用于保存两个数字 \n  * ③使用分支语句分两种情况对两个数字的大小关系进行处理 \n  * ④在main()方法中调用定义好的方法 \n* 代码：\n\n```java\npublic class MethodTest {\n    public static void main(String[] args) {\n        //在main()方法中调用定义好的方法\n        getMax();\n    }\n\n    //定义一个方法，用于打印两个数字中的较大数，例如getMax()\n    public static void getMax() {\n        //方法中定义两个变量，用于保存两个数字\n        int a = 10;\n        int b = 20;\n\n        //使用分支语句分两种情况对两个数字的大小关系进行处理\n        if(a > b) {\n            System.out.println(a);\n        } else {\n            System.out.println(b);\n        }\n    }\n}\n```\n\n## 3. 带参数方法定义和调用\n\n### 3.1 带参数方法定义和调用\n\n* 定义格式：\n\n  参数：由数据类型和变量名组成 -  数据类型 变量名\n\n  参数范例：int a\n\n  ```java\n  public static void 方法名 (参数1) {\n  \t方法体;\n  }\n  \n  public static void 方法名 (参数1, 参数2, 参数3...) {\n  \t方法体;\n  }\n  ```\n\n* 范例：\n\n  ```java\n  public static void isEvenNumber(int number){\n      ...\n  }\n  public static void getMax(int num1, int num2){\n      ...\n  }\n  ```\n\n  * 注意：\n\n  \t\t方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错\n\t\t\t\n  \t\t方法定义时，多个参数之间使用逗号( ，)分隔\n\n* 调用格式：\n\n  ```java\n  方法名(参数)；\n  \n  方法名(参数1,参数2);\n  ```\n\n* 范例：\n\n  ```java\n  isEvenNumber(10);\n  \n  getMax(10,20);\n  ```\n\n  * 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 \n\n### 3.2 形参和实参\n\n1. 形参：方法定义中的参数\n\n​          等同于变量定义格式，例如：int number\n\n2. 实参：方法调用中的参数\n\n​          等同于使用变量或常量，例如： 10  number\n\n### 3.3 带参数方法练习\n\n* 需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }\n* 思路：\n  * ①定义一个方法，用于打印两个数字中的较大数，例如getMax() \n  * ②为方法定义两个参数，用于接收两个数字 \n  * ③使用分支语句分两种情况对两个数字的大小关系进行处理 \n  * ④在main()方法中调用定义好的方法（使用常量）\n  * ⑤在main()方法中调用定义好的方法（使用变量） \n* 代码：\n\n```java\npublic class MethodTest {\n    public static void main(String[] args) {\n        //在main()方法中调用定义好的方法（使用常量）\n        getMax(10,20);\n        //调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的\n        //getMax(30);\n        //getMax(10.0,20.0);\n\n        //在main()方法中调用定义好的方法（使用变量）\n        int a = 10;\n        int b = 20;\n        getMax(a, b);\n    }\n\n    //定义一个方法，用于打印两个数字中的较大数，例如getMax()\n    //为方法定义两个参数，用于接收两个数字\n    public static void getMax(int a, int b) {\n        //使用分支语句分两种情况对两个数字的大小关系进行处理\n        if(a > b) {\n            System.out.println(a);\n        } else {\n            System.out.println(b);\n        }\n    }\n}\n```\n\n## 4. 带返回值方法的定义和调用\n\n### 4.1 带返回值方法定义和调用\n\n* 定义格式\n\n  ```java\n  public static 数据类型 方法名 ( 参数 ) { \n  \treturn 数据 ;\n  }\n  ```\n\n* 范例\n\n  ```java\n  public static boolean isEvenNumber( int number ) {           \n  \treturn true ;\n  }\n  public static int getMax( int a, int b ) {\n  \treturn  100 ;\n  }\n  ```\n\n  * 注意：\n    * 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错\n\n* 调用格式\n\n  ```java\n  方法名 ( 参数 ) ;\n  数据类型 变量名 = 方法名 ( 参数 ) ;\n  ```\n\n* 范例\n\n  ```java\n  isEvenNumber ( 5 ) ;\n  boolean  flag =  isEvenNumber ( 5 ); \n  ```\n\n  * 注意：\n    * 方法的返回值通常会使用变量接收，否则该返回值将无意义\n\n### 4.2 带返回值方法练习1\n\n* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数\n\n* 思路：\n\n  * ①定义一个方法，用于获取两个数字中的较大数 \n  * ②使用分支语句分两种情况对两个数字的大小关系进行处理 \n  * ③根据题设分别设置两种情况下对应的返回结果 \n  * ④在main()方法中调用定义好的方法并使用变量保存 \n  * ⑤在main()方法中调用定义好的方法并直接打印结果 \n\n* 代码：\n\n  ```java\n  public class MethodTest {\n      public static void main(String[] args) {\n          //在main()方法中调用定义好的方法并使用变量保存\n          int result = getMax(10,20);\n          System.out.println(result);\n  \n          //在main()方法中调用定义好的方法并直接打印结果\n          System.out.println(getMax(10,20));\n      }\n  \n      //定义一个方法，用于获取两个数字中的较大数\n      public static int getMax(int a, int b) {\n          //使用分支语句分两种情况对两个数字的大小关系进行处理\n          //根据题设分别设置两种情况下对应的返回结果\n          if(a > b) {\n              return a;\n          } else {\n              return b;\n          }\n      }\n  }\n  ```\n\n### 4.3 带返回值方法练习2\n\n需求：\n\n​\t定义一个方法，求一家商场每个季度的营业额。根据方法结果再计算出全年营业额。\n\n代码示例：\n\n```java\npackage com.itheima.demo;\n\npublic class MethodDemo9 {\n    public static void main(String[] args) {\n        /*需求：定义一个方法，求一家商场每个季度的营业额。\n        根据方法结果再计算出全年营业额。*/\n        int sum1 = getSum(10, 20, 30);\n        int sum2 = getSum(10, 20, 30);\n        int sum3 = getSum(10, 20, 30);\n        int sum4 = getSum(10, 20, 30);\n\n        int sum = sum1 + sum2 + sum3 + sum4;\n        System.out.println(sum);\n\n    }\n\n    //心得：\n    //1.我要干嘛？  决定了方法体   每个季度的营业额\n    //2.我干这件事情，需要什么才能完成？ 决定了形参 需要三个月的营业额 a b c\n    //3.我干完这件事情，看调用处是否需要使用方法的结果。   决定了返回值\n    //如果需要使用，那么必须返回\n    //如果不需要使用，可以返回也可以不返回\n    public static int getSum(int month1,int month2,int month3){\n        int sum = month1 + month2 + month3;\n        //因为方法的调用处，需要继续使用这个结果\n        //所以我们必须要把sum返回\n        return sum;\n    }\n}\n\n```\n\n### 4.4 带返回值方法练习3\n\n需求：\n\n​\t键盘录入两个圆的半径（整数），比较两个圆的面积。\n\n代码示例：\n\n```java\nimport java.util.Scanner;\n\npublic class MethodDemo10 {\n    public static void main(String[] args) {\n        //需求：键盘录入两个圆的半径（整数），比较两个圆的面积。\n        //键盘录入圆的半径\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入圆的半径");\n        int radii1 = sc.nextInt();\n\n        System.out.println("请输入第二个圆的半径");\n        int radii2 = sc.nextInt();\n        double area1 = getArea(radii1);\n        double area2 = getArea(radii2);\n        if(area1 > area2){\n            System.out.println("第一个圆更大");\n        }else{\n            System.out.println("第二个圆更大");\n        }\n    }\n\n    //心得：\n    //1.我要干嘛？   求圆的面积\n    //2.我干这件事情，需要什么才能完成？        半径\n    //3.方法的调用处，是否需要继续使用方法的结果    要比较\n    public static double getArea(int radii) {\n        double area = 3.14 * radii * radii;\n        return area;\n    }\n}\n```\n\n## 5. 方法的注意事项\n\n### 5.1 方法的注意事项\n\n* 方法不能嵌套定义\n\n  * 示例代码：\n\n    ```java\n    public class MethodDemo {\n        public static void main(String[] args) {\n    \n        }\n    \n        public static void methodOne() {\n    \t\tpublic static void methodTwo() {\n           \t\t// 这里会引发编译错误!!!\n        \t}\n        }\n    }\n    ```\n\n* void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据\n\n  * 示例代码：\n\n    ```java\n    public class MethodDemo {\n        public static void main(String[] args) {\n    \n        }\n        public static void methodTwo() {\n            //return 100; 编译错误，因为没有具体返回值类型\n            return;\t\n            //System.out.println(100); return语句后面不能跟数据或代码\n        }\n    }\n    ```\n\n### 5.2 方法的通用格式\n\n* 格式：\n\n  ```java\n  public static 返回值类型 方法名(参数) {\n     方法体; \n     return 数据 ;\n  }\n  ```\n\n* 解释：\n\n  * public static \t修饰符，目前先记住这个格式\n\n  \t 返回值类型\t方法操作完毕之后返回的数据的数据类型\n\n    ​\t\t\t如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return\n\n  \t 方法名\t\t调用方法时候使用的标识\n\n  \t 参数\t\t由数据类型和变量名组成，多个参数之间用逗号隔开\n\n  \t 方法体\t\t完成功能的代码块\n\n  \t return\t\t如果方法操作完毕，有数据返回，用于把数据返回给调用者\n\n* 定义方法时，要做到两个明确\n\n  * 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型\n  * 明确参数：主要是明确参数的类型和数量\n\n* 调用方法时的注意：\n\n  * void类型的方法，直接调用即可\n  * 非void类型的方法，推荐用变量接收调用\n\n## 6. 方法重载\n\n### 6.1 方法重载\n\n* 方法重载概念\n\n  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\n\n  * 多个方法在同一个类中\n  * 多个方法具有相同的方法名\n  * 多个方法的参数不相同，类型不同或者数量不同\n\n* 注意：\n\n  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\n  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\n\n* 正确范例：\n\n  ```java\n  public class MethodDemo {\n  \tpublic static void fn(int a) {\n      \t//方法体\n      }\n      public static int fn(double a) {\n      \t//方法体\n      }\n  }\n  \n  public class MethodDemo {\n  \tpublic static float fn(int a) {\n      \t//方法体\n      }\n      public static int fn(int a , int b) {\n      \t//方法体\n      }\n  }\n  ```\n\n* 错误范例：\n\n  ```java\n  public class MethodDemo {\n  \tpublic static void fn(int a) {\n      \t//方法体\n      }\n      public static int fn(int a) { \t/*错误原因：重载与返回值无关*/\n      \t//方法体\n      }\n  }\n  \n  public class MethodDemo01 {\n      public static void fn(int a) {\n          //方法体\n      }\n  } \n  public class MethodDemo02 {\n      public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\n          //方法体\n      }\n  }\n  ```\n\n### 6.2 方法重载练习\n\n* 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） \n\n* 思路：\n\n  * ①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数\n  * ②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数\n  * ③定义所有的重载方法，两个byte类型与两个short类型参数 \n  * ④完成方法的调用，测试运行结果 \n\n* 代码：\n\n  ```java\n  public class MethodTest {\n      public static void main(String[] args) {\n          //调用方法\n          System.out.println(compare(10, 20));\n          System.out.println(compare((byte) 10, (byte) 20));\n          System.out.println(compare((short) 10, (short) 20));\n          System.out.println(compare(10L, 20L));\n      }\n  \n      //int\n      public static boolean compare(int a, int b) {\n          System.out.println("int");\n          return a == b;\n      }\n  \n      //byte\n      public static boolean compare(byte a, byte b) {\n          System.out.println("byte");\n          return a == b;\n      }\n  \n      //short\n      public static boolean compare(short a, short b) {\n          System.out.println("short");\n          return a == b;\n      }\n  \n      //long\n      public static boolean compare(long a, long b) {\n          System.out.println("long");\n          return a == b;\n      }\n  \n  }\n  ```\n\n### 7.3 数组遍历\n\n* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] \n\n* 思路：\n\n  * ①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);\n\n    System.out.println(“内容”); 输出内容并换行\n\n    System.out.print(“内容”); 输出内容不换行\n\n    System.out.println(); 起到换行的作用\n\n  * ②定义一个数组，用静态初始化完成数组元素初始化\n\n  * ③定义一个方法，用数组遍历通用格式对数组进行遍历\n\n  * ④用新的输出语句修改遍历操作\n\n  * ⑤调用遍历方法\n\n* 代码：\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        /*  //先打印数据，再进行换行\n          System.out.println("aaa");\n          //只打印不换行\n          System.out.print("bbb");\n          System.out.print("ddd");\n          //不打印任何内容，只换行\n          System.out.println();\n          System.out.print("cc");*/\n          //设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\n          int[] arr = {1,2,3,4,5};\n          printArr(arr);\n      }\n      //1.我要遍历数组\n      //2.需要什么？  数组\n      //3.调用处是否需要使用方法的结果。\n      public static void printArr(int[] arr){\n          System.out.print("[");\n          for (int i = 0; i < arr.length; i++) {\n              if(i == arr.length - 1){\n                  System.out.println(arr[i] + "]");\n              }else{\n                  System.out.print(arr[i] + ", ");\n              }\n          }\n      }\n  }\n  ```\n\n### 7.4 数组最大值\n\n* 需求：设计一个方法用于获取数组中元素的最大值 \n\n* 思路：\n\n  * ①定义一个数组，用静态初始化完成数组元素初始化\n  * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了\n  * ③调用获取最大值方法，用变量接收返回结果\n  * ④把结果输出在控制台\n\n* 代码：\n\n  ```java\n  public class MethodTest02 {\n      public static void main(String[] args) {\n          //定义一个数组，用静态初始化完成数组元素初始化\n          int[] arr = {12, 45, 98, 73, 60};\n  \n          //调用获取最大值方法，用变量接收返回结果\n          int number = getMax(arr);\n  \n          //把结果输出在控制台\n          System.out.println("number:" + number);\n      }\n  \n      //定义一个方法，用来获取数组中的最大值\n      /*\n          两个明确：\n              返回值类型：int\n              参数：int[] arr\n       */\n      public static int getMax(int[] arr) {\n          int max = arr[0];\n  \n          for(int x=1; x<arr.length; x++) {\n              if(arr[x] > max) {\n                  max = arr[x];\n              }\n          }\n          return max;\n      }\n  }\n  ```\n\n### 7.6 获取索引\n\n需求：\n\n​\t定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处，如果有重复的，只要获取第一个即可。\n\n代码示例：\n\n```java\npackage com.itheima.demo;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        //定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处\n        //如果有重复的，只要获取第一个即可\n\n        int[] arr = {1,2,3,4,5};\n        int index = contains(arr, 3);\n        System.out.println(index);\n    }\n\n    //1. 我要干嘛？判断数组中的某一个数是否存在\n    //2. 需要什么？数组 数字\n    //3. 调用处是否需要继续使用？返回\n    //获取number在arr中的位置\n    public static int contains(int[] arr, int number) {\n        //遍历arr得到每一个元素\n        for (int i = 0; i < arr.length; i++) {\n            //拿着每一个元素跟number比较\n            if(arr[i] == number){\n                //如果相等，表示找到了\n                return i;\n            }\n        }\n        //当循环结束之后，如果还不能返回索引，表示数组中不存在该数据\n        //可以返回-1\n        return -1;\n    }\n}\n\n```\n\n\n\n\n\n'},{title:"综合练习",headers:[{level:2,title:"练习一：飞机票",slug:"练习一-飞机票",link:"#练习一-飞机票",children:[]},{level:2,title:"练习二：打印素数",slug:"练习二-打印素数",link:"#练习二-打印素数",children:[]},{level:2,title:"练习三：验证码",slug:"练习三-验证码",link:"#练习三-验证码",children:[]},{level:2,title:"练习四：复制数组",slug:"练习四-复制数组",link:"#练习四-复制数组",children:[]},{level:2,title:"练习五：评委打分",slug:"练习五-评委打分",link:"#练习五-评委打分",children:[]},{level:2,title:"练习六：数字加密",slug:"练习六-数字加密",link:"#练习六-数字加密",children:[]},{level:2,title:"练习六扩展：",slug:"练习六扩展",link:"#练习六扩展",children:[]},{level:2,title:"练习七：数字解密",slug:"练习七-数字解密",link:"#练习七-数字解密",children:[]},{level:2,title:"练习八：抽奖",slug:"练习八-抽奖",link:"#练习八-抽奖",children:[{level:3,title:"解法一:",slug:"解法一",link:"#解法一",children:[]},{level:3,title:"解法二：",slug:"解法二",link:"#解法二",children:[]}]},{level:2,title:"练习九：双色球",slug:"练习九-双色球",link:"#练习九-双色球",children:[]}],path:"/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:'---\ntitle: 综合练习\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n综合练习\n\n\x3c!-- more --\x3e\n## 练习一：飞机票\n\n需求:\n\n​\t机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。\n\n​\t按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\nimport java.util.Scanner;\n\npublic class Test1 {\n    public static void main(String[] args) {\n        /* 机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。\n        按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。*/\n\n        //分析：\n        //1.键盘录入机票原价、月份、头等舱或经济舱\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入机票的原价");\n        int ticket = sc.nextInt();\n        System.out.println("请输入当前的月份");\n        int month = sc.nextInt();\n        System.out.println("请输入当前购买的舱位 0 头等舱 1 经济舱");\n        int seat = sc.nextInt();\n        //2.先判断月份是旺季还是淡季\n        //ctrl + alt + M 自动抽取方法\n        if (month >= 5 && month <= 10) {\n            //旺季 //3.继续判断当前机票是经济舱还是头等舱\n            //ticket = getPrice(ticket, seat, 0.9, 0.85);\n            ticket = getTicket(ticket, seat, 0.9, 0.85);\n        } else if ((month >= 1 && month <= 4) || (month >= 11 && month <= 12)) {\n            //淡季\n            //ticket = getPrice(ticket, seat, 0.7, 0.65);\n            ticket = getTicket(ticket, seat, 0.7, 0.65);\n        } else {\n            //表示键盘录入的月份是一个非法数据\n            System.out.println("键盘录入的月份不合法");\n        }\n\n        System.out.println(ticket);\n    }\n\n    public static int getTicket(int ticket, int seat, double v, double v2) {\n        if (seat == 0) {\n            //头等舱\n            ticket = (int) (ticket * v);\n        } else if (seat == 1) {\n            //经济舱\n            ticket = (int) (ticket * v2);\n        } else {\n            System.out.println("没有这个舱位");\n        }\n        return ticket;\n    }\n\n    //1.我要干嘛？根据舱位和折扣来计算最终的票价\n    //2.我干这件事，需要什么才能完成？原价 舱位 头等舱的折扣 经济舱的折扣\n    //3.方法的调用处是否需要继续使用这个结果  需要\n    /*  public static int getPrice(int ticket, int seat, double v0, double v1) {\n        if (seat == 0) {\n            //头等舱\n            ticket = (int) (ticket * v0);\n        } else if (seat == 1) {\n            //经济舱\n            ticket = (int) (ticket * v1);\n        } else {\n            System.out.println("没有这个舱位");\n        }\n        return ticket;\n    }*/\n}\n```\n\n## 练习二：打印素数\n\n​\t判断101~200之间有多少个素数，并输出所有素数。\n\n备注：素数就是质数\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\npublic class Test2 {\n    public static void main(String[] args) {\n        //判断 101 ~ 200 之间有多少个素数，并打印所有素数\n\n        //思路一： 2 ~ 99\n        //定义变量i ，赋值100\n        //判断i是否为质数\n\n        //定义一个变量用来统计有多少个质数\n        int count = 0;\n        //外循环：遍历101~200这个范围，依次得到这个范围之内的每一个数字\n        for (int i = 101; i <= 200; i++) {\n            //i 依次表示循环中的每一个数字\n            //继续判断i是否为一个质数\n            boolean flag = true;\n            //内循环:判断当前数字是否为一个质数。\n            for (int j = 2; j < i; j++) {\n                //j 表示2~99之间的每一个数字\n                if(i % j == 0){\n                    flag = false;\n                    //跳出单层循环，内循环\n                    break;\n                }\n            }\n            if(flag){\n                System.out.println("当前数字"+i+"是质数");\n                count++;\n            }\n        }\n\n        System.out.println("一共有" + count + "个质数");\n\n        /* int i = 7;\n        boolean flag = true;\n        for (int j = 2; j < i; j++) {\n            //j 表示2~99之间的每一个数字\n            if(i % j == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println("当前数字是质数");\n        }else{\n            System.out.println("当前数字不是一个质数");\n        }*/\n    }\n}\n\n```\n\n## 练习三：验证码\n\n需求：\n\n​\t定义方法实现随机产生一个5位的验证码\n\n验证码格式：\n\n​\t长度为5\n\n​\t前四位是大写字母或者小写字母\n\n​\t最后一位是数字\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*   需求：\n            定义方法实现随机产生一个5位的验证码\n            验证码格式：\n            长度为5\n            前四位是大写字母或者小写字母\n            最后一位是数字\n     */\n\n        //方法：\n        //在以后如果我们要在一堆没有什么规律的数据中随机抽取\n        //可以先把这些数据放到数组当中\n        //再随机抽取一个索引\n\n        //分析：\n        //1.大写字母和小写字母都放到数组当中\n        char[] chs = new char[52];\n        for (int i = 0; i < chs.length; i++) {\n            //ASCII码表\n            if(i <= 25){\n                //添加小写字母\n                chs[i] = (char)(97 + i);\n            }else{//27\n                //添加大写字母\n                // A --- 65\n                chs[i] = (char)(65 + i - 26);\n            }\n        }\n\n        //定义一个字符串类型的变量，用来记录最终的结果\n        String result = "";\n\n        //2.随机抽取4次\n        //随机抽取数组中的索引\n        Random r = new Random();\n        for (int i = 0; i < 4; i++) {\n            int randomIndex = r.nextInt(chs.length);\n            //利用随机索引，获取对应的元素\n            //System.out.println(chs[randomIndex]);\n            result = result + chs[randomIndex];\n        }\n        //System.out.println(result);\n        //3.随机抽取一个数字0~9\n        int number = r.nextInt(10);\n        //生成最终的结果\n        result = result + number;\n\n        //打印最终结果\n        System.out.println(result);\n\n    }\n}\n\n```\n\n## 练习四：复制数组\n\n需求：\n\n​\t把一个数组中的元素复制到另一个新数组中去。\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        /* 需求：\n        把一个数组中的元素复制到另一个新数组中去。*/\n\n        //分析：\n        //1.定义一个老数组并存储一些元素\n        int[] arr = {1,2,3,4,5};\n        //2.定义一个新数组的长度跟老数组一致\n        int[] newArr = new int[arr.length];\n        //3.遍历老数组，得到老数组中的每一个元素，依次存入到新数组当中\n        for (int i = 0; i < arr.length; i++) {\n            //i 表示老数组中的索引。新数组中的每一个索引\n            //arr[i]  表示老数组中的元素\n            newArr[i] = arr[i];\n        }\n\n        //4.新数组中已经存满元素了\n        for (int i = 0; i < newArr.length; i++) {\n            System.out.println(newArr[i]);\n        }\n\n    }\n}\n\n```\n\n## 练习五：评委打分\n\n需求 :  \n\n​\t在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\nimport java.util.Scanner;\n\npublic class Test5 {\n    public static void main(String[] args) {\n        //在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。\n        // 选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。\n\n\n        //分析：\n        //1.定义一个数组，用来存储6名评委的打分（0~100）\n        int[] scoreArr = getScores();\n        for (int i = 0; i < scoreArr.length; i++) {\n            System.out.println(scoreArr[i]);\n        }\n        //2.求出数组中的最大值\n        int max = getMax(scoreArr);\n        //3.求出数组中的最小值\n        int min = getMin(scoreArr);\n        //4.求出数组中6个分数的总和\n        int sum = getSum(scoreArr);\n        //5.（总和 - 最大值 - 最小值 ）/4\n        int avg =  (sum - max - min)/(scoreArr.length - 2);\n        //6.打印结果\n        System.out.println("选手的最终得分为：" + avg);\n    }\n\n\n    public static int getSum(int[] scoreArr){\n        int sum = 0;\n        for (int i = 0; i < scoreArr.length; i++) {\n            sum = sum + scoreArr[i];\n        }\n        return  sum;\n\n    }\n\n\n\n    //求数组的最大值\n    public static int getMax(int[] scoreArr){\n        int max = scoreArr[0];\n        for (int i = 1; i < scoreArr.length; i++) {\n            if(scoreArr[i] > max){\n                max = scoreArr[i];\n            }\n        }\n        return max;\n    }\n\n    //求数组的最小值\n    public static int getMin(int[] scoreArr){\n        int min = scoreArr[0];\n        for (int i = 1; i < scoreArr.length; i++) {\n            if(scoreArr[i] < min){\n                min = scoreArr[i];\n            }\n        }\n        return min;\n    }\n\n\n\n    //1.我要干嘛？定义一个数组，用来存储6名评委的打分（0~100）\n    //2.我需要什么？都不需要\n    //3.干完了这件事情，是否需要返回？必须返回\n    public static int[] getScores(){\n        //定义数组\n        int[] scores = new int[6];\n        //使用键盘录入的形式，输入分数：0~100\n        Scanner sc = new Scanner(System.in);\n        for (int i = 0; i < scores.length; ) {\n            System.out.println("请输入评委的打分");\n            int score = sc.nextInt();//100\n            if(score >=0 && score<= 100){\n                scores[i] = score;\n                i++;\n            }else{\n                System.out.println("成绩超出了范围,继续录入，当前的i为：" + i);\n            }\n        }\n        return  scores;\n    }\n}\n```\n\n\n\n## 练习六：数字加密\n\n需求：\n\n​\t某系统的数字密码（大于0），比如1983，采用加密方式进行传输。\n\n规则如下：\n\n​\t先得到每位数，然后每位数都加上5 , 再对10求余，最后将所有数字反转，得到一串新数。\n\n举例：\n\n```java\n\t\t1\t9\t8\t3\n+5\t\t6   14  13  8\n%10\t\t6   4   3   8\n反转\t   8   3   4   6\n加密后的结果就是：8346\n```\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\npublic class Test6 {\n    public static void main(String[] args) {\n        /*\n        某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，\n        规则如下：\n            每位数加上5\n            再对10求余，\n            最后将所有数字反转，\n            得到一串新数。\n*/\n\n\n        //分析：\n        //1.把整数里面的每一位放到数组当中\n        int[] arr = {1, 9, 8, 3};\n        //2.加密\n        //每位数加上5\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] + 5;\n        }\n        //再对10求余，\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] % 10;\n        }\n        //将所有数字反转\n        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n        //8 3 4 6 --\x3e 8346\n        //3.把数组里面的每一个数字进行拼接，变成加密之后的结果\n        int number = 0;\n        for (int i = 0; i < arr.length; i++) {\n            number = number * 10 + arr[i];\n        }\n        System.out.println(number);\n    }\n}\n```\n\n## 练习六扩展：\n\n```java\npackage com.itheima.test;\n\npublic class Test7 {\n    public static void main(String[] args) {\n        //需求：\n        //把整数上的每一位都添加到数组当中\n        //反向推导\n\n\n\n        //1.计算出数组的长度\n        int number = 12345;\n        //定义一个变量临时记录number的值，就是为了第三步的时候再次使用\n        int temp = number;\n        //定义一个变量进行统计\n        int count = 0;\n        while(number != 0){\n            //每一次循环就去掉右边的一个数字\n            number = number / 10;\n            //去掉一位计数器就自增一次。\n            count++;\n        }\n        //2.定义数组\n        //动态初始化\n        int[] arr = new int[count];\n        //3.把整数上的每一位都添加到数组当中\n        int index = arr.length -1;\n        while(temp != 0){//12345\n            //获取temp里面的每一位数组\n            int ge = temp % 10;\n            //再去掉右边的那位数字\n            temp = temp / 10;\n            //把当前获取到的个位添加到数组当中\n            arr[index] = ge;\n            index--;\n        }\n        //验证结果  1  2  3  4 5\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n    }\n}\n```\n\n\n\n\n\n## 练习七：数字解密\n\n把上一题加密之后的数据进行解密\n\n代码示例：\n\n```java\npackage com.itheima.test;\n\npublic class Test8 {\n    public static void main(String[] args) {\n        /*某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，\n        规则如下：\n            每位数加上5\n            再对10求余，\n            最后将所有数字反转，\n            得到一串新数。\n            按照以上规则进行解密：\n            比如1983加密之后变成8346，解密之后变成1983\n        */\n\n\n        //1.定义数组记录解密之后的结果\n        int[] arr = {8, 3, 4, 6};\n        //2.反转\n        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n        //3.由于加密是通过对10取余的方式进行获取的\n        //所以在解密的时候就需要判断，0~4之间+10  5~9数字不变\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] >= 0 && arr[i] <= 4) {\n                arr[i] = arr[i] + 10;\n            }\n        }\n        //4.每一位减5\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] - 5;\n        }\n        //5.获取数组里面的每一位数字拼接成最终的结果\n        int number = 0;\n        for (int i = 0; i < arr.length; i++) {\n            number = number * 10 + arr[i];\n        }\n        System.out.println(number);\n\n\n\n\n    }\n}\n\n```\n\n\n\n\n\n## 练习八：抽奖\n\n需求：\n\n​\t一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。打印效果如下：（随机顺序，不一定是下面的顺序）\n\n```java\n888元的奖金被抽出\n588元的奖金被抽出\n10000元的奖金被抽出\n1000元的奖金被抽出\n2元的奖金被抽出\n```\n\n### 解法一:\n\n```java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test9 {\n    public static void main(String[] args) {\n        /* 需求：\n        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。\n        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。\n        打印效果如下：（随机顺序，不一定是下面的顺序）\n            888元的奖金被抽出\n            588元的奖金被抽出\n            10000元的奖金被抽出\n            1000元的奖金被抽出\n            2元的奖金被抽出\n        */\n\n\n        //分析：\n        //1.定义数组表示奖池\n        int[] arr = {2, 588, 888, 1000, 10000};\n        //2.定义新数组用于存储抽奖的结果\n        int[] newArr = new int[arr.length];\n        //3.抽奖\n        Random r = new Random();\n        //因为有5个奖项，所以这里要循环5次\n        for (int i = 0; i < 5; ) {\n            //获取随机索引\n            int randomIndex = r.nextInt(arr.length);\n            //获取奖项\n            int prize = arr[randomIndex];\n            //判断当前的奖项是否存在，如果存在则重新抽取，如果不存在，就表示是有效奖项\n            boolean flag = contains(newArr, prize);\n            if(!flag){\n                //把当前抽取到的奖项添加到newArr当中\n                newArr[i] = prize;\n                //添加完毕之后，移动索引\n                i++;\n            }\n        }\n        //4.遍历newArr\n        for (int i = 0; i < newArr.length; i++) {\n            System.out.println(newArr[i]);\n        }\n\n\n    }\n\n    //判断prize在数组当中是否存在\n    //存在：true\n    //不存在：false\n    public static boolean contains(int[] arr,int prize){\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == prize){\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n}\n\n```\n\n### 解法二：\n\n```java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test10 {\n    public static void main(String[] args) {\n       /* 需求：\n        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。\n        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。\n        打印效果如下：（随机顺序，不一定是下面的顺序）\n            888元的奖金被抽出\n            588元的奖金被抽出\n            10000元的奖金被抽出\n            1000元的奖金被抽出\n            2元的奖金被抽出\n        */\n\n        //1.把奖池里面的所有奖项打乱顺序\n        int[] arr = {2, 588, 888, 1000, 10000};\n        Random r = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            //获取随机索引\n            int randomIndex = r.nextInt(arr.length);\n            //拿着i跟随机索引randomIndex上的值进行交换\n            int temp = arr[i];\n            arr[i] = arr[randomIndex];\n            arr[randomIndex] = temp;\n        }\n        //2.遍历奖池,从0索引开始获取每一个奖项\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n\n\n    }\n}\n```\n\n\n\n\n\n## 练习九：双色球\n\n ![图片1](img\\图片1.png)\n\n\n\n代码示例:\n\n```java\npackage com.itheima.test;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Test11 {\n    public static void main(String[] args) {\n        //1.生成中奖号码\n        int[] arr = createNumber(); // 123456  7\n\n        System.out.println("=======================");\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n\n        System.out.println("=======================");\n\n\n\n        //2.用户输入彩票号码（红球 + 蓝球）//654321\n        int[] userInputArr = userInputNumber();\n\n        //3.判断用户的中奖情况\n        //红球 蓝球\n        int redCount = 0;\n        int blueCount = 0;\n\n        //判断红球\n        for (int i = 0; i < userInputArr.length - 1; i++) {\n            int redNumber = userInputArr[i];\n            for (int j = 0; j < arr.length - 1; j++) {\n                if(redNumber == arr[j]){\n                    redCount++;\n                    //如果找到了，那么后面的数字就没有必要继续比较了\n                    //跳出内循环，继续判断下一个红球号码是否中奖\n                    break;\n                }\n            }\n        }\n\n        //判断蓝球\n        int blueNumber = userInputArr[userInputArr.length-1];\n        if(blueNumber == arr[arr.length - 1]){\n            blueCount++;\n        }\n\n        //根据红球的个数以及蓝球的个数来判断中奖情况\n        if(redCount == 6 && blueCount == 1){\n            System.out.println("恭喜你，中奖1000万");\n        }else if(redCount == 6 && blueCount == 0){\n            System.out.println("恭喜你，中奖500万");\n        }else if(redCount == 5 && blueCount == 1){\n            System.out.println("恭喜你，中奖3000");\n        }else if((redCount == 5 && blueCount == 0) ||  (redCount == 4 && blueCount == 1)){\n            System.out.println("恭喜你，中奖200");\n        }else if((redCount == 4 && blueCount == 0) ||  (redCount == 3 && blueCount == 1)){\n            System.out.println("恭喜你，中奖10");\n        }else if((redCount == 2 && blueCount == 1) ||  (redCount == 1 && blueCount == 1)|| (redCount == 0 && blueCount == 1)){\n            System.out.println("恭喜你，中奖5");\n        }else{\n            System.out.println("谢谢参与，谢谢惠顾");\n        }\n\n    }\n\n    public static int[] userInputNumber() {\n        //1.创建数组用于添加用户购买的彩票号码\n        //6个红球 1个蓝球 数组长度：7\n        int[] arr = new int[7];\n\n        //2.利用键盘录入让用输入\n        Scanner sc = new Scanner(System.in);\n        //让用户输入红球号码\n        for (int i = 0; i < 6; ) {\n            System.out.println("请输入第" + (i + 1) + "个红球号码");\n            int redNumber = sc.nextInt();\n            //redNumber  在1~33  唯一不重复\n            if (redNumber >= 1 && redNumber <= 33) {\n                boolean flag = contains(arr, redNumber);\n                if (!flag) {\n                    //不存在\n                    //有效的，可以添加到数组当中\n                    arr[i] = redNumber;\n                    i++;\n                } else {\n                    //存在\n                    System.out.println("当前红球号码已经存在，请重新输入");\n                }\n            } else {\n                System.out.println("当前红球号码超出范围");\n            }\n        }\n\n        //让用户输入篮球号码\n        System.out.println("请输入篮球号码");\n        //1~16\n        while (true) {\n            int blueNumber = sc.nextInt();\n            if (blueNumber >= 1 && blueNumber <= 16) {\n                arr[arr.length - 1] = blueNumber;\n                break;\n            } else {\n                System.out.println("当前篮球号码超出范围");\n            }\n        }\n        return arr;\n\n    }\n\n\n    public static int[] createNumber() {\n        //1.创建数组用于添加中奖号码\n        //6个红球 1个蓝球 数组长度：7\n        int[] arr = new int[7];\n\n        //2.随机生成号码并添加到数组当中\n        //红球：不能重复的  1 2 3 4 5 6\n        //蓝球：可以跟红球号码重复 5\n\n        //生成红球号码并添加到数组当中\n        Random r = new Random();\n        for (int i = 0; i < 6; ) {\n            //获取红球号码\n            int redNumber = r.nextInt(33) + 1;\n            boolean flag = contains(arr, redNumber);\n            if (!flag) {\n                //把红球号码添加到数组当中\n                arr[i] = redNumber;\n                i++;\n            }\n        }\n\n        //生成蓝球号码并添加到数组当中\n        int blueNumber = r.nextInt(16) + 1;\n        arr[arr.length - 1] = blueNumber;\n        return arr;\n    }\n\n    //用于判断数组在数组中是否存在\n    public static boolean contains(int[] arr, int number) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == number) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\n'},{title:"类和对象",headers:[{level:2,title:"1. 类和对象",slug:"_1-类和对象",link:"#_1-类和对象",children:[{level:3,title:"1.1 类和对象的理解",slug:"_1-1-类和对象的理解",link:"#_1-1-类和对象的理解",children:[]},{level:3,title:"1.2 类的定义",slug:"_1-2-类的定义",link:"#_1-2-类的定义",children:[]},{level:3,title:"1.3 对象的使用",slug:"_1-3-对象的使用",link:"#_1-3-对象的使用",children:[]},{level:3,title:"1.4 学生对象-练习",slug:"_1-4-学生对象-练习",link:"#_1-4-学生对象-练习",children:[]}]},{level:2,title:"2. 对象内存图",slug:"_2-对象内存图",link:"#_2-对象内存图",children:[{level:3,title:"2.1 单个对象内存图",slug:"_2-1-单个对象内存图",link:"#_2-1-单个对象内存图",children:[]},{level:3,title:"2.2 多个对象内存图",slug:"_2-2-多个对象内存图",link:"#_2-2-多个对象内存图",children:[]}]},{level:2,title:"3. 成员变量和局部变量",slug:"_3-成员变量和局部变量",link:"#_3-成员变量和局部变量",children:[{level:3,title:"3.1 成员变量和局部变量的区别",slug:"_3-1-成员变量和局部变量的区别",link:"#_3-1-成员变量和局部变量的区别",children:[]}]},{level:2,title:"4. 封装",slug:"_4-封装",link:"#_4-封装",children:[{level:3,title:"4.1 封装思想",slug:"_4-1-封装思想",link:"#_4-1-封装思想",children:[]},{level:3,title:"4.2 private关键字",slug:"_4-2-private关键字",link:"#_4-2-private关键字",children:[]},{level:3,title:"4.3 private的使用",slug:"_4-3-private的使用",link:"#_4-3-private的使用",children:[]},{level:3,title:"4.4 this关键字",slug:"_4-4-this关键字",link:"#_4-4-this关键字",children:[]}]},{level:2,title:"5. 构造方法",slug:"_5-构造方法",link:"#_5-构造方法",children:[{level:3,title:"5.1 构造方法概述",slug:"_5-1-构造方法概述",link:"#_5-1-构造方法概述",children:[]},{level:3,title:"5.2 构造方法的注意事项",slug:"_5-2-构造方法的注意事项",link:"#_5-2-构造方法的注意事项",children:[]},{level:3,title:"5.3 标准类制作",slug:"_5-3-标准类制作",link:"#_5-3-标准类制作",children:[]},{level:3,title:"5.4 练习1",slug:"_5-4-练习1",link:"#_5-4-练习1",children:[]},{level:3,title:"5.4 练习2",slug:"_5-4-练习2",link:"#_5-4-练习2",children:[]}]}],path:"/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",pathLocale:"/",extraFields:'---\ntitle: 类和对象\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n类和对象\n\n\x3c!-- more --\x3e\n## 1. 类和对象\n\n### 1.1 类和对象的理解\n\n客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\n\n* 类\n  * 类的理解\n    * 类是对现实生活中一类具有共同属性和行为的事物的抽象\n    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合\n    * 简单理解：类就是对现实事物的一种描述\n  * 类的组成\n    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）\n    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）\n* 类和对象的关系\n  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象\n  * 对象：是能够看得到摸的着的真实存在的实体\n  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**\n\n### 1.2 类的定义\n\n类的组成是由属性和行为两部分组成\n\n* 属性：在类中通过成员变量来体现（类中方法外的变量）\n* 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）\n\n类的定义步骤：\n\n①定义类\n\n②编写类的成员变量\n\n③编写类的成员方法\n\n```java\npublic class 类名 {\n\t// 成员变量\n\t变量1的数据类型 变量1；\n\t变量2的数据类型 变量2;\n\t…\n\t// 成员方法\n\t方法1;\n\t方法2;\t\n}\n```\n\n示例代码：\n\n```java\n/*\n    手机类：\n        类名：\n        手机(Phone)\n\n        成员变量：\n        品牌(brand)\n        价格(price)\n\n        成员方法：\n        打电话(call)\n        发短信(sendMessage)\n */\npublic class Phone {\n    //成员变量\n    String brand;\n    int price;\n\n    //成员方法\n    public void call() {\n        System.out.println("打电话");\n    }\n\n    public void sendMessage() {\n        System.out.println("发短信");\n    }\n}\n\n```\n\n### 1.3 对象的使用\n\n* 创建对象的格式：\n  * 类名 对象名 = new 类名();\n* 调用成员的格式：\n  * 对象名.成员变量\n  * 对象名.成员方法();\n* 示例代码\n\n```java\n/*\n    创建对象\n        格式：类名 对象名 = new 类名();\n        范例：Phone p = new Phone();\n\n    使用对象\n        1：使用成员变量\n            格式：对象名.变量名\n            范例：p.brand\n        2：使用成员方法\n            格式：对象名.方法名()\n            范例：p.call()\n */\npublic class PhoneDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Phone p = new Phone();\n\n        //使用成员变量\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        p.brand = "小米";\n        p.price = 2999;\n\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        //使用成员方法\n        p.call();\n        p.sendMessage();\n    }\n}\n```\n\n### 1.4 学生对象-练习\n\n* 需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用\n* 分析：\n  * 成员变量：姓名，年龄…\n  * 成员方法：学习，做作业…\n* 示例代码：\n\n```java\npublic class Student {\n    //成员变量\n    String name;\n    int age;\n\n    //成员方法\n    public void study() {\n        System.out.println("好好学习，天天向上");\n    }\n\n    public void doHomework() {\n        System.out.println("键盘敲烂，月薪过万");\n    }\n}\n/*\n    学生测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n\n        //使用对象\n        System.out.println(s.name + "," + s.age);\n\n        s.name = "林青霞";\n        s.age = 30;\n\n        System.out.println(s.name + "," + s.age);\n\n        s.study();\n        s.doHomework();\n    }\n}\n```\n\n## 2. 对象内存图\n\n### 2.1 单个对象内存图\n\n* 成员变量使用过程\n\n![1](images\\1.png)\n\n* 成员方法调用过程\n\n![2](images\\2.png)\n\n### 2.2 多个对象内存图\n\n* 成员变量使用过程\n\n![3](images\\3.png)\n\n* 成员方法调用过程\n\n![4](images\\4.png)\n\n* 总结：\n\n  多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份\n\n## 3. 成员变量和局部变量\n\n### 3.1 成员变量和局部变量的区别\n\n* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）\n* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）\n* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）\n* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）\n\n## 4. 封装\n\n### 4.1 封装思想\n\n1. 封装概述\n   是面向对象三大特征之一（封装，继承，多态）\n\n   **对象代表什么，就得封装对应的数据，并提供数据对应的行为** \n\n2. 封装代码实现\n   将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问\n   成员变量private，提供对应的getXxx()/setXxx()方法\n\n### 4.2 private关键字\n\nprivate是一个修饰符，可以用来修饰成员（成员变量，成员方法）\n\n* 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作\n  * 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰\n  * 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰\n\n* 示例代码：\n\n  ```java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      String name;\n      private int age;\n  \n      //提供get/set方法\n      public void setAge(int a) {\n          if(a<0 || a>120) {\n              System.out.println("你给的年龄有误");\n          } else {\n              age = a;\n          }\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      //成员方法\n      public void show() {\n          System.out.println(name + "," + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n          //给成员变量赋值\n          s.name = "林青霞";\n          s.setAge(30);\n          //调用show方法\n          s.show();\n      }\n  }\n  ```\n\n### 4.3 private的使用\n\n* 需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30 \n\n* 示例代码：\n\n  ```java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      private String name;\n      private int age;\n  \n      //get/set方法\n      public void setName(String n) {\n          name = n;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setAge(int a) {\n          age = a;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void show() {\n          System.out.println(name + "," + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n  \n          //使用set方法给成员变量赋值\n          s.setName("林青霞");\n          s.setAge(30);\n  \n          s.show();\n  \n          //使用get方法获取成员变量的值\n          System.out.println(s.getName() + "---" + s.getAge());\n          System.out.println(s.getName() + "," + s.getAge());\n  \n      }\n  }\n  ```\n\n### 4.4 this关键字\n\n* this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）\n  * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量\n  * 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n```\n\n## 5. 构造方法\n\n### 5.1 构造方法概述\n\n构造方法是一种特殊的方法\n\n* 作用：创建对象   Student stu = **new Student();**\n\n* 格式：\n\n  public class 类名{\n\n  ​        修饰符 类名( 参数 ) {\n\n  ​        }\n\n  }\n\n* 功能：主要是完成对象数据的初始化\n\n* 示例代码：\n\n```java\nclass Student {\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n        System.out.println("无参构造方法");\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n        s.show();\n    }\n}\n```\n\n### 5.2 构造方法的注意事项\n\n* 构造方法的创建\n\n如果没有定义构造方法，系统将给出一个默认的无参数构造方法\n如果定义了构造方法，系统将不再提供默认的构造方法\n\n* 构造方法的重载\n\n如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法\n\n* 推荐的使用方式\n\n无论是否使用，都手工书写无参数构造方法\n\n* 重要功能！\n\n可以使用带参构造，为成员变量进行初始化\n\n* 示例代码\n\n```java\n/*\n    学生类\n */\nclass Student {\n    private String name;\n    private int age;\n\n    public Student() {}\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public Student(String name,int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s1 = new Student();\n        s1.show();\n\n        //public Student(String name)\n        Student s2 = new Student("林青霞");\n        s2.show();\n\n        //public Student(int age)\n        Student s3 = new Student(30);\n        s3.show();\n\n        //public Student(String name,int age)\n        Student s4 = new Student("林青霞",30);\n        s4.show();\n    }\n}\n```\n\n### 5.3 标准类制作\n\n① 类名需要见名知意\n\n② 成员变量使用private修饰\n\n③ 提供至少两个构造方法 \n\n* 无参构造方法\n* 带全部参数的构造方法\n\n④ get和set方法 \n\n​\t提供每一个成员变量对应的setXxx()/getXxx()\n\n⑤ 如果还有其他行为，也需要写上\n\n### 5.4 练习1\n\n需求：\n\n​\t定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 \n\n* 示例代码：\n\n```java\nclass Student {\n    //成员变量\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    //成员方法\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    创建对象并为其成员变量赋值的两种方式\n        1:无参构造方法创建对象后使用setXxx()赋值\n        2:使用带参构造方法直接创建带有属性值的对象\n*/\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //无参构造方法创建对象后使用setXxx()赋值\n        Student s1 = new Student();\n        s1.setName("林青霞");\n        s1.setAge(30);\n        s1.show();\n\n        //使用带参构造方法直接创建带有属性值的对象\n        Student s2 = new Student("林青霞",30);\n        s2.show();\n    }\n}\n```\n\n### 5.4 练习2\n\n![111](images\\111.jpg)\n\n```java\npublic class User {\n    //1.私有化全部的成员变量\n    //2.空参构造\n    //3.带全部参数的构造\n    //4.针对于每一个私有化的成员变量都要提供其对应的get和set方法\n    //5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为\n\n    private String username;//用户名\n    private String password;//密码\n    private String email;//邮箱\n    private char gender;//性别\n    private int age;//年龄\n\n    //空参构造方法\n    public User() {\n    }\n\n    //带全部参数的构造\n    public User(String username, String password, String email, char gender, int age) {\n        this.username = username;\n        this.password = password;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n\n    //get和set\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void eat(){\n        System.out.println(username + "在吃饭");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //写一个标准的javabean类\n        //咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了\n\n\n        //利用空参构造创建对象\n        User u1 = new User();\n        //如果利用空参创建对象，还想赋值只能用set方法赋值\n        u1.setUsername("zhangsan");\n        u1.setPassword("1234qwer");\n        u1.setEmail("itheima@itcast.cn");\n        u1.setGender(\'男\');\n        u1.setAge(23);\n        //获取属性的值并打印\n        System.out.println(u1.getUsername() + ", " + u1.getPassword()\n                + ", " + u1.getEmail() + ", " + u1.getGender() + ", " + u1.getAge());\n        u1.eat();\n\n        System.out.println("=============================");\n\n        //简单的办法\n        //利用带全部参数的构造来创建对象\n        //快捷键:ctrl + p\n        User u2 = new User("lisi","12345678","lisi@itcast.cn",\'女\',24);\n        System.out.println(u2.getUsername() + ", " + u2.getPassword()\n                + ", " + u2.getEmail() + ", " + u2.getGender() + ", " + u2.getAge());\n        u2.eat();\n    }\n}\n\n```\n\n'},{title:"扩展：键盘录入笔记",headers:[{level:2,title:"1）next（）、nextLine（）：",slug:"_1-next-、nextline",link:"#_1-next-、nextline",children:[{level:3,title:"代码示例：",slug:"代码示例",link:"#代码示例",children:[]},{level:3,title:"代码示例：",slug:"代码示例-1",link:"#代码示例-1",children:[]}]},{level:2,title:"2）nextInt（）：",slug:"_2-nextint",link:"#_2-nextint",children:[{level:3,title:"代码示例：",slug:"代码示例-2",link:"#代码示例-2",children:[]}]},{level:2,title:"3）nextDouble（）：",slug:"_3-nextdouble",link:"#_3-nextdouble",children:[{level:3,title:"代码示例：",slug:"代码示例-3",link:"#代码示例-3",children:[]},{level:3,title:"第一个细节：",slug:"第一个细节",link:"#第一个细节",children:[]},{level:3,title:"第二个细节：",slug:"第二个细节",link:"#第二个细节",children:[]},{level:3,title:"第三个细节：",slug:"第三个细节",link:"#第三个细节",children:[]},{level:3,title:"代码示例：",slug:"代码示例-5",link:"#代码示例-5",children:[]}]}],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:'---\ntitle: 扩展：键盘录入笔记\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n扩展：键盘录入笔记\n\n\x3c!-- more --\x3e\n# 一，键盘录入涉及到的方法如下：\n\n​\tnext（）、nextLine（）、nextInt（）、nextDouble（）。\n\n## 1）next（）、nextLine（）：\n\n可以接受任意数据，但是都会返回一个字符串。\n\n比如：键盘录入abc，那么会把abc看做字符串返回。\n\n​\t   键盘录入123，那么会把123看做字符串返回。\n\n### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.next();//录入的所有数据都会看做是字符串\nSystem.out.println(s);\n```\n\n### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();//录入的所有数据都会看做是字符串\nSystem.out.println(s);\n```\n\n## 2）nextInt（）：\n\n​\t只能接受整数。\n\n比如：键盘录入123，那么会把123当做int类型的整数返回。\n\n​\t  键盘录入小数或者其他字母，就会报错。\n\n### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nint s = sc.nextInt();//只能录入整数\nSystem.out.println(s);\n```\n\n## 3）nextDouble（）：\n\n​\t能接收整数和小数，但是都会看做小数返回。\n\n​\t录入字母会报错。\n\n### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\ndouble d = sc.nextDouble();//录入的整数，小数都会看做小数。\n\t\t\t\t\t\t//录入字母会报错\nSystem.out.println(d);\n```\n\n# 二，方法底层细节 ：\n\n### 第一个细节：\n\nnext（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。\n\n#### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\ndouble d = sc.nextDouble();\nSystem.out.println(d);\n//键盘录入：1.1 2.2//注意录入的时候1.1和2.2之间加空格隔开。\n//此时控制台打印1.1\n//表示nextDouble方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。\n```\n\n```java\nScanner sc = new Scanner(System.in);\nint i = sc.nextInt();\nSystem.out.println(i);\n//键盘录入：1 2//注意录入的时候1和2之间加空格隔开。\n//此时控制台打印1\n//表示nextInt方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。\n```\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.next();\nSystem.out.println(s);\n//键盘录入：a b//注意录入的时候a和b之间加空格隔开。\n//此时控制台打印a\n//表示next方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。\n```\n\n### 第二个细节：\n\nnext（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。但是这些符号 + 后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。\n\n代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nString s1 = sc.next();\nString s2 = sc.next();\nSystem.out.println(s1);\nSystem.out.println(s2);\n//此时值键盘录入一次a b(注意a和b之间用空格隔开)\n//那么第一个next();会接收a，a后面是空格，那么就停止，所以打印s1是a\n//但是空格+b还在内存中。\n//第二个next会去掉前面的空格，只接收b\n//所以第二个s2打印出来是b\n```\n\n### 第三个细节：\n\nnextLine（）方法是把一整行全部接收完毕。\n\n代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();\nSystem.out.println(s);\n//键盘录入a b(注意a和b之间用空格隔开)\n//那么nextLine不会过滤前面和后面的空格，会把这一整行数据全部接收完毕。\n```\n\n# 三、混用引起的后果\n\n上面说的两套键盘录入不能混用，如果混用会有严重的后果。\n\n代码示例：\n\n```java\nScanner sc = new Scanner(System.in);//①\nint i = sc.nextInt();//②\nString s = sc.nextLine();//③\nSystem.out.println(i);//④\nSystem.out.println(s);//⑤\n```\n\n当代码运行到第二行，会让我们键盘录入，此时录入123。\n\n但是实际上我们录的是123+回车。\n\n而nextInt是遇到空格，回车，制表符都会停止。\n\n所以nextInt只能接受123，回车还在内存中没有被接收。\n\n此时就被nextLine接收了。\n\n所以，如果混用就会导致nextLine接收不到数据。\n\n# 四、结论（如何使用）\n\n键盘录入分为两套：\n\n- next（）、nextInt（）、nextDouble（）这三个配套使用。\n\n如果用了这三个其中一个，就不要用nextLine（）。\n\n- nextLine（）单独使用。\n\n如果想要整数，那么先接收，再使用Integer.parseInt进行类型转换。\n\n### 代码示例：\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.next();//键盘录入123\nSystem.out.println("此时为字符串" + s);//此时123是字符串\nint i = sc.nextInt();//键盘录入123\nSystem.out.println("此时为整数：" + i);\n```\n\n```java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();//键盘录入123\nSystem.out.println("此时为字符串" + s);//此时123是字符串\nint i = Integer.parseInt(s);//想要整数再进行转换\nSystem.out.println("此时为整数：" + i);\n```\n\n\n\n\n\n\n\n\n\n'},{title:"面向对象综合训练综合练习",headers:[{level:2,title:"练习一：文字版格斗游戏",slug:"练习一-文字版格斗游戏",link:"#练习一-文字版格斗游戏",children:[]},{level:2,title:"练习二：文字版格斗游戏进阶",slug:"练习二-文字版格斗游戏进阶",link:"#练习二-文字版格斗游戏进阶",children:[]},{level:2,title:"练习三：对象数组（商品）",slug:"练习三-对象数组-商品",link:"#练习三-对象数组-商品",children:[]},{level:2,title:"练习四：对象数组（汽车）",slug:"练习四-对象数组-汽车",link:"#练习四-对象数组-汽车",children:[]},{level:2,title:"练习五：对象数组（手机）",slug:"练习五-对象数组-手机",link:"#练习五-对象数组-手机",children:[]},{level:2,title:"练习六：对象数组（女朋友）",slug:"练习六-对象数组-女朋友",link:"#练习六-对象数组-女朋友",children:[]},{level:2,title:"练习七：复杂的对象数组操作",slug:"练习七-复杂的对象数组操作",link:"#练习七-复杂的对象数组操作",children:[]}],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:'---\ntitle: 面向对象综合训练综合练习\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n面向对象综合训练综合练习\n\n\x3c!-- more --\x3e\n\n## 练习一：文字版格斗游戏 \n\n需求:\n\n​\t格斗游戏，每个游戏角色的姓名，血量，都不相同，在选定人物的时候（new对象的时候），这些信息就应该被确定下来。 \n\n举例：\n\n​\t程序运行之后结果为：\n\n​\t姓名为:乔峰\t\t血量为:100\n\n​\t姓名为:鸠摩智\t血量为:100\n\n​\t乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。\n\n​\t鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。\n\n​\t乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。\n\n​\t鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。\n\n​\t乔峰K.O.了鸠摩智 \n\n代码示例：\n\n```java\npublic class GameTest {\n    public static void main(String[] args) {\n        //1.创建第一个角色\n        Role r1 = new Role("乔峰",100);\n        //2.创建第二个角色\n        Role r2 = new Role("鸠摩智",100);\n\n        //3.开始格斗 回合制游戏\n        while(true){\n            //r1开始攻击r2\n            r1.attack(r2);\n            //判断r2的剩余血量\n            if(r2.getBlood() == 0){\n                System.out.println(r1.getName() + " K.O了" + r2.getName());\n                break;\n            }\n\n            //r2开始攻击r1\n            r2.attack(r1);\n            if(r1.getBlood() == 0){\n                System.out.println(r2.getName() + " K.O了" + r1.getName());\n                break;\n            }\n\n\n        }\n    }\n}\n\n\n\npublic class Role {\n    private String name;\n    private int blood;\n\n    public Role() {\n    }\n\n    public Role(String name, int blood) {\n        this.name = name;\n        this.blood = blood;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getBlood() {\n        return blood;\n    }\n\n    public void setBlood(int blood) {\n        this.blood = blood;\n    }\n\n\n    //定义一个方法用于攻击别人\n    //思考：谁攻击谁？\n    //Role r1 = new Role（）；\n    //Role r2 = new Role（）；\n    //r1.攻击(r2);\n    //方法的调用者去攻击参数\n    public void attack(Role role) {\n        //计算造成的伤害 1 ~ 20\n        Random r = new Random();\n        int hurt = r.nextInt(20) + 1;\n\n        //剩余血量\n        int remainBoold = role.getBlood() - hurt;\n        //对剩余血量做一个验证，如果为负数了，就修改为0\n        remainBoold = remainBoold < 0 ? 0 : remainBoold;\n        //修改一下挨揍的人的血量\n        role.setBlood(remainBoold);\n\n        //this表示方法的调用者\n        System.out.println(this.getName() + "举起拳头，打了" + role.getName() + "一下，" +\n                "造成了" + hurt + "点伤害，" + role.getName() + "还剩下了" + remainBoold + "点血");\n    }\n\n}\n```\n\n## 练习二：文字版格斗游戏进阶\n\n​\t在上一个的基础上，我想看到人物的性别和长相，打斗的时候我想看到武功招式。\n\n举例：\n\n​\t程序运行之后结果为：\n\n​\t姓名为:乔峰\t\t血量为:100\t性别为:男\t长相为:气宇轩昂\n\n​\t姓名为:鸠摩智\t血量为:100\t性别为:男\t长相为:气宇轩昂\n\n​\t乔峰使出了一招【背心钉】，转到对方的身后，一掌向鸠摩智背心的灵台穴拍去。给鸠摩智造成一处瘀伤。\n\n​\t鸠摩智使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向乔峰。结果乔峰退了半步，毫发无损。 \n\n​\t。。。。\n\n​\t乔峰K.O.了鸠摩智 \n\n分析：\n\n​\t长相是提前定义好的，提前放在一个数组当中，程序运行之后，从数组中随机获取。\n\n```java\n//男生长相数组\nString[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};\n//女生长相数组\nString[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};\n```\n\n​\t武功招式也是提前定义好的，提前放在一个数组当中，程序运行之后，从数组随机获取\n\n```java\n//attack 攻击描述：\nString[] attacks_desc = {\n    "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",\n    "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",\n    "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",\n    "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",\n    "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",\n    "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"\n```\n\n​\t受伤的提前也是提前定义好的，只不过不是随机了，根据剩余血量获取不同的描述\n\n```java\n//injured 受伤描述：\nString[] injureds_desc = {\n    "结果%s退了半步，毫发无损",\n    "结果给%s造成一处瘀伤",\n    "结果一击命中，%s痛得弯下腰",\n    "结果%s痛苦地闷哼了一声，显然受了点内伤",\n    "结果%s摇摇晃晃，一跤摔倒在地",\n    "结果%s脸色一下变得惨白，连退了好几步",\n    "结果『轰』的一声，%s口中鲜血狂喷而出",\n    "结果%s一声惨叫，像滩软泥般塌了下去"\n```\n\n​\t其中输出语句跟以前不一样了，用的是System.out.printf（）；该输出语句支持%s占位符\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        //两部分参数：\n        //第一部分参数：要输出的内容%s（占位）\n        //第二部分参数：填充的数据\n        \n        System.out.printf("你好啊%s","张三");//用张三填充第一个%s\n        System.out.println();//换行\n        System.out.printf("%s你好啊%s","张三","李四");//用张三填充第一个%s，李四填充第二个%s\n    }\n}\n```\n\n最终代码示例：\n\n```java\npackage com.itheima.test2;\n\nimport java.util.Random;\n\npublic class Role {\n    private String name;\n    private int blood;\n    private char gender;\n    private String face;//长相是随机的\n\n    String[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};\n    String[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};\n\n    //attack 攻击描述：\n    String[] attacks_desc = {\n            "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",\n            "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",\n            "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",\n            "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",\n            "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",\n            "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"\n    };\n\n    //injured 受伤描述：\n    String[] injureds_desc = {\n            "结果%s退了半步，毫发无损",\n            "结果给%s造成一处瘀伤",\n            "结果一击命中，%s痛得弯下腰",\n            "结果%s痛苦地闷哼了一声，显然受了点内伤",\n            "结果%s摇摇晃晃，一跤摔倒在地",\n            "结果%s脸色一下变得惨白，连退了好几步",\n            "结果『轰』的一声，%s口中鲜血狂喷而出",\n            "结果%s一声惨叫，像滩软泥般塌了下去"\n    };\n\n    public Role() {\n    }\n\n    public Role(String name, int blood, char gender) {\n        this.name = name;\n        this.blood = blood;\n        this.gender = gender;\n        //随机长相\n        setFace(gender);\n    }\n\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public String getFace() {\n        return face;\n    }\n\n    public void setFace(char gender) {\n        Random r = new Random();\n        //长相是随机的\n        if (gender == \'男\') {\n            //从boyfaces里面随机长相\n            int index = r.nextInt(boyfaces.length);\n            this.face = boyfaces[index];\n        } else if (gender == \'女\') {\n            //从girlfaces里面随机长相\n            int index = r.nextInt(girlfaces.length);\n            this.face = girlfaces[index];\n        } else {\n            this.face = "面目狰狞";\n        }\n\n\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getBlood() {\n        return blood;\n    }\n\n    public void setBlood(int blood) {\n        this.blood = blood;\n    }\n\n\n    //定义一个方法用于攻击别人\n    //思考：谁攻击谁？\n    //Role r1 = new Role（）；\n    //Role r2 = new Role（）；\n    //r1.攻击(r2);\n    //方法的调用者去攻击参数\n    public void attack(Role role) {\n        Random r = new Random();\n        int index = r.nextInt(attacks_desc.length);\n        String KungFu = attacks_desc[index];\n\n        //输出一个攻击的效果\n        System.out.printf(KungFu, this.getName(), role.getName());\n        System.out.println();\n\n        //计算造成的伤害 1 ~ 20\n        int hurt = r.nextInt(20) + 1;\n\n        //剩余血量\n        int remainBoold = role.getBlood() - hurt;\n        //对剩余血量做一个验证，如果为负数了，就修改为0\n        remainBoold = remainBoold < 0 ? 0 : remainBoold;\n        //修改一下挨揍的人的血量\n        role.setBlood(remainBoold);\n\n        //受伤的描述\n        //血量> 90 0索引的描述\n        //80 ~  90  1索引的描述\n        //70 ~  80  2索引的描述\n        //60 ~  70  3索引的描述\n        //40 ~  60  4索引的描述\n        //20 ~  40  5索引的描述\n        //10 ~  20  6索引的描述\n        //小于10的   7索引的描述\n        if (remainBoold > 90) {\n            System.out.printf(injureds_desc[0], role.getName());\n        }else if(remainBoold > 80 && remainBoold <= 90){\n            System.out.printf(injureds_desc[1], role.getName());\n        }else if(remainBoold > 70 && remainBoold <= 80){\n            System.out.printf(injureds_desc[2], role.getName());\n        }else if(remainBoold > 60 && remainBoold <= 70){\n            System.out.printf(injureds_desc[3], role.getName());\n        }else if(remainBoold > 40 && remainBoold <= 60){\n            System.out.printf(injureds_desc[4], role.getName());\n        }else if(remainBoold > 20 && remainBoold <= 40){\n            System.out.printf(injureds_desc[5], role.getName());\n        }else if(remainBoold > 10 && remainBoold <= 20){\n            System.out.printf(injureds_desc[6], role.getName());\n        }else{\n            System.out.printf(injureds_desc[7], role.getName());\n        }\n        System.out.println();\n\n\n    }\n\n\n    public void showRoleInfo() {\n        System.out.println("姓名为：" + getName());\n        System.out.println("血量为：" + getBlood());\n        System.out.println("性别为：" + getGender());\n        System.out.println("长相为：" + getFace());\n    }\n\n}\n\n\n\npackage com.itheima.test2;\n\npublic class GameTest {\n    public static void main(String[] args) {\n        //1.创建第一个角色\n        Role r1 = new Role("乔峰",100,\'男\');\n        //2.创建第二个角色\n        Role r2 = new Role("鸠摩智",100,\'男\');\n\n        //展示一下角色的信息\n        r1.showRoleInfo();\n        r2.showRoleInfo();\n\n        //3.开始格斗 回合制游戏\n        while(true){\n            //r1开始攻击r2\n            r1.attack(r2);\n            //判断r2的剩余血量\n            if(r2.getBlood() == 0){\n                System.out.println(r1.getName() + " K.O了" + r2.getName());\n                break;\n            }\n\n            //r2开始攻击r1\n            r2.attack(r1);\n            if(r1.getBlood() == 0){\n                System.out.println(r2.getName() + " K.O了" + r1.getName());\n                break;\n            }\n        }\n    }\n}\n\n```\n\n## 练习三：对象数组（商品）\n\n需求：\n\n​\t定义数组存储3个商品对象。\n\n​\t商品的属性：商品的id，名字，价格，库存。\n\n​\t创建三个商品对象，并把商品对象存入到数组当中。\n\n代码示例：\n\n```java\npackage com.itheima.test3;\n\npublic class Goods {\n    private String id;\n    private String name;\n    private double price;\n    private int count;\n\n    public Goods() {\n    }\n\n    public Goods(String id, String name, double price, int count) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n        this.count = count;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public void setCount(int count) {\n        this.count = count;\n    }\n}\n\n\n\npackage com.itheima.test3;\n\npublic class GoodsTest {\n    public static void main(String[] args) {\n        //1.创建一个数组\n        Goods[] arr = new Goods[3];\n\n        //2.创建三个商品对象\n        Goods g1 = new Goods("001","华为P40",5999.0,100);\n        Goods g2 = new Goods("002","保温杯",227.0,50);\n        Goods g3 = new Goods("003","枸杞",12.7,70);\n\n        //3.把商品添加到数组中\n        arr[0] = g1;\n        arr[1] = g2;\n        arr[2] = g3;\n\n        //4.遍历\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引 arr[i] 元素\n            Goods goods = arr[i];\n            System.out.println(goods.getId() + ", " + goods.getName() + ", " + goods.getPrice() + ", " + goods.getCount());\n        }\n    }\n}\n\n```\n\n## 练习四：对象数组（汽车）\n\n需求：\n\n​\t定义数组存储3部汽车对象。\n\n​\t汽车的属性：品牌，价格，颜色。\n\n​\t创建三个汽车对象，数据通过键盘录入而来，并把数据存入到数组当中。\n\n代码示例：\n\n```java\npackage com.itheima.test5;\n\npublic class Car {\n    private String brand;//品牌\n    private int price;//价格\n    private String color;//颜色\n\n\n    public Car() {\n    }\n\n    public Car(String brand, int price, String color) {\n        this.brand = brand;\n        this.price = price;\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npackage com.itheima.test5;\n\nimport java.util.Scanner;\n\npublic class CarTest {\n    public static void main(String[] args) {\n        //1.创建一个数组用来存3个汽车对象\n        Car[] arr = new Car[3];\n\n        //2.创建汽车对象，数据来自于键盘录入\n        Scanner sc = new Scanner(System.in);\n        for (int i = 0; i < arr.length; i++) {\n            //创建汽车的对象\n            Car c = new Car();\n            //录入品牌\n            System.out.println("请输入汽车的品牌");\n            String brand = sc.next();\n            c.setBrand(brand);\n            //录入价格\n            System.out.println("请输入汽车的价格");\n            int price = sc.nextInt();\n            c.setPrice(price);\n            //录入颜色\n            System.out.println("请输入汽车的颜色");\n            String color = sc.next();\n            c.setColor(color);\n\n            //把汽车对象添加到数组当中\n            arr[i] = c;\n        }\n\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            Car car = arr[i];\n            System.out.println(car.getBrand() + ", " + car.getPrice() + ", " + car.getColor());\n        }\n    }\n}\n\n```\n\n## 练习五：对象数组（手机）\n\n需求 :  \n\n​\t定义数组存储3部手机对象。\n\n​\t手机的属性：品牌，价格，颜色。\n\n​\t要求，计算出三部手机的平均价格\n\n代码示例：\n\n```java\npackage com.itheima.test6;\n\npublic class Phone {\n    private String brand;//品牌\n    private int price;//价格\n    private String color;//颜色\n\n    public Phone() {\n    }\n\n    public Phone(String brand, int price, String color) {\n        this.brand = brand;\n        this.price = price;\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npackage com.itheima.test6;\n\nimport java.math.BigDecimal;\n\npublic class PhoneTest {\n    public static void main(String[] args) {\n        //1.创建一个数组\n        Phone[] arr = new Phone[3];\n\n        //2.创建手机的对象\n        Phone p1 = new Phone("小米",1999,"白色");\n        Phone p2 = new Phone("华为",4999,"蓝色");\n        Phone p3 = new Phone("魅族",3999,"红色");\n\n        //3.把手机对象添加到数组当中\n        arr[0] = p1;\n        arr[1] = p2;\n        arr[2] = p3;\n\n        //4.获取三部手机的平均价格\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引  arr[i] 元素（手机对象）\n            Phone phone = arr[i];\n            sum = sum + phone.getPrice();\n        }\n\n        //5.求平均值\n        //数据能不写死，尽量不写死\n        //int avg = sum / arr.length;\n\n        double avg2 = sum * 1.0 / arr.length;\n\n        System.out.println(avg2);//3665.6666666666665\n    }\n}\n\n```\n\n## 练习六：对象数组（女朋友）\n\n需求：\n\n​\t定义数组存储4个女朋友的对象\n\n​\t女朋友的属性：姓名、年龄、性别、爱好\n\n​\t要求1：计算出四女朋友的平均年龄\n\n​\t要求2：统计年龄比平均值低的女朋友有几个？并把她们的所有信息打印出来。\n\n代码示例：\n\n```java\npackage com.itheima.test7;\n\npublic class GirlFriend {\n    private String name;//姓名\n    private int age;//年龄\n    private String gender;//性别\n    private String hobby;//爱好\n\n\n    public GirlFriend() {\n    }\n\n    public GirlFriend(String name, int age, String gender, String hobby) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.hobby = hobby;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getHobby() {\n        return hobby;\n    }\n\n    public void setHobby(String hobby) {\n        this.hobby = hobby;\n    }\n}\n\n\npackage com.itheima.test7;\n\npublic class GirlFriendTest {\n    public static void main(String[] args) {\n        //1.定义数组存入女朋友的对象\n        GirlFriend[] arr = new GirlFriend[4];\n\n        //2.创建女朋友对象\n        GirlFriend gf1 = new GirlFriend("小诗诗",18,"萌妹子","吃零食");\n        GirlFriend gf2 = new GirlFriend("小丹丹",19,"萌妹子","玩游戏");\n        GirlFriend gf3 = new GirlFriend("小惠惠",20,"萌妹子","看书，学习");\n        GirlFriend gf4 = new GirlFriend("小莉莉",21,"憨妹子","睡觉");\n\n        //3.把对象添加到数组当中\n        arr[0] = gf1;\n        arr[1] = gf2;\n        arr[2] = gf3;\n        arr[3] = gf4;\n\n        //4.求和\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引 arr[i] 元素（女朋友对象）\n            GirlFriend gf = arr[i];\n            //累加\n            sum = sum + gf.getAge();\n        }\n\n        //5.平均值\n        int avg = sum / arr.length;\n\n        //6.统计年龄比平均值低的有几个，打印他们的信息\n        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            GirlFriend gf = arr[i];\n            if(gf.getAge() < avg){\n                count++;\n                System.out.println(gf.getName() + ", " + gf.getAge() + ", " + gf.getGender() + ", " + gf.getHobby());\n            }\n        }\n\n        System.out.println(count + "个");\n    }\n}\n```\n\n## 练习七：复杂的对象数组操作\n\n定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n\n学生的属性：学号，姓名，年龄。\n\n要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\n\n要求2：添加完毕之后，遍历所有学生信息。\n\n要求3：通过id删除学生信息\n\n​             如果存在，则删除，如果不存在，则提示删除失败。\n\n要求4：删除完毕之后，遍历所有学生信息。\n\n要求5：查询数组id为“heima002”的学生，如果存在，则将他的年龄+1岁\n\n代码示例：\n\n```java\npackage com.itheima.test8;\n\npublic class Student {\n    private int id;\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public Student(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n        要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\n        要求2：添加完毕之后，遍历所有学生信息。\n\t\t*/\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n\n\n        //要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\n        Student stu4 = new Student(1, "zhaoliu", 26);\n\n        //唯一性判断\n        //已存在 --- 不用添加\n        //不存在 --- 就可以把学生对象添加进数组\n        boolean flag = contains(arr, stu4.getId());\n        if(flag){\n            //已存在 --- 不用添加\n            System.out.println("当前id重复，请修改id后再进行添加");\n        }else{\n            //不存在 --- 就可以把学生对象添加进数组\n            //把stu4添加到数组当中\n            //1.数组已经存满 --- 只能创建一个新的数组，新数组的长度 = 老数组 + 1\n            //2.数组没有存满 --- 直接添加\n            int count = getCount(arr);\n            if(count == arr.length){\n                //已经存满\n                //创建一个新的数组，长度 = 老数组的长度 + 1\n                //然后把老数组的元素，拷贝到新数组当中\n                Student[] newArr = creatNewArr(arr);\n                //把stu4添加进去\n                newArr[count] = stu4;\n\n                //要求2：添加完毕之后，遍历所有学生信息。\n                printArr(newArr);\n\n            }else{\n                //没有存满\n                //[stu1,stu2,null]\n                //getCount获取到的是2，表示数组当中已经有了2个元素\n                //还有一层意思：如果下一次要添加数据，就是添加到2索引的位置\n                arr[count] = stu4;\n                //要求2：添加完毕之后，遍历所有学生信息。\n                printArr(arr);\n\n            }\n        }\n    }\n\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n\n    //创建一个新的数组，长度 = 老数组的长度 + 1\n    //然后把老数组的元素，拷贝到新数组当中\n    public static Student[] creatNewArr(Student[] arr){\n        Student[] newArr = new Student[arr.length + 1];\n\n        //循环遍历得到老数组中的每一个元素\n        for (int i = 0; i < arr.length; i++) {\n            //把老数组中的元素添加到新数组当中\n            newArr[i] = arr[i];\n        }\n\n        //把新数组返回\n        return newArr;\n\n    }\n\n    //定义一个方法判断数组中已经存了几个元素\n    public static int getCount(Student[] arr){\n        //定义一个计数器用来统计\n        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] != null){\n                count++;\n            }\n        }\n        //当循环结束之后，我就知道了数组中一共有几个元素\n        return count;\n    }\n\n\n    //1.我要干嘛？  唯一性判断\n    //2.我干这件事情，需要什么才能完成？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 必须返回\n    public static boolean contains(Student[] arr, int id) {\n        for (int i = 0; i < arr.length; i++) {\n            //依次获取到数组里面的每一个学生对象\n            Student stu = arr[i];\n            if(stu != null){\n                //获取数组中学生对象的id\n                int sid = stu.getId();\n                //比较\n                if(sid == id){\n                    return true;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到一样的，那么就表示数组中要查找的id是不存在的。\n        return false;\n    }\n\n\n}\n\n```\n\n```java\npackage com.itheima.test8;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n\n        要求3：通过id删除学生信息\n            如果存在，则删除，如果不存在，则提示删除失败。\n        要求4：删除完毕之后，遍历所有学生信息。\n\n       */\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n        Student stu3 = new Student(3, "wangwu", 25);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n        arr[2] = stu3;\n\n        /*要求3：通过id删除学生信息\n        如果存在，则删除，如果不存在，则提示删除失败。*/\n\n        //要找到id在数组中对应的索引\n        int index = getIndex(arr, 2);\n        if (index >= 0){\n            //如果存在，则删除\n            arr[index] = null;\n            //遍历数组\n            printArr(arr);\n        }else{\n            //如果不存在，则提示删除失败\n            System.out.println("当前id不存在，删除失败");\n        }\n\n\n\n\n\n    }\n\n\n\n    //1.我要干嘛？  找到id在数组中的索引\n    //2.我需要什么？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 要\n    public static int getIndex(Student[] arr , int id){\n        for (int i = 0; i < arr.length; i++) {\n            //依次得到每一个学生对象\n            Student stu = arr[i];\n            //对stu进行一个非空判断\n            if(stu != null){\n                int sid = stu.getId();\n                if(sid == id){\n                    return i;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到就表示不存在\n        return -1;\n    }\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n\n\n}\n\n```\n\n```java\npackage com.itheima.test8;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n\n        要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n        Student stu3 = new Student(3, "wangwu", 25);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n        arr[2] = stu3;\n\n\n        //4.先要找到id为2的学生对于的索引\n        int index = getIndex(arr, 2);\n\n        //5.判断索引\n        if(index >= 0){\n            //存在， 则将他的年龄+1岁\n            Student stu = arr[index];\n            //把原来的年龄拿出来\n            int newAge = stu.getAge() + 1;\n            //把+1之后的年龄塞回去\n            stu.setAge(newAge);\n            //遍历数组\n            printArr(arr);\n        }else{\n            //不存在，则直接提示\n            System.out.println("当前id不存在，修改失败");\n        }\n\n\n    }\n\n    //1.我要干嘛？  找到id在数组中的索引\n    //2.我需要什么？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 要\n    public static int getIndex(Student[] arr , int id){\n        for (int i = 0; i < arr.length; i++) {\n            //依次得到每一个学生对象\n            Student stu = arr[i];\n            //对stu进行一个非空判断\n            if(stu != null){\n                int sid = stu.getId();\n                if(sid == id){\n                    return i;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到就表示不存在\n        return -1;\n    }\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n}\n```\n'},{title:"常用API",headers:[{level:2,title:"1.API",slug:"_1-api",link:"#_1-api",children:[{level:3,title:"1.1.API概述",slug:"_1-1-api概述",link:"#_1-1-api概述",children:[]},{level:3,title:"1.2.如何使用API帮助文档",slug:"_1-2-如何使用api帮助文档",link:"#_1-2-如何使用api帮助文档",children:[]}]},{level:2,title:"2.String类",slug:"_2-string类",link:"#_2-string类",children:[{level:3,title:"2.1.String类概述",slug:"_2-1-string类概述",link:"#_2-1-string类概述",children:[]},{level:3,title:"2.2.String类的特点",slug:"_2-2-string类的特点",link:"#_2-2-string类的特点",children:[]},{level:3,title:"2.3.String类的构造方法",slug:"_2-3-string类的构造方法",link:"#_2-3-string类的构造方法",children:[]},{level:3,title:"2.4.创建字符串对象两种方式的区别",slug:"_2-4-创建字符串对象两种方式的区别",link:"#_2-4-创建字符串对象两种方式的区别",children:[]},{level:3,title:"2.5.字符串的比较",slug:"_2-5-字符串的比较",link:"#_2-5-字符串的比较",children:[]},{level:3,title:"2.6.用户登录案例",slug:"_2-6-用户登录案例",link:"#_2-6-用户登录案例",children:[]},{level:3,title:"2.7.遍历字符串案例",slug:"_2-7-遍历字符串案例",link:"#_2-7-遍历字符串案例",children:[]},{level:3,title:"2.8.统计字符次数案例",slug:"_2-8-统计字符次数案例",link:"#_2-8-统计字符次数案例",children:[]},{level:3,title:"2.9.字符串拼接案例",slug:"_2-9-字符串拼接案例",link:"#_2-9-字符串拼接案例",children:[]},{level:3,title:"2.10.字符串反转案例",slug:"_2-10-字符串反转案例",link:"#_2-10-字符串反转案例",children:[]},{level:3,title:"2.11.金额转换",slug:"_2-11-金额转换",link:"#_2-11-金额转换",children:[]},{level:3,title:"2.12.手机号屏蔽",slug:"_2-12-手机号屏蔽",link:"#_2-12-手机号屏蔽",children:[]},{level:3,title:"2.13.敏感词替换",slug:"_2-13-敏感词替换",link:"#_2-13-敏感词替换",children:[]},{level:3,title:"2.14.身份证信息查看",slug:"_2-14-身份证信息查看",link:"#_2-14-身份证信息查看",children:[]}]},{level:2,title:"3.StringBuilder",slug:"_3-stringbuilder",link:"#_3-stringbuilder",children:[{level:3,title:"3.1.基本使用",slug:"_3-1-基本使用",link:"#_3-1-基本使用",children:[]},{level:3,title:"3.2.链式编程",slug:"_3-2-链式编程",link:"#_3-2-链式编程",children:[]},{level:3,title:"3.3.练习1：对称字符串",slug:"_3-3-练习1-对称字符串",link:"#_3-3-练习1-对称字符串",children:[]},{level:3,title:"3.4.练习2：拼接字符串",slug:"_3-4-练习2-拼接字符串",link:"#_3-4-练习2-拼接字符串",children:[]}]},{level:2,title:"4.StringJoiner",slug:"_4-stringjoiner",link:"#_4-stringjoiner",children:[]},{level:2,title:"5.关于字符串的小扩展：",slug:"_5-关于字符串的小扩展",link:"#_5-关于字符串的小扩展",children:[]}],path:"/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html",pathLocale:"/",extraFields:'---\ntitle: 常用API\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n常用API\n\n\x3c!-- more --\x3e\n## 1.API\n\n### 1.1.API概述\n\n- 什么是API\n\n  ​\tAPI (Application Programming Interface) ：应用程序编程接口\n\n- java中的API\n\n  ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。\n\n### 1.2.如何使用API帮助文档\n\n- 打开帮助文档\n\n![01](img\\01.png)\n\n- 找到索引选项卡中的输入框\n\n![02](img\\02.png)\n\n- 在输入框中输入Random\n\n![03](img\\03.png)\n\n- 看类在哪个包下\n\n![04](img\\04.png)\n\n- 看类的描述\n\n![05](img\\05.png)\n\n- 看构造方法\n\n![06](img\\06.png)\n\n- 看成员方法\n\n![07](img\\07.png)\n\n## 2.String类\n\n### 2.1.String类概述\n\n​\tString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！\n\n### 2.2.String类的特点\n\n- 字符串不可变，它们的值在创建后不能被更改\n- 虽然 String 的值是不可变的，但是它们可以被共享\n- 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )\n\n### 2.3.String类的构造方法\n\n- 常用的构造方法\n\n  | 方法名                      | 说明                                      |\n  | --------------------------- | ----------------------------------------- |\n  | public   String()           | 创建一个空白字符串对象，不含有任何内容    |\n  | public   String(char[] chs) | 根据字符数组的内容，来创建字符串对象      |\n  | public   String(byte[] bys) | 根据字节数组的内容，来创建字符串对象      |\n  | String s =   “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |\n\n- 示例代码\n\n  ```java\n  public class StringDemo01 {\n      public static void main(String[] args) {\n          //public String()：创建一个空白字符串对象，不含有任何内容\n          String s1 = new String();\n          System.out.println("s1:" + s1);\n  \n          //public String(char[] chs)：根据字符数组的内容，来创建字符串对象\n          char[] chs = {\'a\', \'b\', \'c\'};\n          String s2 = new String(chs);\n          System.out.println("s2:" + s2);\n  \n          //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象\n          byte[] bys = {97, 98, 99};\n          String s3 = new String(bys);\n          System.out.println("s3:" + s3);\n  \n          //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc\n          String s4 = "abc";\n          System.out.println("s4:" + s4);\n      }\n  }\n  ```\n\n### 2.4.创建字符串对象两种方式的区别\n\n- 通过构造方法创建\n\n  ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\n\n- 直接赋值方式创建\n\n  ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\n\n### 2.5.字符串的比较\n\n#### 2.5.1.==号的作用\n\n- 比较基本数据类型：比较的是具体的值\n- 比较引用数据类型：比较的是对象地址值\n\n#### 2.5.2.equals方法的作用\n\n- 方法介绍\n\n  ```java\n  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写\n  ```\n\n- 示例代码\n\n  ```java\n  public class StringDemo02 {\n      public static void main(String[] args) {\n          //构造方法的方式得到对象\n          char[] chs = {\'a\', \'b\', \'c\'};\n          String s1 = new String(chs);\n          String s2 = new String(chs);\n  \n          //直接赋值的方式得到对象\n          String s3 = "abc";\n          String s4 = "abc";\n  \n          //比较字符串对象地址是否相同\n          System.out.println(s1 == s2);\n          System.out.println(s1 == s3);\n          System.out.println(s3 == s4);\n          System.out.println("--------");\n  \n          //比较字符串内容是否相同\n          System.out.println(s1.equals(s2));\n          System.out.println(s1.equals(s3));\n          System.out.println(s3.equals(s4));\n      }\n  }\n  ```\n\n### 2.6.用户登录案例\n\n#### 2.6.1.案例需求\n\n​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示\n\n#### 2.6.2代码实现\n\n```java\npublic class Test1登录案例 {\n    public static void main(String[] args) {\n        //1.定义两个变量用来记录正确的用户名和密码\n        String rightUsername = "itheima";\n        String rightPassword = "1234qwer";\n\n        //2.键盘录入用户名和密码\n        //ctrl + alt + T 选择包裹方式\n\n        for (int i = 0; i < 3; i++) {//0 1 2\n            Scanner sc = new Scanner(System.in);\n            System.out.println("请输入用户名");\n            String username = sc.next();\n            System.out.println("请输入密码");\n            String password = sc.next();\n\n            //3.判断比较\n            if (username.equals(rightUsername) && password.equals(rightPassword)) {\n                System.out.println("登录成功");\n                //如果正确，循环结束\n                break;\n            } else {\n                //最后一次机会\n                if(i == 2){\n                    System.out.println("账户" + username + "被锁定，请联系黑马程序员官方小姐姐：XXXXXXX");\n                }else{\n                    //不是最后一次机会\n                    System.out.println("用户名或密码错误，登录失败,还剩下" + (2 - i) + "次机会");//2 1 0\n                }\n            }\n        }\n\n    }\n}\n\n```\n\n### 2.7.遍历字符串案例\n\n#### 2.7.1.案例需求\n\n​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串\n\n#### 2.7.2.直接遍历字符串\n\n```java\npublic class Test2字符串直接遍历 {\n    public static void main(String[] args) {\n        //两个方法：\n        //charAt()：会根据索引获取对应的字符\n        //length(): 会返回字符串的长度\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入字符串");\n        String str = sc.next();\n        System.out.println(str);\n\n        //2.遍历\n        for (int i = 0; i < str.length(); i++) {\n            //i 依次表示字符串的每一个索引\n            //索引的范围：0 ~  长度-1\n\n            //根据索引获取字符串里面的每一个字符\n            //ctrl + alt + V 自动生成左边的接受变量\n            char c = str.charAt(i);\n            System.out.println(c);\n        }\n    }\n}\n\n```\n\n### 2.8.统计字符次数案例\n\n#### 2.8.1.案例需求\n\n​\t键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)\n\n#### 2.8.2.代码实现\n\n```java\npublic class Test4统计个数 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，统计大写，小写，数字出现的次数\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n\n\n        //2.统计 --- 计数器count\n        //此时我要统计的有3样东西，所以要定义3个计数器分别进行统计\n        int bigCount = 0;\n        int smallCount = 0;\n        int numberCount = 0;\n        //得到这个字符串里面每一个字符\n        for (int i = 0; i < str.length(); i++) {\n            //i 表示字符串中的索引\n            //c 表示字符串中的每一个字符\n            char c = str.charAt(i);\n\n            //对c进行判断\n            if (c >= \'a\' && c <= \'z\') {\n                smallCount++;\n            }else if(c >= \'A\' && c <= \'Z\'){\n                bigCount++;\n            }else if(c >= \'0\' && c <= \'9\'){\n                numberCount++;\n            }\n        }\n\n        //3.当循环结束之后，三个变量记录的就是对应的个数\n        System.out.println("大写字符有:" + bigCount + "个");\n        System.out.println("小写字符有:" + smallCount + "个");\n        System.out.println("数字字符有:" + numberCount + "个");\n    }\n}\n\n```\n\n### 2.9.字符串拼接案例\n\n#### 2.9.1.案例需求\n\n​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n\n​\t并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n#### 2.9.2.代码实现\n\n```java\npublic class Test5数组拼接成字符串 {\n    public static void main(String[] args) {\n        //定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n        //并在控制台输出结果。例如，数组为 int[] arr = {1,2,3};\n        //执行方法后的输出结果为：[1, 2, 3]\n\n\n        int[] arr = {1, 2, 3, 4, 5};\n\n        String str = arrToString(arr);\n        System.out.println(str);\n\n    }\n\n\n    //作用：把一个数组变成字符串\n    public static String arrToString(int[] arr) {\n        String s = "";\n        //拼接左括号\n        s = s + "["; //此时是拿着长度为0的字符串，跟[进行拼接，产生一个新的字符串。\n        //把新的字符串再赋值给s，此时变量s记录的就是新的字符串"["的地址值\n\n        //下面我想得到数组里面的每一个元素并进行拼接\n        //那么就需要遍历数组，得到每一个元素才行\n        for (int i = 0; i < arr.length; i++) {\n            //假设第一次循环:i = 0 获取的就是0索引上的元素\n            //在拼接的时候："[" + 1 + ", " 拼接完毕之后产生一个新的字符串 "[1, "\n            //第二次循环：i = 1 获取的就是1索引上的元素\n            //在拼接的时候： 此时s就是第一次循环结束后拼接完毕的结果："[1, "\n            //在拼接的时候："[1, " + 2 + ", " 拼接完毕之后产生一个新的字符串 "[1, 2, "\n            //...\n           if(i == arr.length - 1){\n               //如果是最后一个元素，那么不需要拼接逗号空格\n               s = s + arr[i];\n           }else{\n               //如果不是最后一个元素，需要拼接元素和逗号空格\n               s = s + arr[i] + ", ";\n           }\n        }\n\n        //等循环结束之后，再拼接最后一个右括号\n        s = s + "]";\n\n        return s;\n\n    }\n\n\n    //用来遍历数组\n    public static void printArr(int[] arr) {\n        System.out.print("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length - 1) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(arr[i] + ", ");\n            }\n        }\n        System.out.println("]");\n\n        //[1, 2, 3, 4, 5]\n        //我们现在要知道，这个最终结果是怎么来的？\n        //从到右依次打印得来的。\n    }\n}\n\n```\n\n### 2.10.字符串反转案例\n\n#### 2.10.1.案例需求\n\n​\t定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n\n​\t例如，键盘录入 abc，输出结果 cba\n\n#### 2.10.2.代码实现\n\n```java\npublic class Test6反转字符串 {\n    public static void main(String[] args) {\n        /*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n        例如，键盘录入 abc，输出结果 cba*/\n\n\n\n        //1.定义一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n        //2.定义一个方法，反转字符串\n        //abc  ---\x3e  cba\n        //可以把字符串倒着遍历，再拼接\n        String result = reverse(str);\n        System.out.println(result);\n\n\n    }\n\n    //注释：方法的作用就是反转字符串\n    //把传递进来的字符串进行反转\n    public static String reverse(String str){//abc\n        //核心思想：倒着遍历并进行拼接就可以了\n        //fori :正着遍历  forr：倒着遍历\n        String s = "";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            //i 依次表示字符串里面的每一个索引（倒着的）\n            //我们就可以拿到里面的每一个字符并拼接\n            s = s + str.charAt(i);\n        }\n\n        //把倒着拼接之后的结果返回即可\n        return s;\n\n    }\n}\n\n```\n\n### 2.11.金额转换\n\n#### 2.11.1.案例需求\n\n​\t把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 \n\n​\t把789变成：零佰零拾零万零仟柒佰捌拾玖元\n\n#### 2.11.2.代码实现\n\n```java\npackage com.itheima.stringdemo;\n\nimport java.util.Scanner;\n\npublic class StringDemo9 {\n    public static void main(String[] args) {\n        //1.键盘录入一个金额\n        Scanner sc = new Scanner(System.in);\n        int money;\n        while (true) {\n            System.out.println("请录入一个金额");\n            money = sc.nextInt();\n            if (money >= 0 && money <= 9999999) {\n                break;\n            } else {\n                System.out.println("金额无效");\n            }\n        }\n\n        //定义一个变量用来表示钱的大写\n        String moneyStr = "";\n\n        //2.得到money里面的每一位数字,再转成中文\n        while (true) {//2135\n            //从右往左获取数据，因为右侧是数据的个位\n            int ge = money % 10;\n            String capitalNumber = getCapitalNumber(ge);\n            //把转换之后的大写拼接到moneyStr当中\n            moneyStr = capitalNumber + moneyStr;\n            //第一次循环 ： "伍" + "" = "伍"\n            //第二次循环 ： "叁" + "伍" = "叁伍"\n            //去掉刚刚获取的数据\n            money = money / 10;\n\n            //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束\n            if (money == 0) {\n                break;\n            }\n        }\n\n        //3.在前面补0，补齐7位\n        int count = 7 - moneyStr.length();\n        for (int i = 0; i < count; i++) {\n            moneyStr = "零" + moneyStr;\n        }\n        System.out.println(moneyStr);//零零零贰壹叁伍\n\n        //4.插入单位\n        //定义一个数组表示单位\n        String[] arr = {"佰","拾","万","仟","佰","拾","元"};\n        //               零    零   零   贰   壹   叁   伍\n\n        //遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍\n        //然后把arr的单位插入进去\n\n        String result = "";\n        for (int i = 0; i < moneyStr.length(); i++) {\n            char c = moneyStr.charAt(i);\n            //把大写数字和单位拼接到result当中\n            result = result + c + arr[i];\n        }\n\n        //5.打印最终结果\n        System.out.println(result);\n\n    }\n\n\n    //定义一个方法把数字变成大写的中文\n    //1 -- 壹\n    public static String getCapitalNumber(int number) {\n        //定义数组，让数字跟大写的中文产生一个对应关系\n        String[] arr = {"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"};\n        //返回结果\n        return arr[number];\n    }\n\n}\n\n```\n\n### 2.12.手机号屏蔽\n\n需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\n\n最终效果为：`131****9468`\n\n代码实现：\n\n```java\npublic class Test8手机号屏蔽 {\n    public static void main(String[] args) {\n        /*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\n        最终效果为：131****9468*/\n\n        //1.键盘录入一个手机号码\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入手机号码");\n        String phoneNumber = sc.next();//13112349408\n\n        //2.截取手机号码中的前三位\n        String star = phoneNumber.substring(0, 3);\n\n        //3.截取手机号码中的最后四位\n        //此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好\n        //因为现在我要截取到最后，所以建议使用1个参数的。\n        String end = phoneNumber.substring(7);\n\n        //4.拼接\n        String result = star + "****" + end;\n\n        System.out.println(result);\n\n    }\n}\n\n```\n\n### 2.13.敏感词替换 \n\n需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 \n\n```java\npublic class Test9敏感词替换 {\n    public static void main(String[] args) {\n        //1.定义一个变量表示骂人的话\n        String talk = "后裔你玩什么啊，TMD";\n\n\n        //2.把这句话中的敏感词进行替换\n        String result = talk.replace("TMD", "***");\n\n        //3.打印\n        System.out.println(talk);\n        System.out.println(result);\n    }\n}\n\n```\n\n需求2：如果要替换的敏感词比较多怎么办？\n\n```java\npublic class Test10多个敏感词替换 {\n    public static void main(String[] args) {\n        //实际开发中，敏感词会有很多很多\n\n        //1.先键盘录入要说的话\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要说的话");\n        String talk = sc.next();//后裔你玩什么啊，TMD,GDX,ctmd,ZZ\n\n        //2.定义一个数组用来存多个敏感词\n        String[] arr = {"TMD","GDX","ctmd","ZZ","lj","FW","nt"};\n\n        //3.把说的话中所有的敏感词都替换为***\n\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引\n            //arr[i] 元素 --- 敏感词\n            talk = talk.replace(arr[i],"***");\n        }\n\n        //4.打印结果\n        System.out.println(talk);//后裔你玩什么啊，***,***,***,***\n\n    }\n}\n\n```\n\n### 2.14.身份证信息查看\n\n​\t身份证的每一位都是有固定的含义：\n\n* 1、2位：省份 \n* 3、4位：城市 \n* 5、6位：区县 \n* 7-14位：出生年、月、日 \n* 15、16位：所在地派出所 \n* 17位：性别（奇数男性，偶数女性）\n* 18位：个人信息码（随机产生） \n\n要求打印内容方式如下：\n\n​\t人物信息为：\n\n​\t出生年月日：XXXX年X月X日\n\n​\t性别为：男/女\n\n```java\npackage com.itheima.stringdemo;\n\npublic class StringDemo11 {\n    public static void main(String[] args) {\n        //1.定义一个字符串记录身份证号码\n        String id = "321281202001011234";\n\n        //2.获取出生年月日\n        String year = id.substring(6, 10);\n        String month = id.substring(10, 12);\n        String day = id.substring(12, 14);\n\n\n        System.out.println("人物信息为：");\n        System.out.println("出生年月日:" + year + "年" + month + "月" + day + "日");\n\n        //3.获取性别\n        char gender = id.charAt(16);//\'3\'  ---\x3e 3\n        //利用ASCII码表进行转换\n        //\'0\' ---\x3e  48\n        //\'1\' ---\x3e  49\n        //\'2\' ---\x3e  50\n        //\'3\' ---\x3e  51\n        //\'4\' ---\x3e  52\n        //\'5\' ---\x3e  53\n        //\'6\' ---\x3e  54\n        //\'7\' ---\x3e  55\n        //\'8\' ---\x3e  56\n        //\'9\' ---\x3e  57\n\n       int num = gender - 48;\n        if(num % 2 == 0){\n            System.out.println("性别为:女");\n        }else{\n            System.out.println("性别为:男");\n        }\n    }\n}\n```\n\n## 3.StringBuilder\n\nStringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。\n\n当我们在拼接字符串和反转字符串的时候会使用到\n\n### 3.1.基本使用\n\n```java\npublic class StringBuilderDemo3 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder("abc");\n\n        //2.添加元素\n        /*sb.append(1);\n        sb.append(2.3);\n        sb.append(true);*/\n\n        //反转\n        sb.reverse();\n\n        //获取长度\n        int len = sb.length();\n        System.out.println(len);\n\n\n        //打印\n        //普及：\n        //因为StringBuilder是Java已经写好的类\n        //java在底层对他做了一些特殊处理。\n        //打印对象不是地址值而是属性值。\n        System.out.println(sb);\n    }\n}\n```\n\n### 3.2.链式编程\n\n```java\npublic class StringBuilderDemo4 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder();\n\n        //2.添加字符串\n        sb.append("aaa").append("bbb").append("ccc").append("ddd");\n\n        System.out.println(sb);//aaabbbcccddd\n\n        //3.再把StringBuilder变回字符串\n        String str = sb.toString();\n        System.out.println(str);//aaabbbcccddd\n\n    }\n}\n```\n\n### 3.3.练习1：对称字符串 \n\n需求：\n\n​\t键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是\n\n  \t对称字符串：123321、111\n\n  \t非对称字符串：123123\n\n代码示例：\n\n```java\npublic class StringBuilderDemo6 {\n    //使用StringBuilder的场景：\n    //1.字符串的拼接\n    //2.字符串的反转\n\n    public static void main(String[] args) {\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n\n        //2.反转键盘录入的字符串\n        String result = new StringBuilder().append(str).reverse().toString();\n\n        //3.比较\n        if(str.equals(result)){\n            System.out.println("当前字符串是对称字符串");\n        }else{\n            System.out.println("当前字符串不是对称字符串");\n        }\n\n    }\n}\n\n```\n\n\n\n### 3.4.练习2：拼接字符串 \n\n需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。\n\n​          调用该方法，并在控制台输出结果。\n\n​          例如：数组为int[] arr = {1,2,3}; \n\n​          执行方法后的输出结果为：[1, 2, 3]\n\n代码示例:\n\n```java\npackage com.itheima.stringbuilderdemo;\n\npublic class StringBuilderDemo7 {\n    public static void main(String[] args) {\n        //1.定义数组\n        int[] arr = {1,2,3};\n\n        //2.调用方法把数组变成字符串\n        String str = arrToString(arr);\n\n        System.out.println(str);\n\n    }\n\n\n    public static String arrToString(int[] arr){\n        StringBuilder sb = new StringBuilder();\n        sb.append("[");\n\n        for (int i = 0; i < arr.length; i++) {\n            if(i == arr.length - 1){\n                sb.append(arr[i]);\n            }else{\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n\n        return sb.toString();\n    }\n}\n\n```\n\n## 4.StringJoiner\n\n* StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。\n* 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 \n* JDK8出现的\n\n基本使用：\n\n```java\n//1.创建一个对象，并指定中间的间隔符号\nStringJoiner sj = new StringJoiner("---");\n//2.添加元素\nsj.add("aaa").add("bbb").add("ccc");\n//3.打印结果\nSystem.out.println(sj);//aaa---bbb---ccc\n```\n\n```java\n//1.创建对象\nStringJoiner sj = new StringJoiner(", ","[","]");\n//2.添加元素\nsj.add("aaa").add("bbb").add("ccc");\nint len = sj.length();\nSystem.out.println(len);//15\n//3.打印\nSystem.out.println(sj);//[aaa, bbb, ccc]\nString str = sj.toString();\nSystem.out.println(str);//[aaa, bbb, ccc]\n```\n\n## 5.关于字符串的小扩展：\n\n1. 字符串存储的内存原理\n\n   String s = “abc”；直接赋值\n\n   特点：\n\n   ​\t此时字符串abc是存在字符串常量池中的。\n\n   ​\t先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。\n\n   所以，直接赋值的方式，代码简单，而且节约内存。\n\n2. new出来的字符串\n\n   看到new关键字，一定是在堆里面开辟了一个小空间。\n\n   String s1 = new String（“abc”）；\n\n   String s2 = “abc”；\n\n   s1记录的是new出来的，在堆里面的地址值。\n\n   s2是直接赋值的，所以记录的是字符串常量池中的地址值。\n\n3. ==号比较的到底是什么？\n\n   如果比较的是基本数据类型：比的是具体的数值是否相等。\n\n   如果比较的是引用数据类型：比的是地址值是否相等。\n\n   结论：==只能用于比较基本数据类型。不能比较引用数据类型。\n\n\n\n\n\n\n\n\n\n'},{title:"ArrayList&学生管理系统",headers:[{level:2,title:"1.ArrayList",slug:"_1-arraylist",link:"#_1-arraylist",children:[{level:3,title:"集合和数组的优势对比：",slug:"集合和数组的优势对比",link:"#集合和数组的优势对比",children:[]},{level:3,title:"1.1 ArrayList类概述",slug:"_1-1-arraylist类概述",link:"#_1-1-arraylist类概述",children:[]},{level:3,title:"1.2 ArrayList类常用方法",slug:"_1-2-arraylist类常用方法",link:"#_1-2-arraylist类常用方法",children:[]},{level:3,title:"1.3 ArrayList存储字符串并遍历",slug:"_1-3-arraylist存储字符串并遍历",link:"#_1-3-arraylist存储字符串并遍历",children:[]},{level:3,title:"1.4 ArrayList存储学生对象并遍历",slug:"_1-4-arraylist存储学生对象并遍历",link:"#_1-4-arraylist存储学生对象并遍历",children:[]},{level:3,title:"1.5 查找用户的索引",slug:"_1-5-查找用户的索引",link:"#_1-5-查找用户的索引",children:[]},{level:3,title:"1.6 判断用户的是否存在",slug:"_1-6-判断用户的是否存在",link:"#_1-6-判断用户的是否存在",children:[]}]},{level:2,title:"2.学生管理系统",slug:"_2-学生管理系统",link:"#_2-学生管理系统",children:[{level:3,title:"2.1学生管理系统实现步骤",slug:"_2-1学生管理系统实现步骤",link:"#_2-1学生管理系统实现步骤",children:[]},{level:3,title:"2.2学生类的定义",slug:"_2-2学生类的定义",link:"#_2-2学生类的定义",children:[]},{level:3,title:"2.3测试类的定义",slug:"_2-3测试类的定义",link:"#_2-3测试类的定义",children:[]}]}],path:"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html",pathLocale:"/",extraFields:'---\ntitle: ArrayList&学生管理系统\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nArrayList&学生管理系统\n\n\x3c!-- more --\x3e\n## 1.ArrayList\n\n### 集合和数组的优势对比：\n\n1. 长度可变\n2. 添加数据的时候不需要考虑索引，默认将数据添加到末尾\n\n### 1.1 ArrayList类概述\n\n- 什么是集合\n\n  ​\t提供一种存储空间可变的存储模型，存储的数据容量可以发生改变\n\n- ArrayList集合的特点\n\n  ​\t长度可以变化，只能存储引用数据类型。\n\n- 泛型的使用\n\n  ​\t用于约束集合中存储元素的数据类型\n\n### 1.2 ArrayList类常用方法\n\n#### 1.2.1 构造方法\n\n| 方法名             | 说明                 |\n| ------------------ | -------------------- |\n| public ArrayList() | 创建一个空的集合对象 |\n\n#### 1.2.2 成员方法\n\n| 方法名                                | 说明                                   |\n| ------------------------------------- | -------------------------------------- |\n| public boolean add(要添加的元素)      | 将指定的元素追加到此集合的末尾         |\n| public boolean remove(要删除的元素)   | 删除指定元素,返回值表示是否删除成功    |\n| public E  remove(int   index)         | 删除指定索引处的元素，返回被删除的元素 |\n| public E   set(int index,E   element) | 修改指定索引处的元素，返回被修改的元素 |\n| public E   get(int   index)           | 返回指定索引处的元素                   |\n| public int   size()                   | 返回集合中的元素的个数                 |\n\n#### 1.2.3 示例代码\n\n```java\npublic class ArrayListDemo02 {\n    public static void main(String[] args) {\n        //创建集合\n        ArrayList<String> array = new ArrayList<String>();\n\n        //添加元素\n        array.add("hello");\n        array.add("world");\n        array.add("java");\n\n        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功\n        //        System.out.println(array.remove("world"));\n        //        System.out.println(array.remove("javaee"));\n\n        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素\n        //        System.out.println(array.remove(1));\n\n        //IndexOutOfBoundsException\n        //        System.out.println(array.remove(3));\n\n        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素\n        //        System.out.println(array.set(1,"javaee"));\n\n        //IndexOutOfBoundsException\n        //        System.out.println(array.set(3,"javaee"));\n\n        //public E get(int index)：返回指定索引处的元素\n        //        System.out.println(array.get(0));\n        //        System.out.println(array.get(1));\n        //        System.out.println(array.get(2));\n        //System.out.println(array.get(3)); //？？？？？？ 自己测试\n\n        //public int size()：返回集合中的元素的个数\n        System.out.println(array.size());\n\n        //输出集合\n        System.out.println("array:" + array);\n    }\n}\n```\n\n### 1.3 ArrayList存储字符串并遍历\n\n#### 1.3.1 案例需求\n\n​\t创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合\n\n#### 1.3.2 代码实现\n\n```java\npublic class ArrayListDemo3 {\n    public static void main(String[] args) {\n        //1.创建集合对象\n        ArrayList<String> list = new ArrayList<>();\n\n        //2.添加元素\n        list.add("aaa");\n        list.add("bbb");\n        list.add("ccc");\n        list.add("ddd");\n\n        //3.遍历\n        //快捷键: list.fori 正向遍历\n        //list.forr 倒着遍历\n        System.out.print("[");\n        for (int i = 0; i < list.size(); i++) {\n            //i 依次表示集合里面的每一个索引\n\n            if(i == list.size() - 1){\n                //最大索引\n                System.out.print(list.get(i));\n            }else{\n                //非最大索引\n                System.out.print(list.get(i) + ", ");\n            }\n        }\n        System.out.print("]");\n    }\n}\n\n```\n\n### 1.4 ArrayList存储学生对象并遍历\n\n#### 1.4.1 案例需求\n\n​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n#### 1.4.2 代码实现\n\n```java\npublic class ArrayListDemo4 {\n    public static void main(String[] args) {\n        //1.创建集合对象，用来存储数据\n        ArrayList<Student> list = new ArrayList<>();\n\n        //2.创建学生对象\n        Student s1 = new Student("zhangsan",16);\n        Student s2 = new Student("lisi",15);\n        Student s3 = new Student("wangwu",18);\n\n        //3.把学生对象添加到集合中\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n\n        //4.遍历\n        for (int i = 0; i < list.size(); i++) {\n            //i 依次表示集合中的每一个索引\n            Student stu = list.get(i);\n            System.out.println(stu.getName() + ", " + stu.getAge());\n        }\n\n\n\n    }\n}\n\n```\n\n### 1.5 查找用户的索引\n\n需求： \n\n1，main方法中定义一个集合，存入三个用户对象。 \n\n   用户属性为：id，username，password    \n\n2，要求：定义一个方法，根据id查找对应的学生信息。\n\n   如果存在，返回索引\n\n   如果不存在，返回-1\n\n代码示例：\n\n```java\npublic class ArrayListDemo6 {\n    public static void main(String[] args) {\n        /*需求：\n        1，main方法中定义一个集合，存入三个用户对象。\n        用户属性为：id，username，password\n        2，要求：定义一个方法，根据id查找对应的学生信息。\n        如果存在，返回索引\n        如果不存在，返回-1*/\n\n\n        //1.创建集合对象\n        ArrayList<User> list = new ArrayList<>();\n\n        //2.创建用户对象\n        User u1 = new User("heima001", "zhangsan", "123456");\n        User u2 = new User("heima002", "lisi", "1234");\n        User u3 = new User("heima003", "wangwu", "1234qwer");\n\n        //3.把用户对象添加到集合当中\n        list.add(u1);\n        list.add(u2);\n        list.add(u3);\n\n        //4.调用方法，通过id获取对应的索引\n        int index = getIndex(list, "heima001");\n\n        System.out.println(index);\n\n    }\n\n\n    //1.我要干嘛？  根据id查找对应的学生信息\n    //2.我干这件事情需要什么才能完成？   集合 id\n    //3.方法的调用处是否需要继续使用方法的结果？\n    //要用必须返回，不要用可以返回也可以不返回\n    //明确说明需要有返回值 int\n    public static int getIndex(ArrayList<User> list, String id) {\n        //遍历集合得到每一个元素\n        for (int i = 0; i < list.size(); i++) {\n            User u = list.get(i);\n            String uid = u.getId();\n            if(uid.equals(id)){\n                return i;\n            }\n        }\n        //因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。\n        return -1;\n    }\n}\n\n```\n\n### 1.6 判断用户的是否存在\n\n```java\npublic class ArrayListDemo5 {\n    public static void main(String[] args) {\n       /* 需求：\n        1，main方法中定义一个集合，存入三个用户对象。\n        用户属性为：id，username，password\n        2，要求：定义一个方法，根据id查找对应的学生信息。\n        如果存在，返回true\n        如果不存在，返回false*/\n\n        //1.定义集合\n        ArrayList<User> list = new ArrayList<>();\n\n        //2.创建对象\n        User u1 = new User("heima001","zhangsan","123456");\n        User u2 = new User("heima002","lisi","12345678");\n        User u3 = new User("heima003","wangwu","1234qwer");\n\n        //3.把用户对象添加到集合当中\n        list.add(u1);\n        list.add(u2);\n        list.add(u3);\n\n        //4.调用方法，查询id是否存在\n        boolean result = contains(list, "heima001");\n        System.out.println(result);\n\n    }\n\n    //定义在测试类中的方法需要加static\n    //1.我要干嘛？ 我要根据id查询学生是否存在\n    //2.我干这件事情，需要什么才能完成？ 集合 id\n    //3.方法的调用处是否需要使用方法的结果？\n    //如果要用，必须返回，如果不用，可以返回也可以不返回\n    //但是本题明确说明需要返回\n    public static boolean contains(ArrayList<User> list, String id){\n        //循环遍历集合，得到集合里面的每一个元素\n        //再进行判断\n\n        for (int i = 0; i < list.size(); i++) {\n            //i 索引  list.get(i); 元素\n            User u = list.get(i);\n            //判断id是否存在，我是拿着谁跟谁比较\n            //需要把用户对象里面的id拿出来再进行比较。\n            String uid = u.getId();\n            if(id.equals(uid)){\n                return true;//return 关键字：作用就是结束方法。\n            }\n        }\n        //只有当集合里面所有的元素全部比较完毕才能认为是不存在的。\n        return false;\n    }\n\n}\n\n```\n\n## 2.学生管理系统\n\n### 2.1学生管理系统实现步骤\n\n- 案例需求\n\n  ​\t针对目前我们的所学内容，完成一个综合案例：学生管理系统。该系统主要功能如下：\n\n  ​\t添加学生：通过键盘录入学生信息，添加到集合中\n\n  ​\t删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除\n\n  ​\t修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改\n\n  ​\t查看学生：将集合中的学生对象信息进行展示\n\n  ​\t退出系统：结束程序\n\n- 实现步骤\n\n  1. 定义学生类，包含以下成员变量\n\n     ​       private String sid            // 学生id\n\n     ​       private String name       // 学生姓名\n\n     ​       private String age          // 学生年龄\n\n     ​       private String address   // 学生所在地\n\n  2. 学生管理系统主界面的搭建步骤\n\n     2.1 用输出语句完成主界面的编写\n     2.2 用Scanner实现键盘输入\n     2.3 用switch语句完成选择的功能\n     2.4 用循环完成功能结束后再次回到主界面\n\n  3. 学生管理系统的添加学生功能实现步骤\n\n     3.1 定义一个方法，接收`ArrayList<Student>`集合\n     3.2 方法内完成添加学生的功能\n     ​         ①键盘录入学生信息\n     ​         ②根据录入的信息创建学生对象\n     ​         ③将学生对象添加到集合中\n     ​         ④提示添加成功信息\n     3.3 在添加学生的选项里调用添加学生的方法\n\n  4. 学生管理系统的查看学生功能实现步骤\n\n     4.1 定义一个方法，接收`ArrayList<Student>`集合\n     4.2 方法内遍历集合，将学生信息进行输出\n     4.3 在查看所有学生选项里调用查看学生方法\n\n  5. 学生管理系统的删除学生功能实现步骤\n\n     5.1 定义一个方法，接收`ArrayList<Student>`集合\n     5.2 方法中接收要删除学生的学号\n     5.3 遍历集合，获取每个学生对象\n     5.4 使用学生对象的学号和录入的要删除的学号进行比较,如果相同，则将当前学生对象从集合中删除\n     5.5 在删除学生选项里调用删除学生的方法\n\n  6. 学生管理系统的修改学生功能实现步骤\n\n     6.1 定义一个方法，接收`ArrayList<Student>`集合\n     6.2 方法中接收要修改学生的学号\n     6.3 通过键盘录入学生对象所需的信息，并创建对象\n     6.4 遍历集合，获取每一个学生对象。并和录入的修改学生学号进行比较.如果相同，则使用新学生对象替换当前学生对象\n     6.5 在修改学生选项里调用修改学生的方法\n\n  7. 退出系统\n\n     使用System.exit(0);退出JVM\n\n### 2.2学生类的定义\n\n```java\npackage com.itheima.studentsystem;\n\npublic class Student {\n    private String id;\n    private String name;\n    private int age;\n    private String address;\n\n \t//下面是空参，有参，get和set方法\n}\n\n```\n\n### 2.3测试类的定义\n\n```java\npublic class StudentSystem {\n    public static void main(String[] args) {\n        ArrayList<Student> list = new ArrayList<>();\n        loop:\n        while (true) {\n            System.out.println("-----------------欢迎来到黑马学生管理系统-------------------");\n            System.out.println("1:添加学生");\n            System.out.println("2:删除学生");\n            System.out.println("3:修改学生");\n            System.out.println("4:查询学生");\n            System.out.println("5:退出");\n            System.out.println("请输入您的选择：");\n            Scanner sc = new Scanner(System.in);\n            String choose = sc.next();\n            switch (choose) {\n                case "1" -> addStudent(list);\n                case "2" -> deleteStudent(list);\n                case "3" -> updateStudent(list);\n                case "4" -> queryStudent(list);\n                case "5" -> {\n                    System.out.println("退出");\n                    //break loop;\n                    System.exit(0);//停止虚拟机运行\n                }\n                default -> System.out.println("没有这个选项");\n            }\n        }\n    }\n\n    //添加学生\n    public static void addStudent(ArrayList<Student> list) {\n        //利用空参构造先创建学生对象\n        Student s = new Student();\n\n        Scanner sc = new Scanner(System.in);\n        String id = null;\n        while (true) {\n            System.out.println("请输入学生的id");\n            id = sc.next();\n            boolean flag = contains(list, id);\n            if(flag){\n                //表示id已经存在，需要重新录入\n                System.out.println("id已经存在，请重新录入");\n            }else{\n                //表示id不存在，表示可以使用\n                s.setId(id);\n                break;\n            }\n        }\n\n        System.out.println("请输入学生的姓名");\n        String name = sc.next();\n        s.setName(name);\n\n        System.out.println("请输入学生的年龄");\n        int age = sc.nextInt();\n        s.setAge(age);\n\n        System.out.println("请输入学生的家庭住址");\n        String address = sc.next();\n        s.setAddress(address);\n\n\n        //把学生对象添加到集合当中\n        list.add(s);\n\n        //提示一下用户\n        System.out.println("学生信息添加成功");\n    }\n\n    //删除学生\n    public static void deleteStudent(ArrayList<Student> list) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要删除的id");\n        String id = sc.next();\n        //查询id在集合中的索引\n        int index = getIndex(list, id);\n        //对index进行判断\n        //如果-1，就表示不存在，结束方法，回到初始菜单\n        if(index >= 0){\n            //如果大于等于0的，表示存在，直接删除\n            list.remove(index);\n            System.out.println("id为：" + id + "的学生删除成功");\n        }else{\n            System.out.println("id不存在，删除失败");\n        }\n    }\n\n    //修改学生\n    public static void updateStudent(ArrayList<Student> list) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要修改学生的id");\n        String id = sc.next();\n\n        int index = getIndex(list, id);\n\n        if(index == -1){\n            System.out.println("要修改的id" + id + "不存在，请重新输入");\n            return;\n        }\n\n        //当代码执行到这里，表示什么？表示当前id是存在的。\n        //获取要修改的学生对象\n        Student stu = list.get(index);\n\n        //输入其他的信息并修改\n        System.out.println("请输入要修改的学生姓名");\n        String newName = sc.next();\n        stu.setName(newName);\n\n        System.out.println("请输入要修改的学生年龄");\n        int newAge = sc.nextInt();\n        stu.setAge(newAge);\n\n        System.out.println("请输入要修改的学生家庭住址");\n        String newAddress = sc.next();\n        stu.setAddress(newAddress);\n\n        System.out.println("学生信息修改成功");\n\n\n    }\n\n\n    //查询学生\n    public static void queryStudent(ArrayList<Student> list) {\n        if (list.size() == 0) {\n            System.out.println("当前无学生信息，请添加后再查询");\n            //结束方法\n            return;\n        }\n\n        //打印表头信息\n        System.out.println("id\\t\\t姓名\\t年龄\\t家庭住址");\n        //当代码执行到这里，表示集合中是有数据的\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t" + stu.getAddress());\n        }\n    }\n\n\n    //判断id在集合中是否存在\n    public static boolean contains(ArrayList<Student> list, String id) {\n        //循环遍历集合得到里面的每一个学生对象\n        /*for (int i = 0; i < list.size(); i++) {\n            //拿到学生对象后，获取id并进行判断\n            Student stu = list.get(i);\n            String sid = stu.getId();\n            if(sid.equals(id)){\n                //存在，true\n                return true;\n            }\n        }\n        // 不存在false\n        return false;*/\n       return getIndex(list,id) >= 0;\n    }\n\n    //通过id获取索引的方法\n    public static int getIndex(ArrayList<Student> list, String id){\n        //遍历集合\n        for (int i = 0; i < list.size(); i++) {\n            //得到每一个学生对象\n            Student stu = list.get(i);\n            //得到每一个学生对象的id\n            String sid = stu.getId();\n            //拿着集合中的学生id跟要查询的id进行比较\n            if(sid.equals(id)){\n                //如果一样，那么就返回索引\n                return i;\n            }\n        }\n        //当循环结束之后还没有找到，就表示不存在，返回-1.\n        return -1;\n    }\n}\n\n```\n\n\n\n\n\n'},{title:"面向对象进阶部分学习方法",headers:[{level:2,title:"第一章 复习回顾",slug:"第一章-复习回顾",link:"#第一章-复习回顾",children:[{level:3,title:"1.1 如何定义类",slug:"_1-1-如何定义类",link:"#_1-1-如何定义类",children:[]},{level:3,title:"1.2 如何通过类创建对象",slug:"_1-2-如何通过类创建对象",link:"#_1-2-如何通过类创建对象",children:[]},{level:3,title:"1.3 封装",slug:"_1-3-封装",link:"#_1-3-封装",children:[]},{level:3,title:"1.4 构造方法",slug:"_1-4-构造方法",link:"#_1-4-构造方法",children:[]},{level:3,title:"1.5 this关键字的作用",slug:"_1-5-this关键字的作用",link:"#_1-5-this关键字的作用",children:[]}]},{level:2,title:"第二章 static关键字",slug:"第二章-static关键字",link:"#第二章-static关键字",children:[{level:3,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:3,title:"2.2 定义格式和使用",slug:"_2-2-定义格式和使用",link:"#_2-2-定义格式和使用",children:[]},{level:3,title:"2.3 小结",slug:"_2-3-小结",link:"#_2-3-小结",children:[]}]},{level:2,title:"第三章 继承",slug:"第三章-继承",link:"#第三章-继承",children:[{level:3,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:3,title:"3.2 继承的格式",slug:"_3-2-继承的格式",link:"#_3-2-继承的格式",children:[]},{level:3,title:"3.3 继承案例",slug:"_3-3-继承案例",link:"#_3-3-继承案例",children:[]},{level:3,title:"3.4 子类不能继承的内容",slug:"_3-4-子类不能继承的内容",link:"#_3-4-子类不能继承的内容",children:[]},{level:3,title:"3.5 继承后的特点—成员变量",slug:"_3-5-继承后的特点—成员变量",link:"#_3-5-继承后的特点—成员变量",children:[]},{level:3,title:"3.6 继承后的特点—成员方法",slug:"_3-6-继承后的特点—成员方法",link:"#_3-6-继承后的特点—成员方法",children:[]},{level:3,title:"3.7 方法重写",slug:"_3-7-方法重写",link:"#_3-7-方法重写",children:[]},{level:3,title:"3.8 继承后的特点—构造方法",slug:"_3-8-继承后的特点—构造方法",link:"#_3-8-继承后的特点—构造方法",children:[]},{level:3,title:"3.9 super(...)和this(...)",slug:"_3-9-super-和this",link:"#_3-9-super-和this",children:[]},{level:3,title:"3.10 继承的特点",slug:"_3-10-继承的特点",link:"#_3-10-继承的特点",children:[]},{level:3,title:"4. 关于今天知识的小结：",slug:"_4-关于今天知识的小结",link:"#_4-关于今天知识的小结",children:[]}]}],path:"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html",pathLocale:"/",extraFields:'---\ntitle: 面向对象进阶部分学习方法\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n面向对象进阶部分学习方法\n\x3c!-- more --\x3e\n# 面向对象进阶部分学习方法：\n\n特点：\n\n​\t逻辑性没有那么强，但是概念会比较多。\n\n​\t记忆部分重要的概念，理解需要掌握的概念，多多练习代码。\n\n\n\n# 目标\n\n- [ ] 能够掌握static关键字修饰的变量调用方式\n- [ ] 能够掌握static关键字修饰的方法调用方式\n- [ ] 知道静态代码块的格式和应用场景\n\n- [ ] 能够写出类的继承格式\n- [ ] 能够说出继承的特点\n- [ ] 能够区分this和super的作用\n- [ ] 能够说出方法重写的概念\n- [ ] 能够说出方法重写的注意事项\n\n\n## 第一章 复习回顾\n\n### 1.1 如何定义类\n\n类的定义格式如下:\n\n```java\n修饰符 class 类名 {\n    // 1.成员变量（属性）\n    // 2.成员方法 (行为) \n    // 3.构造方法 （初始化类的对象数据的）\n}\n```\n\n例如:\n\n```java\npublic class Student {\n    // 1.成员变量\n    public String name ;\n    public char sex ; // \'男\'  \'女\'\n    public int age;\n}\n```\n\n### 1.2 如何通过类创建对象\n\n```java\n类名 对象名称 = new 类名();\n```\n\n例如:\n\n```java\nStudent stu = new Student();\n```\n\n### 1.3 封装\n\n##### 1.3.1 封装的步骤\n\n1.使用 `private` 关键字来修饰成员变量。\n\n2.使用`public`修饰getter和setter方法。\n\n##### 1.3.2 封装的步骤实现\n\n1. private修饰成员变量\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n2. public修饰getter和setter方法\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String n) {\n      \tname = n;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int a) {\n        if (a > 0 && a <200) {\n            age = a;\n        } else {\n            System.out.println("年龄非法！");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}\n```\n\n### 1.4 构造方法\n\n#### 1.4.1 构造方法的作用\n\n在创建对象的时候，给成员变量进行初始化。\n\n初始化即赋值的意思。\n\n#### 1.4.2 构造方法的格式\n\n```java\n修饰符 类名(形参列表) {\n    // 构造体代码，执行代码\n}\n```\n\n#### 1.4.3 构造方法的应用\n\n首先定义一个学生类，代码如下：\n\n```java\npublic class Student {\n    // 1.成员变量\n    public String name;\n    public int age;\n\n    // 2.构造方法\n    public Student() {\n\t\tSystem.out.println("无参数构造方法被调用")；\n    }\n}\n```\n\n接下来通过调用构造方法得到两个学生对象。\n\n```java\npublic class CreateStu02 {\n    public static void main(String[] args) {\n        // 创建一个学生对象\n        // 类名 变量名称 = new 类名();\n        Student s1 = new Student();\n        // 使用对象访问成员变量，赋值\n        s1.name = "张三";\n        s1.age = 20 ;\n\n        // 使用对象访问成员变量 输出值\n        System.out.println(s1.name);\n        System.out.println(s1.age); \n\n        Student s2 = new Student();\n        // 使用对象访问成员变量 赋值\n        s2.name = "李四";\n        s2.age = 18 ;\n        System.out.println(s2.name);\n        System.out.println(s2.age);\n    }\n}\n```\n\n### 1.5 this关键字的作用\n\n#### 1.5.1 this关键字的作用\n\nthis代表所在类的当前对象的引用（地址值），即代表当前对象。\n\n#### 1.5.2 this关键字的应用\n\n##### 1.5.2.1 用于普通的gettter与setter方法\n\nthis出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n      \tthis.name = name;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int age) {\n        if (age > 0 && age < 200) {\n            this.age = age;\n        } else {\n            System.out.println("年龄非法！");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}\n```\n\n##### 1.5.2.2 用于构造方法中\n\nthis出现在构造方法中，代表构造方法正在初始化的那个对象。\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    \n    // 无参数构造方法\n    public Student() {} \n    \n    // 有参数构造方法\n    public Student(String name,int age) {\n    \tthis.name = name;\n    \tthis.age = age; \n    }\n}\n```\n\n## 第二章 static关键字   \n\n### 2.1 概述\n\n以前我们定义过如下类：\n\n```java\npublic class Student {\n    // 成员变量\n    public String name;\n    public char sex; // \'男\'  \'女\'\n    public int age;\n\n    // 无参数构造方法\n    public Student() {\n\n    }\n    \n    // 有参数构造方法\n    public Student(String  a) {\n\n    }\n}\n```\n\n我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。\n\n而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。\n\n所以Java中成员（**变量和方法**）等是存在所属性的，Java是通过static关键字来区分的。**static关键字在Java开发非常的重要，对于理解面向对象非常关键。**\n\n关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是**属于类**的是放在静态区中，没有static修饰的成员变量和方法则是**属于对象**的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。\n\n### 2.2 定义格式和使用 \n\nstatic是静态的意思。 static可以修饰成员变量或者修饰方法。\n\n#### 2.2.1 静态变量及其访问\n\n有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。\n\n**如何使用呢**\n\n例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。\n\n**定义格式**\n\n```java\n修饰符 static 数据类型 变量名 = 初始值；    \n```\n\n**举例**\n\n```java\npublic class Student {\n    public static String schoolName = "传智播客"； // 属于类，只有一份。\n    // .....\n}\n```\n\n**静态成员变量的访问:**\n\n**格式：类名.静态变量**\n\n```java\npublic static void  main(String[] args){\n    System.out.println(Student.schoolName); // 传智播客\n    Student.schoolName = "黑马程序员";\n    System.out.println(Student.schoolName); // 黑马程序员\n}\n```\n\n#### 2.2.2 实例变量及其访问\n\n无static修饰的成员变量属于每个对象的，  这个成员变量叫**实例变量**，之前我们写成员变量就是实例成员变量。\n\n**需要注意的是**：实例成员变量属于每个对象，必须创建类的对象才可以访问。   \n\n**格式：对象.实例成员变量**\n\n#### 2.2.3 静态方法及其访问\n\n有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为**类方法或者**静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。\n\n与静态成员变量一样，静态方法也是直接通过**类名.方法名称**即可访问。\n\n**举例**\n\n```java\npublic class Student{\n    public static String schoolName = "传智播客"； // 属于类，只有一份。\n    // .....\n    public static void study(){\n    \tSystem.out.println("我们都在黑马程序员学习");   \n    }\n}\n```\n\n**静态成员变量的访问:**\n\n**格式：类名.静态方法**\n\n```java\npublic static void  main(String[] args){\n    Student.study();\n}\n```\n\n#### 2.2.4 实例方法及其访问\n\n无static修饰的成员方法属于每个对象的，这个成员方法也叫做**实例方法**。\n\n**需要注意的是**：实例方法是属于每个对象，必须创建类的对象才可以访问。  \n\n**格式：对象.实例方法**\n\n**示例**：\n\n```java\npublic class Student {\n    // 实例变量\n    private String name ;\n    // 2.方法：行为\n    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用\n    public void run(){\n        System.out.println("学生可以跑步");\n    }\n\t// 无 static修饰，实例方法\n    public  void sleep(){\n        System.out.println("学生睡觉");\n    }\n    public static void study(){\n        \n    }\n}\n```\n\n```java\npublic static void main(String[] args){\n    // 创建对象 \n    Student stu = new Student ;\n    stu.name = "徐干";\n    // Student.sleep();// 报错，必须用对象访问。\n    stu.sleep();\n    stu.run();\n}\n```\n\n### 2.3 小结\n\n1.当 `static` 修饰成员变量或者成员方法时，该变量称为**静态变量**，该方法称为**静态方法**。该类的每个对象都**共享**同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。\n\n2.无static修饰的成员变量或者成员方法，称为**实例变量，实例方法**，实例变量和实例方法必须创建类的对象，然后通过对象来访问。\n\n3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。\n\n4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。\n\n\n## 第三章 继承 \n\n### 3.1 概述\n\n#### 3.1.1 引入\n假如我们要定义如下类:\n学生类,老师类和工人类，分析如下。\n\n1. 学生类\n   属性:姓名,年龄\n   行为:吃饭,睡觉\n\n2. 老师类\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，教书\n\n3. 班主任\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，管理\n\n如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？\n\n假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要**继承**那一个类即可。如图所示：\n![](imgs/1.jpg)\n\n其中，多个类可以称为**子类**，单独被继承的那一个类称为**父类**、**超类（superclass）**或者**基类**。\n\n#### 3.1.2 继承的含义\n\n继承描述的是事物之间的所属关系，这种关系是：`is-a` 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。\n\n**继承**：就是子类继承父类的**属性**和**行为**，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**非私有**的属性和行为。\n\n#### 3.1.3 继承的好处\n1. 提高**代码的复用性**（减少代码冗余，相同代码重复利用）。\n2. 使类与类之间产生了关系。\n\n### 3.2 继承的格式\n通过 `extends` 关键字，可以声明一个子类继承另外一个父类，定义格式如下：\n```java\nclass 父类 {\n\t...\n}\n\nclass 子类 extends 父类 {\n\t...\n}\n```\n\n**需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。**\n\n### 3.3 继承案例\n#### 3.3.1 案例\n\n请使用继承定义以下类:\n\n1. 学生类\n   属性:姓名,年龄\n   行为:吃饭,睡觉\n2. 老师类\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，教书\n3. 班主任\n   属性:姓名,年龄，薪水\n   行为:吃饭,睡觉，管理\n\n#### 3.3.2 案例图解分析\n\n老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。\n\n如下图所示。\n\n![](imgs/360截图20181202211331250.jpg)\n\n#### 3.3.3 案例代码实现\n\n**1.父类Human类**\n\n  ```java\n public class Human {\n    // 合理隐藏\n    private String name ;\n    private int age ;\n\t\n    // 合理暴露\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n }\n  ```\n\n**2.子类Teacher类**\n\n  ```java\npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n    // 特有方法\n    public void teach(){\n        System.out.println("老师在认真教技术！")；\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}\n  ```\n\n**3.子类Student类**\n\n  ```java\npublic class Student extends Human{\n \n}\n  ```\n\n**4.子类BanZhuren类**\n\n```java \npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n       // 特有方法\n    public void admin(){\n        System.out.println("班主任强调纪律问题！")；\n    }\n    \n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}\n```\n\n\n**5.测试类**\n\n  ```java\n  public class Test {\n      public static void main(String[] args) {\n          Teacher dlei = new Teacher();\n          dlei.setName("播仔");\n          dlei.setAge("31");\n          dlei.setSalary(1000.99);\n          System.out.println(dlei.getName());\n          System.out.println(dlei.getAge());\n          System.out.println(dlei.getSalary());\n          dlei.teach();\n          \n          BanZhuRen linTao = new BanZhuRen();\n          linTao.setName("灵涛");\n          linTao.setAge("28");\n          linTao.setSalary(1000.99);\n          System.out.println(linTao.getName());\n          System.out.println(linTao.getAge());\n          System.out.println(linTao.getSalary());\n          linTao.admin();\n\n          Student xugan = new Student();\n          xugan.setName("播仔");\n          xugan.setAge("31");\n          //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！\n          System.out.println(xugan.getName());\n          System.out.println(xugan.getAge());\n\n\n\n      }\n  }\n  ```\n\n#### 3.3.4 小结\n\n1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。\n\n2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！\n\n### 3.4 子类不能继承的内容\n\n#### 3.4.1 引入\n\n并不是父类的所有内容都可以给子类继承的：\n\n**子类不能继承父类的构造方法。**\n\n**值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。**\n\n#### 3.4.1 演示代码\n```java\npublic class Demo03 {\n    public static void main(String[] args) {\n        Zi z = new Zi();\n        System.out.println(z.num1);\n//\t\tSystem.out.println(z.num2); // 私有的子类无法使用\n        // 通过getter/setter方法访问父类的private成员变量\n        System.out.println(z.getNum2());\n\n        z.show1();\n        // z.show2(); // 私有的子类无法使用\n    }\n}\n\nclass Fu {\n    public int num1 = 10;\n    private int num2 = 20;\n\n    public void show1() {\n        System.out.println("show1");\n    }\n\n    private void show2() {\n        System.out.println("show2");\n    }\n\n    public int getNum2() {\n        return num2;\n    }\n\n    public void setNum2(int num2) {\n        this.num2 = num2;\n    }\n}\n\nclass Zi extends Fu {\n}\n```\n\n### 3.5 继承后的特点—成员变量\n\n当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？\n\n#### 3.5.1 成员变量不重名\n\n如果子类父类中出现**不重名**的成员变量，这时的访问是**没有影响的**。代码如下：\n\n```java\nclass Fu {\n\t// Fu中的成员变量\n\tint num = 5;\n}\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num2 = 6;\n  \n\t// Zi中的成员方法\n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println("Fu num="+num); // 继承而来，所以直接访问。\n\t\t// 访问子类中的num2\n\t\tSystem.out.println("Zi num2="+num2);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n        // 创建子类对象\n\t\tZi z = new Zi(); \n      \t// 调用子类中的show方法\n\t\tz.show();  \n\t}\n}\n\n演示结果：\nFu num = 5\nZi num2 = 6\n```\n\n#### 3.5.2 成员变量重名\n\n如果子类父类中出现**重名**的成员变量，这时的访问是**有影响的**。代码如下：\n\n```java\nclass Fu1 {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\nclass Zi1 extends Fu1 {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println("Fu num=" + num);\n\t\t// 访问子类中的num\n\t\tSystem.out.println("Zi num=" + num);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n演示结果：\nFu num = 6\nZi num = 6\n```\n\n子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。\n\n#### 3.5.3  super访问父类成员变量\n\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用`super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。\n\n需要注意的是：**super代表的是父类对象的引用，this代表的是当前对象的引用。**\n\n**使用格式：**\n\n```java\nsuper.父类成员变量名\n```\n\n子类方法需要修改，代码如下：\n\n```java\nclass Fu {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\n\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n        int num = 1;\n      \n        // 访问方法中的num\n        System.out.println("method num=" + num);\n        // 访问子类中的num\n        System.out.println("Zi num=" + this.num);\n        // 访问父类中的num\n        System.out.println("Fu num=" + super.num);\n\t}\n}\n\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n\n演示结果：\nmethod num=1\nZi num=6\nFu num=5\n```\n\n> 小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。\n\n### 3.6 继承后的特点—成员方法\n\n当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？\n\n#### 3.6.1 成员方法不重名\n\n如果子类父类中出现**不重名**的成员方法，这时的调用是**没有影响的**。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：\n\n```java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println("Fu类中的show方法执行");\n\t}\n}\nclass Zi extends Fu {\n\tpublic void show2() {\n\t\tSystem.out.println("Zi类中的show2方法执行");\n\t}\n}\npublic  class Demo05 {\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t//子类中没有show方法，但是可以找到父类方法去执行\n\t\tz.show(); \n\t\tz.show2();\n\t}\n}\n```\n\n#### 3.6.2 成员方法重名\n\n如果子类父类中出现**重名**的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。\n\n代码如下：\n\n```java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println("Fu show");\n\t}\n}\nclass Zi extends Fu {\n\t//子类重写了父类的show方法\n\tpublic void show() {\n\t\tSystem.out.println("Zi show");\n\t}\n}\npublic class ExtendsDemo05{\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t// 子类中有show方法，只执行重写后的show方法\n\t\tz.show();  // Zi show\n\t}\n}\n```\n\n### 3.7 方法重写\n\n#### 3.7.1 概念\n\n**方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。**声明不变，重新实现**。\n\n#### 3.7.2 使用场景与案例\n\n发生在子父类之间的关系。\n子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。\n\n例如：我们定义了一个动物类代码如下：\n\n```java\npublic class Animal  {\n    public void run(){\n        System.out.println("动物跑的很快！");\n    }\n    public void cry(){\n        System.out.println("动物都可以叫~~~");\n    }\n}\n```\n\n然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求\n\n代码如下：\n\n```java\npublic class Cat extends Animal {\n    public void cry(){\n        System.out.println("我们一起学猫叫，喵喵喵！喵的非常好听！");\n    }\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n      \tCat ddm = new Cat()；\n        // 调用父类继承而来的方法\n        ddm.run();\n      \t// 调用子类重写的方法\n      \tddm.cry();\n\t}\n}\n```\n\n#### 3.7.2 @Override重写注解\n\n* @Override:注解，重写注解校验！\n\n* 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。\n\n* 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！\n\n  加上后的子类代码形式如下：\n\n  ``` java\n  public class Cat extends Animal {\n       // 声明不变，重新实现\n      // 方法名称与父类全部一样，只是方法体中的功能重写写了！\n      @Override\n      public void cry(){\n          System.out.println("我们一起学猫叫，喵喵喵！喵的非常好听！");\n      }\n  }\n  ```\n\n\n#### 3.7.3 注意事项\n\n1. 方法重写是发生在子父类之间的关系。\n2. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。\n3. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。\n\n### 3.8 继承后的特点—构造方法\n#### 3.8.1 引入\n\n当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？\n首先我们要回忆两个事情，构造方法的定义格式和作用。\n\n1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。\n2. 构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个`super()` ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（**先有爸爸，才能有儿子**）\n\n**继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法**\n\n#### 3.8.2 案例演示\n\n按如下需求定义类:\n\n1. 人类\n   成员变量: 姓名,年龄\n   成员方法: 吃饭\n2. 学生类\n   成员变量: 姓名,年龄,成绩\n   成员方法: 吃饭\n\n代码如下：\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        System.out.println("----------");\n        Student s2 = new Student(99.9);\n    }\n}\n\n输出结果：\n父类无参\n子类无参\n----------\n父类无参\n子类有参\n```\n\n#### 3.8.3 小结\n\n* 子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。\n* 子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。\n\n### 3.9 super(...)和this(...)\n\n#### 3.9.1  引入\n\n请看上节中的如下案例：\n\n```java \nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student(99.9);\n        System.out.println(s2.getScore()); // 99.9\n        System.out.println(s2.getName()); // 输出 null\n        System.out.println(s2.getAge()); // 输出 0\n    }\n}\n```\n\n我们发现，子类有参数构造方法只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(...)去调用父类构造方法，以便初始化继承自父类对象的name和age.\n\n#### 3.9.2 super和this的用法格式\n\nsuper和this完整的用法如下，其中this，super访问成员我们已经接触过了。\n\n```java\nthis.成员变量    \t--    本类的\nsuper.成员变量    \t--    父类的\n\nthis.成员方法名()  \t--    本类的    \nsuper.成员方法名()   --    父类的\n```\n\n接下来我们使用调用构造方法格式：\n\n```java\nsuper(...) -- 调用父类的构造方法，根据参数匹配确认\nthis(...) -- 调用本类的其他构造方法，根据参数匹配确认\n```\n\n#### 3.9.3 super(....)用法演示\n\n代码如下：\n\n```java\nclass Person {\n    private String name ="凤姐";\n    private int age = 20;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n    \n    public Person(String name , int age){\n        this.name = name ;\n        this.age = age ;\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score = 100;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(String name ， int age，double score) {\n        super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student("张三"，20，99);\n        System.out.println(s2.getScore()); // 99\n        System.out.println(s2.getName()); // 输出 张三\n        System.out.println(s2.getAge()); // 输出 20\n    }\n}\n```\n\n**注意：**\n\n**子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**\n\n**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**\n\nsuper(..)是根据参数去确定调用父类哪个构造方法的。\n\n#### 3.9.4 super(...)案例图解\n\n**父类空间优先于子类对象产生**\n\n在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：\n\n![](imgs/2.jpg)\n\n\n\n#### 3.9.5 this(...)用法演示\n\nthis(...)\n *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。\n *    为了借用其他构造方法的功能。\n\n```java\npackage com.itheima._08this和super调用构造方法;\n/**\n * this(...):\n *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。\n *    为了借用其他构造方法的功能。\n *\n */\npublic class ThisDemo01 {\n    public static void main(String[] args) {\n        Student xuGan = new Student();\n        System.out.println(xuGan.getName()); // 输出:徐干\n        System.out.println(xuGan.getAge());// 输出:21\n        System.out.println(xuGan.getSex());// 输出： 男\n    }\n}\n\nclass Student{\n    private String name ;\n    private int age ;\n    private char sex ;\n\n    public Student() {\n  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)\n        this("徐干",21,\'男\');\n    }\n\n    public Student(String name, int age, char sex) {\n        this.name = name ;\n        this.age = age   ;\n        this.sex = sex   ;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getSex() {\n        return sex;\n    }\n\n    public void setSex(char sex) {\n        this.sex = sex;\n    }\n}\n```\n\n#### 3.9.6 小结\n\n* **子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。**\n\n* **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。**\n\n* **super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。**\n* super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。\n* this(..)可以调用本类中的其他构造方法。\n\n### 3.10 继承的特点\n1. Java只支持单继承，不支持多继承。\n  ```java\n// 一个类只能有一个父类，不可以有多个父类。\nclass A {}\nclass B {}\nclass C1 extends A {} // ok\n// class C2 extends A, B {} // error\n  ```\n\n2. 一个类可以有多个子类。\n  ```java\n// A可以有多个子类\nclass A {}\nclass C1 extends A {}\nclass C2 extends  A {}\n  ```\n\n3. 可以多层继承。\n  ```java\nclass A {}\nclass C1 extends A {}\nclass D extends C1 {}\n  ```\n  > 顶层父类是Object类。所有的类默认继承Object，作为父类。\n\n### 4. 关于今天知识的小结：\n\n会写一个继承结构下的标准Javabean即可\n\n需求：\n\n​\t猫：属性，姓名，年龄，颜色\n\n​\t狗：属性，姓名，年龄，颜色，吼叫\n\n 分享书写技巧：\n\n​        1.在大脑中要区分谁是父，谁是子\n\n​        2.把共性写到父类中，独有的东西写在子类中\n\n​        3.开始编写标准Javabean（从上往下写）\n\n​        4.在测试类中，创建对象并赋值调用\n\n\n\n代码示例：\n\n```java\npackage com.itheima.test4;\n\npublic class Animal {\n    //姓名，年龄，颜色\n    private String name;\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age, String color) {\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npublic class Cat extends Animal{\n    //因为猫类中没有独有的属性。\n    //所以此时不需要写私有的成员变量\n\n    //空参\n    public Cat() {\n    }\n\n    //需要带子类和父类中所有的属性\n    public Cat(String name, int age, String color) {\n        super(name,age,color);\n    }\n}\n\n\npublic class Dog extends Animal{\n    //Dog ：吼叫\n    private String wang;\n\n    //构造\n    public Dog() {\n    }\n\n    //带参构造：带子类加父类所有的属性\n    public Dog(String name, int age, String color,String wang) {\n        //共性的属性交给父类赋值\n        super(name,age,color);\n        //独有的属性自己赋值\n        this.wang = wang;\n    }\n\n    public String getWang() {\n        return wang;\n    }\n\n    public void setWang(String wang) {\n        this.wang = wang;\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        //Animal ： 姓名，年龄，颜色\n        //Cat :\n        //Dog ：吼叫\n\n        //创建狗的对象\n        Dog d = new Dog("旺财",2,"黑色","嗷呜~~");\n        System.out.println(d.getName()+", " + d.getAge() + ", " + d.getColor() + ", " + d.getWang());\n\n        //创建猫的对象\n        Cat c = new Cat("中华田园猫",3,"黄色");\n        System.out.println(c.getName() + ", " + c.getAge() + ", " + c.getColor());\n    }\n}\n\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'},{title:"多态",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 多态的形式",slug:"_1-1-多态的形式",link:"#_1-1-多态的形式",children:[]},{level:2,title:"1.2 多态的使用场景",slug:"_1-2-多态的使用场景",link:"#_1-2-多态的使用场景",children:[]},{level:2,title:"1.3 多态的定义和前提",slug:"_1-3-多态的定义和前提",link:"#_1-3-多态的定义和前提",children:[]},{level:2,title:"1.4 多态的运行特点",slug:"_1-4-多态的运行特点",link:"#_1-4-多态的运行特点",children:[]},{level:2,title:"1.5 多态的弊端",slug:"_1-5-多态的弊端",link:"#_1-5-多态的弊端",children:[]},{level:2,title:"1.6 引用类型转换",slug:"_1-6-引用类型转换",link:"#_1-6-引用类型转换",children:[{level:3,title:"1.6.1 为什么要转型",slug:"_1-6-1-为什么要转型",link:"#_1-6-1-为什么要转型",children:[]},{level:3,title:"1.6.2 向上转型（自动转换）",slug:"_1-6-2-向上转型-自动转换",link:"#_1-6-2-向上转型-自动转换",children:[]},{level:3,title:"1.6.3 向下转型（强制转换）",slug:"_1-6-3-向下转型-强制转换",link:"#_1-6-3-向下转型-强制转换",children:[]},{level:3,title:"1.6.4 案例演示",slug:"_1-6-4-案例演示",link:"#_1-6-4-案例演示",children:[]},{level:3,title:"1.6.5 转型的异常",slug:"_1-6-5-转型的异常",link:"#_1-6-5-转型的异常",children:[]},{level:3,title:"1.6.6 instanceof关键字",slug:"_1-6-6-instanceof关键字",link:"#_1-6-6-instanceof关键字",children:[]},{level:3,title:"1.6.7 instanceof新特性",slug:"_1-6-7-instanceof新特性",link:"#_1-6-7-instanceof新特性",children:[]},{level:3,title:"1.7 综合练习",slug:"_1-7-综合练习",link:"#_1-7-综合练习",children:[]}]},{level:2,title:"2.1 包",slug:"_2-1-包",link:"#_2-1-包",children:[]},{level:2,title:"2.2 导包",slug:"_2-2-导包",link:"#_2-2-导包",children:[]},{level:2,title:"2.3 使用不同包下的相同类怎么办？",slug:"_2-3-使用不同包下的相同类怎么办",link:"#_2-3-使用不同包下的相同类怎么办",children:[]},{level:2,title:"3.1 权限修饰符",slug:"_3-1-权限修饰符",link:"#_3-1-权限修饰符",children:[]},{level:2,title:"3.2 不同权限的访问能力",slug:"_3-2-不同权限的访问能力",link:"#_3-2-不同权限的访问能力",children:[]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 使用方式",slug:"_4-2-使用方式",link:"#_4-2-使用方式",children:[{level:3,title:"4.2.1 修饰类",slug:"_4-2-1-修饰类",link:"#_4-2-1-修饰类",children:[]},{level:3,title:"4.2.2 修饰方法",slug:"_4-2-2-修饰方法",link:"#_4-2-2-修饰方法",children:[]},{level:3,title:"4.2.3 修饰变量-局部变量",slug:"_4-2-3-修饰变量-局部变量",link:"#_4-2-3-修饰变量-局部变量",children:[]},{level:3,title:"4.2.4 修饰变量-成员变量",slug:"_4-2-4-修饰变量-成员变量",link:"#_4-2-4-修饰变量-成员变量",children:[]}]}],path:"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:'---\ntitle: 多态\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n多态\n\n\x3c!-- more --\x3e\n# day14\n\n## 今日内容\n\n- 多态\n- 包\n- final\n- 权限修饰符\n- 代码块\n\n## 教学目标\n\n- [ ] 能够说出使用多态的前提条件\n- [ ] 理解多态的向上转型\n- [ ] 理解多态的向下转型\n- [ ] 能够知道多态的使用场景\n\n- [ ] 包的作用\n- [ ] public和private权限修饰符的作用\n- [ ] 描述final修饰的类的特点\n- [ ] 描述final修饰的方法的特点\n- [ ] 描述final修饰的变量的特点\n\n\n\n# 第一章 多态\n\n## 1.1 多态的形式\n\n**多态是继封装、继承之后，面向对象的第三大特性。**\n\n**多态是出现在继承或者实现关系中的**。\n\n**多态体现的格式**：\n\n```java\n父类类型 变量名 = new 子类/实现类构造器;\n变量名.方法名();\n```\n\n**多态的前提**：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。\n\n## 1.2 多态的使用场景\n\n如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。\n\n![多态的应用场景](img\\多态的应用场景1.png)\n\n有了多态之后，方法的形参就可以定义为共同的父类Person。\n\n**要注意的是：**\n\n* 当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。\n* 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。\n* 而且多态还可以根据传递的不同对象来调用不同类中的方法。\n\n![多态的应用场景](img\\多态的应用场景2.png)\n\n代码示例：\n\n```java\n父类：\npublic class Person {\n    private String name;\n    private int age;\n\n    空参构造\n    带全部参数的构造\n    get和set方法\n\n    public void show(){\n        System.out.println(name + ", " + age);\n    }\n}\n\n子类1：\npublic class Administrator extends Person {\n    @Override\n    public void show() {\n        System.out.println("管理员的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n子类2：\npublic class Student extends Person{\n\n    @Override\n    public void show() {\n        System.out.println("学生的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n子类3：\npublic class Teacher extends Person{\n\n    @Override\n    public void show() {\n        System.out.println("老师的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n测试类：\npublic class Test {\n    public static void main(String[] args) {\n        //创建三个对象，并调用register方法\n\n        Student s = new Student();\n        s.setName("张三");\n        s.setAge(18);\n\n\n        Teacher t = new Teacher();\n        t.setName("王建国");\n        t.setAge(30);\n\n        Administrator admin = new Administrator();\n        admin.setName("管理员");\n        admin.setAge(35);\n\n\n\n        register(s);\n        register(t);\n        register(admin);\n\n\n    }\n\n\n\n    //这个方法既能接收老师，又能接收学生，还能接收管理员\n    //只能把参数写成这三个类型的父类\n    public static void register(Person p){\n        p.show();\n    }\n}\n```\n\n## 1.3 多态的定义和前提\n\n**多态**： 是指同一行为，具有多个不同表现形式。\n\n从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。\n\n **前提【重点】**\n\n1. 有继承或者实现关系\n\n2. 方法的重写【意义体现：不重写，无意义】\n\n3. 父类引用指向子类对象【格式体现】\n\n   > 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。\n\n## 1.4 多态的运行特点\n\n调用成员变量时：编译看左边，运行看左边\n\n调用成员方法时：编译看左边，运行看右边\n\n代码示例：\n\n```java\nFu f = new Zi()；\n//编译看左边的父类中有没有name这个属性，没有就报错\n//在实际运行的时候，把父类name属性的值打印出来\nSystem.out.println(f.name);\n//编译看左边的父类中有没有show这个方法，没有就报错\n//在实际运行的时候，运行的是子类中的show方法\nf.show();\n```\n\n## 1.5 多态的弊端\n\n我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时**多态的写法就无法访问子类独有功能了**。\n\n```java \nclass Animal{\n    public  void eat()｛\n        System.out.println("动物吃东西！")\n    ｝\n}\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println("吃鱼");  \n    }  \n   \n    public void catchMouse() {  \n        System.out.println("抓老鼠");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println("吃骨头");  \n    }  \n}\n\nclass Test{\n    public static void main(String[] args){\n        Animal a = new Cat();\n        a.eat();\n        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法\n    }\n}\n```\n\n## 1.6 引用类型转换\n\n### 1.6.1 为什么要转型\n\n**多态的写法就无法访问子类独有功能了。**\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。\n\n回顾基本数据类型转换\n\n- 自动转换: 范围小的赋值给范围大的.自动完成:double d = 5; \n- 强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14 \n\n​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。\n\n### 1.6.2 向上转型（自动转换）\n\n- **向上转型**：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。\n  当父类引用指向一个子类对象时，便是向上转型。\n  使用格式：\n\n```java\n父类类型  变量名 = new 子类类型();\n如：Animal a = new Cat();\n```\n\n**原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。**所以子类范围小可以直接自动转型给父类类型的变量。\n\n### 1.6.3 向下转型（强制转换）\n\n- **向下转型**：父类类型向子类类型向下转换的过程，这个过程是强制的。\n  一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\n\n使用格式：\n\n```java\n子类类型 变量名 = (子类类型) 父类变量名;\n如:Aniaml a = new Cat();\n   Cat c =(Cat) a;  \n```\n\n### 1.6.4 案例演示\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，**不能调用**子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。\n\n转型演示，代码如下：\n\n定义类：\n\n```java\nabstract class Animal {  \n    abstract void eat();  \n}  \n\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println("吃鱼");  \n    }  \n    public void catchMouse() {  \n        System.out.println("抓老鼠");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println("吃骨头");  \n    }  \n    public void watchHouse() {  \n        System.out.println("看家");  \n    }  \n}\n```\n\n定义测试类：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat(); \t\t\t\t// 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Cat c = (Cat)a;       \n        c.catchMouse(); \t\t// 调用的是 Cat 的 catchMouse\n    }  \n}\n```\n\n### 1.6.5 转型的异常\n\n转型的过程中，一不小心就会遇到这样的问题，请看如下代码：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Dog d = (Dog)a;       \n        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】\n    }  \n}\n```\n\n这段代码可以通过编译，但是运行时，却报出了 `ClassCastException` ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。\n\n### 1.6.6 instanceof关键字\n\n为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：\n\n```java\n变量名 instanceof 数据类型 \n如果变量属于该数据类型或者其子类类型，返回true。\n如果变量不属于该数据类型或者其子类类型，返回false。\n```\n\n所以，转换前，我们最好先做一个判断，代码如下：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        if (a instanceof Cat){\n            Cat c = (Cat)a;       \n            c.catchMouse();        // 调用的是 Cat 的 catchMouse\n        } else if (a instanceof Dog){\n            Dog d = (Dog)a;       \n            d.watchHouse();       // 调用的是 Dog 的 watchHouse\n        }\n    }  \n}\n```\n\n### 1.6.7 instanceof新特性\n\nJDK14的时候提出了新特性，把判断和强转合并成了一行\n\n```java\n//新特性\n//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d\n//如果不是，则不强转，结果直接是false\nif(a instanceof Dog d){\n    d.lookHome();\n}else if(a instanceof Cat c){\n    c.catchMouse();\n}else{\n    System.out.println("没有这个类型，无法转换");\n}\n```\n\n### 1.7 综合练习\n\n```java\n需求：根据需求完成代码:\n\t1.定义狗类\n\t\t属性：\n\t\t\t年龄，颜色\n\t\t行为:\n\t\t\teat(String something)(something表示吃的东西)\n\t\t\t看家lookHome方法(无参数)\n2.定义猫类\n\t属性：\n\t\t年龄，颜色\n\t行为:\n\t\teat(String something)方法(something表示吃的东西)\n\t\t逮老鼠catchMouse方法(无参数)\n3.定义Person类//饲养员\n\t属性：\n\t\t姓名，年龄\n\t行为：\n\t\tkeepPet(Dog dog,String something)方法\n\t\t\t功能：喂养宠物狗，something表示喂养的东西\n\t行为：\n\t\tkeepPet(Cat cat,String something)方法\n\t\t\t功能：喂养宠物猫，something表示喂养的东西\n\t生成空参有参构造，set和get方法  \n4.定义测试类(完成以下打印效果):\n\tkeepPet(Dog dog,String somethind)方法打印内容如下：\n\t\t年龄为30岁的老王养了一只黑颜色的2岁的狗\n\t\t2岁的黑颜色的狗两只前腿死死的抱住骨头猛吃\n\tkeepPet(Cat cat,String somethind)方法打印内容如下：\n\t\t年龄为25岁的老李养了一只灰颜色的3岁的猫\n\t\t3岁的灰颜色的猫眯着眼睛侧着头吃鱼\n5.思考：\t\t\n\t1.Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？\n\t2.Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？\n```\n画图分析：\n\n![多态练习的分析](img\\多态练习的分析.png)\n\n\n\n代码示例：\n\n```java\n//动物类（父类）\npublic class Animal {\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(int age, String color) {\n        this.age = age;\n        this.color = color;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void eat(String something){\n        System.out.println("动物在吃" + something);\n    }\n}\n\n//猫类（子类）\npublic class Cat extends Animal {\n\n    public Cat() {\n    }\n\n    public Cat(int age, String color) {\n        super(age, color);\n    }\n\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + "岁的" + getColor() + "颜色的猫眯着眼睛侧着头吃" + something);\n    }\n\n    public void catchMouse(){\n        System.out.println("猫抓老鼠");\n    }\n\n}\n\n//狗类（子类）\npublic class Dog extends Animal {\n    public Dog() {\n    }\n\n    public Dog(int age, String color) {\n        super(age, color);\n    }\n\n    //行为\n    //eat(String something)(something表示吃的东西)\n    //看家lookHome方法(无参数)\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + "岁的" + getColor() + "颜色的狗两只前腿死死的抱住" + something + "猛吃");\n    }\n\n    public void lookHome(){\n        System.out.println("狗在看家");\n    }\n}\n\n\n//饲养员类\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    //饲养狗\n   /* public void keepPet(Dog dog, String something) {\n        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getColor() + "颜色的" + dog.getAge() + "岁的狗");\n        dog.eat(something);\n    }\n\n    //饲养猫\n    public void keepPet(Cat cat, String something) {\n        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getColor() + "颜色的" + cat.getAge() + "岁的猫");\n        cat.eat(something);\n    }*/\n\n\n    //想要一个方法，能接收所有的动物，包括猫，包括狗\n    //方法的形参：可以写这些类的父类 Animal\n    public void keepPet(Animal a, String something) {\n        if(a instanceof Dog d){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + a.getColor() + "颜色的" + a.getAge() + "岁的狗");\n            d.eat(something);\n        }else if(a instanceof Cat c){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + c.getColor() + "颜色的" + c.getAge() + "岁的猫");\n            c.eat(something);\n        }else{\n            System.out.println("没有这种动物");\n        }\n    }\n}\n\n//测试类\npublic class Test {\n    public static void main(String[] args) {\n        //创建对象并调用方法\n       /* Person p1 = new Person("老王",30);\n        Dog d = new Dog(2,"黑");\n        p1.keepPet(d,"骨头");\n\n\n        Person p2 = new Person("老李",25);\n        Cat c = new Cat(3,"灰");\n        p2.keepPet(c,"鱼");*/\n\n\n        //创建饲养员的对象\n        Person p = new Person("老王",30);\n        Dog d = new Dog(2,"黑");\n        Cat c = new Cat(3,"灰");\n        p.keepPet(d,"骨头");\n        p.keepPet(c,"鱼");\n\n    }\n}\n```\n\n# 第二章 包\n\n## 2.1 包\n\n​\t包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。\n\n在IDEA项目中，建包的操作如下：\n\n![](img/aaa.jpg)\n\n**包名的命名规范**：\n\n```java\n路径名.路径名.xxx.xxx\n// 例如：com.itheima.oa\n```\n\n- 包名一般是公司域名的倒写。例如：黑马是www.itheima.com,包名就可以定义成com.itheima.技术名称。\n- 包名必须用”.“连接。\n- 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。\n\n## 2.2 导包\n\n什么时候需要导包？\n\n​\t情况一：在使用Java中提供的非核心包中的类时\n\n​\t情况二：使用自己写的其他包中的类时\n\n什么时候不需要导包？\n\n​\t情况一：在使用Java核心包（java.lang）中的类时\n\n​\t情况二：在使用自己写的同一个包中的类时\n\n## 2.3 使用不同包下的相同类怎么办？\n\n假设demo1和demo2中都有一个Student该如何使用？\n\n代码示例：\n\n```java\n//使用全类名的形式即可。\n//全类名：包名 + 类名\n//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference\ncom.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();\ncom.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();\n```\n\n# 第三章 权限修饰符\n\n## 3.1 权限修饰符\n\n​\t在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。\n\n- public：公共的，所有地方都可以访问。\n\n- protected：本类 ，本包，其他包中的子类都可以访问。\n\n- 默认（没有修饰符）：本类 ，本包可以访问。\n\n  注意：默认是空着不写，不是default\n\n- private：私有的，当前类可以访问。\n  `public > protected > 默认 > private`\n\n## 3.2 不同权限的访问能力\n\n|                  | public | protected | 默认 | private |\n| ---------------- | ------ | --------- | ---- | ------- |\n| 同一类中         | √      | √         | √    | √       |\n| 同一包中的类     | √      | √         | √    |         |\n| 不同包的子类     | √      | √         |      |         |\n| 不同包中的无关类 | √      |           |      |         |\n\n可见，public具有最大权限。private则是最小权限。\n\n编写代码时，如果没有特殊的考虑，建议这样使用权限：\n\n- 成员变量使用`private` ，隐藏细节。\n- 构造方法使用` public` ，方便创建对象。\n- 成员方法使用`public` ，方便调用方法。\n\n> 小贴士：不加权限修饰符，就是默认权限\n\n# 第四章 final关键字\n\n## 4.1 概述\n\n​\t学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。\n\n如果有一个方法我不想别人去改写里面内容，该怎么办呢？\n\nJava提供了`final` 关键字，表示修饰的内容不可变。\n\n- **final**：  不可改变，最终的含义。可以用于修饰类、方法和变量。\n  - 类：被修饰的类，不能被继承。\n  - 方法：被修饰的方法，不能被重写。\n  - 变量：被修饰的变量，有且仅能被赋值一次。\n\n## 4.2 使用方式\n\n### 4.2.1 修饰类\n\nfinal修饰的类，不能被继承。\n\n格式如下：\n\n```java\nfinal class 类名 {\n}\n```\n\n代码:\n\n```java\nfinal class Fu {\n}\n// class Zi extends Fu {} // 报错,不能继承final的类\n```\n\n查询API发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。\n\n### 4.2.2 修饰方法\n\nfinal修饰的方法，不能被重写。\n格式如下：\n\n```java\n修饰符 final 返回值类型 方法名(参数列表){\n    //方法体\n}\n```\n\n代码: \n\n```java\nclass Fu2 {\n\tfinal public void show1() {\n\t\tSystem.out.println("Fu2 show1");\n\t}\n\tpublic void show2() {\n\t\tSystem.out.println("Fu2 show2");\n\t}\n}\n\nclass Zi2 extends Fu2 {\n//\t@Override\n//\tpublic void show1() {\n//\t\tSystem.out.println("Zi2 show1");\n//\t}\n\t@Override\n\tpublic void show2() {\n\t\tSystem.out.println("Zi2 show2");\n\t}\n}\n```\n\n### 4.2.3 修饰变量-局部变量\n\n1. **局部变量——基本类型**\n   基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：\n\n```java\npublic class FinalDemo1 {\n    public static void main(String[] args) {\n        // 声明变量，使用final修饰\n        final int a;\n        // 第一次赋值 \n        a = 10;\n        // 第二次赋值\n        a = 20; // 报错,不可重新赋值\n\n        // 声明变量，直接赋值，使用final修饰\n        final int b = 10;\n        // 第二次赋值\n        b = 20; // 报错,不可重新赋值\n    }\n}\n```\n\n思考，下面两种写法，哪种可以通过编译？\n\n写法1：\n\n```java\nfinal int c = 0;\nfor (int i = 0; i < 10; i++) {\n    c = i;\n    System.out.println(c);\n}\n```\n\n写法2：\n\n```java\nfor (int i = 0; i < 10; i++) {\n    final int c = i;\n    System.out.println(c);\n}\n```\n\n根据 `final` 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。\n\n### 4.2.4 修饰变量-成员变量\n\n成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：\n\n- 显示初始化(在定义成员变量的时候立马赋值)（常用）；\n\n```java\npublic class Student {\n    final int num = 10;\n}\n```\n\n- 构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。\n\n  **注意：每个构造方法中都要赋值一次！**\n\n```java\npublic class Student {\n    final int num = 10;\n    final int num2;\n\n    public Student() {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n    \n     public Student(String name) {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n}\n```\n\n> 被final修饰的常量名称，一般都有书写规范，所有字母都**大写**。\n\n\n\n\n\n'},{title:"抽象类",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[{level:3,title:"1.1.1 抽象类引入",slug:"_1-1-1-抽象类引入",link:"#_1-1-1-抽象类引入",children:[]}]},{level:2,title:"1.2 abstract使用格式",slug:"_1-2-abstract使用格式",link:"#_1-2-abstract使用格式",children:[{level:3,title:"1.2.1 抽象方法",slug:"_1-2-1-抽象方法",link:"#_1-2-1-抽象方法",children:[]},{level:3,title:"1.2.2 抽象类",slug:"_1-2-2-抽象类",link:"#_1-2-2-抽象类",children:[]},{level:3,title:"1.2.3 抽象类的使用",slug:"_1-2-3-抽象类的使用",link:"#_1-2-3-抽象类的使用",children:[]}]},{level:2,title:"1.3 抽象类的特征",slug:"_1-3-抽象类的特征",link:"#_1-3-抽象类的特征",children:[]},{level:2,title:"1.4 抽象类的细节",slug:"_1-4-抽象类的细节",link:"#_1-4-抽象类的细节",children:[]},{level:2,title:"1.5 抽象类存在的意义",slug:"_1-5-抽象类存在的意义",link:"#_1-5-抽象类存在的意义",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 定义格式",slug:"_2-2-定义格式",link:"#_2-2-定义格式",children:[]},{level:2,title:"2.3 接口成分的特点",slug:"_2-3-接口成分的特点",link:"#_2-3-接口成分的特点",children:[{level:3,title:"2.3.1.抽象方法",slug:"_2-3-1-抽象方法",link:"#_2-3-1-抽象方法",children:[]},{level:3,title:"2.3.2 常量",slug:"_2-3-2-常量",link:"#_2-3-2-常量",children:[]},{level:3,title:"2.3.3 案例演示",slug:"_2-3-3-案例演示",link:"#_2-3-3-案例演示",children:[]}]},{level:2,title:"2.4 基本的实现",slug:"_2-4-基本的实现",link:"#_2-4-基本的实现",children:[{level:3,title:"2.4.1 实现接口的概述",slug:"_2-4-1-实现接口的概述",link:"#_2-4-1-实现接口的概述",children:[]},{level:3,title:"2.4.2 实现接口的格式",slug:"_2-4-2-实现接口的格式",link:"#_2-4-2-实现接口的格式",children:[]},{level:3,title:"2.4.3 类实现接口的要求和意义",slug:"_2-4-3-类实现接口的要求和意义",link:"#_2-4-3-类实现接口的要求和意义",children:[]},{level:3,title:"2.4.4  类与接口基本实现案例",slug:"_2-4-4-类与接口基本实现案例",link:"#_2-4-4-类与接口基本实现案例",children:[]},{level:3,title:"2.4.5 类与接口的多实现案例",slug:"_2-4-5-类与接口的多实现案例",link:"#_2-4-5-类与接口的多实现案例",children:[]}]},{level:2,title:"2.5 接口与接口的多继承",slug:"_2-5-接口与接口的多继承",link:"#_2-5-接口与接口的多继承",children:[]},{level:2,title:"2.6扩展：接口的细节",slug:"_2-6扩展-接口的细节",link:"#_2-6扩展-接口的细节",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[{level:3,title:"3.1.1 什么是内部类",slug:"_3-1-1-什么是内部类",link:"#_3-1-1-什么是内部类",children:[]},{level:3,title:"3.1.2 什么时候使用内部类",slug:"_3-1-2-什么时候使用内部类",link:"#_3-1-2-什么时候使用内部类",children:[]}]},{level:2,title:"3.2 内部类的分类",slug:"_3-2-内部类的分类",link:"#_3-2-内部类的分类",children:[]},{level:2,title:"3.3 成员内部类",slug:"_3-3-成员内部类",link:"#_3-3-成员内部类",children:[]},{level:2,title:"3.4 成员内部类的细节",slug:"_3-4-成员内部类的细节",link:"#_3-4-成员内部类的细节",children:[]},{level:2,title:"3.5 成员内部类面试题",slug:"_3-5-成员内部类面试题",link:"#_3-5-成员内部类面试题",children:[]},{level:2,title:"3.6 成员内部类内存图",slug:"_3-6-成员内部类内存图",link:"#_3-6-成员内部类内存图",children:[]},{level:2,title:"3.7 静态内部类",slug:"_3-7-静态内部类",link:"#_3-7-静态内部类",children:[]},{level:2,title:"3.8 局部内部类",slug:"_3-8-局部内部类",link:"#_3-8-局部内部类",children:[]},{level:2,title:"3.9 匿名内部类【重点】",slug:"_3-9-匿名内部类【重点】",link:"#_3-9-匿名内部类【重点】",children:[{level:3,title:"3.9.1 概述",slug:"_3-9-1-概述",link:"#_3-9-1-概述",children:[]},{level:3,title:"3.9.2 格式",slug:"_3-9-2-格式",link:"#_3-9-2-格式",children:[]},{level:3,title:"3.9.2 什么时候用到匿名内部类",slug:"_3-9-2-什么时候用到匿名内部类",link:"#_3-9-2-什么时候用到匿名内部类",children:[]},{level:3,title:"3.9.3 匿名内部类前提和格式",slug:"_3-9-3-匿名内部类前提和格式",link:"#_3-9-3-匿名内部类前提和格式",children:[]},{level:3,title:"3.9.4 使用方式",slug:"_3-9-4-使用方式",link:"#_3-9-4-使用方式",children:[]},{level:3,title:"3.9.5 匿名内部类的特点",slug:"_3-9-5-匿名内部类的特点",link:"#_3-9-5-匿名内部类的特点",children:[]},{level:3,title:"3.9.6 匿名内部类的使用场景",slug:"_3-9-6-匿名内部类的使用场景",link:"#_3-9-6-匿名内部类的使用场景",children:[]}]}],path:"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:'---\ntitle: 抽象类\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n抽象类\n\n\x3c!-- more --\x3e\n## 今日内容\n- 抽象类\n- 接口\n- 内部类\n\n## 教学目标 \n- [ ] 能够写出抽象类的格式\n- [ ] 能够写出抽象方法的格式\n- [ ] 能说出抽象类的应用场景\n- [ ] 写出定义接口的格式\n- [ ] 写出实现接口的格式\n- [ ] 说出接口中成员的特点\n- [ ] 能说出接口的应用场景\n- [ ] 能说出接口中为什么会出现带有方法体的方法\n- [ ] 能完成适配器设计模式\n\n# 第一章 抽象类\n\n## 1.1 概述\n\n### 1.1.1 抽象类引入\n\n​\t父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。**我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类**。\n\n- **抽象方法** ： 没有方法体的方法。\n- **抽象类**：包含抽象方法的类。\n\n## 1.2 abstract使用格式\n\n**abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。**\n\n### 1.2.1 抽象方法\n\n使用`abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。\n\n定义格式：\n\n```java\n修饰符 abstract 返回值类型 方法名 (参数列表)；\n```\n\n代码举例：\n\n```java\npublic abstract void run()；\n```\n\n### 1.2.2 抽象类\n\n如果一个类包含抽象方法，那么该类必须是抽象类。**注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。**\n\n定义格式：\n\n```java\nabstract class 类名字 { \n  \n}\n```\n\n代码举例：\n\n```java\npublic abstract class Animal {\n    public abstract void run()；\n}\n```\n\n### 1.2.3 抽象类的使用\n\n**要求**：继承抽象类的子类**必须重写父类所有的抽象方法**。否则，该子类也必须声明为抽象类。\n\n代码举例：\n\n```java\n// 父类,抽象类\nabstract class Employee {\n\tprivate String id;\n\tprivate String name;\n\tprivate double salary;\n\t\n\tpublic Employee() {\n\t}\n\t\n\tpublic Employee(String id, String name, double salary) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\t\n\t// 抽象方法\n\t// 抽象方法必须要放在抽象类中\n\tabstract public void work();\n}\n\n// 定义一个子类继承抽象类\nclass Manager extends Employee {\n\tpublic Manager() {\n\t}\n\tpublic Manager(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t// 2.重写父类的抽象方法\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println("管理其他人");\n\t}\n}\n\n// 定义一个子类继承抽象类\nclass Cook extends Employee {\n\tpublic Cook() {\n\t}\n\tpublic Cook(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println("厨师炒菜多加点盐...");\n\t}\n}\n\n// 测试类\npublic class Demo10 {\n\tpublic static void main(String[] args) {\n\t\t// 创建抽象类,抽象类不能创建对象\n\t\t// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象\n//\t\tEmployee e = new Employee();\n//\t\te.work();\n\t\t\n\t\t// 3.创建子类\n\t\tManager m = new Manager();\n\t\tm.work();\n\t\t\n\t\tCook c = new Cook("ap002", "库克", 1);\n\t\tc.work();\n\t}\n}\n```\n\n此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做**实现方法**。\n\n## 1.3 抽象类的特征\n\n抽象类的特征总结起来可以说是 **有得有失**\n\n**有得：抽象类得到了拥有抽象方法的能力。**\n\n**有失：抽象类失去了创建对象的能力。**\n\n其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。\n\n## 1.4 抽象类的细节\n\n不需要背，只要当idea报错之后，知道如何修改即可。\n\n关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。\n\n1. 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。\n\n   > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n\n2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\n\n   > 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。\n\n3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n\n   > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。\n\n4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 \n\n   > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。\n\n5. 抽象类存在的意义是为了被子类继承。\n\n   > 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。\n\n## 1.5 抽象类存在的意义\n\n​\t抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。\n\n# 第二章 接口\n\n## 2.1 概述\n\n我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。那么什么是接口呢？**接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的**。\n\n## 2.2 定义格式\n\n```java\n//接口的定义格式：\ninterface 接口名称{\n    // 抽象方法\n}\n\n// 接口的声明：interface\n// 接口名称：首字母大写，满足“驼峰模式”\n```\n\n## 2.3 接口成分的特点\n\n  在JDK7，包括JDK7之前，接口中的**只有**包含：抽象方法和常量\n\n### 2.3.1.抽象方法\n\n​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！\n​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。\n\n### 2.3.2 常量\n\n 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。\n\n### 2.3.3 案例演示\n\n```java\npublic interface InterF {\n    // 抽象方法！\n    //    public abstract void run();\n    void run();\n\n    //    public abstract String getName();\n    String getName();\n\n    //    public abstract int add(int a , int b);\n    int add(int a , int b);\n\n\n    // 它的最终写法是：\n    // public static final int AGE = 12 ;\n    int AGE  = 12; //常量\n    String SCHOOL_NAME = "黑马程序员";\n\n}\n```\n\n## 2.4 基本的实现\n\n### 2.4.1 实现接口的概述\n\n类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 ` implements`关键字。\n\n### 2.4.2 实现接口的格式\n\n```java\n/**接口的实现：\n    在Java中接口是被实现的，实现接口的类称为实现类。\n    实现类的格式:*/\nclass 类名 implements 接口1,接口2,接口3...{\n\n}\n```\n\n从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？\n\n### 2.4.3 类实现接口的要求和意义\n\n1. 必须重写实现的全部接口中所有抽象方法。\n2. 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。\n3. **意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。**\n\n### 2.4.4  类与接口基本实现案例\n\n假如我们定义一个运动员的**接口**（规范），代码如下：\n\n```java\n/**\n   接口：接口体现的是规范。\n * */\npublic interface SportMan {\n    void run(); // 抽象方法，跑步。\n    void law(); // 抽象方法，遵守法律。\n    String compittion(String project);  // 抽象方法，比赛。\n}\n```\n\n接下来定义一个乒乓球运动员类，实现接口，实现接口的**实现类**代码如下：\n\n```java\npackage com.itheima._03接口的实现;\n/**\n * 接口的实现：\n *    在Java中接口是被实现的，实现接口的类称为实现类。\n *    实现类的格式:\n *      class 类名 implements 接口1,接口2,接口3...{\n *\n *\n *      }\n * */\npublic class PingPongMan  implements SportMan {\n    @Override\n    public void run() {\n        System.out.println("乒乓球运动员稍微跑一下！！");\n    }\n\n    @Override\n    public void law() {\n        System.out.println("乒乓球运动员守法！");\n    }\n\n    @Override\n    public String compittion(String project) {\n        return "参加"+project+"得金牌！";\n    }\n}\n```\n\n**测试代码**：\n\n```java\npublic class TestMain {\n    public static void main(String[] args) {\n        // 创建实现类对象。\n        PingPongMan zjk = new PingPongMan();\n        zjk.run();\n        zjk.law();\n        System.out.println(zjk.compittion("全球乒乓球比赛"));\n\n    }\n}\n```\n\n### 2.4.5 类与接口的多实现案例\n\n**类与接口之间的关系是多实现的，一个类可以同时实现多个接口。**\n\n首先我们先定义两个接口，代码如下：\n\n```java\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n}\n\n/** 这一个运动员的规范：接口*/\npublic interface SportMan {\n    void run();\n}\n\n```\n\n然后定义一个实现类：\n\n```java\n/**\n * Java中接口是可以被多实现的：\n *    一个类可以实现多个接口: Law, SportMan\n *\n * */\npublic class JumpMan implements Law ,SportMan {\n    @Override\n    public void rule() {\n        System.out.println("尊长守法");\n    }\n\n    @Override\n    public void run() {\n        System.out.println("训练跑步！");\n    }\n}\n```\n\n从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。\n\n## 2.5 接口与接口的多继承\n\nJava中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：\n\n**类与接口是实现关系**\n\n**接口与接口是继承关系**\n\n接口继承接口就是把其他接口的抽象方法与本接口进行了合并。\n\n案例演示：\n\n```java \npublic interface Abc {\n    void go();\n    void test();\n}\n\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n    void test();\n}\n\n *\n *  总结：\n *     接口与类之间是多实现的。\n *     接口与接口之间是多继承的。\n * */\npublic interface SportMan extends Law , Abc {\n    void run();\n}\n```\n\n## 2.6扩展：接口的细节\n\n不需要背，只要当idea报错之后，知道如何修改即可。\n\n关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。\n\n1. 当两个接口中存在相同抽象方法的时候，该怎么办？\n\n> 只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。\n\n2. 实现类能不能继承A类的时候，同时实现其他接口呢？\n\n> 继承的父类，就好比是亲爸爸一样\n> 实现的接口，就好比是干爹一样\n> 可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。\n\n3. 实现类能不能继承一个抽象类的时候，同时实现其他接口呢？\n\n> 实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。\n\n4. 实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？\n\n> 处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。\n> 处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。\n\n5. 如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?\n\n> 可以在接口跟实现类中间，新建一个中间类（适配器类）\n> 让这个适配器类去实现接口，对接口里面的所有的方法做空重写。\n> 让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。\n> 因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象\n\n\n\n# 第三章 内部类\n\n## 3.1 概述\n\n### 3.1.1 什么是内部类\n\n将一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则称为**外部类**。可以把内部类理解成寄生，外部类理解成宿主。\n\n### 3.1.2 什么时候使用内部类\n\n一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用\n\n1. 人里面有一颗心脏。\n2. 汽车内部有一个发动机。\n3. 为了实现更好的封装性。\n\n## 3.2 内部类的分类\n\n按定义的位置来分\n\n1. **成员内部内**，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)\n2. **静态内部类**，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)\n3. **局部内部类**，类定义在方法内\n4. **匿名内部类**，没有名字的内部类，可以在方法中，也可以在类中方法外。\n\n## 3.3 成员内部类\n\n**成员内部类特点**：\n\n- 无static修饰的内部类，属于外部类对象的。\n- 宿主：外部类对象。\n\n**内部类的使用格式**：\n\n```java\n 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类\n```\n\n**获取成员内部类对象的两种方式**：\n\n方式一：外部直接创建成员内部类的对象\n\n```java\n外部类.内部类 变量 = new 外部类（）.new 内部类（）;\n```\n\n方式二：在外部类中定义一个方法提供内部类的对象\n\n**案例演示**\n\n```java\n方式一：\npublic class Test {\n    public static void main(String[] args) {\n        //  宿主：外部类对象。\n       // Outer out = new Outer();\n        // 创建内部类对象。\n        Outer.Inner oi = new Outer().new Inner();\n        oi.method();\n    }\n}\n\nclass Outer {\n    // 成员内部类，属于外部类对象的。\n    // 拓展：成员内部类不能定义静态成员。\n    public class Inner{\n        // 这里面的东西与类是完全一样的。\n        public void method(){\n            System.out.println("内部类中的方法被调用了");\n        }\n    }\n}\n\n\n方式二：\npublic class Outer {\n    String name;\n    private class Inner{\n        static int a = 10;\n    }\n    public Inner getInstance(){\n        return new Inner();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        System.out.println(o.getInstance());\n\n\n    }\n}\n```\n\n## 3.4 成员内部类的细节\n\n编写成员内部类的注意点：\n\n1. 成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等\n2. 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。\n3. 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）\n\n详解：\n\n​\t内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象\n\n​\t被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象\n\n​\t内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。\n\n​\t内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。\n\n## 3.5 成员内部类面试题\n\n请在?地方向上相应代码,以达到输出的内容\n\n注意：内部类访问外部类对象的格式是：**外部类名.this**\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Outer.inner oi = new Outer().new inner();\n        oi.method();\n    }\n}\n\nclass Outer {\t// 外部类\n    private int a = 30;\n\n    // 在成员位置定义一个类\n    class inner {\n        private int a = 20;\n\n        public void method() {\n            int a = 10;\n            System.out.println(???);\t// 10   答案：a\n            System.out.println(???);\t// 20\t答案：this.a\n            System.out.println(???);\t// 30\t答案：Outer.this.a\n        }\n    }\n}\n```\n\n## 3.6 成员内部类内存图\n\n![内部类内存图](img\\内部类内存图.png)\n\n## 3.7 静态内部类\n\n**静态内部类特点**：\n\n* 静态内部类是一种特殊的成员内部类。\n\n- 有static修饰，属于外部类本身的。\n- 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。\n- **拓展1**:静态内部类可以直接访问外部类的静态成员。\n- **拓展2**:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。\n- **拓展3**:静态内部类中没有银行的Outer.this。\n\n**内部类的使用格式**：\n\n```\n外部类.内部类。\n```\n\n**静态内部类对象的创建格式**：\n\n```java\n外部类.内部类  变量 = new  外部类.内部类构造器;\n```\n\n**调用方法的格式：**\n\n* 调用非静态方法的格式：先创建对象，用对象调用\n* 调用静态方法的格式：外部类名.内部类名.方法名();\n\n**案例演示**：\n\n```java\n// 外部类：Outer01\nclass Outer01{\n    private static  String sc_name = "黑马程序";\n    // 内部类: Inner01\n    public static class Inner01{\n        // 这里面的东西与类是完全一样的。\n        private String name;\n        public Inner01(String name) {\n            this.name = name;\n        }\n        public void showName(){\n            System.out.println(this.name);\n            // 拓展:静态内部类可以直接访问外部类的静态成员。\n            System.out.println(sc_name);\n        }\n    }\n}\n\npublic class InnerClassDemo01 {\n    public static void main(String[] args) {\n        // 创建静态内部类对象。\n        // 外部类.内部类  变量 = new  外部类.内部类构造器;\n        Outer01.Inner01 in  = new Outer01.Inner01("张三");\n        in.showName();\n    }\n}\n```\n\n## 3.8 局部内部类\n\n- **局部内部类** ：定义在**方法中**的类。\n\n定义格式:\n\n```java\nclass 外部类名 {\n\t数据类型 变量名;\n\t\n\t修饰符 返回值类型 方法名(参数列表) {\n\t\t// …\n\t\tclass 内部类 {\n\t\t\t// 成员变量\n\t\t\t// 成员方法\n\t\t}\n\t}\n}\n```\n\n## 3.9 匿名内部类【重点】\n\n### 3.9.1 概述\n\n**匿名内部类** ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。\n\n### 3.9.2 格式\n\n```java\nnew 类名或者接口名() {\n     重写方法;\n};\n```\n\n包含了：\n\n* 继承或者实现关系\n\n* 方法重写\n* 创建对象\n\n所以从语法上来讲，这个整体其实是匿名内部类对象\n\n### 3.9.2 什么时候用到匿名内部类 \n\n**实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用**\n\n**是为了简化代码**。 \n\n之前我们使用接口时，似乎得做如下几步操作：\n\n1. 定义子类\n2. 重写接口中的方法\n3. 创建子类对象\n4. 调用重写后的方法\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\n// 1. 定义接口的实现类\nclass Student implements Swim {\n    // 2. 重写抽象方法\n    @Override\n    public void swimming() {\n        System.out.println("狗刨式...");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        // 3. 创建实现类对象\n        Student s = new Student();\n        // 4. 调用方法\n        s.swimming();\n    }\n}\n```\n\n我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。\n\n### 3.9.3 匿名内部类前提和格式\n\n匿名内部类必须**继承一个父类**或者**实现一个父接口**。\n\n**匿名内部类格式**\n\n```java\nnew 父类名或者接口名(){\n    // 方法重写\n    @Override \n    public void method() {\n        // 执行语句\n    }\n};\n```\n\n### 3.9.4 使用方式\n\n以接口为例，匿名内部类的使用，代码如下：\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 使用匿名内部类\n\t\tnew Swim() {\n\t\t\t@Override\n\t\t\tpublic void swimming() {\n\t\t\t\tSystem.out.println("自由泳...");\n\t\t\t}\n\t\t}.swimming();\n\n        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法\n        Swim s2 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println("蛙泳...");\n            }\n        };\n\n        s2.swimming();\n        s2.swimming();\n    }\n}\n```\n\n### 3.9.5 匿名内部类的特点\n\n1. 定义一个没有名字的内部类\n2. 这个类实现了父类，或者父类接口\n3. 匿名内部类会创建这个没有名字的类的对象\n\n### 3.9.6 匿名内部类的使用场景\n\n通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：\n\n```java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 普通方式传入对象\n        // 创建实现类对象\n        Student s = new Student();\n        \n        goSwimming(s);\n        // 匿名内部类使用场景:作为方法参数传递\n        Swim s3 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println("蝶泳...");\n            }\n        };\n        // 传入匿名内部类\n        goSwimming(s3);\n\n        // 完美方案: 一步到位\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println("大学生, 蛙泳...");\n            }\n        });\n\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println("小学生, 自由泳...");\n            }\n        });\n    }\n\n    // 定义一个方法,模拟请一些人去游泳\n    public static void goSwimming(Swim s) {\n        s.swimming();\n    }\n}\n```\n\n'},{title:"day16-面向对象综合练习（上）",headers:[{level:2,title:"1. 设计游戏的目的",slug:"_1-设计游戏的目的",link:"#_1-设计游戏的目的",children:[]},{level:2,title:"2. 游戏的最终效果呈现",slug:"_2-游戏的最终效果呈现",link:"#_2-游戏的最终效果呈现",children:[]},{level:2,title:"3. 实现思路",slug:"_3-实现思路",link:"#_3-实现思路",children:[]},{level:2,title:"4. 三行代码实现主界面搭建",slug:"_4-三行代码实现主界面搭建",link:"#_4-三行代码实现主界面搭建",children:[{level:3,title:"界面效果：",slug:"界面效果",link:"#界面效果",children:[]},{level:3,title:"实现步骤：",slug:"实现步骤",link:"#实现步骤",children:[]}]},{level:2,title:"5. 主界面的其他设置",slug:"_5-主界面的其他设置",link:"#_5-主界面的其他设置",children:[]},{level:2,title:"6. 利用继承简化代码",slug:"_6-利用继承简化代码",link:"#_6-利用继承简化代码",children:[]},{level:2,title:"7. 菜单制作",slug:"_7-菜单制作",link:"#_7-菜单制作",children:[{level:3,title:"7.1菜单的组成",slug:"_7-1菜单的组成",link:"#_7-1菜单的组成",children:[]},{level:3,title:"7.2代码书写步骤",slug:"_7-2代码书写步骤",link:"#_7-2代码书写步骤",children:[]}]},{level:2,title:"8.添加图片",slug:"_8-添加图片",link:"#_8-添加图片",children:[{level:3,title:"8.1使用到的Java类",slug:"_8-1使用到的java类",link:"#_8-1使用到的java类",children:[]},{level:3,title:"8.2位置坐标",slug:"_8-2位置坐标",link:"#_8-2位置坐标",children:[]},{level:3,title:"8.3添加步骤：",slug:"_8-3添加步骤",link:"#_8-3添加步骤",children:[]},{level:3,title:"8.4 打乱图片的位置",slug:"_8-4-打乱图片的位置",link:"#_8-4-打乱图片的位置",children:[]}]},{level:2,title:"9. 事件",slug:"_9-事件",link:"#_9-事件",children:[{level:3,title:"9.1 常见的三个核心要素",slug:"_9-1-常见的三个核心要素",link:"#_9-1-常见的三个核心要素",children:[]},{level:3,title:"9.2 常见的三种事件监听",slug:"_9-2-常见的三种事件监听",link:"#_9-2-常见的三种事件监听",children:[]},{level:3,title:"9.3 动作监听",slug:"_9-3-动作监听",link:"#_9-3-动作监听",children:[]}]}],path:"/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html",pathLocale:"/",extraFields:'---\ntitle: day16-面向对象综合练习（上）\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nday16-面向对象综合练习（上）\n\n\x3c!-- more --\x3e\n## 1. 设计游戏的目的\n\n* 锻炼逻辑思维能力\n* 利用Java的图形化界面，写一个项目，知道前面学习的知识点在实际开发中的应用场景\n\n## 2. 游戏的最终效果呈现\n\nHello，各位同学大家好。今天，我们要写一个非常有意思的小游戏 ---《拼图小游戏》\n我们先来看一下游戏的最终成品展示，然后再一步一步的从0开始，完成游戏里面每一个细节。\n游戏运行之后，就是这样的界面。\n                                         ![创建项目1](img\\最终效果1.png) \n\n刚开始打开，是登录页面，因为是第一次运行，需要注册。点击注册就会跳转到注册页面\n\n​                                       ![创建项目1](img\\最终效果2.png)\n\n在注册页面我们可以注册账号，用户名如果已存在则会注册失败。\n\n​                                       ![创建项目1](img\\最终效果3.png)\n\n在游戏主界面中，我们可以利用上下左右移动小图片去玩游戏，还有快捷键A可以查看最终效果，W一键通关。\n\n## 3. 实现思路\n\n我们在写游戏的时候，也是一部分一部分完成的。\n\n先写游戏主界面，实现步骤如下：\n\n1，完成最外层窗体的搭建。\n\n2，再把菜单添加到窗体当中。\n\n3，把小图片添加到窗体当中。\n\n4，打乱数字图片的顺序。\n\n5，让数字图片可以移动起来。\n\n6，通关之后的胜利判断。\n\n7，添加其他额外的功能。\n\n## 4. 三行代码实现主界面搭建\n\n### 界面效果：\n\n![初始界面](img\\初始界面.png)\n\n### 实现步骤：\n\n1. 创建App类, 编写main方法\n\n   作用: 程序的主入口\n\n2. 书写以下代码\n\n```java\n//1.召唤主界面\nJFrame jFrame = new JFrame();\n\n//2.设置主界面的大小\njFrame.setSize(514,595);\n\n//3.让主界面显示出来\njFrame.setVisible(true);\n```\n\n## 5. 主界面的其他设置\n\n   ```java\n//1.召唤主界面\nJFrame jFrame = new JFrame();\n\n//设置主界面的大小\njFrame.setSize(514,595);\n\n//将主界面设置到屏幕的正中央\njFrame.setLocationRelativeTo(null);\n\n//将主界面置顶\njFrame.setAlwaysOnTop(true);\n\n//关闭主界面的时候让代码一起停止\njFrame.setDefaultCloseOperation(3);\n\n//给主界面设置一个标题\njFrame.setTitle("拼图游戏单机版 v1.0");\n\n//2.让主界面显示出来\njFrame.setVisible(true);\n   ```\n\n   注意事项：\n\n​\tjFrame.setVisible(true);必须要写在最后一行。\n\n## 6. 利用继承简化代码\n\n需求：\n\n​\t如果把所有的代码都写在main方法中，那么main方法里面的代码，就包含游戏主界面的代码，登录界面的代码，注册界面的代码，会变得非常臃肿后期维护也是一件非常难的事情，所以我们需要用继承改进，改进之后，代码就可以分类了。\n\n```java\n//登录界面\npublic class LoginJFrame extends JFrame {\n    //LoginJFrame 表示登录界面\n    //以后所有跟登录相关的代码，都写在这里\n\n\n    public LoginJFrame(){\n        //在创建登录界面的时候，同时给这个界面去设置一些信息\n        //比如，宽高，直接展示出来\n        this.setSize(488,430);\n        //设置界面的标题\n        this.setTitle("拼图 登录");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //让显示显示出来，建议写在最后\n        this.setVisible(true);\n    }\n}\n\n\n\n//注册界面\npublic class RegisterJFrame extends JFrame {\n    //跟注册相关的代码，都写在这个界面中\n    public RegisterJFrame(){\n        this.setSize(488,500);\n        //设置界面的标题\n        this.setTitle("拼图 注册");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //让显示显示出来，建议写在最后\n        this.setVisible(true);\n\n\n        getContentPane();\n    }\n}\n\n//游戏主界面\npublic class GameJFrame extends JFrame {\n\n    public GameJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n    }\n}\n```\n\n注意点：\n\n​\t其中this表示当前窗体的意思。\n\n## 7. 菜单制作\n\n菜单就是下图红色边框的内容。\n\n![初始界面](img\\菜单.png)\n\n### 7.1菜单的组成\n\n![初始界面](img\\菜单2.png)\n在菜单中有：JMenuBar、JMenu、JMenuItem三个角色。\n\nJMenuBar：如上图中红色边框\n\nJMenu：如上图蓝色边框\n\nJMenuItem：如上图绿色字体处\n\n其中JMenuBar是整体，一个界面中一般只有一个JMenuBar。\n\n而JMenu是菜单中的选项，可以有多个。\n\nJMenuItem是选项下面的条目，也可以有多个。\n\n### 7.2代码书写步骤\n\n1，创建JMenuBar对象\n\n2，创建JMenu对象\n\n3，创建JMenuItem对象\n\n4，把JMenuItem添加到JMenu中\n\n5，把JMenu添加到JMenuBar中\n\n6，把整个JMenuBar设置到整个界面中\n\n代码示例：\n\n```java\n//创建一个菜单对象\nJMenuBar jMenuBar = new JMenuBar();\n//设置菜单的宽高\njMenuBar.setSize(514, 20);\n//创建一个选项\nJMenu jMenu1 = new JMenu("功能");\n//创建一个条目\njMenuItem1 = new JMenuItem("重新游戏");\n\n//把条目添加到选项当中\njMenu1.add(jMenuItem1);\n//把选项添加到菜单当中\njMenuBar.add(jMenu1);\n//把菜单添加到最外层的窗体当中\nthis.setJMenuBar(jMenuBar);\n```\n\n## 8.添加图片\n\n![](img\\添加图片.png)\n\n在上图中，其实是15张小图片。我们在添加图片的时候，要把添加图片的操作重复15次，才能把所有图片都添加到界面当中。\n\n### 8.1使用到的Java类\n\n​\tImageIcon：描述图片的类，可以关联计算中任意位置的图片。\n\n​\t\t\t    但是一般会把图片拷贝到当前项目中。\n\n​\tJLabel：用来管理图片，文字的类。\n\n​\t\t      可以用来设置位置，宽高。\n\n### 8.2位置坐标\n\n![](img\\坐标.png)\n\n界面左上角的点可以看做是坐标的原点，横向的是X轴，纵向的是Y轴。\n\n图片的位置其实取决于图片左上角的点，在坐标中的位置。\n\n如果是（0,0）那么该图片会显示再屏幕的左上角。\n\n### 8.3添加步骤：\n\n​\t1，取消整个界面的默认居中布局\n\n​\t2，创建ImageIcon对象，并制定图片位置。\n\n​\t3，创建JLabel对象，并把ImageIcon对象放到小括号中。\n\n​\t4，利用JLabel对象设置大小，宽高。\n\n​\t5，将JLabel对象添加到整个界面当中。\n\n代码示例：\n\n```java\n//1，先对整个界面进行设置\n\t//取消内部居中放置方式\n\tthis.setLayout(null);\n//2，创建ImageIcon对象，并制定图片位置。\n\tImageIcon imageIcon1 = new ImageIcon("image\\\\1.png");\n//3，创建JLabel对象，并把ImageIcon对象放到小括号中。\n\tJLabel jLabel1 = new JLabel(imageIcon1);\n//4，利用JLabel对象设置大小，宽高。\n\tjLabel1.setBounds(0, 0, 100, 100);\n//5，将JLabel对象添加到整个界面当中。\n\tthis.add(jLabel1);\n```\n\n以此类推，只要能确定15张图片的位置，把上面的代码重复写15遍，就可以将所有图片都添加到界面中了。\n\n### 8.4 打乱图片的位置\n\n每一张图片都对应1~15之间的数字，空白处为0，打乱图片实际上就是把数字打乱，添加图片的时候按照打乱的图片添加即可\n\n#### 8.4.1 打乱数组中数据的练习\n\n​\tint[] tempArr = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n\n​\t要求：打乱一维数组中的数据，并按照4个一组的方式添加到二维数组中。\n\n代码示例：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        //需求：\n        //把一个一维数组中的数据：0~15 打乱顺序\n        //然后再按照4个一组的方式添加到二维数组当中\n\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n        //3.遍历数组\n        for (int i = 0; i < tempArr.length; i++) {\n            System.out.print(tempArr[i] + " ");\n        }\n        System.out.println();\n\n        //4.创建一个二维数组\n        int[][] data = new int[4][4];\n\n        //5.给二维数组添加数据\n        //解法一：\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            data[i / 4][i % 4] = tempArr[i];\n        }\n\n        //遍历二维数组\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                System.out.print(data[i][j] + " ");\n            }\n            System.out.println();\n        }\n    }\n}\n\n```\n\n#### 8.4.2 打乱图片\n\n```java\npublic class GameJFrame extends JFrame {\n    //JFrame 界面，窗体\n    //子类呢？也表示界面，窗体\n    //规定：GameJFrame这个界面表示的就是游戏的主界面\n    //以后跟游戏相关的所有逻辑都写在这个类中\n\n    //创建一个二维数组\n    //目的：用来管理数据\n    //加载图片的时候，会根据二维数组中的数据进行加载\n    int[][] data = new int[4][4];\n\n    public GameJFrame() {\n        //初始化界面\n        initJFrame();\n\n        //初始化菜单\n        initJMenuBar();\n\n        //初始化数据（打乱）\n        initData();\n\n        //初始化图片（根据打乱之后的结果去加载图片）\n        initImage();\n\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n\n    }\n\n    //初始化数据（打乱）\n    private void initData() {\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n\n        //4.给二维数组添加数据\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            data[i / 4][i % 4] = tempArr[i];\n        }\n\n\n    }\n\n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\animal\\\\animal3\\\\" + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j, 105 * i, 105, 105);\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n\n        }\n\n\n    }\n\n\n    private void initJMenuBar() {\n        //创建整个的菜单对象\n        JMenuBar jMenuBar = new JMenuBar();\n\n        //创建菜单上面的两个选项的对象 （功能  关于我们）\n        JMenu functionJMenu = new JMenu("功能");\n        JMenu aboutJMenu = new JMenu("关于我们");\n\n        //创建选项下面的条目对象\n        JMenuItem replayItem = new JMenuItem("重新游戏");\n        JMenuItem reLoginItem = new JMenuItem("重新登录");\n        JMenuItem closeItem = new JMenuItem("关闭游戏");\n\n        JMenuItem accountItem = new JMenuItem("公众号");\n\n        //将每一个选项下面的条目天极爱到选项当中\n        functionJMenu.add(replayItem);\n        functionJMenu.add(reLoginItem);\n        functionJMenu.add(closeItem);\n\n        aboutJMenu.add(accountItem);\n\n        //将菜单里面的两个选项添加到菜单当中\n        jMenuBar.add(functionJMenu);\n        jMenuBar.add(aboutJMenu);\n\n        //给整个界面设置菜单\n        this.setJMenuBar(jMenuBar);\n    }\n\n    private void initJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n\n    }\n}\n```\n\n## 9. 事件\n\n​\t事件是可以被组件识别的操作。\n\n### 9.1 常见的三个核心要素\n\n* 事件源： 按钮 图片 窗体... \n* 事件：某些操作\n* 绑定监听：当事件源上发生了某个事件，则执行某段代码 \n\n### 9.2 常见的三种事件监听\n\n* 键盘监听 KeyListener\n* 鼠标监听 MouseListener\n* 动作监听 ActionListener\n\n### 9.3 动作监听\n\n包含：\n\n* 鼠标左键点击\n* 空格\n\n#### 9.3.1 事件的三种实现方式\n\n* 定义实现类实现接口\n* 匿名内部类\n* 本类实现接口\n\n#### 方式一：实现类\n\n​\t定义实现类实现ActionListener接口\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n        JFrame jFrame = new JFrame();\n        //设置界面的宽高\n        jFrame.setSize(603, 680);\n        //设置界面的标题\n        jFrame.setTitle("事件演示");\n        //设置界面置顶\n        jFrame.setAlwaysOnTop(true);\n        //设置界面居中\n        jFrame.setLocationRelativeTo(null);\n        //设置关闭模式\n        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        jFrame.setLayout(null);\n\n\n        //创建一个按钮对象\n        JButton jtb = new JButton("点我啊");\n        //设置位置和宽高\n        jtb.setBounds(0,0,100,50);\n        //给按钮添加动作监听\n        //jtb:组件对象，表示你要给哪个组件添加事件\n        //addActionListener：表示我要给组件添加哪个事件监听（动作监听包含鼠标左键点击，空格）\n        //参数：表示事件被触发之后要执行的代码\n        jtb.addActionListener(new MyActionListener());\n\n\n        //把按钮添加到界面当中\n        jFrame.getContentPane().add(jtb);\n\n\n        jFrame.setVisible(true);\n    }\n}\n\n\npublic class MyActionListener implements ActionListener {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println("按钮被点击了");\n    }\n}\n```\n\n#### 方式二：匿名内部类\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n        JFrame jFrame = new JFrame();\n        //设置界面的宽高\n        jFrame.setSize(603, 680);\n        //设置界面的标题\n        jFrame.setTitle("事件演示");\n        //设置界面置顶\n        jFrame.setAlwaysOnTop(true);\n        //设置界面居中\n        jFrame.setLocationRelativeTo(null);\n        //设置关闭模式\n        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        jFrame.setLayout(null);\n\n\n        //创建一个按钮对象\n        JButton jtb = new JButton("点我啊");\n        //设置位置和宽高\n        jtb.setBounds(0,0,100,50);\n        //给按钮添加动作监听\n        //jtb:组件对象，表示你要给哪个组件添加事件\n        //addActionListener：表示我要给组件添加哪个事件监听（动作监听包含鼠标左键点击，空格）\n        //参数：表示事件被触发之后要执行的代码\n\n        jtb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println("达咩~不要点我哟~");\n            }\n        });\n\n\n        //把按钮添加到界面当中\n        jFrame.getContentPane().add(jtb);\n\n\n        jFrame.setVisible(true);\n    }\n}\n```\n\n#### 方式三：本类实现接口\n\n```java\npublic class MyJFrame extends JFrame implements ActionListener {\n\n    //创建一个按钮对象\n    JButton jtb1 = new JButton("点我啊");\n    //创建一个按钮对象\n    JButton jtb2 = new JButton("再点我啊");\n\n    public MyJFrame(){\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n\n\n        //给按钮设置位置和宽高\n        jtb1.setBounds(0,0,100,50);\n        //给按钮添加事件\n        jtb1.addActionListener(this);\n\n\n        //给按钮设置位置和宽高\n        jtb2.setBounds(100,0,100,50);\n        jtb2.addActionListener(this);\n\n\n        //那按钮添加到整个界面当中\n        this.getContentPane().add(jtb1);\n        this.getContentPane().add(jtb2);\n\n        //让整个界面显示出来\n        this.setVisible(true);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //对当前的按钮进行判断\n\n        //获取当前被操作的那个按钮对象\n        Object source = e.getSource();\n\n        if(source == jtb1){\n            jtb1.setSize(200,200);\n        }else if(source == jtb2){\n            Random r = new Random();\n            jtb2.setLocation(r.nextInt(500),r.nextInt(500));\n        }\n    }\n}\n```\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n\n\n'},{title:"day16-面向对象综合练习（下）",headers:[{level:2,title:"1. 美化界面",slug:"_1-美化界面",link:"#_1-美化界面",children:[{level:3,title:"1.1 小图片居中",slug:"_1-1-小图片居中",link:"#_1-1-小图片居中",children:[]},{level:3,title:"1.2 添加背景图片",slug:"_1-2-添加背景图片",link:"#_1-2-添加背景图片",children:[]},{level:3,title:"1.3 添加图片的边框",slug:"_1-3-添加图片的边框",link:"#_1-3-添加图片的边框",children:[]},{level:3,title:"1.4 优化路径",slug:"_1-4-优化路径",link:"#_1-4-优化路径",children:[]}]},{level:2,title:"2. 上下左右移动的逻辑",slug:"_2-上下左右移动的逻辑",link:"#_2-上下左右移动的逻辑",children:[]},{level:2,title:"3. 查看完整图片的功能",slug:"_3-查看完整图片的功能",link:"#_3-查看完整图片的功能",children:[]},{level:2,title:"4. 作弊码",slug:"_4-作弊码",link:"#_4-作弊码",children:[]},{level:2,title:"5. 判断胜利",slug:"_5-判断胜利",link:"#_5-判断胜利",children:[]},{level:2,title:"6. 计步功能",slug:"_6-计步功能",link:"#_6-计步功能",children:[]},{level:2,title:"7. 其他功能",slug:"_7-其他功能",link:"#_7-其他功能",children:[]},{level:2,title:"8.游戏完整代码",slug:"_8-游戏完整代码",link:"#_8-游戏完整代码",children:[]}],path:"/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html",pathLocale:"/",extraFields:'---\ntitle: day16-面向对象综合练习（下）\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nday16-面向对象综合练习（下）\n\n\x3c!-- more --\x3e\n## 1. 美化界面\n\n界面搭建好之后，就需要美化界面了，本次需要美化下面四个地方：\n\n1. 将15张小图片移动到界面的中央偏下方 \n2. 添加背景图片\n\n3. 添加图片的边框 \n4. 优化路径\n\n### 1.1 小图片居中\n\n原本的小图片，都在左上角的位置，不好看，我想让他们居中，这样就需要给每一张图片在x和y都进行一个偏移即可。\n\n代码示例：\n\n```java\nfor (int i = 0; i < 4; i++) {\n    //内循环 --- 表示在一行添加4张图片\n    for (int j = 0; j < 4; j++) {\n        //获取当前要加载图片的序号\n        int num = data[i][j];\n        //创建一个JLabel的对象（管理容器）\n        JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n        //指定图片位置，并进行适当的偏移\n        jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n        //给图片添加边框\n        //0:表示让图片凸起来\n        //1：表示让图片凹下去\n        jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n        //把管理容器添加到界面中\n        this.getContentPane().add(jLabel);\n    }\n}\n```\n\n###  1.2 添加背景图片\n\n​\t细节：代码中后添加的，塞在下方\n\n代码示例：\n\n```java\nfor (int i = 0; i < 4; i++) {\n    //内循环 --- 表示在一行添加4张图片\n    for (int j = 0; j < 4; j++) {\n        //获取当前要加载图片的序号\n        int num = data[i][j];\n        //创建一个JLabel的对象（管理容器）\n        JLabel jLabel = new JLabel(new ImageIcon("F:\\\\JavaSE最新版\\\\day17-面向对象综合练习（下）\\\\代码\\\\" + num + ".jpg"));\n        //指定图片位置\n        jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n        //给图片添加边框\n        //0:表示让图片凸起来\n        //1：表示让图片凹下去\n        jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n        //把管理容器添加到界面中\n        this.getContentPane().add(jLabel);\n    }\n}\n\n\n//添加背景图片\nJLabel background = new JLabel(new ImageIcon("F:\\JavaSE最新版\\day17-面向对象综合练习（下）\\代码\\puzzlegame\\\\image\\\\background.png"));\nbackground.setBounds(40, 40, 508, 560);\n//把背景图片添加到界面当中\nthis.getContentPane().add(background);\n```\n\n### 1.3 添加图片的边框\n\n```java\n//给图片添加边框\n//括号中也可以写0或者1\n//要注意，这个凸凹跟大家自己理解的可能会有偏差\n//0:表示让图片凸起来，图片凸起来，边框就会凹下去\n//1：表示让图片凹下去，图片凹下去，边框就会凸起来\n//但是0和1不好记，所以Java中就定义了常亮表示，方便记忆\n//BevelBorder.LOWERED：表示1\n//BevelBorder.RAISED：表示0\njLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n```\n\n### 1.4 优化路径\n\n之前我们写的路径是完整路径：\n\n```java\nF:\\JavaSE最新版\\day17-面向对象综合练习（下）\\代码\\puzzlegame\\image\\animal\\animal3\\1.jpg\n```\n\n这样会有两个坏处：\n\n一：路径太长，代码阅读不方便\n\n二：项目拿到别人电脑上时，如果别人电脑上没有F盘和对应的文件夹，就找不到图片\n\n#### 1.4.1 计算机中的两种路径\n\n* 绝对路径\n\n  从判断开始的路径，此时路径是固定的。\n\n```java\nC:\\\\a.txt\n```\n\n* 相对路径\n\n  没有从判断开始的路径\n\n```java\naaa\\\\bbb\\\\a.txt\n```\n\n目前为止，在idea中，相对路径是相对当前项目而言的。\n\n以下面的路径为例：\n\n```java\naaa\\\\bbb\\\\a.txt\n```\n\n在寻找的时候，先找当前项目，在当前项目下找aaa，在aaa里面找bbb，在bbb里面找a.txt\n\n利用这个原理，我们可以修改项目中路径的书写：\n\n代码示例：\n\n```java\n//添加背景图片\nJLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\nbackground.setBounds(40, 40, 508, 560);\n//把背景图片添加到界面当中\nthis.getContentPane().add(background);\n```\n\n\n\n## 2. 上下左右移动的逻辑\n\n\n![移动](img\\移动.png)\n\n#### 业务分析：\n\n上下左右的我们看上去就是移动空白的方块，实则逻辑跟我们看上去的相反：\n\n* 上移：是把空白区域下方的图片上移。\n* 下移：是把空白区域上方的图片下移。\n* 左移：是把空白区域右方的图片左移。\n* 右移：是把空白区域左方的图片右移。\n\n但是在移动的时候也有一些小问题要注意：\n\n* 如果空白区域已经在最上面了，此时x=0，那么就无法再下移了。\n* 如果空白区域已经在最下面了，此时x=3，那么就无法再上移了。\n* 如果空白区域已经在最左侧了，此时y=1，那么就无法再右移了。\n* 如果空白区域已经在最右侧了，此时y=3，那么就无法再左移了。\n\n#### 实现步骤：\n\n1. 本类实现KeyListener接口，并重写所有抽象方法\n2. 给整个界面添加键盘监听事件\n3. 统计一下空白方块对应的数字0在二维数组中的位置\n4. 在keyReleased方法当中实现移动的逻辑\n\n#### 代码实现：\n\n```java\n//松开按键的时候会调用这个方法\n@Override\npublic void keyReleased(KeyEvent e) {\n    //对上，下，左，右进行判断\n    //左：37 上：38 右：39 下：40\n    int code = e.getKeyCode();\n    if (code == 37) {\n        System.out.println("向左移动");\n        //逻辑：\n        //把空白方块右方的数字往左移动\n        data[x][y] = data[x][y + 1];\n        data[x][y + 1] = 0;\n        y++;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    } else if (code == 38) {\n        System.out.println("向上移动");\n        //逻辑：\n        //把空白方块下方的数字往上移动\n        //x，y  表示空白方块\n        //x + 1， y 表示空白方块下方的数字\n        //把空白方块下方的数字赋值给空白方块\n        data[x][y] = data[x + 1][y];\n        data[x + 1][y] = 0;\n        x++;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    } else if (code == 39) {\n        System.out.println("向右移动");\n        //逻辑：\n        //把空白方块左方的数字往右移动\n        data[x][y] = data[x][y - 1];\n        data[x][y - 1] = 0;\n        y--;\n        //每移动一次，计数器就自增一次。\n        initImage();\n    } else if (code == 40) {\n        System.out.println("向下移动");\n        //逻辑：\n        //把空白方块上方的数字往下移动\n        data[x][y] = data[x - 1][y];\n        data[x - 1][y] = 0;\n        x--;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    }\n}\n```\n\n## 3. 查看完整图片的功能\n\n ![查看完整图片](img\\查看完整图片.png)\n\n#### 业务分析：\n\n​\t在玩游戏的过程中，我想看一下最终的效果图，该怎么办呢？\n\n此时可以添加一个功能，当我们长按某个键（假设为A）,不松的时候，就显示完整图片，松开就显示原来的图片\n\n#### 实现步骤：\n\n1. 给整个界面添加键盘事件\n2. 在keyPressed中书写按下不松的逻辑\n3. 在keyReleased中书写松开的逻辑\n\n#### 代码实现：\n\n```java\n//按下不松时会调用这个方法\n@Override\npublic void keyPressed(KeyEvent e) {\n    int code = e.getKeyCode();\n    if (code == 65){\n        //把界面中所有的图片全部删除\n        this.getContentPane().removeAll();\n        //加载第一张完整的图片\n        JLabel all = new JLabel(new ImageIcon(path + "all.jpg"));\n        all.setBounds(83,134,420,420);\n        this.getContentPane().add(all);\n        //加载背景图片\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n        //刷新界面\n        this.getContentPane().repaint();\n\n\n    }\n}\n\n\n//松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        ...\n        else if(code == 65){\n            initImage();\n        }\n        ....\n    }\n```\n\n\n\n## 4. 作弊码\n\n#### 业务分许：\n\n​\t不想玩了，想要一键通关\n\n#### 实现步骤：\n\n1. 给整个界面添加键盘事件\n2. 在keyReleased中书写松开的逻辑，当按下W的时候一键通关。\n\n备注：当然各位小伙伴可以改写这段逻辑，当按下W的时候，可以将数据排列成还需要走这么两三步才能一键通关的，这样你在跟好基友PK的时候，操作是不是更加隐秘呢？\n\n#### 代码实现：\n\n```java\n//松开按键的时候会调用这个方法\n@Override\npublic void keyReleased(KeyEvent e) {\n    ...\n        else if(code == 87){\n            data = new int[][]{\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12},\n                {13,14,15,0}\n            };\n            initImage();\n        }\n    ....\n}\n```\n\n## 5. 判断胜利\n\n#### 业务分许：\n\n​\t当游戏的图标排列正确了，需要有胜利图标显示。\n\n​\t每次上下左右移动图片的时候都需要进行判断。\n\n​\t在keyReleased中方法一开始的地方就需要写判断是否胜利\n\n#### 实现步骤：\n\n1. 定义一个正确的二维数组win。\n2. 在加载图片之前，先判断一下二维数组中的数字跟win数组中是否相同。\n3. 如果相同展示正确图标\n4. 如果不同则不展示正确图标\n\n#### 代码实现：\n\n   ```java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    ...\n        //定义一个二维数组，存储正确的数据\n        int[][] win = {\n        {1,2,3,4},\n        {5,6,7,8},\n        {9,10,11,12},\n        {13,14,15,0}\n    };\n\n    private void initImage() {\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }   \n        \n        ...\n            \n    }   \n\n    //判断data数组中的数据是否跟win数组中相同\n    //如果全部相同，返回true。否则返回false\n    public boolean victory(){\n        for (int i = 0; i < data.length; i++) {\n            //i : 依次表示二维数组 data里面的索引\n            //data[i]：依次表示每一个一维数组\n            for (int j = 0; j < data[i].length; j++) {\n                if(data[i][j] != win[i][j]){\n                    //只要有一个数据不一样，则返回false\n                    return false;\n                }\n            }\n        }\n        //循环结束表示数组遍历比较完毕，全都一样返回true\n        return true;\n    }\n}\n   ```\n\n## 6. 计步功能\n\n![移动](img\\移动.png)\n\n#### 业务分许：\n\n​\t左上角的计步器，每移动一次，计步器就需要自增一次\n\n#### 实现步骤：\n\n1. 定义一个变量用来统计已经玩了多少步。\n2. 每次按上下左右的时候计步器自增一次即可。\n\n#### 代码实现：\n\n```java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    ...\n    //定义变量用来统计步数\n    int step = 0;\n    \n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }\n\n\n        JLabel stepCount = new JLabel("步数：" + step);\n        stepCount.setBounds(50,30,100,20);\n        this.getContentPane().add(stepCount);\n\n\n        //路径分为两种：\n        //绝对路径：一定是从盘符开始的。C:\\  D：\\\n        //相对路径：不是从盘符开始的\n        //相对路径相对当前项目而言的。 aaa\\\\bbb\n        //在当前项目下，去找aaa文件夹，里面再找bbb文件夹。\n\n        //细节：\n        //先加载的图片在上方，后加载的图片塞在下面。\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n                //给图片添加边框\n                //0:表示让图片凸起来\n                //1：表示让图片凹下去\n                jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n        }\n\n\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n\n\n        //刷新一下界面\n        this.getContentPane().repaint();\n\n\n    }\n\n   //松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        //判断游戏是否胜利，如果胜利，此方法需要直接结束，不能再执行下面的移动代码了\n        if(victory()){\n            //结束方法\n            return;\n        }\n        //对上，下，左，右进行判断\n        //左：37 上：38 右：39 下：40\n        int code = e.getKeyCode();\n        System.out.println(code);\n        if (code == 37) {\n            System.out.println("向左移动");\n            if(y == 3){\n                return;\n            }\n            //逻辑：\n            //把空白方块右方的数字往左移动\n            data[x][y] = data[x][y + 1];\n            data[x][y + 1] = 0;\n            y++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n\n        } else if (code == 38) {\n            System.out.println("向上移动");\n            if(x == 3){\n                //表示空白方块已经在最下方了，他的下面没有图片再能移动了\n                return;\n            }\n            //逻辑：\n            //把空白方块下方的数字往上移动\n            //x，y  表示空白方块\n            //x + 1， y 表示空白方块下方的数字\n            //把空白方块下方的数字赋值给空白方块\n            data[x][y] = data[x + 1][y];\n            data[x + 1][y] = 0;\n            x++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 39) {\n            System.out.println("向右移动");\n            if(y == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块左方的数字往右移动\n            data[x][y] = data[x][y - 1];\n            data[x][y - 1] = 0;\n            y--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 40) {\n            System.out.println("向下移动");\n            if(x == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块上方的数字往下移动\n            data[x][y] = data[x - 1][y];\n            data[x - 1][y] = 0;\n            x--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        }else if(code == 65){\n            initImage();\n        }else if(code == 87){\n            data = new int[][]{\n                    {1,2,3,4},\n                    {5,6,7,8},\n                    {9,10,11,12},\n                    {13,14,15,0}\n            };\n            initImage();\n        }\n    }\n    \n    ...\n}\n```\n\n## 7. 其他功能\n\n#### 业务分许：\n\n​\t完成重新开始、关闭游戏、关于我们。这三个都是在菜单上的，所以可以一起完成\n\n重新开始：点击之后，重新打乱图片，计步器清零\n\n关闭游戏：点击之后，全部关闭\n\n关于我们：点击之后出现黑马程序员的公众号二维码\n\n#### 实现步骤：\n\n1. 给菜单上的每个选项添加点击事件\n2. 在actionPerformed方法中实现对应的逻辑即可\n\n#### 代码实现：\n\n\n\n代码实现：\n\n```java\n@Override\npublic void actionPerformed(ActionEvent e) {\n    //获取当前被点击的条目对象\n    Object obj = e.getSource();\n    //判断\n    if(obj == replayItem){\n        System.out.println("重新游戏");\n        //计步器清零\n        step = 0;\n        //再次打乱二维数组中的数据\n        initData();\n        //重新加载图片\n        initImage();\n    }else if(obj == reLoginItem){\n        System.out.println("重新登录");\n        //关闭当前的游戏界面\n        this.setVisible(false);\n        //打开登录界面\n        new LoginJFrame();\n    }else if(obj == closeItem){\n        System.out.println("关闭游戏");\n        //直接关闭虚拟机即可\n        System.exit(0);\n    }else if(obj == accountItem){\n        System.out.println("公众号");\n\n        //创建一个弹框对象\n        JDialog jDialog = new JDialog();\n        //创建一个管理图片的容器对象JLabel\n        JLabel jLabel = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\about.png"));\n        //设置位置和宽高\n        jLabel.setBounds(0,0,258,258);\n        //把图片添加到弹框当中\n        jDialog.getContentPane().add(jLabel);\n        //给弹框设置大小\n        jDialog.setSize(344,344);\n        //让弹框置顶\n        jDialog.setAlwaysOnTop(true);\n        //让弹框居中\n        jDialog.setLocationRelativeTo(null);\n        //弹框不关闭则无法操作下面的界面\n        jDialog.setModal(true);\n        //让弹框显示出来\n        jDialog.setVisible(true);\n    }\n}\n```\n\n## 8.游戏完整代码\n\n```java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    //JFrame 界面，窗体\n    //子类呢？也表示界面，窗体\n    //规定：GameJFrame这个界面表示的就是游戏的主界面\n    //以后跟游戏相关的所有逻辑都写在这个类中\n\n    //创建一个二维数组\n    //目的：用来管理数据\n    //加载图片的时候，会根据二维数组中的数据进行加载\n    int[][] data = new int[4][4];\n\n    //记录空白方块在二维数组中的位置\n    int x = 0;\n    int y = 0;\n\n    //定义一个变量，记录当前展示图片的路径\n    String path = "puzzlegame\\\\image\\\\animal\\\\animal3\\\\";\n\n\n\n\n\n    //定义一个二维数组，存储正确的数据\n    int[][] win = {\n        {1,2,3,4},\n        {5,6,7,8},\n        {9,10,11,12},\n        {13,14,15,0}\n    };\n\n    //定义变量用来统计步数\n    int step = 0;\n\n\n    //创建选项下面的条目对象\n    JMenuItem replayItem = new JMenuItem("重新游戏");\n    JMenuItem reLoginItem = new JMenuItem("重新登录");\n    JMenuItem closeItem = new JMenuItem("关闭游戏");\n\n    JMenuItem accountItem = new JMenuItem("公众号");\n\n\n    public GameJFrame() {\n        //初始化界面\n        initJFrame();\n\n        //初始化菜单\n        initJMenuBar();\n\n\n        //初始化数据（打乱）\n        initData();\n\n        //初始化图片（根据打乱之后的结果去加载图片）\n        initImage();\n\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n\n    }\n\n\n    //初始化数据（打乱）\n    private void initData() {\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n\n        /*\n        *\n        *           5   6   8   9\n        *           10  11  15  1\n        *           4   7   12  13\n        *           2   3   0  14\n        *\n        *           5   6   8   9   10  11  15  1   4   7   12  13  2   3   0   14\n        * */\n\n        //4.给二维数组添加数据\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            if (tempArr[i] == 0) {\n                x = i / 4;\n                y = i % 4;\n            }\n            data[i / 4][i % 4] = tempArr[i];\n        }\n    }\n\n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }\n\n\n        JLabel stepCount = new JLabel("步数：" + step);\n        stepCount.setBounds(50,30,100,20);\n        this.getContentPane().add(stepCount);\n\n\n        //路径分为两种：\n        //绝对路径：一定是从盘符开始的。C:\\  D：\\\n        //相对路径：不是从盘符开始的\n        //相对路径相对当前项目而言的。 aaa\\\\bbb\n        //在当前项目下，去找aaa文件夹，里面再找bbb文件夹。\n\n        //细节：\n        //先加载的图片在上方，后加载的图片塞在下面。\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n                //给图片添加边框\n                //0:表示让图片凸起来\n                //1：表示让图片凹下去\n                jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n        }\n\n\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n\n\n        //刷新一下界面\n        this.getContentPane().repaint();\n\n\n    }\n\n    private void initJMenuBar() {\n        //创建整个的菜单对象\n        JMenuBar jMenuBar = new JMenuBar();\n        //创建菜单上面的两个选项的对象 （功能  关于我们）\n        JMenu functionJMenu = new JMenu("功能");\n        JMenu aboutJMenu = new JMenu("关于我们");\n\n\n\n        //将每一个选项下面的条目添加到选项当中\n        functionJMenu.add(replayItem);\n        functionJMenu.add(reLoginItem);\n        functionJMenu.add(closeItem);\n\n        aboutJMenu.add(accountItem);\n\n        //给条目绑定事件\n        replayItem.addActionListener(this);\n        reLoginItem.addActionListener(this);\n        closeItem.addActionListener(this);\n        accountItem.addActionListener(this);\n\n        //将菜单里面的两个选项添加到菜单当中\n        jMenuBar.add(functionJMenu);\n        jMenuBar.add(aboutJMenu);\n\n\n\n\n        //给整个界面设置菜单\n        this.setJMenuBar(jMenuBar);\n    }\n\n    private void initJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n        //给整个界面添加键盘监听事件\n        this.addKeyListener(this);\n\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n    //按下不松时会调用这个方法\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == 65){\n            //把界面中所有的图片全部删除\n            this.getContentPane().removeAll();\n            //加载第一张完整的图片\n            JLabel all = new JLabel(new ImageIcon(path + "all.jpg"));\n            all.setBounds(83,134,420,420);\n            this.getContentPane().add(all);\n            //加载背景图片\n            //添加背景图片\n            JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n            background.setBounds(40, 40, 508, 560);\n            //把背景图片添加到界面当中\n            this.getContentPane().add(background);\n            //刷新界面\n            this.getContentPane().repaint();\n\n\n        }\n    }\n\n    //松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        //判断游戏是否胜利，如果胜利，此方法需要直接结束，不能再执行下面的移动代码了\n        if(victory()){\n            //结束方法\n            return;\n        }\n        //对上，下，左，右进行判断\n        //左：37 上：38 右：39 下：40\n        int code = e.getKeyCode();\n        System.out.println(code);\n        if (code == 37) {\n            System.out.println("向左移动");\n            if(y == 3){\n                return;\n            }\n            //逻辑：\n            //把空白方块右方的数字往左移动\n            data[x][y] = data[x][y + 1];\n            data[x][y + 1] = 0;\n            y++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n\n        } else if (code == 38) {\n            System.out.println("向上移动");\n            if(x == 3){\n                //表示空白方块已经在最下方了，他的下面没有图片再能移动了\n                return;\n            }\n            //逻辑：\n            //把空白方块下方的数字往上移动\n            //x，y  表示空白方块\n            //x + 1， y 表示空白方块下方的数字\n            //把空白方块下方的数字赋值给空白方块\n            data[x][y] = data[x + 1][y];\n            data[x + 1][y] = 0;\n            x++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 39) {\n            System.out.println("向右移动");\n            if(y == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块左方的数字往右移动\n            data[x][y] = data[x][y - 1];\n            data[x][y - 1] = 0;\n            y--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 40) {\n            System.out.println("向下移动");\n            if(x == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块上方的数字往下移动\n            data[x][y] = data[x - 1][y];\n            data[x - 1][y] = 0;\n            x--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        }else if(code == 65){\n            initImage();\n        }else if(code == 87){\n            data = new int[][]{\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12},\n                {13,14,15,0}\n            };\n            initImage();\n        }\n    }\n\n\n    //判断data数组中的数据是否跟win数组中相同\n    //如果全部相同，返回true。否则返回false\n    public boolean victory(){\n        for (int i = 0; i < data.length; i++) {\n            //i : 依次表示二维数组 data里面的索引\n            //data[i]：依次表示每一个一维数组\n            for (int j = 0; j < data[i].length; j++) {\n                if(data[i][j] != win[i][j]){\n                    //只要有一个数据不一样，则返回false\n                    return false;\n                }\n            }\n        }\n        //循环结束表示数组遍历比较完毕，全都一样返回true\n        return true;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //获取当前被点击的条目对象\n        Object obj = e.getSource();\n        //判断\n        if(obj == replayItem){\n            System.out.println("重新游戏");\n            //计步器清零\n            step = 0;\n            //再次打乱二维数组中的数据\n            initData();\n            //重新加载图片\n            initImage();\n        }else if(obj == reLoginItem){\n            System.out.println("重新登录");\n            //关闭当前的游戏界面\n            this.setVisible(false);\n            //打开登录界面\n            new LoginJFrame();\n        }else if(obj == closeItem){\n            System.out.println("关闭游戏");\n            //直接关闭虚拟机即可\n            System.exit(0);\n        }else if(obj == accountItem){\n            System.out.println("公众号");\n\n            //创建一个弹框对象\n            JDialog jDialog = new JDialog();\n            //创建一个管理图片的容器对象JLabel\n            JLabel jLabel = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\about.png"));\n            //设置位置和宽高\n            jLabel.setBounds(0,0,258,258);\n            //把图片添加到弹框当中\n            jDialog.getContentPane().add(jLabel);\n            //给弹框设置大小\n            jDialog.setSize(344,344);\n            //让弹框置顶\n            jDialog.setAlwaysOnTop(true);\n            //让弹框居中\n            jDialog.setLocationRelativeTo(null);\n            //弹框不关闭则无法操作下面的界面\n            jDialog.setModal(true);\n            //让弹框显示出来\n            jDialog.setVisible(true);\n        }\n    }\n}\n```\n\n\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n\n\n'},{title:"常见API，对象克隆",headers:[{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:2,title:"1.2 常见方法",slug:"_1-2-常见方法",link:"#_1-2-常见方法",children:[]},{level:2,title:"1.3 算法小题(质数)",slug:"_1-3-算法小题-质数",link:"#_1-3-算法小题-质数",children:[]},{level:2,title:"1.4 算法小题(自幂数)",slug:"_1-4-算法小题-自幂数",link:"#_1-4-算法小题-自幂数",children:[]},{level:2,title:"1.5 课后练习",slug:"_1-5-课后练习",link:"#_1-5-课后练习",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 常见方法",slug:"_2-2-常见方法",link:"#_2-2-常见方法",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 常见方法",slug:"_3-2-常见方法",link:"#_3-2-常见方法",children:[]},{level:2,title:"3.3 恶搞好基友",slug:"_3-3-恶搞好基友",link:"#_3-3-恶搞好基友",children:[]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 常见方法",slug:"_4-2-常见方法",link:"#_4-2-常见方法",children:[]},{level:2,title:"5.1 概述",slug:"_5-1-概述",link:"#_5-1-概述",children:[]},{level:2,title:"5.2 常见方法",slug:"_5-2-常见方法",link:"#_5-2-常见方法",children:[]},{level:2,title:"6.1 引入",slug:"_6-1-引入",link:"#_6-1-引入",children:[]},{level:2,title:"6.2  概述",slug:"_6-2-概述",link:"#_6-2-概述",children:[]},{level:2,title:"6.3 常见方法",slug:"_6-3-常见方法",link:"#_6-3-常见方法",children:[]},{level:2,title:"6.4 底层存储方式：",slug:"_6-4-底层存储方式",link:"#_6-4-底层存储方式",children:[]},{level:2,title:"7.1 引入",slug:"_7-1-引入",link:"#_7-1-引入",children:[]},{level:2,title:"7.2 概述",slug:"_7-2-概述",link:"#_7-2-概述",children:[]},{level:2,title:"7.3 常见方法",slug:"_7-3-常见方法",link:"#_7-3-常见方法",children:[]},{level:2,title:"7.4 底层存储方式：",slug:"_7-4-底层存储方式",link:"#_7-4-底层存储方式",children:[]}],path:"/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html",pathLocale:"/",extraFields:'---\ntitle: 常见API，对象克隆\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n常见API，对象克隆\n\n\x3c!-- more --\x3e\n# 课程目标\n\n能够熟练使用Math类中的常见方法\n\n能够熟练使用System类中的常见方法\n\n能够理解Object类的常见方法作用\n\n能够熟练使用Objects类的常见方法\n\n能够熟练使用BigInteger类的常见方法\n\n能够熟练使用BigDecimal类的常见方法\n\n# 1 Math类\n\n## 1.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于Math类的定义如下：\n\n ![1576047659085](.\\assets\\1576047659085.png) \n\nMath类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。\n\nMath类包含执行基本数字运算的方法，我们可以使用Math类完成基本的数学运算。\n\n\n\n要想使用Math类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对Math类有没有提供对应的构造方法。通过API文档来查看\n\n一下Math类的成员，如下所示：\n\n![1576047846672](.\\assets\\1576047846672.png) \n\n在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建Math类的对象。同时我们发现Math类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用。在Math类中\n\n定义了很多数学运算的方法，但是我们并不可能将所有的方法学习一遍，我们主要学习的就是一些常见的方法。\n\n## 1.2 常见方法\n\n> tips：重点讲解内容\n\n<font color="red" size="3">**常见方法介绍**</font>\n\n我们要学习的Math的常见方法如下所示：\n\n```java\npublic static int abs(int a)\t\t\t\t\t// 返回参数的绝对值\npublic static double ceil(double a)\t\t\t\t// 返回大于或等于参数的最小整数\npublic static double floor(double a)\t\t\t// 返回小于或等于参数的最大整数\npublic static int round(float a)\t\t\t\t// 按照四舍五入返回最接近参数的int类型的值\npublic static int max(int a,int b)\t\t\t\t// 获取两个int值中的较大值\npublic static int min(int a,int b)\t\t\t\t// 获取两个int值中的较小值\npublic static double pow (double a,double b)\t// 计算a的b次幂的值\npublic static double random()\t\t\t\t\t// 返回一个[0.0,1.0)的随机值\n```\n\n<font color="red" size="3">**案例演示**</font>\n\n接下来我们就来演示一些这些方法的执行效果，如下所示：\n\n```java\npublic class MathDemo01 {\n\n    public static void main(String[] args) {\n\n        // public static int abs(int a)         返回参数的绝对值\n        System.out.println("-2的绝对值为：" + Math.abs(-2));\n        System.out.println("2的绝对值为：" + Math.abs(2));\n\n        // public static double ceil(double a)  返回大于或等于参数的最小整数\n        System.out.println("大于或等于23.45的最小整数位：" + Math.ceil(23.45));\n        System.out.println("大于或等于-23.45的最小整数位：" + Math.ceil(-23.45));\n\n        // public static double floor(double a) 返回小于或等于参数的最大整数\n        System.out.println("小于或等于23.45的最大整数位：" + Math.floor(23.45));\n        System.out.println("小于或等于-23.45的最大整数位：" + Math.floor(-23.45));\n\n        // public static int round(float a)     按照四舍五入返回最接近参数的int\n        System.out.println("23.45四舍五入的结果为：" + Math.round(23.45));\n        System.out.println("23.55四舍五入的结果为：" + Math.round(23.55));\n\n        // public static int max(int a,int b)   返回两个int值中的较大值\n        System.out.println("23和45的最大值为: " + Math.max(23, 45));\n\n        // public static int min(int a,int b)   返回两个int值中的较小值\n        System.out.println("12和34的最小值为: " + Math.min(12 , 34));\n\n        // public static double pow (double a,double b)返回a的b次幂的值\n        System.out.println("2的3次幂计算结果为: " + Math.pow(2,3));\n\n        // public static double random()返回值为double的正值，[0.0,1.0)\n        System.out.println("获取到的0-1之间的随机数为: " + Math.random());\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n-2的绝对值为：2\n2的绝对值为：2\n大于或等于23.45的最小整数位：24.0\n大于或等于-23.45的最小整数位：-23.0\n小于或等于23.45的最大整数位：23.0\n小于或等于-23.45的最大整数位：-24.0\n23.45四舍五入的结果为：23\n23.55四舍五入的结果为：24\n23和45的最大值为: 45\n12和34的最小值为: 12\n2的3次幂计算结果为: 8.0\n获取到的0-1之间的随机数为: 0.7322484131745958\n```\n\n## 1.3 算法小题(质数)\n\n需求：\n\n​\t判断一个数是否为一个质数\n\n代码实现：\n\n```java\npublic class MathDemo2 {\n    public static void main(String[] args) {\n        //判断一个数是否为一个质数\n        System.out.println(isPrime(997));\n        //997 2~996 995次\n    }\n\n    public static boolean isPrime(int number) {\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            count++;\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        System.out.println(count);\n        return true;\n    }\n}\n```\n\n## 1.4 算法小题(自幂数)\n\n自幂数，一个n位自然数等于自身各个数位上数字的n次幂之和\n\n​\t举例1：三位数  1^3 + 5^3 + 3^3 = 153  \n\n​\t举例2：四位数  1^4 + 6^4 + 3^4 + 4^3 = 1634\n\n如果自幂数是：\n\n* 一位自幂数，也叫做：独身数\n* 三位自幂数：水仙花数  四位自幂数：四叶玫瑰数\n* 五位自幂数：五角星数  六位自幂数：六合数\n* 七位自幂数：北斗七星数  八位自幂数：八仙数\n* 九位自幂数：九九重阳数  十位自幂数：十全十美数\n\n要求1：统计一共有多少个水仙花数。\n\n要求2：（课后作业）证明没有两位的自幂数。\n\n要求3：（课后作业）分别统计有多少个四叶玫瑰数和五角星数。（答案：都是3个）\n\n```java\n//水仙花数:100 ~ 999\nint count = 0;\n//得到每一个三位数\nfor (int i = 100; i <= 999; i++) {\n    //个位 十位 百位\n    int ge = i % 10;\n    int shi = i / 10 % 10;\n    int bai = i / 100 % 10;\n    //判断:\n    //每一位的三次方之和 跟本身 进行比较。\n    double sum = Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3);\n    if (sum == i) {\n        count++;\n        //System.out.println(i);\n\n        System.out.println(count);\n    }\n}\n```\n\n## 1.5 课后练习\n\n要求2：（课后作业）证明没有两位的自幂数。\n\n要求3：（课后作业）分别统计有多少个四叶玫瑰数和五角星数。（答案：都是3个）\n\n\n\n# 2 System类\n\n## 2.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于System类的定义如下：\n\n ![1576049347968](assets/1576049347968.png) \n\n\n\nSystem类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。\n\nSystem包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。\n\n\n\n要想使用System类我们就需要先创建该类的对象，那么创建对象就需要借助于构造方法。因此我们就需要首先查看一下API文档，看看API文档中针对System类有没有提供对应的构造方法。通过API文档来\n\n查看一下System类的成员，如下所示：\n\n![1576049535584](assets/1576049535584.png) \n\n在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建System类的对象。同时我们发现System类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用（Nested \n\nClass Summary内部类或者内部接口的描述）。\n\n## 2.2 常见方法\n\n> tips：重点讲解内容\n\n<font color="red" size="3">**常见方法介绍**</font>\n\n我们要学习的System类中的常见方法如下所示：\n\n```java\npublic static long currentTimeMillis()\t\t\t// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置）\npublic static void exit(int status)\t\t\t\t// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); // 进行数值元素copy\n```\n\n<font color="red" size="3">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下这些方法的特点。\n\n<font color="blue" size="2">**案例1**</font>：演示currentTimeMillis方法\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 获取当前时间所对应的毫秒值\n        long millis = System.currentTimeMillis();\n\n        // 输出结果\n        System.out.println("当前时间所对应的毫秒值为：" + millis);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台的输出结果如下：\n\n```java\n当前时间所对应的毫秒值为：1576050298343\n```\n\n获取到当前时间的毫秒值的意义：我们常常来需要统计某一段代码的执行时间。此时我们就可以在执行这段代码之前获取一次时间，在执行完毕以后再次获取一次系统时间，然后计算两个时间的差值，\n\n这个差值就是这段代码执行完毕以后所需要的时间。如下代码所示：\n\n```java\npublic class SystemDemo2 {\n    public static void main(String[] args) {\n        //判断1~100000之间有多少个质数\n\n        long start = System.currentTimeMillis();\n\n        for (int i = 1; i <= 100000; i++) {\n            boolean flag = isPrime2(i);\n            if (flag) {\n                System.out.println(i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        //获取程序运行的总时间\n        System.out.println(end - start); //方式一：1514 毫秒  方式二：71毫秒\n    }\n\n    //以前判断是否为质数的方式\n    public static boolean isPrime1(int number) {\n        for (int i = 2; i < number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //改进之后判断是否为质数的方式（效率高）\n    public static boolean isPrime2(int number) {\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n<font color="blue" size="2">**案例2**</font>：演示exit方法\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n        \n        // 输出\n        System.out.println("程序开始执行了.....");\n        \n        // 终止JVM\n        System.exit(0);\n        \n        // 输出\n        System.out.println("程序终止了..........");\n        \n    }\n    \n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n程序开始执行了.....\n```\n\n此时可以看到在控制台只输出了"程序开始了..."，由于JVM终止了，因此输出"程序终止了..."这段代码没有被执行。\n\n<font color="blue" size="2">**案例3**</font>：演示arraycopy方法\n\n方法参数说明：\n\n```java\n// src: \t 源数组\n// srcPos：  源数值的开始位置\n// dest：    目标数组\n// destPos： 目标数组开始位置\n// length:   要复制的元素个数\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); \n```\n\n代码如下所示：\n\n```java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 定义源数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n\n        // 定义目标数组\n        int[] desArray = new int[10] ;\n\n        // 进行数组元素的copy: 把srcArray数组中从0索引开始的3个元素，从desArray数组中的1索引开始复制过去\n        System.arraycopy(srcArray , 0 , desArray , 1 , 3);\n\n        // 遍历目标数组\n        for(int x = 0 ; x < desArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(desArray[x] + ", ");\n            }else {\n                System.out.println(desArray[x]);\n            }\n\n        }\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\n0, 23, 45, 67, 0, 0, 0, 0, 0, 0\n```\n\n通过控制台输出结果我们可以看到，数组元素的确进行复制了。\n\n使用这个方法我们也可以完成数组元素的删除操作，如下所示：\n\n```java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(srcArray[x] + ", ");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}\n```\n\n运行程序进行测试，控制台的输出结果如下所示：\n\n```java\n23, 45, 89, 14, 56, 56 \n```\n\n通过控制台输出结果我们可以看到此时多出了一个56元素，此时我们只需要将最后一个位置设置为0即可。如下所示：\n\n```java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 将最后一个位置的元素设置为0\n        srcArray[srcArray.length - 1] = 0 ;\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != srcArray.length - 1 ) {\n                System.out.print(srcArray[x] + ", ");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\n23, 45, 89, 14, 56, 0\n```\n\n此时我们可以看到元素"67"已经被删除掉了。67后面的其他元素依次向前进行移动了一位。\n\n**arraycopy方法底层细节：**\n\n1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n\n2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n\n3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n\n代码示例：\n\n```java\npublic class SystemDemo3 {\n    public static void main(String[] args) {\n        //public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数) 数组拷贝\n        //细节:\n        //1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n        //2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n        //3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n\n        Student s1 = new Student("zhangsan", 23);\n        Student s2 = new Student("lisi", 24);\n        Student s3 = new Student("wangwu", 25);\n\n        Student[] arr1 = {s1, s2, s3};\n        Person[] arr2 = new Person[3];\n        //把arr1中对象的地址值赋值给arr2中\n        System.arraycopy(arr1, 0, arr2, 0, 3);\n\n        //遍历数组arr2\n        for (int i = 0; i < arr2.length; i++) {\n            Student stu = (Student) arr2[i];\n            System.out.println(stu.getName() + "," + stu.getAge());\n        }\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     *\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     *\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     *\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     *\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Person{name = " + name + ", age = " + age + "}";\n    }\n}\n\n\nclass Student extends Person {\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        super(name, age);\n    }\n}\n```\n\n# 3 Runtime\n\n## 3.1 概述\n\n​\tRuntime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息\n\n## 3.2 常见方法\n\n<font color="red" size="3">**常见方法介绍**</font>\n\n我们要学习的Object类中的常见方法如下所示：\n\n```java\npublic static Runtime getRuntime()\t\t//当前系统的运行环境对象\npublic void exit(int status)\t\t\t//停止虚拟机\npublic int availableProcessors()\t\t//获得CPU的线程数\npublic long maxMemory()\t\t\t\t    //JVM能从系统中获取总内存大小（单位byte）\npublic long totalMemory()\t\t\t\t//JVM已经从系统中获取总内存大小（单位byte）\npublic long freeMemory()\t\t\t\t//JVM剩余内存大小（单位byte）\npublic Process exec(String command) \t//运行cmd命令\n```\n\n代码示例：\n\n```java\npublic class RunTimeDemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n            public static Runtime getRuntime() 当前系统的运行环境对象\n            public void exit(int status) 停止虚拟机\n            public int availableProcessors() 获得CPU的线程数\n            public long maxMemory() JVM能从系统中获取总内存大小(单位byte)\n            public long totalMemory() JVM已经从系统中获取总内存大小(单位byte)\n            public long freeMemory() JVM剩余内存大小(单位byte)\n            public Process exec(string command) 运行cmd命令\n        */\n\n        //1.获取Runtime的对象\n        //Runtime r1 =Runtime.getRuntime();\n\n        //2.exit 停止虚拟机\n        //Runtime.getRuntime().exit(0);\n        //System.out.println("看看我执行了吗?");\n\n\n        //3.获得CPU的线程数\n        System.out.println(Runtime.getRuntime().availableProcessors());//8\n        //4.总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().maxMemory() / 1024 / 1024);//4064\n        //5.已经获取的总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().totalMemory() / 1024 / 1024);//254\n        //6.剩余内存大小\n        System.out.println(Runtime.getRuntime().freeMemory() / 1024 / 1024);//251\n\n        //7.运行cmd命令\n        //shutdown :关机\n        //加上参数才能执行\n        //-s :默认在1分钟之后关机\n        //-s -t 指定时间 : 指定关机时间\n        //-a :取消关机操作\n        //-r: 关机并重启\n        Runtime.getRuntime().exec("shutdown -s -t 3600");\n\n\n    }\n}\n\n```\n\n## 3.3 恶搞好基友\n\n需求：\n\n​\t界面上方按钮默认隐藏\n\n​\t界面中间有一个提示文本和三个按钮\n\n​\t当你的好基友点击中间三个按钮的时候就在N秒之后关机，不同的按钮N的值不一样\n\n​\t任意一个按钮被点击之后，上方了按钮出现。当点击上方按钮之后取消关机任务\n\n ![恶搞好基友](assets\\恶搞好基友.png)\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        new MyJframe();\n    }\n}\n```\n\n```java\npublic class MyJframe extends JFrame implements ActionListener {\n\n    JButton yesBut = new JButton("帅爆了");\n    JButton midBut = new JButton("一般般吧");\n    JButton noBut = new JButton("不帅，有点磕碜");\n    JButton dadBut = new JButton("饶了我吧！");\n\n\n    //决定了上方的按钮是否展示\n    boolean flag = false;\n\n\n    public MyJframe() {\n        initJFrame();\n\n\n        initView();\n\n\n        //显示\n        this.setVisible(true);\n    }\n\n    private void initView() {\n\n        this.getContentPane().removeAll();\n\n        if (flag) {\n            //展示按钮\n            dadBut.setBounds(50, 20, 100, 30);\n            dadBut.addActionListener(this);\n            this.getContentPane().add(dadBut);\n        }\n\n\n        JLabel text = new JLabel("你觉得自己帅吗？");\n        text.setFont(new Font("微软雅黑", 0, 30));\n        text.setBounds(120, 150, 300, 50);\n\n\n        yesBut.setBounds(200, 250, 100, 30);\n        midBut.setBounds(200, 325, 100, 30);\n        noBut.setBounds(160, 400, 180, 30);\n\n        yesBut.addActionListener(this);\n        midBut.addActionListener(this);\n        noBut.addActionListener(this);\n\n        this.getContentPane().add(text);\n        this.getContentPane().add(yesBut);\n        this.getContentPane().add(midBut);\n        this.getContentPane().add(noBut);\n\n        this.getContentPane().repaint();\n    }\n\n    private void initJFrame() {\n        //设置宽高\n        this.setSize(500, 600);\n        //设置标题\n        this.setTitle("恶搞好基友");\n        //设置关闭模式\n        this.setDefaultCloseOperation(3);\n        //置顶\n        this.setAlwaysOnTop(true);\n        //居中\n        this.setLocationRelativeTo(null);\n        //取消内部默认布局\n        this.setLayout(null);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        Object obj = e.getSource();\n        if (obj == yesBut) {\n            //给好基友一个弹框\n            showJDialog("xxx，你太自信了，给你一点小惩罚");\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 3600");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n            flag = true;\n            initView();\n\n        } else if (obj == midBut) {\n            System.out.println("你的好基友点击了一般般吧");\n\n            //给好基友一个弹框\n            showJDialog("xxx，你还是太自信了，也要给你一点小惩罚");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 7200");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n\n\n        } else if (obj == noBut) {\n            System.out.println("你的好基友点击了不帅");\n\n            //给好基友一个弹框\n            showJDialog("xxx，你还是有一点自知之明的，也要给你一点小惩罚");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 1800");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n        } else if (obj == dadBut) {\n            //给好基友一个弹框\n            showJDialog("xxx，这次就饶了你~");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -a");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n        }\n    }\n\n    public void showJDialog(String content) {\n        //创建一个弹框对象\n        JDialog jDialog = new JDialog();\n        //给弹框设置大小\n        jDialog.setSize(200, 150);\n        //让弹框置顶\n        jDialog.setAlwaysOnTop(true);\n        //让弹框居中\n        jDialog.setLocationRelativeTo(null);\n        //弹框不关闭永远无法操作下面的界面\n        jDialog.setModal(true);\n\n        //创建Jlabel对象管理文字并添加到弹框当中\n        JLabel warning = new JLabel(content);\n        warning.setBounds(0, 0, 200, 150);\n        jDialog.getContentPane().add(warning);\n\n        //让弹框展示出来\n        jDialog.setVisible(true);\n    }\n}\n\n```\n\n# 4 Object类\n\n## 4.1 概述\n\n> tips：重点讲解内容\n\n查看API文档，我们可以看到API文档中关于Object类的定义如下：\n\n![1576053677194](assets/1576053677194.png) \n\n\n\nObject类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。\n\n\n\n查看API文档我们可以看到，在Object类中提供了一个无参构造方法，如下所示：\n\n![1576053871503](assets/1576053871503.png) \n\n但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。\n\n## 4.2 常见方法\n\n> tips：重点讲解内容\n\n<font color="red" size="3">**常见方法介绍**</font>\n\n我们要学习的Object类中的常见方法如下所示：\n\n```java\npublic String toString()\t\t\t\t//返回该对象的字符串表示形式(可以看做是对象的内存地址值)\npublic boolean equals(Object obj)\t\t//比较两个对象地址值是否相等；true表示相同，false表示不相同\nprotected Object clone()    \t\t\t//对象克隆\n```\n\n<font color="red" size="3">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下这些方法的特点。\n\n<font color="blue" size="2">**案例1**</font>：演示toString方法\n\n实现步骤：\n\n1. 创建一个学生类，提供两个成员变量（name ， age）；并且提供对应的无参构造方法和有参构造方法以及get/set方法\n2. 创建一个测试类（ObjectDemo01），在测试类的main方法中去创建学生对象，然后调用该对象的toString方法获取该对象的字符串表现形式，并将结果进行输出\n\n如下所示：\n\nStudent类\n\n```java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 无参构造方法和有参构造方法以及get和set方法略\n    ...\n        \n}\n```\n\nObjectDemo01测试类\n\n```java\npublic class ObjectDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用toString方法获取s1对象的字符串表现形式\n        String result1 = s1.toString();\n\n        // 输出结果\n        System.out.println("s1对象的字符串表现形式为：" + result1);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\ns1对象的字符串表现形式为：com.itheima.api.system.demo04.Student@3f3afe78\n```\n\n为什么控制台输出的结果为：com.itheima.api.system.demo04.Student@3f3afe78； 此时我们可以查看一下Object类中toString方法的源码，如下所示：\n\n```java\npublic String toString() {\t\t// Object类中toString方法的源码定义\n\treturn getClass().getName() + "@" + Integer.toHexString(hashCode());\n}\n```\n\n其中getClass().getName()对应的结果就是：com.itheima.api.system.demo04.Student；Integer.toHexString(hashCode())对应的结果就是3f3afe78。\n\n我们常常将"com.itheima.api.system.demo04.Student@3f3afe78"这一部分称之为对象的内存地址值。但是一般情况下获取对象的内存地址值没有太大的意义。获取对象的成员变量的字符串拼接形式才\n\n算有意义，怎么实现呢？此时我们就需要在Student类中重写Object的toString方法。我们可以通过idea开发工具进行实现，具体步骤如下所示：\n\n1. 在空白处使用快捷键：alt + insert。此时会弹出如下的对话框\n\n![1576055135105](assets/1576055135105.png) \n\n2. 选择toString，此时会弹出如下的对话框\n\n![1576055198877](assets/1576055198877.png) \n\n同时选择name和age属性，点击OK。此时就会完成toString方法的重写，代码如下所示：\n\n```java\n@Override\npublic String toString() {\n    return "Student{" +\n        "name=\'" + name + \'\\\'\' +\n        ", age=\'" + age + \'\\\'\' +\n        \'}\';\n}\n```\n\n这段代码就是把Student类中的成员变量进行了字符串的拼接。重写完毕以后，再次运行程序，控制台输出结果如下所示：\n\n```java\ns1对象的字符串表现形式为：Student{name=\'itheima\', age=\'14\'}\n```\n\n此时我们就可以清楚的查看Student的成员变量值，因此重写toString方法的意义就是以良好的格式，更方便的展示对象中的属性值\n\n\n\n我们再来查看一下如下代码的输出：\n\n```java\n// 创建学生对象\nStudent s1 = new Student("itheima" , "14") ;\n\n// 直接输出对象s1\nSystem.out.println(s1);\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\nStudent{name=\'itheima\', age=\'14\'}\n```\n\n我们可以看到和刚才的输出结果是一致的。那么此时也就证明直接输出一个对象，那么会默认调用对象的toString方法，因此如上代码的等同于如下代码：\n\n```java\n// 创建学生对象\nStudent s1 = new Student("itheima" , "14") ;\n\n// 调用s1的toString方法，把结果进行输出\nSystem.out.println(s1.toString());\n```\n\n因此后期为了方便进行测试，我们常常是通过输出语句直接输出一个对象的名称。\n\n\n\n小结：\n\n1. 在通过输出语句输出一个对象时，默认调用的就是toString()方法\n2. 输出地址值一般没有意义，我们可以通过重写toString方法去输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -> Generate -> 选择toString）\n3. toString方法的作用：以良好的格式，更方便的展示对象中的属性值\n4. 一般情况下Jdk所提供的类都会重写Object类中的toString方法\n\n<font color="blue" size="2">**案例2**</font>：演示equals方法\n\n实现步骤：\n\n1. 在测试类（ObjectDemo02）的main方法中，创建两个学生对象，然后比较两个对象是否相同\n\n代码如下所示：\n\n```java\npublic class ObjectDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n        Student s2 = new Student("itheima" , "14") ;\n\n        // 比较两个对象是否相等\n        System.out.println(s1 == s2);\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台的输出结果如下所示：\n\n```java\nfalse\n```\n\n因为"=="号比较的是对象的地址值，而我们通过new关键字创建了两个对象，它们的地址值是不相同的。因此比较结果就是false。\n\n\n\n我们尝试调用Object类中的equals方法进行比较，代码如下所示：\n\n```java\n// 调用equals方法比较两个对象是否相等\nboolean result = s1.equals(s2);\n\n// 输出结果\nSystem.out.println(result);\n```\n\n运行程序进行测试，控制台的输出结果为：\n\n```java\nfalse\n```\n\n为什么结果还是false呢？我们可以查看一下Object类中equals方法的源码，如下所示：\n\n```java\npublic boolean equals(Object obj) {\t\t// Object类中的equals方法的源码\n    return (this == obj);\n}\n```\n\n通过源码我们可以发现默认情况下equals方法比较的也是对象的地址值。比较内存地址值一般情况下是没有意义的，我们希望比较的是对象的属性，如果两个对象的属性相同，我们认为就是同一个对象；\n\n那么要比较对象的属性，我们就需要在Student类中重写Object类中的equals方法。equals方法的重写，我们也可以使用idea开发工具完成，具体的操作如下所示：\n\n1. 在空白处使用快捷键：alt + insert。此时会弹出如下的对话框\n\n ![1576056718392](assets/1576056718392.png) \n\n2. 选择equals() and hashCode()方法，此时会弹出如下的对话框\n\n![1576057779458](assets/1576057779458.png) \n\n点击next，会弹出如下对话框：\n\n![1576057813175](assets/1576057813175.png) \n\n选择neme和age属性点击next，此时就会弹出如下对话框：\n\n![1576057892814](assets/1576057892814.png) \n\n取消name和age属性（因为此时选择的是在生成hashCode方法时所涉及到的属性，关于hashCode方法后期再做重点介绍），点击Finish完成生成操作。生成的equals方法和hashCode方法如下：\n\n```java\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Student student = (Student) o;\n    return Objects.equals(name, student.name) && Objects.equals(age, student.age);\t// 比较的是对象的name属性值和age属性值\n}\n\n@Override\npublic int hashCode() {\n    return 0;\n}\n```\n\nhashCode方法我们暂时使用不到，可以将hashCode方法删除。重写完毕以后运行程序进行测试，控制台输出结果如下所示：\n\n```java\ntrue\n```\n\n此时equals方法比较的是对象的成员变量值，而s1和s2两个对象的成员变量值都是相同的。因此比较完毕以后的结果就是true。\n\n小结：\n\n1. 默认情况下equals方法比较的是对象的地址值\n2. 比较对象的地址值是没有意义的，因此一般情况下我们都会重写Object类中的equals方法\n\n<font color="blue" size="2">**案例2**</font>：对象克隆\n\n​\t把A对象的属性值完全拷贝给B对象，也叫对象拷贝,对象复制\n\n**对象克隆的分类：**\n\n>深克隆和浅克隆\n\n**浅克隆：**\n\n​\t不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来 \n\n​\t基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。\n\n​\tObject类默认的是浅克隆\n\n![浅克隆](assets\\浅克隆.png)\n\n**深克隆：**\n\n​\t基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的\n\n![深克隆](assets\\深克隆.png)\n\n代码实现：\n\n```java\npackage com.itheima.a04objectdemo;\n\npublic class ObjectDemo4 {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        // protected object clone(int a) 对象克隆 \n\n        //1.先创建一个对象\n        int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};\n        User u1 = new User(1, "zhangsan", "1234qwer", "girl11", data);\n\n        //2.克隆对象\n        //细节:\n        //方法在底层会帮我们创建一个对象,并把原对象中的数据拷贝过去。\n        //书写细节:\n        //1.重写Object中的clone方法\n        //2.让javabean类实现Cloneable接口\n        //3.创建原对象并调用clone就可以了\n        //User u2 =(User)u1.clone();\n\n        //验证一件事情：Object中的克隆是浅克隆\n        //想要进行深克隆，就需要重写clone方法并修改里面的方法体\n        //int[] arr = u1.getData();\n        //arr[0] = 100;\n\n        //System.out.println(u1);\n        //System.out.println(u2);\n\n\n        //以后一般会用第三方工具进行克隆\n        //1.第三方写的代码导入到项目中\n        //2.编写代码\n        //Gson gson =new Gson();\n        //把对象变成一个字符串\n        //String s=gson.toJson(u1);\n        //再把字符串变回对象就可以了\n        //User user =gson.fromJson(s, User.class);\n\n        //int[] arr=u1.getData();\n        //arr[0] = 100;\n\n        //打印对象\n        //System.out.println(user);\n\n    }\n}\n\npackage com.itheima.a04objectdemo;\n\nimport java.util.StringJoiner;\n\n\n\n//Cloneable\n//如果一个接口里面没有抽象方法\n//表示当前的接口是一个标记性接口\n//现在Cloneable表示一旦实现了，那么当前类的对象就可以被克降\n//如果没有实现，当前类的对象就不能克隆\npublic class User implements Cloneable {\n    private int id;\n    private String username;\n    private String password;\n    private String path;\n    private int[] data;\n\n\n\n\n    public User() {\n    }\n\n    public User(int id, String username, String password, String path, int[] data) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.path = path;\n        this.data = data;\n    }\n\n    /**\n     * 获取\n     *\n     * @return id\n     */\n    public int getId() {\n        return id;\n    }\n\n    /**\n     * 设置\n     *\n     * @param id\n     */\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    /**\n     * 获取\n     *\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * 设置\n     *\n     * @param username\n     */\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    /**\n     * 获取\n     *\n     * @return password\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * 设置\n     *\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * 获取\n     *\n     * @return path\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * 设置\n     *\n     * @param path\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * 获取\n     *\n     * @return data\n     */\n    public int[] getData() {\n        return data;\n    }\n\n    /**\n     * 设置\n     *\n     * @param data\n     */\n    public void setData(int[] data) {\n        this.data = data;\n    }\n\n    public String toString() {\n        return "角色编号为：" + id + "，用户名为：" + username + "密码为：" + password + ", 游戏图片为:" + path + ", 进度:" + arrToString();\n    }\n\n\n    public String arrToString() {\n        StringJoiner sj = new StringJoiner(", ", "[", "]");\n\n        for (int i = 0; i < data.length; i++) {\n            sj.add(data[i] + "");\n        }\n        return sj.toString();\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        //调用父类中的clone方法\n        //相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。\n\n        //先把被克隆对象中的数组获取出来\n        int[] data = this.data;\n        //创建新的数组\n        int[] newData =new int[data.length];\n        //拷贝数组中的数据\n        for (int i = 0; i < data.length; i++) {\n            newData[i] = data[i];\n        }\n        //调用父类中的方法克隆对象\n            User u=(User)super.clone();\n        //因为父类中的克隆方法是浅克隆，替换克隆出来对象中的数组地址值\n        u.data =newData;\n        return u;\n    }\n}\n\n```\n\n\n\n# 5 Objects类\n\n## 5.1 概述\n\n> tips：了解内容\n\n查看API文档，我们可以看到API文档中关于Objects类的定义如下：\n\n![1576058492444](assets/1576058492444.png) \n\nObjects类所在包是在java.util包下，因此在使用的时候需要进行导包。并且Objects类是被final修饰的，因此该类不能被继承。\n\nObjects类提供了一些对象常见操作的方法。比如判断对象是否相等，判断对象是否为null等等。\n\n\n\n接下来我们来查看一下API文档，看一下Objects类中的成员，如下所示：\n\n![1576058659628](assets/1576058659628.png) \n\n我们可以发现Objects类中无无参构造方法，因此我们不能使用new关键字去创建Objects的对象。同时我们可以发现Objects类中所提供的方法都是静态的。因此我们可以通过类名直接去调用这些方法。\n\n## 5.2 常见方法\n\n> tips：重点讲解内容\n\n<font color="red" size="3">**常见方法介绍**</font>\n\n我们要重点学习的Objects类中的常见方法如下所示：\n\n```java\npublic static String toString(Object o) \t\t\t\t\t// 获取对象的字符串表现形式\npublic static boolean equals(Object a, Object b)\t\t\t// 比较两个对象是否相等\npublic static boolean isNull(Object obj)\t\t\t\t\t// 判断对象是否为null\npublic static boolean nonNull(Object obj)\t\t\t\t\t// 判断对象是否不为null\n```\n\n\n\n我们要了解的Objects类中的常见方法如下所示：\n\n```java\npublic static <T> T requireNonNull(T obj)\t\t\t\t\t// 检查对象是否不为null,如果为null直接抛出异常；如果不是null返回该对象；\npublic static <T> T requireNonNullElse(T obj, T defaultObj) // 检查对象是否不为null，如果不为null，返回该对象；如果为null返回defaultObj值\npublic static <T> T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)\t// 检查对象是否不为null，如果不为null，返回该对象；如果\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // 为null,返回由Supplier所提供的值\n```\n\n上述方法中的T可以理解为是Object类型。\n\n<font color="red" size="3">**案例演示**</font>\n\n接下来我们就来通过一些案例演示一下Objects类中的这些方法特点。\n\n<font color="blue" size="2">**案例1**</font>：演示重点学习方法\n\n实现步骤：\n\n1. 创建一个学生类，提供两个成员变量（name ， age）；并且提供对应的无参构造方法和有参构造方法以及get/set方法，并且重写toString方法和equals方法\n2. 创建一个测试类（ObjectsDemo01）, 在该类中编写测试代码\n\n如下所示：\n\nStudent类\n\n```java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 其他代码略\n    ...\n        \n}\n```\n\nObjectsDemo01测试类\n\n```java\npublic class ObjectsDemo01 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_04() ;\n\n    }\n\n    // 测试nonNull方法\n    public static void method_04() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的nonNull方法\n        boolean result = Objects.nonNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试isNull方法\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的isNull方法\n        boolean result = Objects.isNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试equals方法\n    public static void method_02() {\n\n        // 创建两个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n        Student s2 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的equals方法，比较两个对象是否相等\n        boolean result = Objects.equals(s1, s2);     // 如果Student没有重写Object类中的equals方法，此处比较的还是对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试toString方法\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects中的toString方法,获取s1对象的字符串表现形式\n        String result = Objects.toString(s1);       // 如果Student没有重写Object类中的toString方法，此处还是返回的对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n}\n```\n\n<font color="blue" size="2">**案例2**</font>：演示需要了解的方法\n\n```java\npublic class ObjectsDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03();\n\n    }\n\n    // 演示requireNonNullElseGet\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNullElseGet方法,该方法的第二个参数是Supplier类型的，查看源码我们发现Supplier是一个函数式接口,\n        // 那么我们就可以为其传递一个Lambda表达式，而在Supplier接口中所定义的方法是无参有返回值的方法，因此具体调用所传入的Lambda表达式如下所示\n        Student student = Objects.requireNonNullElseGet(s1, () -> {\n            return new Student("itcast", "14");\n        });\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNullElse\n    public static void method_02() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNullElse方法\n        Student student = Objects.requireNonNullElse(s1, new Student("itcast", "14"));\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNull\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNull方法\n        Student student = Objects.requireNonNull(s1);\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n}\n```\n\n注：了解性的方法可以可以作为扩展视频进行下发。\n\n# 6 BigInteger类\n\n## 6.1 引入\n\n​\t平时在存储整数的时候，Java中默认是int类型，int类型有取值范围：-2147483648 ~ 2147483647。如果数字过大，我们可以使用long类型，但是如果long类型也表示不下怎么办呢？\n\n​\t就需要用到BigInteger，可以理解为：大的整数。\n\n​\t有多大呢？理论上最大到42亿的21亿次方\n\n​\t基本上在内存撑爆之前，都无法达到这个上限。\n\n## 6.2  概述\n\n查看API文档，我们可以看到API文档中关于BigInteger类的定义如下：\n\n ![Snipaste_2022-09-04_21-36-01](assets\\Snipaste_2022-09-04_21-36-01.png)\n\nBigInteger所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigInteger类进行大整数的计算\n\n## 6.3 常见方法\n\n<font color="red" size="3">**构造方法**</font>\n\n```java\npublic BigInteger(int num, Random rnd) \t\t//获取随机大整数，范围：[0 ~ 2的num次方-1]\npublic BigInteger(String val) \t\t\t\t//获取指定的大整数\npublic BigInteger(String val, int radix) \t//获取指定进制的大整数\n    \n下面这个不是构造，而是一个静态方法获取BigInteger对象\npublic static BigInteger valueOf(long val) \t//静态方法获取BigInteger的对象，内部有优化\n```\n\n**构造方法小结：**\n\n* 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。\n* 如果BigInteger表示的超出long的范围，可以用构造方法获取。\n* 对象一旦创建，BigInteger内部记录的值不能发生改变。\n* 只要进行计算都会产生一个新的BigInteger对象\n\n\n\n<font color="red" size="3">**常见成员方法**</font>\n\nBigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\n\n```java\npublic BigInteger add(BigInteger val)\t\t\t\t\t//加法\npublic BigInteger subtract(BigInteger val)\t\t\t\t//减法\npublic BigInteger multiply(BigInteger val)\t\t\t\t//乘法\npublic BigInteger divide(BigInteger val)\t\t\t\t//除法\npublic BigInteger[] divideAndRemainder(BigInteger val)\t //除法，获取商和余数\npublic  boolean equals(Object x) \t\t\t\t\t    //比较是否相同\npublic  BigInteger pow(int exponent) \t\t\t\t\t//次幂、次方\npublic  BigInteger max/min(BigInteger val) \t\t\t\t//返回较大值/较小值\npublic  int intValue(BigInteger val) \t\t\t\t\t//转为int类型整数，超出范围数据有误\n```\n\n代码实现：\n\n```java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo1 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger(int num, Random rnd) 获取随机大整数，范围:[0~ 2的num次方-11\n            public BigInteger(String val) 获取指定的大整数\n            public BigInteger(String val, int radix) 获取指定进制的大整数\n\n            public static BigInteger valueOf(long val) 静态方法获取BigInteger的对象，内部有优化\n\n            细节:\n            对象一旦创建里面的数据不能发生改变。\n        */\n\n\n        //1.获取一个随机的大整数\n        /* Random r=new Random();\n            for (int i = e; i < 100; i++) {\n            BigInteger bd1 = new BigInteger(4,r);\n            System.out.println(bd1);//[@ ~ 15]}\n            }\n        */\n\n        //2.获取一个指定的大整数，可以超出long的取值范围\n        //细节:字符串中必须是整数，否则会报错\n        /* BigInteger bd2 = new BigInteger("1.1");\n            System.out.println(bd2);\n        */\n\n        /*\n            BigInteger bd3 = new BigInteger("abc");\n            System.out.println(bd3);\n         */\n\n        //3.获取指定进制的大整数\n        //细节:\n        //1.字符串中的数字必须是整数\n        //2.字符串中的数字必须要跟进制吻合。\n        //比如二进制中，那么只能写日和1，写其他的就报错。\n        BigInteger bd4 = new BigInteger("123", 2);\n        System.out.println(bd4);\n\n        //4.静态方法获取BigInteger的对象，内部有优化\n        //细节:\n        //1.能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了。\n        //2.在内部对常用的数字: -16 ~ 16 进行了优化。\n        //  提前把-16~16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。\n        BigInteger bd5 = BigInteger.valueOf(16);\n        BigInteger bd6 = BigInteger.valueOf(16);\n        System.out.println(bd5 == bd6);//true\n\n\n        BigInteger bd7 = BigInteger.valueOf(17);\n        BigInteger bd8 = BigInteger.valueOf(17);\n        System.out.println(bd7 == bd8);//false\n\n\n        //5.对象一旦创建内部的数据不能发生改变\n        BigInteger bd9 =BigInteger.valueOf(1);\n        BigInteger bd10 =BigInteger.valueOf(2);\n        //此时，不会修改参与计算的BigInteger对象中的借，而是产生了一个新的BigInteger对象记录\n        BigInteger result=bd9.add(bd10);\n        System.out.println(result);//3\n\n    }\n}\n\n```\n\n```java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo2 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger add(BigInteger val) 加法\n            public BigInteger subtract(BigInteger val) 减法\n            public BigInteger multiply(BigInteger val) 乘法\n            public BigInteger divide(BigInteger val) 除法，获取商\n            public BigInteger[] divideAndRemainder(BigInteger val) 除法，获取商和余数\n            public boolean equals(Object x) 比较是否相同\n            public BigInteger pow(int exponent) 次幂\n            public BigInteger max/min(BigInteger val) 返回较大值/较小值\n            public int intValue(BigInteger val) 转为int类型整数，超出范围数据有误\n        */\n\n        //1.创建两个BigInteger对象\n        BigInteger bd1 = BigInteger.valueOf(10);\n        BigInteger bd2 = BigInteger.valueOf(5);\n\n        //2.加法\n        BigInteger bd3 = bd1.add(bd2);\n        System.out.println(bd3);\n\n        //3.除法，获取商和余数\n        BigInteger[] arr = bd1.divideAndRemainder(bd2);\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n\n        //4.比较是否相同\n        boolean result = bd1.equals(bd2);\n        System.out.println(result);\n\n        //5.次幂\n        BigInteger bd4 = bd1.pow(2);\n        System.out.println(bd4);\n\n        //6.max\n        BigInteger bd5 = bd1.max(bd2);\n\n\n        //7.转为int类型整数，超出范围数据有误\n        /* BigInteger bd6 = BigInteger.valueOf(2147483647L);\n         int i = bd6.intValue();\n         System.out.println(i);\n         */\n\n        BigInteger bd6 = BigInteger.valueOf(200);\n        double v = bd6.doubleValue();\n        System.out.println(v);//200.0\n    }\n}\n\n```\n\n\n\n## 6.4 底层存储方式：\n\n对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。 \n\n数组中最多能存储元素个数：21亿多\n\n数组中每一位能表示的数字：42亿多\n\n理论上，BigInteger能表示的最大数字为：42亿的21亿次方。\n\n但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。 \n\n存储方式如图所示：\n\n![bigInteger的底层原理](assets\\bigInteger的底层原理.png)\n\n\n\n\n\n\n\n\n\n# 7 BigDecimal类\n\n## 7.1 引入\n\n首先我们来分析一下如下程序的执行结果：\n\n```java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n        System.out.println(0.09 + 0.01);\n    }\n\n}\n```\n\n这段代码比较简单，就是计算0.09和0.01之和，并且将其结果在控制台进行输出。那么按照我们的想法在控制台输出的结果应该为0.1。那么实际的运行结果是什么呢？我们来运行一下程序，控制台的输出\n\n结果如下所示：\n\n```java\n0.09999999999999999\n```\n\n这样的结果其实就是一个丢失精度的结果。为什么会产生精度丢失呢？\n\n在使用float或者double类型的数据在进行数学运算的时候，很有可能会产生精度丢失问题。我们都知道计算机底层在进行运算的时候，使用的都是二进制数据； 当我们在程序中写了一个十进制数据 ，在\n\n进行运算的时候，计算机会将这个十进制数据转换成二进制数据，然后再进行运算，计算完毕以后计算机会把运算的结果再转换成十进制数据给我们展示； 如果我们使用的是整数类型的数据进行计算，那\n\n么在把十进制数据转换成二进制数据的时候不会存在精度问题； 如果我们的数据是一个浮点类型的数据，有的时候计算机并不会将这个数据完全转换成一个二进制数据，而是将这个将其转换成一个无限的\n\n趋近于这个十进数的二进制数据； 这样使用一个不太准确的数据进行运算的时候， 最终就会造成精度丢失；为了提高精度，Java就给我们提供了BigDecimal供我们进行数据运算。\n\n## 7.2 概述\n\n查看API文档，我们可以看到API文档中关于BigDecimal类的定义如下：\n\n ![1576132679789](.\\assets\\1576132679789.png)\n\nBigDecimal所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigDecimal类进行更加精准的数据计算。\n\n## 7.3 常见方法\n\n<font color="red" size="3">**构造方法**</font>\n\n要用BigDecimal类，那么就需要首先学习一下如何去创建BigDecimal的对象。通过查看API文档，我们可以发现Jdk中针对BigDecimal类提供了很多的构造方法，但是最常用的构造方法是：\n\n ![1576134383441](.\\assets\\1576134383441.png)\n\n了解完常见的构造方法以后，我们接下来就重点介绍一下常见的成员方法。\n\n<font color="red" size="3">**常见成员方法**</font>\n\nBigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\n\n```java\npublic BigDecimal add(BigDecimal value)\t\t\t\t// 加法运算\npublic BigDecimal subtract(BigDecimal value)\t\t// 减法运算\npublic BigDecimal multiply(BigDecimal value)\t\t// 乘法运算\npublic BigDecimal divide(BigDecimal value)\t\t\t// 触发运算\n```\n\n接下来我们就来通过一些案例演示一下这些成员方法的使用。\n\n<font color="blue" size="2">**案例1**</font>：演示基本的四则运算\n\n代码如下所示：\n\n```java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("0.3") ;\n        BigDecimal b2 = new BigDecimal("4") ;\n\n        // 调用方法进行b1和b2的四则运算，并将其运算结果在控制台进行输出\n        System.out.println(b1.add(b2));         // 进行加法运算\n        System.out.println(b1.subtract(b2));    // 进行减法运算\n        System.out.println(b1.multiply(b2));    // 进行乘法运算\n        System.out.println(b1.divide(b2));      // 进行除法运算\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下：\n\n```java\n4.3\n-3.7\n1.2\n0.075\n```\n\n此时我们可以看到使用BigDecimal类来完成浮点数的计算不会存在损失精度的问题。\n\n<font color="blue" size="2">**案例2**</font>：演示除法的特殊情况\n\n如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。 如下代码所示：\n\n```java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2));\n\n    }\n\n}\n```\n\n运行程序进行测试，控制台输出结果如下所示：\n\n```java\nException in thread "main" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n\tat java.base/java.math.BigDecimal.divide(BigDecimal.java:1716)\n\tat com.itheima.api.bigdecimal.demo02.BigDecimalDemo02.main(BigDecimalDemo02.java:14)\n```\n\n针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：\n\n```java\nBigDecimal divide(BigDecimal divisor, int scale, int roundingMode)\n```\n\n上述divide方法参数说明：\n\n```\ndivisor:\t\t\t除数对应的BigDecimal对象；\nscale:\t\t\t\t精确的位数；\nroundingMode:\t\t取舍模式；\n取舍模式被封装到了RoundingMode这个枚举类中（关于枚举我们后期再做重点讲解），在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个：\nUP(直接进1) ， FLOOR(直接删除) ， HALF_UP(4舍五入),我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名\n```\n\n接下来我们就来演示一下这些取舍模式，代码如下所示：\n\n```java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03() ;\n\n    }\n\n    // 演示取舍模式HALF_UP\n    public static void method_03() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("0.3") ;\n        BigDecimal b2 = new BigDecimal("4") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.HALF_UP));\n\n    }\n\n    // 演示取舍模式FLOOR\n    public static void method_02() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.FLOOR));\n\n    }\n\n    // 演示取舍模式UP\n    public static void method_01() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.UP));\n\n    }\n\n}\n```\n\n小结：后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。\n\n## 7.4 底层存储方式：\n\n把数据看成字符串，遍历得到里面的每一个字符，把这些字符在ASCII码表上的值，都存储到数组中。\n\n ![bigdecimal存储原理](assets\\bigdecimal存储原理.png)\n\n\n\n\n\n\n\n\n\n'},{title:"正则表达式",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 正则表达式的概念及演示",slug:"_1-1-正则表达式的概念及演示",link:"#_1-1-正则表达式的概念及演示",children:[]},{level:2,title:"1.2 正则表达式-字符类",slug:"_1-2-正则表达式-字符类",link:"#_1-2-正则表达式-字符类",children:[]},{level:2,title:"1.3 正则表达式-逻辑运算符",slug:"_1-3-正则表达式-逻辑运算符",link:"#_1-3-正则表达式-逻辑运算符",children:[]},{level:2,title:"1.4 正则表达式-预定义字符",slug:"_1-4-正则表达式-预定义字符",link:"#_1-4-正则表达式-预定义字符",children:[]},{level:2,title:"1.5 正则表达式-数量词",slug:"_1-5-正则表达式-数量词",link:"#_1-5-正则表达式-数量词",children:[]},{level:2,title:"1.6 正则表达式练习1",slug:"_1-6-正则表达式练习1",link:"#_1-6-正则表达式练习1",children:[]},{level:2,title:"1.7 正则表达式练习2",slug:"_1-7-正则表达式练习2",link:"#_1-7-正则表达式练习2",children:[]},{level:2,title:"1.8 本地数据爬取",slug:"_1-8-本地数据爬取",link:"#_1-8-本地数据爬取",children:[]},{level:2,title:"1.9 网络数据爬取（了解）",slug:"_1-9-网络数据爬取-了解",link:"#_1-9-网络数据爬取-了解",children:[]},{level:2,title:"1.10 爬取数据练习",slug:"_1-10-爬取数据练习",link:"#_1-10-爬取数据练习",children:[]},{level:2,title:"1.11 按要求爬取",slug:"_1-11-按要求爬取",link:"#_1-11-按要求爬取",children:[]},{level:2,title:"1.12 贪婪爬取和非贪婪爬取",slug:"_1-12-贪婪爬取和非贪婪爬取",link:"#_1-12-贪婪爬取和非贪婪爬取",children:[]},{level:2,title:"1.13 String的split方法中使用正则表达式",slug:"_1-13-string的split方法中使用正则表达式",link:"#_1-13-string的split方法中使用正则表达式",children:[]},{level:2,title:"1.14 String类的replaceAll方法中使用正则表达式",slug:"_1-14-string类的replaceall方法中使用正则表达式",link:"#_1-14-string类的replaceall方法中使用正则表达式",children:[]},{level:2,title:"1.15 正则表达式-分组括号( )",slug:"_1-15-正则表达式-分组括号",link:"#_1-15-正则表达式-分组括号",children:[]},{level:2,title:"1.16 分组练习",slug:"_1-16-分组练习",link:"#_1-16-分组练习",children:[]},{level:2,title:"1.17 忽略大小写的写法",slug:"_1-17-忽略大小写的写法",link:"#_1-17-忽略大小写的写法",children:[]},{level:2,title:"1.18 非捕获分组",slug:"_1-18-非捕获分组",link:"#_1-18-非捕获分组",children:[]},{level:2,title:"1.19 正则表达式练习",slug:"_1-19-正则表达式练习",link:"#_1-19-正则表达式练习",children:[]}],path:"/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",pathLocale:"/",extraFields:'---\ntitle: 正则表达式\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n正则表达式\n\n\x3c!-- more --\x3e\n## 今日内容\n\n* 正则表达式\n\n## 教学目标  \n\n- [ ] 能够理解正则表达式的作用\n- [ ] 能够使用正则表达式的字符类\n- [ ] 能够使用正则表达式的逻辑运算符\n- [ ] 能够使用正则表达式的预定义字符类\n- [ ] 能够使用正则表达式的限定符\n- [ ] 能够使用正则表达式的分组\n- [ ] 能够在String的split方法中使用正则表达式\n\n# 正则表达式\n\n## 1.1 正则表达式的概念及演示\n\n- 在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。\n- 先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证：\n  - QQ号码必须是5--15位长度\n  - 而且必须全部是数字\n  - 而且首位不能为0\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo1 {\n    public static void main(String[] args) {\n        /* 假如现在要求校验一个qq号码是否正确。\n            规则:6位及20位之内，日不能在开头，必须全部是数字。\n            先使用目前所学知识完成校验需求然后体验一下正则表达式检验。\n        */\n\n        String qq ="1234567890";\n        System.out.println(checkQQ(qq));\n\n        System.out.println(qq.matches("[1-9]\\\\d{5,19}"));\n\n    }\n\n    public static boolean checkQQ(String qq) {\n        //规则:6位及20位之内，日不能在开头，必须全部是数字 。\n        //核心思想:\n        //先把异常数据进行过滤\n        //下面的就是满足要求的数据了。\n        int len = qq.length();\n        if (len < 6 || len > 20) {\n            return false;\n        }\n        //0不能在开头\n        if (qq.startsWith("0")) {\n            return false;\n        }\n        //必须全部是数字\n        for (int i = 0; i < qq.length(); i++) {\n            char c = qq.charAt(i);\n            if (c < \'0\' | c > \'9\') {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- 使用正则表达式验证：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        String qq ="1234567890";\n        System.out.println(qq.matches("[1-9]\\\\d{5,19}"));\n    }\n}\n```\n\n**我们接下来就重点学习怎样写正则表达式**\n\n## 1.2 正则表达式-字符类\n\n- 语法示例：\n\n1. \\[abc\\]：代表a或者b，或者c字符中的一个。\n2. \\[^abc\\]：代表除a,b,c以外的任何字符。\n3. [a-z]：代表a-z的所有小写字符中的一个。\n4. [A-Z]：代表A-Z的所有大写字符中的一个。\n5. [0-9]：代表0-9之间的某一个数字字符。\n6. [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。\n7. [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 \n\n- 代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo2 {\n    public static void main(String[] args) {\n        //public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true\n        // 只能是a b c\n        System.out.println("-----------1-------------");\n        System.out.println("a".matches("[abc]")); // true\n        System.out.println("z".matches("[abc]")); // false\n\n        // 不能出现a b c\n        System.out.println("-----------2-------------");\n        System.out.println("a".matches("[^abc]")); // false\n        System.out.println("z".matches("[^abc]")); // true\n        System.out.println("zz".matches("[^abc]")); //false\n        System.out.println("zz".matches("[^abc][^abc]")); //true\n\n        // a到zA到Z(包括头尾的范围)\n        System.out.println("-----------3-------------");\n        System.out.println("a".matches("[a-zA-z]")); // true\n        System.out.println("z".matches("[a-zA-z]")); // true\n        System.out.println("aa".matches("[a-zA-z]"));//false\n        System.out.println("zz".matches("[a-zA-Z]")); //false\n        System.out.println("zz".matches("[a-zA-Z][a-zA-Z]")); //true\n        System.out.println("0".matches("[a-zA-Z]"));//false\n        System.out.println("0".matches("[a-zA-Z0-9]"));//true\n\n\n        // [a-d[m-p]] a到d，或m到p\n        System.out.println("-----------4-------------");\n        System.out.println("a".matches("[a-d[m-p]]"));//true\n        System.out.println("d".matches("[a-d[m-p]]")); //true\n        System.out.println("m".matches("[a-d[m-p]]")); //true\n        System.out.println("p".matches("[a-d[m-p]]")); //true\n        System.out.println("e".matches("[a-d[m-p]]")); //false\n        System.out.println("0".matches("[a-d[m-p]]")); //false\n\n        // [a-z&&[def]] a-z和def的交集。为:d，e，f\n        System.out.println("----------5------------");\n        System.out.println("a".matches("[a-z&[def]]")); //false\n        System.out.println("d".matches("[a-z&&[def]]")); //true\n        System.out.println("0".matches("[a-z&&[def]]")); //false\n\n        // [a-z&&[^bc]] a-z和非bc的交集。(等同于[ad-z])\n        System.out.println("-----------6------------_");\n        System.out.println("a".matches("[a-z&&[^bc]]"));//true\n        System.out.println("b".matches("[a-z&&[^bc]]")); //false\n        System.out.println("0".matches("[a-z&&[^bc]]")); //false\n\n        // [a-z&&[^m-p]] a到z和除了m到p的交集。(等同于[a-1q-z])\n        System.out.println("-----------7-------------");\n        System.out.println("a".matches("[a-z&&[^m-p]]")); //true\n        System.out.println("m".matches("[a-z&&[^m-p]]")); //false\n        System.out.println("0".matches("[a-z&&[^m-p]]")); //false\n\n    }\n}\n\n```\n\n## 1.3 正则表达式-逻辑运算符\n\n- 语法示例：\n  1. &&：并且\n  2. |    ：或者\n  3.  \\  ：转义字符\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\tString str = "had";\n\t\t\n\t\t//1.要求字符串是小写辅音字符开头，后跟ad\n\t\tString regex = "[a-z&&[^aeiou]]ad";\n\t\tSystem.out.println("1." + str.matches(regex));\n\t\t\n\t\t//2.要求字符串是aeiou中的某个字符开头，后跟ad\n\t\tregex = "[a|e|i|o|u]ad";//这种写法相当于：regex = "[aeiou]ad";\n\t\tSystem.out.println("2." + str.matches(regex));\n\t}\n}\n\n```\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo3 {\n    public static void main(String[] args) {\n        // \\ 转义字符 改变后面那个字符原本的含义\n        //练习:以字符串的形式打印一个双引号\n        //"在Java中表示字符串的开头或者结尾\n\n        //此时\\表示转义字符，改变了后面那个双引号原本的含义\n        //把他变成了一个普普通通的双引号而已。\n        System.out.println("\\"");\n\n        // \\表示转义字符\n        //两个\\的理解方式：前面的\\是一个转义字符，改变了后面\\原本的含义，把他变成一个普普通通的\\而已。\n        System.out.println("c:Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\myapi\\\\src\\\\com\\\\itheima\\\\a08regexdemo\\\\RegexDemo1.java");\n\n\n\n\n    }\n}\n\n```\n\n\n\n## 1.4 正则表达式-预定义字符\n\n- 语法示例：\n  1. "." ： 匹配任何字符。\n  2. "\\d"：任何数字[0-9]的简写；\n  3. "\\D"：任何非数字\\[^0-9\\]的简写；\n  4. "\\s"： 空白字符：[ \\t\\n\\x0B\\f\\r] 的简写\n  5. "\\S"： 非空白字符：\\[^\\s\\] 的简写\n  6. "\\w"：单词字符：[a-zA-Z_0-9]的简写\n  7. "\\W"：非单词字符：\\[^\\w\\]\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n        //.表示任意一个字符\n        System.out.println("你".matches("..")); //false\n        System.out.println("你".matches(".")); //true\n        System.out.println("你a".matches(".."));//true\n\n        // \\\\d 表示任意的一个数字\n        // \\\\d只能是任意的一位数字\n        // 简单来记:两个\\表示一个\\\n        System.out.println("a".matches("\\\\d")); // false\n        System.out.println("3".matches("\\\\d")); // true\n        System.out.println("333".matches("\\\\d")); // false\n\n        //\\\\w只能是一位单词字符[a-zA-Z_0-9]\n        System.out.println("z".matches("\\\\w")); // true\n        System.out.println("2".matches("\\\\w")); // true\n        System.out.println("21".matches("\\\\w")); // false\n        System.out.println("你".matches("\\\\w"));//false\n\n        // 非单词字符\n        System.out.println("你".matches("\\\\W")); // true\n        System.out.println("---------------------------------------------");\n        // 以上正则匹配只能校验单个字符。\n\n\n        // 必须是数字 字母 下划线 至少 6位\n        System.out.println("2442fsfsf".matches("\\\\w{6,}"));//true\n        System.out.println("244f".matches("\\\\w{6,}"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println("23dF".matches("[a-zA-Z0-9]{4}"));//true\n        System.out.println("23 F".matches("[a-zA-Z0-9]{4}"));//false\n        System.out.println("23dF".matches("[\\\\w&&[^_]]{4}"));//true\n        System.out.println("23_F".matches("[\\\\w&&[^_]]{4}"));//false\n\t\t\n\t}\n}\n```\n\n## 1.5 正则表达式-数量词\n\n- 语法示例：\n  1. X? : 0次或1次\n  2. X* : 0次到多次\n  3. X+ : 1次或多次\n  4. X{n} : 恰好n次\n  5. X{n,} : 至少n次\n  6. X{n,m}: n到m次(n和m都是包含的)\n- 代码示例：\n\n```java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\t // 必须是数字 字母 下划线 至少 6位\n        System.out.println("2442fsfsf".matches("\\\\w{6,}"));//true\n        System.out.println("244f".matches("\\\\w{6,}"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println("23dF".matches("[a-zA-Z0-9]{4}"));//true\n        System.out.println("23 F".matches("[a-zA-Z0-9]{4}"));//false\n        System.out.println("23dF".matches("[\\\\w&&[^_]]{4}"));//true\n        System.out.println("23_F".matches("[\\\\w&&[^_]]{4}"));//false\n\t}\n}\n\n```\n\n## 1.6 正则表达式练习1\n\n需求：\n\n​\t请编写正则表达式验证用户输入的手机号码是否满足要求。\n\n​\t请编写正则表达式验证用户输入的邮箱号是否满足要求。\n\n​\t请编写正则表达式验证用户输入的电话号码是否满足要求。\n\n​\t验证手机号码 13112345678 13712345667 13945679027 139456790271\n\n​\t验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434\n\n​\t验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo4 {\n    public static void main(String[] args) {\n        /*\n            需求\n            请编写正则表达式验证用户输入的手机号码是否满足要求。请编写正则表达式验证用户输入的邮箱号是否满足要求。请编写正则表达式验证用户输入的电话号码是否满足要求。\n            验证手机号码 13112345678 13712345667 13945679027 139456790271\n            验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434\n            验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        */\n\n        //心得:\n        //拿着一个正确的数据，从左到右依次去写。\n        //13112345678\n        //分成三部分:\n        //第一部分:1 表示手机号码只能以1开头\n        //第二部分:[3-9] 表示手机号码第二位只能是3-9之间的\n        //第三部分:\\\\d{9} 表示任意数字可以出现9次，也只能出现9次\n        String regex1 = "1[3-9]\\\\d{9}";\n        System.out.println("13112345678".matches(regex1));//true\n        System.out.println("13712345667".matches(regex1));//true\n        System.out.println("13945679027".matches(regex1));//true\n        System.out.println("139456790271".matches(regex1));//false\n        System.out.println("-----------------------------------");\n\n        //座机电话号码\n        //020-2324242 02122442 027-42424 0712-3242434\n        //思路:\n        //在书写座机号正则的时候需要把正确的数据分为三部分\n        //一:区号@\\\\d{2,3}\n        //      0:表示区号一定是以0开头的\n        //      \\\\d{2,3}:表示区号从第二位开始可以是任意的数字，可以出现2到3次。\n        //二:- ?表示次数，日次或一次\n        //三:号码 号码的第一位也不能以日开头，从第二位开始可以是任意的数字，号码的总长度:5-10位\n        String regex2 = "0\\\\d{2,3}-?[1-9]\\\\d{4,9}";\n        System.out.println("020-2324242".matches(regex2));\n        System.out.println("02122442".matches(regex2));\n        System.out.println("027-42424".matches(regex2));\n        System.out.println("0712-3242434".matches(regex2));\n\n        //邮箱号码\n        //3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        //思路:\n        //在书写邮箱号码正则的时候需要把正确的数据分为三部分\n        //第一部分:@的左边 \\\\w+\n        //      任意的字母数字下划线，至少出现一次就可以了\n        //第二部分:@ 只能出现一次\n        //第三部分:\n        //      3.1         .的左边[\\\\w&&[^_]]{2,6}\n        //                  任意的字母加数字，总共出现2-6次(此时不能出现下划线)\n        //      3.2         . \\\\.\n        //      3.3         大写字母，小写字母都可以，只能出现2-3次[a-zA-Z]{2,3}\n        //      我们可以把3.2和3.3看成一组，这一组可以出现1次或者两次\n        String regex3 = "\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}";\n        System.out.println("3232323@qq.com".matches(regex3));\n        System.out.println("zhangsan@itcast.cnn".matches(regex3));\n        System.out.println("dlei0009@163.com".matches(regex3));\n        System.out.println("dlei0009@pci.com.cn".matches(regex3));\n\n\n        //24小时的正则表达式\n        String regex4 = "([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d";\n        System.out.println("23:11:11".matches(regex4));\n\n        String regex5 = "([01]\\\\d 2[0-3])(:[0-5]\\\\d){2}";\n        System.out.println("23:11:11".matches(regex5));\n    }\n}\n\n```\n\n## 1.7 正则表达式练习2\n\n需求\n\t请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位\n\t请编写正则表达式验证身份证号码是否满足要求。\n\t简单要求:\n    \t\t18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n\t复杂要求:\n    \t\t按照身份证号码的格式严格要求。\n\n​\t身份证号码:\n\t\t41080119930228457x\n\t\t510801197609022309\n\t\t15040119810705387X\n\t\t130133197204039024 \n\t\t430102197606046442\n\n代码示例：\n\n```java\npublic class RegexDemo5 {\n    public static void main(String[] args) {\n        /*\n            正则表达式练习:\n            需求\n            请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位\n            请编写正则表达式验证身份证号码是否满足要求。\n            简单要求:\n                18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n            复杂要求:\n                按照身份证号码的格式严格要求。\n\n            身份证号码:\n            41080119930228457x\n            510801197609022309\n            15040119810705387X\n            130133197204039024 I\n            430102197606046442\n        */\n\n        //用户名要求:大小写字母，数字，下划线一共4-16位\n        String regex1 = "\\\\w{4,16}";\n        System.out.println("zhangsan".matches(regex1));\n        System.out.println("lisi".matches(regex1));\n        System.out.println("wangwu".matches(regex1));\n        System.out.println("$123".matches(regex1));\n\n\n        //身份证号码的简单校验:\n        //18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n        String regex2 = "[1-9]\\\\d{16}(\\\\d|x|x)";\n        String regex3 = "[1-9]\\\\d{16}[\\\\dXx]";\n        String regex5 = "[1-9]\\\\d{16}(\\\\d(?i)x)";\n\n        System.out.println("41080119930228457x".matches(regex3));\n        System.out.println("510801197609022309".matches(regex3));\n        System.out.println("15040119810705387X".matches(regex3));\n        System.out.println("130133197204039024".matches(regex3));\n        System.out.println("430102197606046442".matches(regex3));\n\n\n        //忽略大小写的书写方式\n        //在匹配的时候忽略abc的大小写\n        String regex4 = "a((?i)b)c";\n        System.out.println("------------------------------");\n        System.out.println("abc".matches(regex4));//true\n        System.out.println("ABC".matches(regex4));//false\n        System.out.println("aBc".matches(regex4));//true\n\n\n        //身份证号码的严格校验\n        //编写正则的小心得:\n        //第一步:按照正确的数据进行拆分\n        //第二步:找每一部分的规律，并编写正则表达式\n        //第三步:把每一部分的正则拼接在一起，就是最终的结果\n        //书写的时候:从左到右去书写。\n\n        //410801 1993 02 28 457x\n        //前面6位:省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字       [1-9]\\\\d{5}\n        //年的前半段: 18 19 20                                                (18|19|20)\n        //年的后半段: 任意数字出现两次                                           \\\\d{2}\n        //月份: 01~ 09 10 11 12                                               (@[1-9]|1[0-2])\n        //日期: 01~09 10~19 20~29 30 31                                       (0[1-9]|[12]\\\\d|3[01])\n        //后面四位: 任意数字出现3次 最后一位可以是数字也可以是大写x或者小写x        \\\\d{3}[\\\\dXx]\n        String regex6 = "[1-9]\\\\d{5}(18|19|20)\\\\d{2}(@[1-9]|1[0-2])(@[1-9]|[12]\\\\d|3[01])\\\\d{3}[\\\\dxXx]";\n\n        System.out.println("41080119930228457x".matches(regex6));\n        System.out.println("510801197609022309".matches(regex6));\n        System.out.println("15040119810705387X".matches(regex6));\n        System.out.println("130133197204039024".matches(regex6));\n        System.out.println("430102197606046442".matches(regex6));\n\n\n    }\n}\n\n```\n\n## 1.8 本地数据爬取\n\nPattern：表示正则表达式\nMatcher：文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\n         \t在大串中去找符合匹配规则的子串。\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo6 {\n    public static void main(String[] args) {\n        /* 有如下文本，请按照要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n                要求:找出里面所有的JavaXX\n         */\n\n        String str = "Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，" +\n                "因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile("Java\\\\d{0,2}");\n        //2.获取文本匹配器的对象\n        //拿着m去读取str，找符合p规则的子串\n        Matcher m = p.matcher(str);\n\n        //3.利用循环获取\n        while (m.find()) {\n            String s = m.group();\n            System.out.println(s);\n        }\n\n\n    }\n\n    private static void method1(String str) {\n        //Pattern:表示正则表达式\n        //Matcher: 文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\n        //          在大串中去找符合匹配规则的子串。\n\n        //获取正则表达式的对象\n        Pattern p = Pattern.compile("Java\\\\d{0,2}");\n        //获取文本匹配器的对象\n        //m:文本匹配器的对象\n        //str:大串\n        //p:规则\n        //m要在str中找符合p规则的小串\n        Matcher m = p.matcher(str);\n\n        //拿着文本匹配器从头开始读取，寻找是否有满足规则的子串\n        //如果没有，方法返回false\n        //如果有，返回true。在底层记录子串的起始索引和结束索引+1\n        // 0,4\n        boolean b = m.find();\n\n        //方法底层会根据find方法记录的索引进行字符串的截取\n        // substring(起始索引，结束索引);包头不包尾\n        // (0,4)但是不包含4索引\n        // 会把截取的小串进行返回。\n        String s1 = m.group();\n        System.out.println(s1);\n\n\n        //第二次在调用find的时候，会继续读取后面的内容\n        //读取到第二个满足要求的子串，方法会继续返回true\n        //并把第二个子串的起始索引和结束索引+1，进行记录\n        b = m.find();\n\n        //第二次调用group方法的时候，会根据find方法记录的索引再次截取子串\n        String s2 = m.group();\n        System.out.println(s2);\n    }\n}\n```\n\n## 1.9 网络数据爬取（了解）\n\n需求：\n\n​\t把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i中所有的身份证号码都爬取出来。\n\n代码示例：\n\n```java\npublic class RegexDemo7 {\n    public static void main(String[] args) throws IOException {\n        /* 扩展需求2:\n            把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i\n            中所有的身份证号码都爬取出来。\n        */\n\n        //创建一个URL对象\n        URL url = new URL("https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i");\n        //连接上这个网址\n        //细节:保证网络是畅通\n        URLConnection conn = url.openConnection();//创建一个对象去读取网络中的数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String line;\n        //获取正则表达式的对象pattern\n        String regex = "[1-9]\\\\d{17}";\n        Pattern pattern = Pattern.compile(regex);//在读取的时候每次读一整行\n        while ((line = br.readLine()) != null) {\n            //拿着文本匹配器的对象matcher按照pattern的规则去读取当前的这一行信息\n            Matcher matcher = pattern.matcher(line);\n            while (matcher.find()) {\n                System.out.println(matcher.group());\n            }\n        }\n        br.close();\n    }\n}\n\n```\n\n## 1.10 爬取数据练习\n\n需求：\n\n​\t把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。\n\n来黑马程序员学习Java，手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090手机号的正则表达式:1[3-9]\\d{9}\n\n代码示例：\n\n```java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo8 {\n    public static void main(String[] args) {\n        /*\n            需求:把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。\n            来黑马程序员学习Java，\n            手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，\n            座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，\n            热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090\n\n            手机号的正则表达式:1[3-9]\\d{9}\n            邮箱的正则表达式:\\w+@[\\w&&[^_]]{2,6}(\\.[a-zA-Z]{2,3}){1,2}座机电话的正则表达式:θ\\d{2,3}-?[1-9]\\d{4,9}\n            热线电话的正则表达式:400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3}\n\n        */\n\n        String s = "来黑马程序员学习Java，" +\n                "电话:18512516758，18512508907" + "或者联系邮箱:boniu@itcast.cn，" +\n                "座机电话:01036517895，010-98951256" + "邮箱:bozai@itcast.cn，" +\n                "热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090";\n\n        System.out.println("400-618-9090");\n\n        String regex = "(1[3-9]\\\\d{9})|(\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2})" +\n                "|(0\\\\d{2,3}-?[1-9]\\\\d{4,9})" +\n                "(400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3})";\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile(regex);\n\n        //2.获取文本匹配器的对象\n        //利用m去读取s，会按照p的规则找里面的小串\n        Matcher m = p.matcher(s);\n        //3.利用循环获取每一个数据 while(m.find()){\n        String str = m.group();\n        System.out.println(str);\n\n    }\n}\n```\n\n## 1.11 按要求爬取\n\n需求：\n\n​\t有如下文本，按要求爬取数据。   \n\n​\t Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台。\n\n需求1：\n\n​\t爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。\n\n需求2：\n\n​\t爬取版本号为8，11，17的Java文本。正确爬取结果为：Java8 Java11 Java17 Java17\n\n需求3：\n\n​\t爬取除了版本号为8，11，17的Java文本。\n代码示例：\n\n```java\npublic class RegexDemo9 {\n    public static void main(String[] args) {\n        /*\n            有如下文本，按要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n\n\n            需求1:爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。\n            需求2:爬取版本号为8，11，17的Java文本。正确爬取结果为:Java8 Java11 Java17 Java17\n            需求3:爬取除了版本号为8，11.17的Java文本，\n        */\n        String s = "Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，" +\n            "因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n        //1.定义正则表达式\n        //?理解为前面的数据Java\n        //=表示在Java后面要跟随的数据\n        //但是在获取的时候，只获取前半部分\n        //需求1:\n        String regex1 = "((?i)Java)(?=8|11|17)";\n        //需求2:\n        String regex2 = "((?i)Java)(8|11|17)";\n        String regex3 = "((?i)Java)(?:8|11|17)";\n        //需求3:\n        String regex4 = "((?i)Java)(?!8|11|17)";\n\n        Pattern p = Pattern.compile(regex4);\n        Matcher m = p.matcher(s);\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}\n\n```\n\n## 1.12 贪婪爬取和非贪婪爬取\n\n```java\n只写+和表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取\n+? 非贪婪匹配\n*? 非贪婪匹配\n贪婪爬取:在爬取数据的时候尽可能的多获取数据\n非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n举例：\n如果获取数据：ab+\n贪婪爬取获取结果:abbbbbbbbbbbb\n非贪婪爬取获取结果:ab\n```\n\n代码示例：\n\n```java\npublic class RegexDemo10 {\n    public static void main(String[] args) {\n        /*\n            只写+和*表示贪婪匹配\n\n            +? 非贪婪匹配\n            *? 非贪婪匹配\n\n            贪婪爬取:在爬取数据的时候尽可能的多获取数据\n            非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n            ab+:\n            贪婪爬取:abbbbbbbbbbbb\n            非贪婪爬取:ab\n        */\n        String s = "Java自从95年问世以来，abbbbbbbbbbbbaaaaaaaaaaaaaaaaaa" +\n                "经历了很多版木，目前企业中用的最多的是]ava8和]ava11，因为这两个是长期支持版木。" +\n                "下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n        String regex = "ab+";\n        Pattern p = Pattern.compile(regex);\n        Matcher m = p.matcher(s);\n\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n\n\n    }\n}\n\n```\n\n## 1.13 String的split方法中使用正则表达式\n\n- String类的split()方法原型：\n\n  ```java\n  public String[] split(String regex)\n  //参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为"分隔符"来切割字符串。\n  ```\n\n- 代码示例：\n\n```java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = "小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就切割。\nString[] arr = s.split("[\\\\w&&[^_]]+");\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}\n```\n\n## 1.14 String类的replaceAll方法中使用正则表达式\n\n- String类的replaceAll()方法原型：\n\n```java\npublic String replaceAll(String regex,String newStr)\n//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。\n```\n\n- 代码示例：\n\n```java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = "小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就用第一个参数去替换。\nString result1 = s.replaceAll("[\\\\w&&[^_]]+", "vs");\nSystem.out.println(result1);\n```\n\n## 1.15 正则表达式-分组括号( )\n\n细节：如何识别组号？\n\n只看左括号，不看有括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等\n\n```java\n//需求1:判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符\n//举例: a123a b456b 17891 &abc& a123b(false)\n// \\\\组号:表示把第X组的内容再出来用一次\nString regex1 = "(.).+\\\\1";\nSystem.out.println("a123a".matches(regex1));\nSystem.out.println("b456b".matches(regex1));\nSystem.out.println("17891".matches(regex1));\nSystem.out.println("&abc&".matches(regex1));\nSystem.out.println("a123b".matches(regex1));\nSystem.out.println("--------------------------");\n\n\n//需求2:判断一个字符串的开始部分和结束部分是否一致?可以有多个字符\n//举例: abc123abc b456b 123789123 &!@abc&!@ abc123abd(false)\nString regex2 = "(.+).+\\\\1";\nSystem.out.println("abc123abc".matches(regex2));\nSystem.out.println("b456b".matches(regex2));\nSystem.out.println("123789123".matches(regex2));\nSystem.out.println("&!@abc&!@".matches(regex2));\nSystem.out.println("abc123abd".matches(regex2));\nSystem.out.println("---------------------");\n\n//需求3:判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致\n//举例: aaa123aaa bbb456bbb 111789111 &&abc&&\n//(.):把首字母看做一组\n// \\\\2:把首字母拿出来再次使用\n// *:作用于\\\\2,表示后面重复的内容出现日次或多次\nString regex3 = "((.)\\\\2*).+\\\\1";\nSystem.out.println("aaa123aaa".matches(regex3));\nSystem.out.println("bbb456bbb".matches(regex3));\nSystem.out.println("111789111".matches(regex3));\nSystem.out.println("&&abc&&".matches(regex3));\nSystem.out.println("aaa123aab".matches(regex3));\n```\n\n## 1.16 分组练习\n\n需求:\n\n​    将字符串：我要学学编编编编程程程程程程。\n\n​    替换为：我要学编程\n\n```java\nString str = "我要学学编编编编程程程程程程";\n\n//需求:把重复的内容 替换为 单个的\n//学学                学\n//编编编编            编\n//程程程程程程        程\n//  (.)表示把重复内容的第一个字符看做一组\n//  \\\\1表示第一字符再次出现\n//  + 至少一次\n//  $1 表示把正则表达式中第一组的内容，再拿出来用\nString result = str.replaceAll("(.)\\\\1+", "$1");\nSystem.out.println(result);\n```\n\n## 1.17 忽略大小写的写法\n\n```java\n//(?i) ：表示忽略后面数据的大小写\n//忽略abc的大小写\nString regex = "(?i)abc";\n//a需要一模一样，忽略bc的大小写\nString regex = "a(?i)bc";\n//ac需要一模一样，忽略b的大小写\nString regex = "a((?i)b)c";\n```\n\n## 1.18 非捕获分组\n\n非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来。\n\n```java\n//身份证号码的简易正则表达式\n//非捕获分组:仅仅是把数据括起来\n//特点:不占用组号\n//这里\\\\1报错原因:(?:)就是非捕获分组，此时是不占用组号的。\n\n\n//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个\n//String regex1 ="[1-9]\\\\d{16}(?:\\\\d|x|x)\\\\1";\nString regex2 ="[1-9]\\\\d{16}(\\\\d Xx)\\\\1";\n//^([01]\\d|2[0-3]):[0-5]\\d:[@-5]\\d$\n\nSystem.out.println("41080119930228457x".matches(regex2));\n```\n\n## 1.19 正则表达式练习\n\n```java\n手机号码:1[3-9]\\\\d{9}\n座机号码：0\\\\d{2,3}-?[1-9]\\\\d{4,9}\n邮箱号码：\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}\n24小时：([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\n\t   ([01]\\\\d|2[0-3])(:[0-5]\\\\d){2}\n用户名:\t\\\\w{4,16}\n身份证号码，简单校验：\n\t\t[1-9]\\\\d{16}(\\\\d|X|x)\n\t\t[1-9]\\\\d{16}[\\\\dXx]\n\t\t[1-9]\\\\d{16}(\\\\d(?i)X)\n身份证号码，严格校验：\n\t\t[1-9]\\\\d{5}(18|19|20)\\\\d{2}(0[1-9]|1[0-2])(0[1-9|[12])\\\\d|3[01])\\\\d{3}[\\\\dXx]\n```\n\n'},{title:"常用API",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 Date概述",slug:"_1-1-date概述",link:"#_1-1-date概述",children:[]},{level:2,title:"1.2 Date常用方法",slug:"_1-2-date常用方法",link:"#_1-2-date常用方法",children:[]},{level:2,title:"2.1 构造方法",slug:"_2-1-构造方法",link:"#_2-1-构造方法",children:[]},{level:2,title:"2.2 格式规则",slug:"_2-2-格式规则",link:"#_2-2-格式规则",children:[]},{level:2,title:"2.3 常用方法",slug:"_2-3-常用方法",link:"#_2-3-常用方法",children:[]},{level:2,title:"2.4 练习1(初恋女友的出生日期)",slug:"_2-4-练习1-初恋女友的出生日期",link:"#_2-4-练习1-初恋女友的出生日期",children:[]},{level:2,title:"2.5 练习2(秒杀活动)",slug:"_2-5-练习2-秒杀活动",link:"#_2-5-练习2-秒杀活动",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 常用方法",slug:"_3-2-常用方法",link:"#_3-2-常用方法",children:[]},{level:2,title:"3.3 get方法示例",slug:"_3-3-get方法示例",link:"#_3-3-get方法示例",children:[]},{level:2,title:"3.4 set方法示例：",slug:"_3-4-set方法示例",link:"#_3-4-set方法示例",children:[]},{level:2,title:"3.5 add方法示例：",slug:"_3-5-add方法示例",link:"#_3-5-add方法示例",children:[]},{level:2,title:"4.1  ZoneId 时区",slug:"_4-1-zoneid-时区",link:"#_4-1-zoneid-时区",children:[]},{level:2,title:"4.2  Instant 时间戳",slug:"_4-2-instant-时间戳",link:"#_4-2-instant-时间戳",children:[]},{level:2,title:"4.3 ZoneDateTime  带时区的时间",slug:"_4-3-zonedatetime-带时区的时间",link:"#_4-3-zonedatetime-带时区的时间",children:[]},{level:2,title:"4.4DateTimeFormatter   用于时间的格式化和解析",slug:"_4-4datetimeformatter-用于时间的格式化和解析",link:"#_4-4datetimeformatter-用于时间的格式化和解析",children:[]},{level:2,title:"4.5LocalDate  年、月、日",slug:"_4-5localdate-年、月、日",link:"#_4-5localdate-年、月、日",children:[]},{level:2,title:"4.6 LocalTime  时、分、秒",slug:"_4-6-localtime-时、分、秒",link:"#_4-6-localtime-时、分、秒",children:[]},{level:2,title:"4.7 LocalDateTime  年、月、日、时、分、秒",slug:"_4-7-localdatetime-年、月、日、时、分、秒",link:"#_4-7-localdatetime-年、月、日、时、分、秒",children:[]},{level:2,title:"4.8 Duration  时间间隔（秒，纳，秒）",slug:"_4-8-duration-时间间隔-秒-纳-秒",link:"#_4-8-duration-时间间隔-秒-纳-秒",children:[]},{level:2,title:"4.9 Period  时间间隔（年，月，日）",slug:"_4-9-period-时间间隔-年-月-日",link:"#_4-9-period-时间间隔-年-月-日",children:[]},{level:2,title:"4.10 ChronoUnit  时间间隔（所有单位）",slug:"_4-10-chronounit-时间间隔-所有单位",link:"#_4-10-chronounit-时间间隔-所有单位",children:[]},{level:2,title:"5.1 概述",slug:"_5-1-概述",link:"#_5-1-概述",children:[]},{level:2,title:"5.2 Integer类",slug:"_5-2-integer类",link:"#_5-2-integer类",children:[]},{level:2,title:"5.3 装箱与拆箱",slug:"_5-3-装箱与拆箱",link:"#_5-3-装箱与拆箱",children:[]},{level:2,title:"5.4 自动装箱与自动拆箱",slug:"_5-4-自动装箱与自动拆箱",link:"#_5-4-自动装箱与自动拆箱",children:[]},{level:2,title:"5.5 基本类型与字符串之间的转换",slug:"_5-5-基本类型与字符串之间的转换",link:"#_5-5-基本类型与字符串之间的转换",children:[{level:3,title:"基本类型转换为String",slug:"基本类型转换为string",link:"#基本类型转换为string",children:[]},{level:3,title:"String转换成基本类型",slug:"string转换成基本类型",link:"#string转换成基本类型",children:[]}]},{level:2,title:"5.6 底层原理",slug:"_5-6-底层原理",link:"#_5-6-底层原理",children:[]},{level:2,title:"练习一：",slug:"练习一",link:"#练习一",children:[]},{level:2,title:"练习二：",slug:"练习二",link:"#练习二",children:[]},{level:2,title:"练习三：",slug:"练习三",link:"#练习三",children:[]},{level:2,title:"练习四：",slug:"练习四",link:"#练习四",children:[]},{level:2,title:"练习五：",slug:"练习五",link:"#练习五",children:[]}],path:"/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html",pathLocale:"/",extraFields:'---\ntitle: 常用API\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n常用API\n\n\x3c!-- more --\x3e\n# day04【常用API】\n\n## 今日内容\n\n* JDK7时间相关类\n* JDK8时间相关类\n* 包装类\n* 综合练习\n* Collection集合\n\n## 教学目标\n\n- [ ] 能够使用日期类输出当前日期\n- [ ] 能够使用将日期格式化为字符串的方法\n- [ ] 能够使用将字符串转换成日期的方法\n- [ ] 能够说出8种基本类型对应的包装类名称\n- [ ] 能够说出自动装箱、自动拆箱的概念\n- [ ] 能够将字符串转换为对应的基本类型\n- [ ] 能够将基本类型转换为对应的字符串\n- [ ] 能够完成课题上讲解的所有练习\n\n# 第一章 Date类\n\n## 1.1 Date概述\n\njava.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数\n\n- `public Date()`：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n\n## 1.2 Date常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n- `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n- `public void setTime(long time)` 把方法参数给定的毫秒值设置给日期对象\n\n示例代码\n\n```java\npublic class DateDemo02 {\n    public static void main(String[] args) {\n        //创建日期对象\n        Date d = new Date();\n        \n        //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n        //System.out.println(d.getTime());\n        //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n\n        //public void setTime(long time):设置时间，给的是毫秒值\n        //long time = 1000*60*60;\n        long time = System.currentTimeMillis();\n        d.setTime(time);\n\n        System.out.println(d);\n    }\n}\n```\n\n> 小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。\n\n# 第二章 SimpleDateFormat类\n\n`java.text.SimpleDateFormat` 是日期/时间格式化类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n- **格式化**：按照指定的格式，把Date对象转换为String对象。\n- **解析**：按照指定的格式，把String对象转换为Date对象。\n\n## 2.1 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n- `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。\n\n## 2.2 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义 |\n| ---------------------- | ---- |\n| y                      | 年   |\n| M                      | 月   |\n| d                      | 日   |\n| H                      | 时   |\n| m                      | 分   |\n| s                      | 秒   |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。\n\n## 2.3 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n  ```java\n  package com.itheima.a01jdk7datedemo;\n  \n  import java.text.ParseException;\n  import java.text.SimpleDateFormat;\n  import java.util.Date;\n  \n  public class A03_SimpleDateFormatDemo1 {\n      public static void main(String[] args) throws ParseException {\n          /*\n              public simpleDateFormat() 默认格式\n              public simpleDateFormat(String pattern) 指定格式\n              public final string format(Date date) 格式化(日期对象 ->字符串)\n              public Date parse(string source) 解析(字符串 ->日期对象)\n          */\n  \n          //1.定义一个字符串表示时间\n          String str = "2023-11-11 11:11:11";\n          //2.利用空参构造创建simpleDateFormat对象\n          // 细节:\n          //创建对象的格式要跟字符串的格式完全一致\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n          Date date = sdf.parse(str);\n          //3.打印结果\n          System.out.println(date.getTime());//1699672271000\n  \n  \n      }\n  \n      private static void method1() {\n          //1.利用空参构造创建simpleDateFormat对象，默认格式\n          SimpleDateFormat sdf1 = new SimpleDateFormat();\n          Date d1 = new Date(0L);\n          String str1 = sdf1.format(d1);\n          System.out.println(str1);//1970/1/1 上午8:00\n  \n          //2.利用带参构造创建simpleDateFormat对象，指定格式\n          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");\n          String str2 = sdf2.format(d1);\n          System.out.println(str2);//1970年01月01日 08:00:00\n  \n          //课堂练习:yyyy年MM月dd日 时:分:秒 星期\n      }\n  }\n  \n  ```\n\n> 小结：DateFormat可以将Date对象和字符串相互转换。\n\n## 2.4 练习1(初恋女友的出生日期)\n\n```java\n/*\n     假设，你初恋的出生年月日为:2000-11-11\n     请用字符串表示这个数据，并将其转换为:2000年11月11日\n\n     创建一个Date对象表示2000年11月11日\n     创建一个SimpleDateFormat对象，并定义格式为年月日把时间变成:2000年11月11日\n*/\n\n//1.可以通过2000-11-11进行解析，解析成一个Date对象\nString str = "2000-11-11";\n//2.解析\nSimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");\nDate date = sdf1.parse(str);\n//3.格式化\nSimpleDateFormat sdf2 = new SimpleDateFormat("yyyy年MM月dd日");\nString result = sdf2.format(date);\nSystem.out.println(result);\n```\n\n## 2.5 练习2(秒杀活动)\n\n```java\n/* 需求:\n            秒杀活动开始时间:2023年11月11日 0:0:0(毫秒值)\n            秒杀活动结束时间:2023年11月11日 0:10:0(毫秒值)\n\n            小贾下单并付款的时间为:2023年11月11日 0:01:0\n            小皮下单并付款的时间为:2023年11月11日 0:11:0\n            用代码说明这两位同学有没有参加上秒杀活动?\n         */\n\n//1.定义字符串表示三个时间\nString startstr = "2023年11月11日 0:0:0";\nString endstr = "2023年11月11日 0:10:0";\nString orderstr = "2023年11月11日 0:01:00";\n//2.解析上面的三个时间，得到Date对象\nSimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");\nDate startDate = sdf.parse(startstr);\nDate endDate = sdf.parse(endstr);\nDate orderDate = sdf.parse(orderstr);\n\n//3.得到三个时间的毫秒值\nlong startTime = startDate.getTime();\nlong endTime = endDate.getTime();\nlong orderTime = orderDate.getTime();\n\n//4.判断\nif (orderTime >= startTime && orderTime <= endTime) {\n    System.out.println("参加秒杀活动成功");\n} else {\n    System.out.println("参加秒杀活动失败");\n}\n```\n\n# 第三章 Calendar类\n\n## 3.1 概述\n\n- java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。\n- 有两种方式可以获取GregorianCalendar对象：\n  - 直接创建GregorianCalendar对象；\n  - 通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象【本次课使用】\n\n## 3.2 常用方法\n\n| 方法名                                | 说明                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| public static Calendar getInstance()  | 获取一个它的子类GregorianCalendar对象。                      |\n| public int get(int field)             | 获取某个字段的值。field参数表示获取哪个字段的值，<br />可以使用Calender中定义的常量来表示：<br />Calendar.YEAR : 年<br />Calendar.MONTH ：月<br />Calendar.DAY_OF_MONTH：月中的日期<br />Calendar.HOUR：小时<br />Calendar.MINUTE：分钟<br />Calendar.SECOND：秒<br />Calendar.DAY_OF_WEEK：星期 |\n| public void set(int field,int value)  | 设置某个字段的值                                             |\n| public void add(int field,int amount) | 为某个字段增加/减少指定的值                                  |\n\n## 3.3 get方法示例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //1.获取一个GregorianCalendar对象\n        Calendar instance = Calendar.getInstance();//获取子类对象\n\n        //2.打印子类对象\n        System.out.println(instance);\n\n        //3.获取属性\n        int year = instance.get(Calendar.YEAR);\n        int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11\n        int day = instance.get(Calendar.DAY_OF_MONTH);\n\n        int hour = instance.get(Calendar.HOUR);\n        int minute = instance.get(Calendar.MINUTE);\n        int second = instance.get(Calendar.SECOND);\n\n        int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示："星期日","星期一","星期二",...,"星期六"\n\n        System.out.println(year + "年" + month + "月" + day + "日" + \n                           \thour + ":" + minute + ":" + second);\n        System.out.println(getWeek(week));\n\n    }\n\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n\n```\n\n## 3.4 set方法示例：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //设置属性——set(int field,int value):\n\t\tCalendar c1 = Calendar.getInstance();//获取当前日期\n\n\t\t//计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)\n\t\tc1.set(Calendar.YEAR, 1998);\n\t\tc1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值\n\t\tc1.set(Calendar.DAY_OF_MONTH, 18);\n\n\t\tint w = c1.get(Calendar.DAY_OF_WEEK);\n\t\tSystem.out.println("班长出生那天是：" + getWeek(w));\n\n        \n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n```\n\n\n\n## 3.5 add方法示例：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //计算200天以后是哪年哪月哪日，星期几？\n\t\tCalendar c2 = Calendar.getInstance();//获取当前日期\n        c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200\n\n        int y = c2.get(Calendar.YEAR);\n        int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份\n        int d = c2.get(Calendar.DAY_OF_MONTH);\n\n        int wk = c2.get(Calendar.DAY_OF_WEEK);\n        System.out.println("200天后是：" + y + "年" + m + "月" + d + "日" + getWeek(wk));\n\n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}\n```\n\n# 第四章 JDK8时间相关类\n\n| JDK8时间类类名    | 作用                   |\n| ----------------- | ---------------------- |\n| ZoneId            | 时区                   |\n| Instant           | 时间戳                 |\n| ZoneDateTime      | 带时区的时间           |\n| DateTimeFormatter | 用于时间的格式化和解析 |\n| LocalDate         | 年、月、日             |\n| LocalTime         | 时、分、秒             |\n| LocalDateTime     | 年、月、日、时、分、秒 |\n| Duration          | 时间间隔（秒，纳，秒） |\n| Period            | 时间间隔（年，月，日） |\n| ChronoUnit        | 时间间隔（所有单位）   |\n\n## 4.1  ZoneId 时区\n\n```java\n/*\n        static Set<string> getAvailableZoneIds() 获取Java中支持的所有时区\n        static ZoneId systemDefault() 获取系统默认时区\n        static Zoneld of(string zoneld) 获取一个指定时区\n        */\n\n//1.获取所有的时区名称\nSet<String> zoneIds = ZoneId.getAvailableZoneIds();\nSystem.out.println(zoneIds.size());//600\nSystem.out.println(zoneIds);// Asia/Shanghai\n\n//2.获取当前系统的默认时区\nZoneId zoneId = ZoneId.systemDefault();\nSystem.out.println(zoneId);//Asia/Shanghai\n\n//3.获取指定的时区\nZoneId zoneId1 = ZoneId.of("Asia/Pontianak");\nSystem.out.println(zoneId1);//Asia/Pontianak\n```\n\n## 4.2  Instant 时间戳\n\n```java\n/*\n            static Instant now() 获取当前时间的Instant对象(标准时间)\n            static Instant ofXxxx(long epochMilli) 根据(秒/毫秒/纳秒)获取Instant对象\n            ZonedDateTime atZone(ZoneIdzone) 指定时区\n            boolean isxxx(Instant otherInstant) 判断系列的方法\n            Instant minusXxx(long millisToSubtract) 减少时间系列的方法\n            Instant plusXxx(long millisToSubtract) 增加时间系列的方法\n        */\n//1.获取当前时间的Instant对象(标准时间)\nInstant now = Instant.now();\nSystem.out.println(now);\n\n//2.根据(秒/毫秒/纳秒)获取Instant对象\nInstant instant1 = Instant.ofEpochMilli(0L);\nSystem.out.println(instant1);//1970-01-01T00:00:00z\n\nInstant instant2 = Instant.ofEpochSecond(1L);\nSystem.out.println(instant2);//1970-01-01T00:00:01Z\n\nInstant instant3 = Instant.ofEpochSecond(1L, 1000000000L);\nSystem.out.println(instant3);//1970-01-01T00:00:027\n\n//3. 指定时区\nZonedDateTime time = Instant.now().atZone(ZoneId.of("Asia/Shanghai"));\nSystem.out.println(time);\n\n\n//4.isXxx 判断\nInstant instant4=Instant.ofEpochMilli(0L);\nInstant instant5 =Instant.ofEpochMilli(1000L);\n\n//5.用于时间的判断\n//isBefore:判断调用者代表的时间是否在参数表示时间的前面\nboolean result1=instant4.isBefore(instant5);\nSystem.out.println(result1);//true\n\n//isAfter:判断调用者代表的时间是否在参数表示时间的后面\nboolean result2 = instant4.isAfter(instant5);\nSystem.out.println(result2);//false\n\n//6.Instant minusXxx(long millisToSubtract) 减少时间系列的方法\nInstant instant6 =Instant.ofEpochMilli(3000L);\nSystem.out.println(instant6);//1970-01-01T00:00:03Z\n\nInstant instant7 =instant6.minusSeconds(1);\nSystem.out.println(instant7);//1970-01-01T00:00:02Z\n\n```\n\n\n\n## 4.3 ZoneDateTime  带时区的时间\n\n```java\n/*\n            static ZonedDateTime now() 获取当前时间的ZonedDateTime对象\n            static ZonedDateTime ofXxxx(。。。) 获取指定时间的ZonedDateTime对象\n            ZonedDateTime withXxx(时间) 修改时间系列的方法\n            ZonedDateTime minusXxx(时间) 减少时间系列的方法\n            ZonedDateTime plusXxx(时间) 增加时间系列的方法\n         */\n//1.获取当前时间对象(带时区)\nZonedDateTime now = ZonedDateTime.now();\nSystem.out.println(now);\n\n//2.获取指定的时间对象(带时区)1/年月日时分秒纳秒方式指定\nZonedDateTime time1 = ZonedDateTime.of(2023, 10, 1,\n                                       11, 12, 12, 0, ZoneId.of("Asia/Shanghai"));\nSystem.out.println(time1);\n\n//通过Instant + 时区的方式指定获取时间对象\nInstant instant = Instant.ofEpochMilli(0L);\nZoneId zoneId = ZoneId.of("Asia/Shanghai");\nZonedDateTime time2 = ZonedDateTime.ofInstant(instant, zoneId);\nSystem.out.println(time2);\n\n\n//3.withXxx 修改时间系列的方法\nZonedDateTime time3 = time2.withYear(2000);\nSystem.out.println(time3);\n\n//4. 减少时间\nZonedDateTime time4 = time3.minusYears(1);\nSystem.out.println(time4);\n\n//5.增加时间\nZonedDateTime time5 = time4.plusYears(1);\nSystem.out.println(time5);\n```\n\n\n\n## 4.4DateTimeFormatter   用于时间的格式化和解析\n\n```java\n/*\n            static DateTimeFormatter ofPattern(格式) 获取格式对象\n            String format(时间对象) 按照指定方式格式化\n        */\n//获取时间对象\nZonedDateTime time = Instant.now().atZone(ZoneId.of("Asia/Shanghai"));\n\n// 解析/格式化器\nDateTimeFormatter dtf1=DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm;ss EE a");\n// 格式化\nSystem.out.println(dtf1.format(time));\n```\n\n\n\n## 4.5LocalDate  年、月、日\n\n```java\n//1.获取当前时间的日历对象(包含 年月日)\nLocalDate nowDate = LocalDate.now();\n//System.out.println("今天的日期:" + nowDate);\n//2.获取指定的时间的日历对象\nLocalDate ldDate = LocalDate.of(2023, 1, 1);\nSystem.out.println("指定日期:" + ldDate);\n\nSystem.out.println("=============================");\n\n//3.get系列方法获取日历中的每一个属性值//获取年\nint year = ldDate.getYear();\nSystem.out.println("year: " + year);\n//获取月//方式一:\nMonth m = ldDate.getMonth();\nSystem.out.println(m);\nSystem.out.println(m.getValue());\n\n//方式二:\nint month = ldDate.getMonthValue();\nSystem.out.println("month: " + month);\n\n\n//获取日\nint day = ldDate.getDayOfMonth();\nSystem.out.println("day:" + day);\n\n//获取一年的第几天\nint dayofYear = ldDate.getDayOfYear();\nSystem.out.println("dayOfYear:" + dayofYear);\n\n//获取星期\nDayOfWeek dayOfWeek = ldDate.getDayOfWeek();\nSystem.out.println(dayOfWeek);\nSystem.out.println(dayOfWeek.getValue());\n\n//is开头的方法表示判断\nSystem.out.println(ldDate.isBefore(ldDate));\nSystem.out.println(ldDate.isAfter(ldDate));\n\n//with开头的方法表示修改，只能修改年月日\nLocalDate withLocalDate = ldDate.withYear(2000);\nSystem.out.println(withLocalDate);\n\n//minus开头的方法表示减少，只能减少年月日\nLocalDate minusLocalDate = ldDate.minusYears(1);\nSystem.out.println(minusLocalDate);\n\n\n//plus开头的方法表示增加，只能增加年月日\nLocalDate plusLocalDate = ldDate.plusDays(1);\nSystem.out.println(plusLocalDate);\n\n//-------------\n// 判断今天是否是你的生日\nLocalDate birDate = LocalDate.of(2000, 1, 1);\nLocalDate nowDate1 = LocalDate.now();\n\nMonthDay birMd = MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());\nMonthDay nowMd = MonthDay.from(nowDate1);\n\nSystem.out.println("今天是你的生日吗? " + birMd.equals(nowMd));//今天是你的生日吗?\n```\n\n\n\n## 4.6 LocalTime  时、分、秒\n\n```java\n// 获取本地时间的日历对象。(包含 时分秒)\nLocalTime nowTime = LocalTime.now();\nSystem.out.println("今天的时间:" + nowTime);\n\nint hour = nowTime.getHour();//时\nSystem.out.println("hour: " + hour);\n\nint minute = nowTime.getMinute();//分\nSystem.out.println("minute: " + minute);\n\nint second = nowTime.getSecond();//秒\nSystem.out.println("second:" + second);\n\nint nano = nowTime.getNano();//纳秒\nSystem.out.println("nano:" + nano);\nSystem.out.println("------------------------------------");\nSystem.out.println(LocalTime.of(8, 20));//时分\nSystem.out.println(LocalTime.of(8, 20, 30));//时分秒\nSystem.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒\nLocalTime mTime = LocalTime.of(8, 20, 30, 150);\n\n//is系列的方法\nSystem.out.println(nowTime.isBefore(mTime));\nSystem.out.println(nowTime.isAfter(mTime));\n\n//with系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.withHour(10));\n\n//plus系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.plusHours(10));\n```\n\n\n\n## 4.7 LocalDateTime  年、月、日、时、分、秒\n\n```java\n// 当前时间的的日历对象(包含年月日时分秒)\nLocalDateTime nowDateTime = LocalDateTime.now();\n\nSystem.out.println("今天是:" + nowDateTime);//今天是：\nSystem.out.println(nowDateTime.getYear());//年\nSystem.out.println(nowDateTime.getMonthValue());//月\nSystem.out.println(nowDateTime.getDayOfMonth());//日\nSystem.out.println(nowDateTime.getHour());//时\nSystem.out.println(nowDateTime.getMinute());//分\nSystem.out.println(nowDateTime.getSecond());//秒\nSystem.out.println(nowDateTime.getNano());//纳秒\n// 日:当年的第几天\nSystem.out.println("dayofYear:" + nowDateTime.getDayOfYear());\n//星期\nSystem.out.println(nowDateTime.getDayOfWeek());\nSystem.out.println(nowDateTime.getDayOfWeek().getValue());\n//月份\nSystem.out.println(nowDateTime.getMonth());\nSystem.out.println(nowDateTime.getMonth().getValue());\n\nLocalDate ld = nowDateTime.toLocalDate();\nSystem.out.println(ld);\n\nLocalTime lt = nowDateTime.toLocalTime();\nSystem.out.println(lt.getHour());\nSystem.out.println(lt.getMinute());\nSystem.out.println(lt.getSecond());\n```\n\n\n\n## 4.8 Duration  时间间隔（秒，纳，秒）\n\n```java\n// 本地日期时间对象。\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n\n// 出生的日期时间对象\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1, 0, 0, 0);\nSystem.out.println(birthDate);\n\nDuration duration = Duration.between(birthDate, today);//第二个参数减第一个参数\nSystem.out.println("相差的时间间隔对象:" + duration);\n\nSystem.out.println("============================================");\nSystem.out.println(duration.toDays());//两个时间差的天数\nSystem.out.println(duration.toHours());//两个时间差的小时数\nSystem.out.println(duration.toMinutes());//两个时间差的分钟数\nSystem.out.println(duration.toMillis());//两个时间差的毫秒数\nSystem.out.println(duration.toNanos());//两个时间差的纳秒数\n```\n\n\n\n## 4.9 Period  时间间隔（年，月，日）\n\n```java\n// 当前本地 年月日\nLocalDate today = LocalDate.now();\nSystem.out.println(today);\n\n// 生日的 年月日\nLocalDate birthDate = LocalDate.of(2000, 1, 1);\nSystem.out.println(birthDate);\n\nPeriod period = Period.between(birthDate, today);//第二个参数减第一个参数\n\nSystem.out.println("相差的时间间隔对象:" + period);\nSystem.out.println(period.getYears());\nSystem.out.println(period.getMonths());\nSystem.out.println(period.getDays());\n\nSystem.out.println(period.toTotalMonths());\n```\n\n\n\n## 4.10 ChronoUnit  时间间隔（所有单位）\n\n```java\n// 当前时间\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n// 生日时间\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1,0, 0, 0);\nSystem.out.println(birthDate);\n\nSystem.out.println("相差的年数:" + ChronoUnit.YEARS.between(birthDate, today));\nSystem.out.println("相差的月数:" + ChronoUnit.MONTHS.between(birthDate, today));\nSystem.out.println("相差的周数:" + ChronoUnit.WEEKS.between(birthDate, today));\nSystem.out.println("相差的天数:" + ChronoUnit.DAYS.between(birthDate, today));\nSystem.out.println("相差的时数:" + ChronoUnit.HOURS.between(birthDate, today));\nSystem.out.println("相差的分数:" + ChronoUnit.MINUTES.between(birthDate, today));\nSystem.out.println("相差的秒数:" + ChronoUnit.SECONDS.between(birthDate, today));\nSystem.out.println("相差的毫秒数:" + ChronoUnit.MILLIS.between(birthDate, today));\nSystem.out.println("相差的微秒数:" + ChronoUnit.MICROS.between(birthDate, today));\nSystem.out.println("相差的纳秒数:" + ChronoUnit.NANOS.between(birthDate, today));\nSystem.out.println("相差的半天数:" + ChronoUnit.HALF_DAYS.between(birthDate, today));\nSystem.out.println("相差的十年数:" + ChronoUnit.DECADES.between(birthDate, today));\nSystem.out.println("相差的世纪(百年)数:" + ChronoUnit.CENTURIES.between(birthDate, today));\nSystem.out.println("相差的千年数:" + ChronoUnit.MILLENNIA.between(birthDate, today));\nSystem.out.println("相差的纪元数:" + ChronoUnit.ERAS.between(birthDate, today));\n```\n\n# 第五章  包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型 | 对应的包装类（位于java.lang包中） |\n| -------- | --------------------------------- |\n| byte     | Byte                              |\n| short    | Short                             |\n| int      | **Integer**                       |\n| long     | Long                              |\n| float    | Float                             |\n| double   | Double                            |\n| char     | **Character**                     |\n| boolean  | Boolean                           |\n\n## 5.2 Integer类\n\n- Integer类概述\n\n  包装一个对象中的原始类型 int 的值\n\n- Integer类构造方法及静态方法\n\n| 方法名                                  | 说明                                   |\n| --------------------------------------- | -------------------------------------- |\n| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)     |\n| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)  |\n| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例 |\n| public static Integer valueOf(String s) | 返回保存指定String值的 Integer 对象    |\n| static string tobinarystring(int i)     | 得到二进制                             |\n| static string tooctalstring(int i)      | 得到八进制                             |\n| static string toHexstring(int i)        | 得到十六进制                           |\n| static int parseInt(string s)           | 将字符串类型的整数转成int类型的整数    |\n\n- 示例代码\n\n```java\n//public Integer(int value)：根据 int 值创建 Integer 对象(过时)\nInteger i1 = new Integer(100);\nSystem.out.println(i1);\n\n//public Integer(String s)：根据 String 值创建 Integer 对象(过时)\nInteger i2 = new Integer("100");\n//Integer i2 = new Integer("abc"); //NumberFormatException\nSystem.out.println(i2);\nSystem.out.println("--------");\n\n//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\nInteger i3 = Integer.valueOf(100);\nSystem.out.println(i3);\n\n//public static Integer valueOf(String s)：返回保存指定String值的Integer对象 \nInteger i4 = Integer.valueOf("100");\nSystem.out.println(i4);\n```\n\n```java\n/*\n            public static string tobinarystring(int i) 得到二进制\n            public static string tooctalstring(int i) 得到八进制\n            public static string toHexstring(int i) 得到十六进制\n            public static int parseInt(string s) 将字符串类型的整数转成int类型的整数\n */\n\n//1.把整数转成二进制，十六进制\nString str1 = Integer.toBinaryString(100);\nSystem.out.println(str1);//1100100\n\n//2.把整数转成八进制\nString str2 = Integer.toOctalString(100);\nSystem.out.println(str2);//144\n\n//3.把整数转成十六进制\nString str3 = Integer.toHexString(100);\nSystem.out.println(str3);//64\n\n//4.将字符串类型的整数转成int类型的整数\n//强类型语言:每种数据在java中都有各自的数据类型\n//在计算的时候，如果不是同一种数据类型，是无法直接计算的。\nint i = Integer.parseInt("123");\nSystem.out.println(i);\nSystem.out.println(i + 1);//124\n//细节1:\n//在类型转换的时候，括号中的参数只能是数字不能是其他，否则代码会报错\n//细节2:\n//8种包装类当中，除了Character都有对应的parseXxx的方法，进行类型转换\nString str = "true";\nboolean b = Boolean.parseBoolean(str);\nSystem.out.println(b);\n```\n\n## 5.3 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n- **装箱**：从基本类型转换为对应的包装类对象。\n- **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值----\x3e包装对象\n\n```java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n```\n\n包装对象----\x3e基本数值\n\n```java\nint num = i.intValue();\n```\n\n## 5.4 自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.5 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n- 转换方式\n- 方式一：直接在数字后加一个空字符串\n- 方式二：通过String类静态方法valueOf()\n- 示例代码\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //int --- String\n        int number = 100;\n        //方式1\n        String s1 = number + "";\n        System.out.println(s1);\n        //方式2\n        //public static String valueOf(int i)\n        String s2 = String.valueOf(number);\n        System.out.println(s2);\n        System.out.println("--------");\n    }\n}\n```\n\n### String转换成基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- **`public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。**\n- **`public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。**\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n- 转换方式\n  - 方式一：先将字符串数字转成Integer，再调用valueOf()方法\n  - 方式二：通过Integer静态方法parseInt()进行转换\n- 示例代码\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //String --- int\n        String s = "100";\n        //方式1：String --- Integer --- int\n        Integer i = Integer.valueOf(s);\n        //public int intValue()\n        int x = i.intValue();\n        System.out.println(x);\n        //方式2\n        //public static int parseInt(String s)\n        int y = Integer.parseInt(s);\n        System.out.println(y);\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n\n## 5.6 底层原理\n\n建议：获取Integer对象的时候不要自己new，而是采取直接赋值或者静态方法valueOf的方式\n\n因为在实际开发中，-128~127之间的数据，用的比较多。如果每次使用都是new对象，那么太浪费内存了。\n\n所以，提前把这个范围之内的每一个数据都创建好对象，如果要用到了不会创建新的，而是返回已经创建好的对象。\n\n```java\n//1.利用构造方法获取Integer的对象(JDK5以前的方式)\n/*Integer i1 = new Integer(1);\n        Integer i2 = new Integer("1");\n        System.out.println(i1);\n        System.out.println(i2);*/\n\n//2.利用静态方法获取Integer的对象(JDK5以前的方式)\nInteger i3 = Integer.valueOf(123);\nInteger i4 = Integer.valueOf("123");\nInteger i5 = Integer.valueOf("123", 8);\n\nSystem.out.println(i3);\nSystem.out.println(i4);\nSystem.out.println(i5);\n\n//3.这两种方式获取对象的区别(掌握)\n//底层原理：\n//因为在实际开发中，-128~127之间的数据，用的比较多。\n//如果每次使用都是new对象，那么太浪费内存了\n//所以，提前把这个范围之内的每一个数据都创建好对象\n//如果要用到了不会创建新的，而是返回已经创建好的对象。\nInteger i6 = Integer.valueOf(127);\nInteger i7 = Integer.valueOf(127);\nSystem.out.println(i6 == i7);//true\n\nInteger i8 = Integer.valueOf(128);\nInteger i9 = Integer.valueOf(128);\nSystem.out.println(i8 == i9);//false\n\n//因为看到了new关键字，在Java中，每一次new都是创建了一个新的对象\n//所以下面的两个对象都是new出来，地址值不一样。\n/*Integer i10 = new Integer(127);\n        Integer i11 = new Integer(127);\n        System.out.println(i10 == i11);\n\n        Integer i12 = new Integer(128);\n        Integer i13 = new Integer(128);\n        System.out.println(i12 == i13);*/\n```\n\n# 第六章：算法小题\n\n## 练习一：\n\n需求：\n\n​\t键盘录入一些1~10日之间的整数，并添加到集合中。直到集合中所有数据和超过200为止。\n\n代码示例：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        /*\n            键盘录入一些1~10日之间的整数，并添加到集合中。直到集合中所有数据和超过200为止。\n        */\n        //1.创建一个集合用来添加整数\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.键盘录入数据添加到集合中\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.println("请输入一个整数");\n            String numStr = sc.nextLine();\n            int num = Integer.parseInt(numStr);//先把异常数据先进行过滤\n            if (num < 1 || num > 100){\n                System.out.println("当前数字不在1~100的范围当中，请重新输入");\n                continue;\n            }\n            //添加到集合中//细节:\n            //num:基本数据类型\n            //集合里面的数据是Integer\n            //在添加数据的时候触发了自动装箱\n            list.add(num);\n            //统计集合中所有的数据和\n            int sum = getSum(list);\n            //对sum进行判断\n            if(sum > 200){\n            System.out.println("集合中所有的数据和已经满足要求");\n            break;\n        }\n    }\n\n}\n\n\n    private static int getSum(ArrayList<Integer> list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            //i :索引\n            //list.get(i);\n            int num = list.get(i);\n            sum = sum + num;//+=\n        }\n        return sum;\n    }\n}\n\n```\n\n## 练习二：\n\n需求：\n\n​\t自己实现parseInt方法的效果，将字符串形式的数据转成整数。要求:字符串中只能是数字不能有其他字符最少一位，最多10位日不能开头\n\n代码示例：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /*\n            自己实现parseInt方法的效果，将字符串形式的数据转成整数。要求:\n            字符串中只能是数字不能有其他字符最少一位，最多10位日不能开头\n        */\n\n        //1.定义一个字符串\n        String str = "123";\n        //2.校验字符串\n        //习惯:会先把异常数据进行过滤，剩下来就是正常的数据。\n        if (!str.matches("[1-9]\\\\d{0,9}")) {\n            //错误的数据\n            System.out.println("数据格式有误");\n        } else {\n            //正确的数据\n            System.out.println("数据格式正确");\n            //3.定义一个变量表示最终的结果\n            int number = 0;\n            //4.遍历字符串得到里面的每一个字符\n            for (int i = 0; i < str.length(); i++) {\n                int c = str.charAt(i) - \'0\';//把每一位数字放到number当中\n                number = number * 10 + c;\n            }\n            System.out.println(number);\n            System.out.println(number + 1);\n        }\n    }\n}\n```\n\n## 练习三：\n\n需求：\n\n​\t定义一个方法自己实现toBinaryString方法的效果，将一个十进制整数转成字符串表示的二进制\n\n代码示例：\n\n```java\npackage com.itheima.a04test;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*\n\n            定义一个方法自己实现toBinaryString方法的效果，将一个十进制整数转成字符串表示的二进制\n\n         */\n    }\n\n\n    public static String tobinarystring(int number) {//6\n        //核心逻辑:\n        //不断的去除以2，得到余数，一直到商为日就结束。\n        //还需要把余数倒着拼接起来\n\n        //定义一个StringBuilder用来拼接余数\n        StringBuilder sb = new StringBuilder();\n        //利用循环不断的除以2获取余数\n        while (true) {\n            if (number == 0) {\n                break;\n            }\n            //获取余数 %\n            int remaindar = number % 2;//倒着拼接\n            sb.insert(0, remaindar);\n            //除以2 /\n            number = number / 2;\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n## 练习四：\n\n需求：\n\n​\t请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成\n\n代码示例：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) throws ParseException {\n        //请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成\n        //JDK7\n        //规则:只要对时间进行计算或者判断，都需要先获取当前时间的毫秒值\n        //1.计算出生年月日的毫秒值\n        String birthday = "2000年1月1日";\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");\n        Date date = sdf.parse(birthday);\n        long birthdayTime = date.getTime();\n        //2.获取当前时间的毫秒值\n        long todayTime = System.currentTimeMillis();\n        //3.计算间隔多少天\n        long time = todayTime - birthdayTime;\n        System.out.println(time / 1000 / 60 / 60 / 24);\n\n\n        //JDK8\n        LocalDate ld1 = LocalDate.of(2000, 1, 1);\n        LocalDate ld2 = LocalDate.now();\n        long days = ChronoUnit.DAYS.between(ld1, ld2);\n        System.out.println(days);\n    }\n}\n```\n\n## 练习五：\n\n需求：\n\n​\t判断任意的一个年份是闰年还是平年要求:用JDK7和JDK8两种方式判断提示:二月有29天是闰年一年有366天是闰年\n\n代码示例：\n\n```java\npublic class Test5 {\n    public static void main(String[] args) {\n        /*\n            判断任意的一个年份是闰年还是平年要求:用JDK7和JDK8两种方式判断提示:\n            二月有29天是闰年一年有366天是闰年\n        */\n\n        //jdk7\n        //我们可以把时间设置为2000年3月1日\n        Calendar c = Calendar.getInstance();\n        c.set(2000, 2, 1);\n        //月份的范围:0~11\n        //再把日历往前减一天\n        c.add(Calendar.DAY_OF_MONTH, -1);\n        //看当前的时间是28号还是29号?\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        System.out.println(day);\n\n\n        //jdk8\n        //月份的范围:1~12\n        //设定时间为2000年的3月1日\n        LocalDate ld = LocalDate.of(2001, 3, 1);\n        //把时间往前减一天\n        LocalDate ld2 = ld.minusDays(1);\n        //获取这一天是一个月中的几号\n        int day2 = ld2.getDayOfMonth();\n        System.out.println(day2);\n\n        //true:闰年\n        //false:平年\n        System.out.println(ld.isLeapYear());\n    }\n}\n```\n\n'},{title:"常见的七种查找算法",headers:[{level:2,title:"1. 基本查找",slug:"_1-基本查找",link:"#_1-基本查找",children:[]},{level:2,title:"2. 二分查找",slug:"_2-二分查找",link:"#_2-二分查找",children:[]},{level:2,title:"3. 插值查找",slug:"_3-插值查找",link:"#_3-插值查找",children:[]},{level:2,title:"4. 斐波那契查找",slug:"_4-斐波那契查找",link:"#_4-斐波那契查找",children:[]},{level:2,title:"5. 分块查找",slug:"_5-分块查找",link:"#_5-分块查找",children:[]},{level:2,title:"6. 哈希查找",slug:"_6-哈希查找",link:"#_6-哈希查找",children:[]},{level:2,title:"7. 树表查找",slug:"_7-树表查找",link:"#_7-树表查找",children:[]},{level:2,title:"1. 冒泡排序",slug:"_1-冒泡排序",link:"#_1-冒泡排序",children:[{level:3,title:"1.1 算法步骤",slug:"_1-1-算法步骤",link:"#_1-1-算法步骤",children:[]},{level:3,title:"1.2 动图演示",slug:"_1-2-动图演示",link:"#_1-2-动图演示",children:[]},{level:3,title:"1.3 代码示例",slug:"_1-3-代码示例",link:"#_1-3-代码示例",children:[]}]},{level:2,title:"2. 选择排序",slug:"_2-选择排序",link:"#_2-选择排序",children:[{level:3,title:"2.1 算法步骤",slug:"_2-1-算法步骤",link:"#_2-1-算法步骤",children:[]},{level:3,title:"2.2 动图演示",slug:"_2-2-动图演示",link:"#_2-2-动图演示",children:[]}]},{level:2,title:"3. 插入排序",slug:"_3-插入排序",link:"#_3-插入排序",children:[{level:3,title:"3.1 算法步骤",slug:"_3-1-算法步骤",link:"#_3-1-算法步骤",children:[]},{level:3,title:"3.2 动图演示",slug:"_3-2-动图演示",link:"#_3-2-动图演示",children:[]}]},{level:2,title:"4. 快速排序",slug:"_4-快速排序",link:"#_4-快速排序",children:[{level:3,title:"4.1 算法步骤",slug:"_4-1-算法步骤",link:"#_4-1-算法步骤",children:[]},{level:3,title:"4.2 动图演示",slug:"_4-2-动图演示",link:"#_4-2-动图演示",children:[]}]}],path:"/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html",pathLocale:"/",extraFields:'---\ntitle: 常见的七种查找算法\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n常见的七种查找算法：\n\n\x3c!-- more --\x3e\n# 常见的七种查找算法：\n\n​\t数据结构是数据存储的方式，算法是数据计算的方式。所以在开发中，算法和数据结构息息相关。今天的讲义中会涉及部分数据结构的专业名词，如果各位铁粉有疑惑，可以先看一下哥们后面录制的数据结构，再回头看算法。\n\n## 1. 基本查找 \n\n​\t也叫做顺序查找\n\n​        说明：顺序查找适合于存储结构为数组或者链表。\n\n**基本思想**：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。\n\n示例代码：\n\n```java\npublic class A01_BasicSearchDemo1 {\n    public static void main(String[] args) {\n        //基本查找/顺序查找\n        //核心：\n        //从0索引开始挨个往后查找\n\n        //需求：定义一个方法利用基本查找，查询某个元素是否存在\n        //数据如下：{131, 127, 147, 81, 103, 23, 7, 79}\n\n\n        int[] arr = {131, 127, 147, 81, 103, 23, 7, 79};\n        int number = 82;\n        System.out.println(basicSearch(arr, number));\n\n    }\n\n    //参数：\n    //一：数组\n    //二：要查找的元素\n\n    //返回值：\n    //元素是否存在\n    public static boolean basicSearch(int[] arr, int number){\n        //利用基本查找来查找number在数组中是否存在\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == number){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 2. 二分查找\n\n​\t也叫做折半查找\n\n说明：元素必须是有序的，从小到大，或者从大到小都是可以的。\n\n如果是无序的，也可以先进行排序。但是排序之后，会改变原有数据的顺序，查找出来元素位置跟原来的元素可能是不一样的，所以排序之后再查找只能判断当前数据是否在容器当中，返回的索引无实际的意义。\n\n　　**基本思想**：也称为是折半查找，属于有序查找算法。用给定值先与中间结点比较。比较完之后有三种情况：\n\n* 相等\n\n  说明找到了\n\n* 要查找的数据比中间节点小\n\n  说明要查找的数字在中间节点左边\n\n* 要查找的数据比中间节点大\n\n  说明要查找的数字在中间节点右边\n\n代码示例：\n\n```java\npackage com.itheima.search;\n\npublic class A02_BinarySearchDemo1 {\n    public static void main(String[] args) {\n        //二分查找/折半查找\n        //核心：\n        //每次排除一半的查找范围\n\n        //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引\n        //数据如下：{7, 23, 79, 81, 103, 127, 131, 147}\n\n        int[] arr = {7, 23, 79, 81, 103, 127, 131, 147};\n        System.out.println(binarySearch(arr, 150));\n    }\n\n    public static int binarySearch(int[] arr, int number){\n        //1.定义两个变量记录要查找的范围\n        int min = 0;\n        int max = arr.length - 1;\n\n        //2.利用循环不断的去找要查找的数据\n        while(true){\n            if(min > max){\n                return -1;\n            }\n            //3.找到min和max的中间位置\n            int mid = (min + max) / 2;\n            //4.拿着mid指向的元素跟要查找的元素进行比较\n            if(arr[mid] > number){\n                //4.1 number在mid的左边\n                //min不变，max = mid - 1；\n                max = mid - 1;\n            }else if(arr[mid] < number){\n                //4.2 number在mid的右边\n                //max不变，min = mid + 1;\n                min = mid + 1;\n            }else{\n                //4.3 number跟mid指向的元素一样\n                //找到了\n                return mid;\n            }\n\n        }\n    }\n}\n```\n\n## 3. 插值查找\n\n在介绍插值查找之前，先考虑一个问题：\n\n​\t为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？\n\n其实就是因为方便，简单，但是如果我能在二分查找的基础上，让中间的mid点，尽可能靠近想要查找的元素，那不就能提高查找的效率了吗？\n\n二分查找中查找点计算如下：\n\n　　mid=(low+high)/2, 即mid=low+1/2*(high-low);\n\n我们可以将查找的点改进为如下：\n\n　　mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，\n\n这样，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。\n\n　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。\n\n**细节：**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。\n\n代码跟二分查找类似，只要修改一下mid的计算方式即可。\n\n\n\n## 4. 斐波那契查找\n\n在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。\n\n　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。\n\n　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。\n\n　　在数学中有一个非常有名的数学规律：斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….\n\n（从第三个数开始，后边每一个数都是前两个数的和）。\n\n然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。\n\n![img](https://img-blog.csdn.net/20150323100632467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbmJvMjAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) \n\n基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。\n\n斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式即可\n\n代码示例：\n\n```java\npublic class FeiBoSearchDemo {\n    public static int maxSize = 20;\n\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 10, 89, 1000, 1234};\n        System.out.println(search(arr, 1234));\n    }\n\n    public static int[] getFeiBo() {\n        int[] arr = new int[maxSize];\n        arr[0] = 1;\n        arr[1] = 1;\n        for (int i = 2; i < maxSize; i++) {\n            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        return arr;\n    }\n\n    public static int search(int[] arr, int key) {\n        int low = 0;\n        int high = arr.length - 1;\n        //表示斐波那契数分割数的下标值\n        int index = 0;\n        int mid = 0;\n        //调用斐波那契数列\n        int[] f = getFeiBo();\n        //获取斐波那契分割数值的下标\n        while (high > (f[index] - 1)) {\n            index++;\n        }\n        //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐\n        int[] temp = Arrays.copyOf(arr, f[index]);\n        //实际需要使用arr数组的最后一个数来填充不足的部分\n        for (int i = high + 1; i < temp.length; i++) {\n            temp[i] = arr[high];\n        }\n        //使用while循环处理，找到key值\n        while (low <= high) {\n            mid = low + f[index - 1] - 1;\n            if (key < temp[mid]) {//向数组的前面部分进行查找\n                high = mid - 1;\n                /*\n                  对k--进行理解\n                  1.全部元素=前面的元素+后面的元素\n                  2.f[k]=k[k-1]+f[k-2]\n                  因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3]\n                  即在f[k-1]的前面继续查找k--\n                  即下次循环,mid=f[k-1-1]-1\n                 */\n                index--;\n            } else if (key > temp[mid]) {//向数组的后面的部分进行查找\n                low = mid + 1;\n                index -= 2;\n            } else {//找到了\n                //需要确定返回的是哪个下标\n                if (mid <= high) {\n                    return mid;\n                } else {\n                    return high;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n## 5. 分块查找 \n\n当数据表中的数据元素很多时，可以采用分块查找。\n\n汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找\n\n分块查找适用于数据较多，但是数据不会发生变化的情况，如果需要一边添加一边查找，建议使用哈希查找\n\n分块查找的过程：\n\n1. 需要把数据分成N多小块，块与块之间不能有数据重复的交集。\n2. 给每一块创建对象单独存储到数组当中\n3. 查找数据的时候，先在数组查，当前数据属于哪一块\n4. 再到这一块中顺序查找\n\n代码示例：\n\n```java\npackage com.itheima.search;\n\npublic class A03_BlockSearchDemo {\n    public static void main(String[] args) {\n        /*\n            分块查找\n            核心思想：\n                块内无序，块间有序\n            实现步骤：\n                1.创建数组blockArr存放每一个块对象的信息\n                2.先查找blockArr确定要查找的数据属于哪一块\n                3.再单独遍历这一块数据即可\n        */\n        int[] arr = {16, 5, 9, 12,21, 18,\n                     32, 23, 37, 26, 45, 34,\n                     50, 48, 61, 52, 73, 66};\n\n        //创建三个块的对象\n        Block b1 = new Block(21,0,5);\n        Block b2 = new Block(45,6,11);\n        Block b3 = new Block(73,12,17);\n\n        //定义数组用来管理三个块的对象（索引表）\n        Block[] blockArr = {b1,b2,b3};\n\n        //定义一个变量用来记录要查找的元素\n        int number = 37;\n\n        //调用方法，传递索引表，数组，要查找的元素\n        int index = getIndex(blockArr,arr,number);\n\n        //打印一下\n        System.out.println(index);\n\n\n\n    }\n\n    //利用分块查找的原理，查询number的索引\n    private static int getIndex(Block[] blockArr, int[] arr, int number) {\n        //1.确定number是在那一块当中\n        int indexBlock = findIndexBlock(blockArr, number);\n\n        if(indexBlock == -1){\n            //表示number不在数组当中\n            return -1;\n        }\n\n        //2.获取这一块的起始索引和结束索引   --- 30\n        // Block b1 = new Block(21,0,5);   ----  0\n        // Block b2 = new Block(45,6,11);  ----  1\n        // Block b3 = new Block(73,12,17); ----  2\n        int startIndex = blockArr[indexBlock].getStartIndex();\n        int endIndex = blockArr[indexBlock].getEndIndex();\n\n        //3.遍历\n        for (int i = startIndex; i <= endIndex; i++) {\n            if(arr[i] == number){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n    //定义一个方法，用来确定number在哪一块当中\n    public static int findIndexBlock(Block[] blockArr,int number){ //100\n\n\n        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的\n        for (int i = 0; i < blockArr.length; i++) {\n            if(number <= blockArr[i].getMax()){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n\n}\n\nclass Block{\n    private int max;//最大值\n    private int startIndex;//起始索引\n    private int endIndex;//结束索引\n\n\n    public Block() {\n    }\n\n    public Block(int max, int startIndex, int endIndex) {\n        this.max = max;\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * 获取\n     * @return max\n     */\n    public int getMax() {\n        return max;\n    }\n\n    /**\n     * 设置\n     * @param max\n     */\n    public void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * 获取\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * 设置\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * 获取\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * 设置\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    public String toString() {\n        return "Block{max = " + max + ", startIndex = " + startIndex + ", endIndex = " + endIndex + "}";\n    }\n}\n```\n\n## 6. 哈希查找\n\n哈希查找是分块查找的进阶版，适用于数据一边添加一边查找的情况。\n\n一般是数组 + 链表的结合体或者是数组+链表 + 红黑树的结合体\n\n在课程中，为了让大家方便理解，所以规定：\n\n- 数组的0索引处存储1~100\n- 数组的1索引处存储101~200\n- 数组的2索引处存储201~300\n- 以此类推\n\n但是实际上，我们一般不会采取这种方式，因为这种方式容易导致一块区域添加的元素过多，导致效率偏低。\n\n更多的是先计算出当前数据的哈希值，用哈希值跟数组的长度进行计算，计算出应存入的位置，再挂在数组的后面形成链表，如果挂的元素太多而且数组长度过长，我们也会把链表转化为红黑树，进一步提高效率。\n\n具体的过程，大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了哈希表的数据结构。全程采取动画形式讲解，让大家一目了然。\n\n在此不多做阐述。\n\n ![Snipaste_2022-09-05_21-36-50](img/Snipaste_2022-09-05_21-36-50.png)\n\n## 7. 树表查找 \n\n本知识点涉及到数据结构：树。\n\n建议先看一下后面阿玮讲解的数据结构，再回头理解。\n\n基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 \n\n　　二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree），具有下列性质的二叉树：\n\n　　1）若任意节点左子树上所有的数据，均小于本身；\n\n　　2）若任意节点右子树上所有的数据，均大于本身；\n\n　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。\n\n​        不同形态的二叉查找树如下图所示：\n\n ![20180226113852869](img\\20180226113852869.png) \n\n\n\n　　基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。\n\n具体细节大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了树数据结构。全程采取动画形式讲解，让大家一目了然。\n\n在此不多做阐述。\n\n​\t不管是二叉查找树，还是平衡二叉树，还是红黑树，查找的性能都比较高\n\n\n\n\n\n\n\n# 十大排序算法：\n\n## 1. 冒泡排序\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。\n\n它重复的遍历过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。\n\n这个算法的名字由来是因为越大的元素会经由交换慢慢"浮"到最后面。\n\n当然，大家可以按照从大到小的方式进行排列。\n\n### 1.1 算法步骤\n\n1. 相邻的元素两两比较，大的放右边，小的放左边\n2. 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推\n3. 如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以\n\n### 1.2 动图演示\n\n![冒泡](img/冒泡.gif)\n\n### 1.3 代码示例\n\n```java\npublic class A01_BubbleDemo {\n    public static void main(String[] args) {\n        /*\n            冒泡排序：\n            核心思想：\n            1，相邻的元素两两比较，大的放右边，小的放左边。\n            2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。\n            3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。\n        */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n        //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5\n\n        //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮\n        for (int i = 0; i < arr.length - 1; i++) {\n            //内循环：每一轮中我如何比较数据并找到当前的最大值\n            //-1：为了防止索引越界\n            //-i：提高效率，每一轮执行的次数应该比上一轮少一次。\n            for (int j = 0; j < arr.length - 1 - i; j++) {\n                //i 依次表示数组中的每一个索引：0 1 2 3 4\n                if(arr[j] > arr[j + 1]){\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n\n        printArr(arr);\n\n\n\n\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n}\n```\n\n\n\n## 2. 选择排序\n\n### 2.1 算法步骤\n\n1. 从0索引开始，跟后面的元素一一比较\n2. 小的放前面，大的放后面\n3. 第一次循环结束后，最小的数据已经确定\n4. 第二次循环从1索引开始以此类推\n5. 第三轮循环从2索引开始以此类推\n6. 第四轮循环从3索引开始以此类推。 \n\n### 2.2 动图演示\n\n![选择排序](img\\选择排序.gif)\n\n \n\n```java\npublic class A02_SelectionDemo {\n    public static void main(String[] args) {\n\n        /*\n            选择排序：\n                1，从0索引开始，跟后面的元素一一比较。\n                2，小的放前面，大的放后面。\n                3，第一次循环结束后，最小的数据已经确定。\n                4，第二次循环从1索引开始以此类推。\n\n         */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n\n        //2.利用选择排序让数组变成 1 2 3 4 5\n       /* //第一轮：\n        //从0索引开始，跟后面的元素一一比较。\n        for (int i = 0 + 1; i < arr.length; i++) {\n            //拿着0索引跟后面的数据进行比较\n            if(arr[0] > arr[i]){\n                int temp = arr[0];\n                arr[0] = arr[i];\n                arr[i] = temp;\n            }\n        }*/\n\n        //最终代码：\n        //外循环：几轮\n        //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换\n        for (int i = 0; i < arr.length -1; i++) {\n            //内循环：每一轮我要干什么事情？\n            //拿着i跟i后面的数据进行比较交换\n            for (int j = i + 1; j < arr.length; j++) {\n                if(arr[i] > arr[j]){\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n\n\n        printArr(arr);\n\n\n    }\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n\n}\n\n```\n\n\n\n## 3. 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过创建有序序列和无序序列，然后再遍历无序序列得到里面每一个数字，把每一个数字插入到有序序列中正确的位置。\n\n插入排序在插入的时候，有优化算法，在遍历有序序列找正确位置时，可以采取二分查找\n\n### 3.1 算法步骤\n\n将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n\n遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\n\nN的范围：0~最大索引\n\n### 3.2 动图演示\n\n![插入排序](img\\插入排序.gif)\n\n```java\npackage com.itheima.mysort;\n\n\npublic class A03_InsertDemo {\n    public static void main(String[] args) {\n        /*\n            插入排序：\n                将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n                遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\n                N的范围：0~最大索引\n\n        */\n        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};\n\n        //1.找到无序的哪一组数组是从哪个索引开始的。  2\n        int startIndex = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] > arr[i + 1]){\n                startIndex = i + 1;\n                break;\n            }\n        }\n\n        //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素\n        for (int i = startIndex; i < arr.length; i++) {\n            //问题：如何把遍历到的数据，插入到前面有序的这一组当中\n\n            //记录当前要插入数据的索引\n            int j = i;\n\n            while(j > 0 && arr[j] < arr[j - 1]){\n                //交换位置\n                int temp = arr[j];\n                arr[j] = arr[j - 1];\n                arr[j - 1] = temp;\n                j--;\n            }\n\n        }\n        printArr(arr);\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n\n}\n\n```\n\n\n\n\n\n## 4. 快速排序 \n\n快速排序是由东尼·霍尔所发展的一种排序算法。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。\n\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！\n\n它是处理大数据最快的排序算法之一了。\n\n### 4.1 算法步骤\n\n1. 从数列中挑出一个元素，一般都是左边第一个数字，称为 "基准数";\n2. 创建两个指针，一个从前往后走，一个从后往前走。\n3. 先执行后面的指针，找出第一个比基准数小的数字\n4. 再执行前面的指针，找出第一个比基准数大的数字\n5. 交换两个指针指向的数字\n6. 直到两个指针相遇\n7. 将基准数跟指针指向位置的数字交换位置，称之为：基准数归位。\n8. 第一轮结束之后，基准数左边的数字都是比基准数小的，基准数右边的数字都是比基准数大的。\n9. 把基准数左边看做一个序列，把基准数右边看做一个序列，按照刚刚的规则递归排序\n\n### 4.2 动图演示\n\n![快速排序](img\\快速排序.gif)\n\n ```java\npackage com.itheima.mysort;\n\nimport java.util.Arrays;\n\npublic class A05_QuickSortDemo {\n    public static void main(String[] args) {\n        System.out.println(Integer.MAX_VALUE);\n        System.out.println(Integer.MIN_VALUE);\n      /*\n        快速排序：\n            第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。\n            比基准数小的全部在左边，比基准数大的全部在右边。\n            后面以此类推。\n      */\n\n        int[] arr = {1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8};\n\n\n        //int[] arr = new int[1000000];\n\n       /* Random r = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = r.nextInt();\n        }*/\n\n\n        long start = System.currentTimeMillis();\n        quickSort(arr, 0, arr.length - 1);\n        long end = System.currentTimeMillis();\n\n        System.out.println(end - start);//149\n\n        System.out.println(Arrays.toString(arr));\n        //课堂练习：\n        //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率\n        //得到一个结论：快速排序真的非常快。\n\n       /* for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }*/\n\n    }\n\n\n    /*\n     *   参数一：我们要排序的数组\n     *   参数二：要排序数组的起始索引\n     *   参数三：要排序数组的结束索引\n     * */\n    public static void quickSort(int[] arr, int i, int j) {\n        //定义两个变量记录要查找的范围\n        int start = i;\n        int end = j;\n\n        if(start > end){\n            //递归的出口\n            return;\n        }\n\n\n\n        //记录基准数\n        int baseNumber = arr[i];\n        //利用循环找到要交换的数字\n        while(start != end){\n            //利用end，从后往前开始找，找比基准数小的数字\n            //int[] arr = {1, 6, 2, 7, 9, 3, 4, 5, 10, 8};\n            while(true){\n                if(end <= start || arr[end] < baseNumber){\n                    break;\n                }\n                end--;\n            }\n            System.out.println(end);\n            //利用start，从前往后找，找比基准数大的数字\n            while(true){\n                if(end <= start || arr[start] > baseNumber){\n                    break;\n                }\n                start++;\n            }\n\n\n\n            //把end和start指向的元素进行交换\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n        }\n\n        //当start和end指向了同一个元素的时候，那么上面的循环就会结束\n        //表示已经找到了基准数在数组中应存入的位置\n        //基准数归位\n        //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换\n        int temp = arr[i];\n        arr[i] = arr[start];\n        arr[start] = temp;\n\n        //确定6左边的范围，重复刚刚所做的事情\n        quickSort(arr,i,start - 1);\n        //确定6右边的范围，重复刚刚所做的事情\n        quickSort(arr,start + 1,j);\n\n    }\n}\n ```\n\n\n\n其他排序方式待更新~'},{title:"Collection集合",headers:[{level:2,title:"1.Collection集合",slug:"_1-collection集合",link:"#_1-collection集合",children:[{level:3,title:"1.1数组和集合的区别【理解】",slug:"_1-1数组和集合的区别【理解】",link:"#_1-1数组和集合的区别【理解】",children:[]},{level:3,title:"1.2集合类体系结构【理解】",slug:"_1-2集合类体系结构【理解】",link:"#_1-2集合类体系结构【理解】",children:[]},{level:3,title:"1.3Collection 集合概述和使用【应用】",slug:"_1-3collection-集合概述和使用【应用】",link:"#_1-3collection-集合概述和使用【应用】",children:[]},{level:3,title:"1.4Collection集合的遍历",slug:"_1-4collection集合的遍历",link:"#_1-4collection集合的遍历",children:[]}]},{level:2,title:"2.List集合",slug:"_2-list集合",link:"#_2-list集合",children:[{level:3,title:"2.1List集合的概述和特点【记忆】",slug:"_2-1list集合的概述和特点【记忆】",link:"#_2-1list集合的概述和特点【记忆】",children:[]},{level:3,title:"2.2List集合的特有方法【应用】",slug:"_2-2list集合的特有方法【应用】",link:"#_2-2list集合的特有方法【应用】",children:[]},{level:3,title:"2.3List集合的五种遍历方式【应用】",slug:"_2-3list集合的五种遍历方式【应用】",link:"#_2-3list集合的五种遍历方式【应用】",children:[]},{level:3,title:"2.4 细节点注意：",slug:"_2-4-细节点注意",link:"#_2-4-细节点注意",children:[]}]},{level:2,title:"3.数据结构",slug:"_3-数据结构",link:"#_3-数据结构",children:[{level:3,title:"3.1数据结构之栈和队列【记忆】",slug:"_3-1数据结构之栈和队列【记忆】",link:"#_3-1数据结构之栈和队列【记忆】",children:[]},{level:3,title:"3.2数据结构之数组和链表【记忆】",slug:"_3-2数据结构之数组和链表【记忆】",link:"#_3-2数据结构之数组和链表【记忆】",children:[]}]},{level:2,title:"4.List集合的实现类",slug:"_4-list集合的实现类",link:"#_4-list集合的实现类",children:[{level:3,title:"4.1List集合子类的特点【记忆】",slug:"_4-1list集合子类的特点【记忆】",link:"#_4-1list集合子类的特点【记忆】",children:[]},{level:3,title:"4.2LinkedList集合的特有功能【应用】",slug:"_4-2linkedlist集合的特有功能【应用】",link:"#_4-2linkedlist集合的特有功能【应用】",children:[]}]},{level:2,title:"5. 源码分析",slug:"_5-源码分析",link:"#_5-源码分析",children:[{level:3,title:"5.1 ArrayList源码分析：",slug:"_5-1-arraylist源码分析",link:"#_5-1-arraylist源码分析",children:[]},{level:3,title:"5.2 LinkedList源码分析：",slug:"_5-2-linkedlist源码分析",link:"#_5-2-linkedlist源码分析",children:[]},{level:3,title:"5.3 迭代器源码分析：",slug:"_5-3-迭代器源码分析",link:"#_5-3-迭代器源码分析",children:[]}]}],path:"/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html",pathLocale:"/",extraFields:'---\ntitle: Collection集合\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nCollection集合\n\n\x3c!-- more --\x3e\n## 1.Collection集合\n\n### 1.1数组和集合的区别【理解】\n\n- 相同点\n\n  都是容器,可以存储多个数据\n\n- 不同点\n\n  - 数组的长度是不可变的,集合的长度是可变的\n\n  - 数组可以存基本数据类型和引用数据类型\n\n    集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类\n\n### 1.2集合类体系结构【理解】\n\n![01_集合类体系结构图](/img/01_%E9%9B%86%E5%90%88%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)\n\n### 1.3Collection 集合概述和使用【应用】\n\n- Collection集合概述\n\n  - 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\n  - JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现\n\n- 创建Collection集合的对象\n\n  - 多态的方式\n  - 具体的实现类ArrayList\n\n- Collection集合常用方法\n\n  | 方法名                     | 说明                               |\n  | :------------------------- | :--------------------------------- |\n  | `boolean add(E e)`           | 添加元素                           |\n  | `boolean remove(Object o)`   | 从集合中移除指定的元素             |\n  | `boolean removeIf(Object o)` | 根据条件进行移除                   |\n  | `void   clear() `            | 清空集合中的元素                   |\n  | `boolean contains(Object o)` | 判断集合中是否存在指定的元素       |\n  | `boolean isEmpty() `         | 判断集合是否为空                   |\n  | `int   size() `              | 集合的长度，也就是集合中元素的个数 |\n\n### 1.4Collection集合的遍历\n\n#### 1.4.1 迭代器遍历\n\n- 迭代器介绍\n\n  - 迭代器,集合的专用遍历方式\n  - `Iterator<E> iterator()`: 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到\n\n- Iterator中的常用方法\n\n  ​\t`boolean hasNext()`: 判断当前位置是否有元素可以被取出\n  \t`E next()`: 获取当前位置的元素,将迭代器对象移向下一个索引位置\n\n- Collection集合的遍历\n\n  ```java\n  public class IteratorDemo1 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Collection<String> c = new ArrayList<>();\n  \n          //添加元素\n          c.add("hello");\n          c.add("world");\n          c.add("java");\n          c.add("javaee");\n  \n          //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n          Iterator<String> it = c.iterator();\n  \n          //用while循环改进元素的判断和获取\n          while (it.hasNext()) {\n              String s = it.next();\n              System.out.println(s);\n          }\n      }\n  }\n  ```\n\n- 迭代器中删除的方法\n\n  ​\tvoid remove(): 删除迭代器对象当前指向的元素\n\n  ```java\n  public class IteratorDemo2 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n  \n          Iterator<String> it = list.iterator();\n          while(it.hasNext()){\n              String s = it.next();\n              if("b".equals(s)){\n                  //指向谁,那么此时就删除谁.\n                  it.remove();\n              }\n          }\n          System.out.println(list);\n      }\n  }\n  ```\n\n#### 1.4.2 增强for\n\n- 介绍\n\n  - 它是JDK5之后出现的,其内部原理是一个Iterator迭代器\n  - 实现Iterable接口的类才可以使用迭代器和增强for\n  - 简化数组和Collection集合的遍历\n\n- 格式\n\n  ​\tfor(集合/数组中元素的数据类型 变量名 :  集合/数组名) {\n\n  ​\t\t// 已经将当前遍历到的元素封装到变量中了,直接使用变量即可\n\n  ​\t}\n\n- 代码\n\n  ```java\n  public class MyCollectonDemo1 {\n      public static void main(String[] args) {\n          ArrayList<String> list =  new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n          list.add("e");\n          list.add("f");\n  \n          //1,数据类型一定是集合或者数组中元素的类型\n          //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素\n          //3,list就是要遍历的集合或者数组\n          for(String str : list){\n              System.out.println(str);\n          }\n      }\n  }\n  ```\n\n- 细节点注意：\n\n1.报错NoSuchElementException       \n\n 2.迭代器遍历完毕，指针不会复位        \n\n3.循环中只能用一次next方法        \n\n4.迭代器遍历时，不能用集合的方法进行增加或者删除\n\n```java\npublic class A04_CollectionDemo4 {\n    public static void main(String[] args) {\n      /*\n        迭代器的细节注意点：\n            1.报错NoSuchElementException\n            2.迭代器遍历完毕，指针不会复位\n            3.循环中只能用一次next方法\n            4.迭代器遍历时，不能用集合的方法进行增加或者删除\n            \t暂时当做一个结论先行记忆，在今天我们会讲解源码详细的再来分析。\n                如果我实在要删除：那么可以用迭代器提供的remove方法进行删除。\n                如果我要添加，暂时没有办法。(只是暂时)\n       */\n\n        //1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add("aaa");\n        coll.add("bbb");\n        coll.add("ccc");\n        coll.add("ddd");\n\n        //2.获取迭代器对象\n        //迭代器就好比是一个箭头，默认指向集合的0索引处\n        Iterator<String> it = coll.iterator();\n        //3.利用循环不断的去获取集合中的每一个元素\n        while(it.hasNext()){\n            //4.next方法的两件事情：获取元素并移动指针\n            String str = it.next();\n            System.out.println(str);\n        }\n\n        //当上面循环结束之后，迭代器的指针已经指向了最后没有元素的位置\n        //System.out.println(it.next());//NoSuchElementException\n\n        //迭代器遍历完毕，指针不会复位\n        System.out.println(it.hasNext());\n\n        //如果我们要继续第二次遍历集合，只能再次获取一个新的迭代器对象\n        Iterator<String> it2 = coll.iterator();\n        while(it2.hasNext()){\n            String str = it2.next();\n            System.out.println(str);\n        }\n    }\n}\n```\n\n#### 1.4.3 lambda表达式\n\n​\t利用forEach方法，再结合lambda表达式的方式进行遍历\n\n```java\npublic class A07_CollectionDemo7 {\n    public static void main(String[] args) {\n       /* \n        lambda表达式遍历：\n                default void forEach(Consumer<? super T> action):\n        */\n\n        //1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add("zhangsan");\n        coll.add("lisi");\n        coll.add("wangwu");\n        //2.利用匿名内部类的形式\n        //底层原理：\n        //其实也会自己遍历集合，依次得到每一个元素\n        //把得到的每一个元素，传递给下面的accept方法\n        //s依次表示集合中的每一个数据\n       /* coll.forEach(new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        });*/\n\n        //lambda表达式\n        coll.forEach(s -> System.out.println(s));\n    }\n}\n```\n\n## 2.List集合\n\n### 2.1List集合的概述和特点【记忆】\n\n- List集合的概述\n  - 有序集合,这里的有序指的是存取顺序\n  - 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素\n  - 与Set集合不同,列表通常允许重复的元素\n- List集合的特点\n  - 存取有序\n  - 可以重复\n  - 有索引\n\n### 2.2List集合的特有方法【应用】\n\n- 方法介绍\n\n  | 方法名                          | 描述                                   |\n  | ------------------------------- | -------------------------------------- |\n  | void add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |\n  | E remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |\n  | E set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |\n  | E get(int   index)              | 返回指定索引处的元素                   |\n\n- 示例代码\n\n  ```java\n  public class MyListDemo {\n      public static void main(String[] args) {\n          List<String> list = new ArrayList<>();\n          list.add("aaa");\n          list.add("bbb");\n          list.add("ccc");\n          //method1(list);\n          //method2(list);\n          //method3(list);\n          //method4(list);\n      }\n  \n      private static void method4(List<String> list) {\n          //        E get(int index)\t\t返回指定索引处的元素\n          String s = list.get(0);\n          System.out.println(s);\n      }\n  \n      private static void method3(List<String> list) {\n          //        E set(int index,E element)\t修改指定索引处的元素，返回被修改的元素\n          //被替换的那个元素,在集合中就不存在了.\n          String result = list.set(0, "qqq");\n          System.out.println(result);\n          System.out.println(list);\n      }\n  \n      private static void method2(List<String> list) {\n          //        E remove(int index)\t\t删除指定索引处的元素，返回被删除的元素\n          //在List集合中有两个删除的方法\n          //第一个 删除指定的元素,返回值表示当前元素是否删除成功\n          //第二个 删除指定索引的元素,返回值表示实际删除的元素\n          String s = list.remove(0);\n          System.out.println(s);\n          System.out.println(list);\n      }\n  \n      private static void method1(List<String> list) {\n          //        void add(int index,E element)\t在此集合中的指定位置插入指定的元素\n          //原来位置上的元素往后挪一个索引.\n          list.add(0,"qqq");\n          System.out.println(list);\n      }\n  }\n  ```\n\n### 2.3List集合的五种遍历方式【应用】\n\n1. 迭代器\n2. 列表迭代器\n3. 增强for\n4. Lambda表达式\n5. 普通for循环\n\n代码示例：\n\n```java\n//创建集合并添加元素\nList<String> list = new ArrayList<>();\nlist.add("aaa");\nlist.add("bbb");\nlist.add("ccc");\n\n//1.迭代器\n/*Iterator<String> it = list.iterator();\n     while(it.hasNext()){\n        String str = it.next();\n        System.out.println(str);\n}*/\n\n\n//2.增强for\n//下面的变量s，其实就是一个第三方的变量而已。\n//在循环的过程中，依次表示集合中的每一个元素\n/* for (String s : list) {\n       System.out.println(s);\n   }*/\n\n//3.Lambda表达式\n//forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素\n//并把每一个元素传递给下面的accept方法\n//accept方法的形参s，依次表示集合中的每一个元素\n//list.forEach(s->System.out.println(s) );\n\n\n//4.普通for循环\n//size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素\n/*for (int i = 0; i < list.size(); i++) {\n            //i:依次表示集合中的每一个索引\n            String s = list.get(i);\n            System.out.println(s);\n        }*/\n\n// 5.列表迭代器\n//获取一个列表迭代器的对象，里面的指针默认也是指向0索引的\n\n//额外添加了一个方法：在遍历的过程中，可以添加元素\nListIterator<String> it = list.listIterator();\nwhile(it.hasNext()){\n    String str = it.next();\n    if("bbb".equals(str)){\n        //qqq\n        it.add("qqq");\n    }\n}\nSystem.out.println(list);\n```\n\n### 2.4 细节点注意：\n\nList系列集合中的两个删除的方法\n\n```java\n1.直接删除元素\n2.通过索引进行删除\n```\n代码示例:\n\n```java\n//List系列集合中的两个删除的方法\n//1.直接删除元素\n//2.通过索引进行删除\n\n//1.创建集合并添加元素\nList<Integer> list = new ArrayList<>();\n\nlist.add(1);\nlist.add(2);\nlist.add(3);\n\n\n//2.删除元素\n//请问：此时删除的是1这个元素，还是1索引上的元素？\n//为什么？\n//因为在调用方法的时候，如果方法出现了重载现象\n//优先调用，实参跟形参类型一致的那个方法。\n\n//list.remove(1);\n\n\n//手动装箱，手动把基本数据类型的1，变成Integer类型\nInteger i = Integer.valueOf(1);\n\nlist.remove(i);\n\nSystem.out.println(list);\n\n```\n\n## 3.数据结构\n\n### 3.1数据结构之栈和队列【记忆】\n\n- 栈结构\n\n  ​\t先进后出\n\n- 队列结构\n\n  ​\t先进先出\n\n### 3.2数据结构之数组和链表【记忆】\n\n- 数组结构\n\n  ​\t查询快、增删慢\n\n- 队列结构\n\n  ​\t查询慢、增删快\n\n## 4.List集合的实现类\n\n### 4.1List集合子类的特点【记忆】\n\n- ArrayList集合\n\n  ​\t底层是数组结构实现，查询快、增删慢\n\n- LinkedList集合\n\n  ​\t底层是链表结构实现，查询慢、增删快\n\n### 4.2LinkedList集合的特有功能【应用】\n\n- 特有方法\n\n  | 方法名                    | 说明                             |\n  | ------------------------- | -------------------------------- |\n  | public void addFirst(E e) | 在该列表开头插入指定的元素       |\n  | public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |\n  | public E getFirst()       | 返回此列表中的第一个元素         |\n  | public   E getLast()      | 返回此列表中的最后一个元素       |\n  | public E removeFirst()    | 从此列表中删除并返回第一个元素   |\n  | public   E removeLast()   | 从此列表中删除并返回最后一个元素 |\n\n- 示例代码\n\n  ```java\n  public class MyLinkedListDemo4 {\n      public static void main(String[] args) {\n          LinkedList<String> list = new LinkedList<>();\n          list.add("aaa");\n          list.add("bbb");\n          list.add("ccc");\n  //        public void addFirst(E e)\t在该列表开头插入指定的元素\n          //method1(list);\n  \n  //        public void addLast(E e)\t将指定的元素追加到此列表的末尾\n          //method2(list);\n  \n  //        public E getFirst()\t\t返回此列表中的第一个元素\n  //        public E getLast()\t\t返回此列表中的最后一个元素\n          //method3(list);\n  \n  //        public E removeFirst()\t\t从此列表中删除并返回第一个元素\n  //        public E removeLast()\t\t从此列表中删除并返回最后一个元素\n          //method4(list);\n        \n      }\n  \n      private static void method4(LinkedList<String> list) {\n          String first = list.removeFirst();\n          System.out.println(first);\n  \n          String last = list.removeLast();\n          System.out.println(last);\n  \n          System.out.println(list);\n      }\n  \n      private static void method3(LinkedList<String> list) {\n          String first = list.getFirst();\n          String last = list.getLast();\n          System.out.println(first);\n          System.out.println(last);\n      }\n  \n      private static void method2(LinkedList<String> list) {\n          list.addLast("www");\n          System.out.println(list);\n      }\n  \n      private static void method1(LinkedList<String> list) {\n          list.addFirst("qqq");\n          System.out.println(list);\n      }\n  }\n  ```\n\n## 5. 源码分析\n\n### 5.1 ArrayList源码分析：\n\n核心步骤：\n\n1. 创建ArrayList对象的时候，他在底层先创建了一个长度为0的数组。\n\n   数组名字：elementDate，定义变量size。\n\n   size这个变量有两层含义：\n   ①：元素的个数，也就是集合的长度\n   ②：下一个元素的存入位置\n\n2. 添加元素，添加完毕后，size++\n\n扩容时机一：\n\n3. 当存满时候，会创建一个新的数组，新数组的长度，是原来的1.5倍，也就是长度为15.再把所有的元素，全拷贝到新数组中。如果继续添加数据，这个长度为15的数组也满了，那么下次还会继续扩容，还是1.5倍。\n\n扩容时机二：\n\n4. 一次性添加多个数据，扩容1.5倍不够，怎么办呀？\n\n   如果一次添加多个元素，1.5倍放不下，那么新创建数组的长度以实际为准。\n\n举个例子：\n在一开始，如果默认的长度为10的数组已经装满了，在装满的情况下，我一次性要添加100个数据很显然，10扩容1.5倍，变成15，还是不够，\n\n怎么办？\n\n此时新数组的长度，就以实际情况为准，就是110\n\n具体分析过程可以参见视频讲解。\n\n**添加一个元素时的扩容：**\n\n![第一次添加数据](img\\第一次添加数据.png)\n\n**添加多个元素时的扩容：**\n\n![第11次添加数据](img\\第11次添加数据.png)\n\n### 5.2 LinkedList源码分析：\n\n底层是双向链表结构\n\n核心步骤如下：\n\n1. 刚开始创建的时候，底层创建了两个变量：一个记录头结点first，一个记录尾结点last，默认为null\n2. 添加第一个元素时，底层创建一个结点对象，first和last都记录这个结点的地址值\n3. 添加第二个元素时，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，last会记录新结点的地址值\n\n具体分析过程可以参见视频讲解。\n\n![LinkedList源码分析](img\\LinkedList源码分析.png)\n\n### 5.3 迭代器源码分析：\n\n迭代器遍历相关的三个方法：\n\n* `Iterator<E> iterator() ` ：获取一个迭代器对象\n\n* `boolean hasNext()`       ：判断当前指向的位置是否有元素\n\n* `E next()`                ：获取当前指向的元素并移动指针\n\n\n![迭代器源码分析](img\\迭代器源码分析.png)\n\n'},{title:"泛型",headers:[{level:2,title:"1.泛型",slug:"_1-泛型",link:"#_1-泛型",children:[{level:3,title:"1.1泛型概述",slug:"_1-1泛型概述",link:"#_1-1泛型概述",children:[]}]},{level:2,title:"2.Set集合",slug:"_2-set集合",link:"#_2-set集合",children:[{level:3,title:"2.1Set集合概述和特点【应用】",slug:"_2-1set集合概述和特点【应用】",link:"#_2-1set集合概述和特点【应用】",children:[]},{level:3,title:"2.2Set集合的使用【应用】",slug:"_2-2set集合的使用【应用】",link:"#_2-2set集合的使用【应用】",children:[]}]},{level:2,title:"3.TreeSet集合",slug:"_3-treeset集合",link:"#_3-treeset集合",children:[{level:3,title:"3.1TreeSet集合概述和特点【应用】",slug:"_3-1treeset集合概述和特点【应用】",link:"#_3-1treeset集合概述和特点【应用】",children:[]},{level:3,title:"3.2TreeSet集合基本使用【应用】",slug:"_3-2treeset集合基本使用【应用】",link:"#_3-2treeset集合基本使用【应用】",children:[]},{level:3,title:"3.3自然排序Comparable的使用【应用】",slug:"_3-3自然排序comparable的使用【应用】",link:"#_3-3自然排序comparable的使用【应用】",children:[]},{level:3,title:"3.4比较器排序Comparator的使用【应用】",slug:"_3-4比较器排序comparator的使用【应用】",link:"#_3-4比较器排序comparator的使用【应用】",children:[]},{level:3,title:"3.5两种比较方式总结【理解】",slug:"_3-5两种比较方式总结【理解】",link:"#_3-5两种比较方式总结【理解】",children:[]}]},{level:2,title:"4.数据结构",slug:"_4-数据结构",link:"#_4-数据结构",children:[{level:3,title:"4.1二叉树【理解】",slug:"_4-1二叉树【理解】",link:"#_4-1二叉树【理解】",children:[]},{level:3,title:"4.2二叉查找树【理解】",slug:"_4-2二叉查找树【理解】",link:"#_4-2二叉查找树【理解】",children:[]},{level:3,title:"4.3平衡二叉树【理解】",slug:"_4-3平衡二叉树【理解】",link:"#_4-3平衡二叉树【理解】",children:[]},{level:3,title:"4.3红黑树【理解】",slug:"_4-3红黑树【理解】",link:"#_4-3红黑树【理解】",children:[]},{level:3,title:"5.1HashSet集合概述和特点【应用】",slug:"_5-1hashset集合概述和特点【应用】",link:"#_5-1hashset集合概述和特点【应用】",children:[]},{level:3,title:"5.2HashSet集合的基本应用【应用】",slug:"_5-2hashset集合的基本应用【应用】",link:"#_5-2hashset集合的基本应用【应用】",children:[]},{level:3,title:"5.3哈希值【理解】",slug:"_5-3哈希值【理解】",link:"#_5-3哈希值【理解】",children:[]},{level:3,title:"5.4哈希表结构【理解】",slug:"_5-4哈希表结构【理解】",link:"#_5-4哈希表结构【理解】",children:[]},{level:3,title:"5.5HashSet集合存储学生对象并遍历【应用】",slug:"_5-5hashset集合存储学生对象并遍历【应用】",link:"#_5-5hashset集合存储学生对象并遍历【应用】",children:[]}]}],path:"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html",pathLocale:"/",extraFields:'---\ntitle: 泛型\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n泛型\n\n\x3c!-- more --\x3e\n## 1.泛型\n\n### 1.1泛型概述\n\n- 泛型的介绍\n\n  ​\t泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制\n\n- 泛型的好处\n\n  1. 把运行时期的问题提前到了编译期间\n  2. 避免了强制类型转换\n\n- 泛型的定义格式\n\n  - `<类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>`\n  - `<类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>`\n\n## 2.Set集合\n\n### 2.1Set集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引,不能使用普通for循环遍历\n\n### 2.2Set集合的使用【应用】\n\n存储字符串并遍历\n\n```java\npublic class MySet1 {\n    public static void main(String[] args) {\n      \t//创建集合对象\n        Set<String> set = new TreeSet<>();\n      \t//添加元素\n        set.add("ccc");\n        set.add("aaa");\n        set.add("aaa");\n        set.add("bbb");\n\n//        for (int i = 0; i < set.size(); i++) {\n//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法\n//        }\n      \n      \t//遍历集合\n        Iterator<String> it = set.iterator();\n        while (it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("-----------------------------------");\n        for (String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## 3.TreeSet集合\n\n### 3.1TreeSet集合概述和特点【应用】\n\n+ 不可以存储重复元素\n+ 没有索引\n+ 可以将元素按照规则进行排序\n  + TreeSet()：根据其元素的自然排序进行排序\n  + TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n\n### 3.2TreeSet集合基本使用【应用】\n\n存储Integer类型的整数并遍历\n\n```java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n### 3.3自然排序Comparable的使用【应用】\n\n- 案例需求\n\n  - 存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  1. 使用空参构造创建TreeSet集合\n     + 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\n  2. 自定义的Student类实现Comparable接口\n     + 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\n  3. 重写接口中的compareTo方法\n     + 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照对象的年龄进行排序\n          //主要判断条件: 按照年龄从小到大排序\n          int result = this.age - o.age;\n          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序\n          result = result == 0 ? this.name.compareTo(o.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet2 {\n      public static void main(String[] args) {\n          //创建集合对象\n          TreeSet<Student> ts = new TreeSet<>();\n  \t    //创建学生对象\n          Student s1 = new Student("zhangsan",28);\n          Student s2 = new Student("lisi",27);\n          Student s3 = new Student("wangwu",29);\n          Student s4 = new Student("zhaoliu",28);\n          Student s5 = new Student("qianqi",30);\n  \t\t//把学生添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n          ts.add(s4);\n          ts.add(s5);\n  \t\t//遍历集合\n          for (Student student : ts) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 3.4比较器排序Comparator的使用【应用】\n\n- 案例需求\n\n  - 存储老师对象并遍历，创建TreeSet集合使用带参构造方法\n  - 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n- 实现步骤\n\n  - 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n  - 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n  - 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n- 代码实现\n\n  老师类\n\n  ```java\n  public class Teacher {\n      private String name;\n      private int age;\n\n      public Teacher() {\n      }\n\n      public Teacher(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Teacher{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class MyTreeSet4 {\n      public static void main(String[] args) {\n        \t//创建集合对象\n          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {\n              @Override\n              public int compare(Teacher o1, Teacher o2) {\n                  //o1表示现在要存入的那个元素\n                  //o2表示已经存入到集合中的元素\n                \n                  //主要条件\n                  int result = o1.getAge() - o2.getAge();\n                  //次要条件\n                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;\n                  return result;\n              }\n          });\n  \t\t//创建老师对象\n          Teacher t1 = new Teacher("zhangsan",23);\n          Teacher t2 = new Teacher("lisi",22);\n          Teacher t3 = new Teacher("wangwu",24);\n          Teacher t4 = new Teacher("zhaoliu",24);\n  \t\t//把老师添加到集合\n          ts.add(t1);\n          ts.add(t2);\n          ts.add(t3);\n          ts.add(t4);\n  \t\t//遍历集合\n          for (Teacher teacher : ts) {\n              System.out.println(teacher);\n          }\n      }\n  }\n  ```\n\n### 3.5两种比较方式总结【理解】\n\n+ 两种比较方式小结\n  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序\n  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\n  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\n+ 两种方式中关于返回值的规则\n  + 如果返回值为负数，表示当前存入的元素是较小值，存左边\n  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\n  + 如果返回值为正数，表示当前存入的元素是较大值，存右边\n\n## 4.数据结构\n\n### 4.1二叉树【理解】\n\n+ 二叉树的特点\n\n  + 二叉树中,任意一个节点的度要小于等于2\n    + 节点: 在树结构中,每一个元素称之为节点\n    + 度: 每一个节点的子节点数量称之为度\n\n+ 二叉树结构图\n\n  ![01_二叉树结构图](.\\img\\01_二叉树结构图.png)\n\n### 4.2二叉查找树【理解】\n\n+ 二叉查找树的特点\n\n  + 二叉查找树,又称二叉排序树或者二叉搜索树\n  + 每一个节点上最多有两个子节点\n  + 左子树上所有节点的值都小于根节点的值\n  + 右子树上所有节点的值都大于根节点的值\n\n+ 二叉查找树结构图\n\n  ![02_二叉查找树结构图](.\\img\\02_二叉查找树结构图.png)\n\n+ 二叉查找树和二叉树对比结构图\n\n  ![03_二叉查找树和二叉树对比结构图](.\\img\\03_二叉查找树和二叉树对比结构图.png)\n\n+ 二叉查找树添加节点规则\n\n  + 小的存左边\n  + 大的存右边\n  + 一样的不存\n\n  ![04_二叉查找树添加节点规则](.\\img\\04_二叉查找树添加节点规则.png)\n\n### 4.3平衡二叉树【理解】\n\n+ 平衡二叉树的特点\n\n  + 二叉树左右两个子树的高度差不超过1\n  + 任意节点的左右两个子树都是一颗平衡二叉树\n\n+ 平衡二叉树旋转\n\n  + 旋转触发时机\n\n    + 当添加一个节点之后,该树不再是一颗平衡二叉树\n\n  + 左旋\n\n    + 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点\n\n    ![05_平衡二叉树左旋01](.\\img\\05_平衡二叉树左旋01.png)\n\n    ![05_平衡二叉树左旋02](.\\img\\05_平衡二叉树左旋02.png)\n\n  + 右旋\n\n    + 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点\n\n      ![06_平衡二叉树右旋01](.\\img\\06_平衡二叉树右旋01.png)\n\n      ![06_平衡二叉树右旋02](.\\img\\06_平衡二叉树右旋02.png)\n\n+ 平衡二叉树和二叉查找树对比结构图\n\n  ![07_平衡二叉树和二叉查找树对比结构图](.\\img\\07_平衡二叉树和二叉查找树对比结构图.png)\n\n+ 平衡二叉树旋转的四种情况\n\n  + 左左\n\n    + 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行右旋即可\n\n      ![08_平衡二叉树左左](.\\img\\08_平衡二叉树左左.png)\n\n  + 左右\n\n    + 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋\n\n      ![09_平衡二叉树左右](.\\img\\09_平衡二叉树左右.png)\n\n  + 右右\n\n    + 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 直接对整体进行左旋即可\n\n      ![10_平衡二叉树右右](.\\img\\10_平衡二叉树右右.png)\n\n  + 右左\n\n    + 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡\n\n    + 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋\n\n      ![11_平衡二叉树右左](.\\img\\11_平衡二叉树右左.png)\n\n### 4.3红黑树【理解】\n\n- 红黑树的特点\n\n  - 平衡二叉B树\n  - 每一个节点可以是红或者黑\n  - 红黑树不是高度平衡的,它的平衡是通过"自己的红黑规则"进行实现的\n\n- 红黑树的红黑规则有哪些\n\n  1. 每一个节点或是红色的,或者是黑色的\n\n  2. 根节点必须是黑色\n\n  3. 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的\n\n  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)\n\n  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点\n\n     ![12_红黑树结构图](/img/12_%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png)\n\n- 红黑树添加节点的默认颜色\n\n  - 添加节点时,默认为红色,效率高\n\n    ![13_红黑树添加节点颜色](/img/13_%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png)\n\n- 红黑树添加节点后如何保持红黑规则\n\n  - 根节点位置\n    - 直接变为黑色\n  - 非根节点位置\n    - 父节点为黑色\n      - 不需要任何操作,默认红色即可\n    - 父节点为红色\n      - 叔叔节点为红色\n        1. 将"父节点"设为黑色,将"叔叔节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 如果"祖父节点"为根节点,则将根节点再次变成黑色\n      - 叔叔节点为黑色\n        1. 将"父节点"设为黑色\n        2. 将"祖父节点"设为红色\n        3. 以"祖父节点"为支点进行旋转\n\n##5.HashSet集合\n\n### 5.1HashSet集合概述和特点【应用】\n\n- 底层数据结构是哈希表\n- 存取无序\n- 不可以存储重复元素\n- 没有索引,不能使用普通for循环遍历\n\n### 5.2HashSet集合的基本应用【应用】\n\n存储字符串并遍历\n\n```java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n### 5.3哈希值【理解】\n\n- 哈希值简介\n\n  ​\t是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n\n- 如何获取哈希值\n\n  ​\tObject类中的public int hashCode()：返回对象的哈希码值\n\n- 哈希值的特点\n\n  - 同一个对象多次调用hashCode()方法返回的哈希值是相同的\n  - 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n### 5.4哈希表结构【理解】\n\n- JDK1.8以前\n\n  ​\t数组 + 链表\n\n  ![14_JKD8以前哈希表](img/14_JKD8%E4%BB%A5%E5%89%8D%E5%93%88%E5%B8%8C%E8%A1%A8.png)\n\n- JDK1.8以后\n\n  - 节点个数少于等于8个\n\n    ​\t数组 + 链表\n\n  - 节点个数多于8个\n\n    ​\t数组 + 红黑树\n\n  ![15_JKD8以后哈希表](img/15_JKD8%E4%BB%A5%E5%90%8E%E5%93%88%E5%B8%8C%E8%A1%A8.png)\n\n### 5.5HashSet集合存储学生对象并遍历【应用】\n\n- 案例需求\n\n  - 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n  - 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n  \n          Student student = (Student) o;\n  \n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  \n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashSetDemo02 {\n      public static void main(String[] args) {\n          //创建HashSet集合对象\n          HashSet<Student> hs = new HashSet<Student>();\n  \n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n  \n          Student s4 = new Student("王祖贤", 33);\n  \n          //把学生添加到集合\n          hs.add(s1);\n          hs.add(s2);\n          hs.add(s3);\n          hs.add(s4);\n  \n          //遍历集合(增强for)\n          for (Student s : hs) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }\n  ```\n\n- 总结\n\n  ​\tHashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法\n\n'},{title:"Map集合",headers:[{level:2,title:"1.Map集合",slug:"_1-map集合",link:"#_1-map集合",children:[{level:3,title:"1.1Map集合概述和特点【理解】",slug:"_1-1map集合概述和特点【理解】",link:"#_1-1map集合概述和特点【理解】",children:[]},{level:3,title:"1.2Map集合的基本功能【应用】",slug:"_1-2map集合的基本功能【应用】",link:"#_1-2map集合的基本功能【应用】",children:[]},{level:3,title:"1.3Map集合的获取功能【应用】",slug:"_1-3map集合的获取功能【应用】",link:"#_1-3map集合的获取功能【应用】",children:[]},{level:3,title:"1.4Map集合的遍历(方式1)【应用】",slug:"_1-4map集合的遍历-方式1-【应用】",link:"#_1-4map集合的遍历-方式1-【应用】",children:[]},{level:3,title:"1.5Map集合的遍历(方式2)【应用】",slug:"_1-5map集合的遍历-方式2-【应用】",link:"#_1-5map集合的遍历-方式2-【应用】",children:[]}]},{level:2,title:"2.HashMap集合",slug:"_2-hashmap集合",link:"#_2-hashmap集合",children:[{level:3,title:"2.1HashMap集合概述和特点【理解】",slug:"_2-1hashmap集合概述和特点【理解】",link:"#_2-1hashmap集合概述和特点【理解】",children:[]},{level:3,title:"2.2HashMap集合应用案例【应用】",slug:"_2-2hashmap集合应用案例【应用】",link:"#_2-2hashmap集合应用案例【应用】",children:[]}]},{level:2,title:"3.TreeMap集合",slug:"_3-treemap集合",link:"#_3-treemap集合",children:[{level:3,title:"3.1TreeMap集合概述和特点【理解】",slug:"_3-1treemap集合概述和特点【理解】",link:"#_3-1treemap集合概述和特点【理解】",children:[]},{level:3,title:"3.2TreeMap集合应用案例【应用】",slug:"_3-2treemap集合应用案例【应用】",link:"#_3-2treemap集合应用案例【应用】",children:[]}]}],path:"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html",pathLocale:"/",extraFields:'---\ntitle: Map集合\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nMap集合\n\n\x3c!-- more --\x3e\n## 1.Map集合\n\n### 1.1Map集合概述和特点【理解】\n\n- Map集合概述\n\n  ```java\n  interface Map<K,V>  K：键的类型；V：值的类型\n  ```\n\n- Map集合的特点\n\n  - 双列集合,一个键对应一个值\n  - 键不可以重复,值可以重复\n\n- Map集合的基本使用\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put("itheima001","林青霞");\n          map.put("itheima002","张曼玉");\n          map.put("itheima003","王祖贤");\n          map.put("itheima003","柳岩");\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.2Map集合的基本功能【应用】\n\n- 方法介绍\n\n  | 方法名                                 | 说明                 |\n  | ----------------------------------- | ------------------ |\n  | `V   put(K key,V   value)`            | 添加元素               |\n  | `V   remove(Object key)`              | 根据键删除键值对元素         |\n  | `void   clear()`                      | 移除所有的键值对元素         |\n  | `boolean containsKey(Object key)`     | 判断集合是否包含指定的键       |\n  | `boolean containsValue(Object value)` | 判断集合是否包含指定的值       |\n  | `boolean isEmpty()  `                 | 判断集合是否为空           |\n  | `int size()   `                       | 集合的长度，也就是集合中键值对的个数 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key,V value)：添加元素\n          map.put("张无忌","赵敏");\n          map.put("郭靖","黄蓉");\n          map.put("杨过","小龙女");\n\n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove("郭靖"));\n  //        System.out.println(map.remove("郭襄"));\n\n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n\n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey("郭靖"));\n  //        System.out.println(map.containsKey("郭襄"));\n\n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n\n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }\n  ```\n\n### 1.3Map集合的获取功能【应用】\n\n- 方法介绍\n\n  | 方法名                              | 说明           |\n  | -------------------------------- | ------------ |\n  | `V   get(Object key) `             | 根据键获取值       |\n  | `Set<K>   keySet()  `              | 获取所有键的集合     |\n  | `Collection<V>   values()  `       | 获取所有值的集合     |\n  | `Set<Map.Entry<K,V>>   entrySet() `| 获取所有键值对对象的集合 |\n\n- 示例代码\n\n  ```java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get("张无忌"));\n  //        System.out.println(map.get("张三丰"));\n\n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n\n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }\n  ```\n\n### 1.4Map集合的遍历(方式1)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 把所有的丈夫给集中起来\n    - 遍历丈夫的集合，获取到每一个丈夫\n    - 根据丈夫去找对应的妻子\n\n- 步骤分析\n\n  - 获取所有键的集合。用keySet()方法实现\n  - 遍历键的集合，获取到每一个键。用增强for实现  \n  - 根据键去找值。用get(Object key)方法实现\n\n- 代码实现\n\n  ```java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n### 1.5Map集合的遍历(方式2)【应用】\n\n- 遍历思路\n\n  - 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n    - 获取所有结婚证的集合\n    - 遍历结婚证的集合，得到每一个结婚证\n    - 根据结婚证获取丈夫和妻子\n\n- 步骤分析\n\n  - 获取所有键值对对象的集合\n    - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\n  - 遍历键值对对象的集合，得到每一个键值对对象\n    - 用增强for实现，得到每一个Map.Entry\n  - 根据键值对对象获取键和值\n    - 用getKey()得到键\n    - 用getValue()得到值\n\n- 代码实现\n\n  ```java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + "," + value);\n          }\n      }\n  }\n  ```\n\n## 2.HashMap集合\n\n### 2.1HashMap集合概述和特点【理解】\n\n+ HashMap底层是哈希表结构的\n+ 依赖hashCode方法和equals方法保证键的唯一\n+ 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n### 2.2HashMap集合应用案例【应用】\n\n- 案例需求\n\n  - 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\n  - 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n- 代码实现\n\n  学生类\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hm.put(s1, "西安");\n          hm.put(s2, "武汉");\n          hm.put(s3, "郑州");\n          hm.put(s4, "北京");\n\n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + "," + key.getAge() + "," + value);\n          }\n      }\n  }\n  ```\n\n## 3.TreeMap集合\n\n### 3.1TreeMap集合概述和特点【理解】\n\n+ TreeMap底层是红黑树结构\n+ 依赖自然排序或者比较器排序,对键进行排序\n+ 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n### 3.2TreeMap集合应用案例【应用】\n\n+ 案例需求\n\n  + 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\n  + 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\n\n+ 代码实现\n\n  学生类\n\n  ```java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student("xiaohei",23);\n          Student s2 = new Student("dapang",22);\n          Student s3 = new Student("xiaomei",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,"江苏");\n          tm.put(s2,"北京");\n          tm.put(s3,"天津");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + "---" + value);\n                  }\n          );\n      }\n  }\n  ```\n'},{title:"可变参数&综合练习",headers:[{level:2,title:"2.1 Collections常用功能",slug:"_2-1-collections常用功能",link:"#_2-1-collections常用功能",children:[]},{level:2,title:"2.2 Comparator比较器",slug:"_2-2-comparator比较器",link:"#_2-2-comparator比较器",children:[{level:3,title:"练习1：随机点名器",slug:"练习1-随机点名器",link:"#练习1-随机点名器",children:[]},{level:3,title:"练习2：带概率的随机",slug:"练习2-带概率的随机",link:"#练习2-带概率的随机",children:[]},{level:3,title:"练习3：随机不重复",slug:"练习3-随机不重复",link:"#练习3-随机不重复",children:[]}]},{level:2,title:"练习4：集合的嵌套",slug:"练习4-集合的嵌套",link:"#练习4-集合的嵌套",children:[]},{level:2,title:"4.1 案例介绍",slug:"_4-1-案例介绍",link:"#_4-1-案例介绍",children:[]},{level:2,title:"4.2 案例分析",slug:"_4-2-案例分析",link:"#_4-2-案例分析",children:[]},{level:2,title:"4.3 代码实现",slug:"_4-3-代码实现",link:"#_4-3-代码实现",children:[]},{level:2,title:"4.4 排序（第一种排序方式）",slug:"_4-4-排序-第一种排序方式",link:"#_4-4-排序-第一种排序方式",children:[]},{level:2,title:"4.5 排序（第二种排序方式）",slug:"_4-5-排序-第二种排序方式",link:"#_4-5-排序-第二种排序方式",children:[]}],path:"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:'---\ntitle: 可变参数&综合练习\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n可变参数&综合练习\n\n\x3c!-- more --\x3e\n# 1. 可变参数\n\n在**JDK1.5**之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化.\n\n**格式：**\n\n```\n修饰符 返回值类型 方法名(参数类型... 形参名){  }\n```\n\n**底层：**\n\n​\t其实就是一个数组\n\n**好处：**\n\n​\t在传递数据的时候，省的我们自己创建数组并添加元素了，JDK底层帮我们自动创建数组并添加元素了\n\n**代码演示:**\n\n```java\n  public class ChangeArgs {\n    public static void main(String[] args) {\n        int sum = getSum(6, 7, 2, 12, 2121);\n        System.out.println(sum);\n    }\n    \n    public static int getSum(int... arr) {\n   \t\tint sum = 0;\n   \t     for (int a : arr) {\n         sum += a;\n        }\n   \t\t return sum;\n    }\n}\n```\n\n**注意：**\n\n​\t1.一个方法只能有一个可变参数\n\n​\t2.如果方法中有多个参数，可变参数要放到最后。\n\n**应用场景: Collections**\n\n​\t在Collections中也提供了添加一些元素方法：\n\n​\t`public static <T> boolean addAll(Collection<T> c, T... elements)  `:往集合中添加一些元素。\n\n**代码演示:**\n\n```java\npublic class CollectionsDemo {\n\tpublic static void main(String[] args) {\n      ArrayList<Integer> list = new ArrayList<Integer>();\n      //原来写法\n      //list.add(12);\n      //list.add(14);\n      //list.add(15);\n      //list.add(1000);\n      //采用工具类 完成 往集合中添加元素  \n      Collections.addAll(list, 5, 222, 1，2);\n      System.out.println(list);\n}\n```\n\n# 2. Collections类\n\n## 2.1 Collections常用功能\n\n- `java.utils.Collections`是集合工具类，用来对集合进行操作。\n\n  常用方法如下：\n\n- `public static void shuffle(List<?> list) `:打乱集合顺序。\n- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。\n- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。\n\n代码演示：\n\n```java\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<Integer>();\n   \n        list.add(100);\n        list.add(300);\n        list.add(200);\n        list.add(50);\n        //排序方法 \n        Collections.sort(list);\n        System.out.println(list);\n    }\n}\n结果：\n[50,100, 200, 300]\n```\n\n我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？\n\n## 2.2 Comparator比较器\n\n创建一个学生类，存储到ArrayList集合中完成指定排序操作。\n\nStudent 类\n\n```java\npublic class Student{\n    private String name;\n    private int age;\n\t//构造方法\n    //get/set\n \t//toString\n}\n```\n\n测试类：\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        // 创建四个学生对象 存储到集合中\n        ArrayList<Student> list = new ArrayList<Student>();\n\n        list.add(new Student("rose",18));\n        list.add(new Student("jack",16));\n        list.add(new Student("abc",20));\n\t\tCollections.sort(list, new Comparator<Student>() {\n  \t\t  @Override\n    \t\tpublic int compare(Student o1, Student o2) {\n        \treturn o1.getAge()-o2.getAge();//以学生的年龄升序\n   \t\t }\n\t\t});\n\n\n        for (Student student : list) {\n            System.out.println(student);\n        }\n    }\n}\nStudent{name=\'jack\', age=16}\nStudent{name=\'rose\', age=18}\nStudent{name=\'abc\', age=20}\n```\n\n# 3. 综合练习\n\n### 练习1：随机点名器\n\n需求：班级里有N个学生，实现随机点名器\n\n代码实现：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生，学生属性:姓名，年龄，性别。\n        实现随机点名器。*/\n\n\n        //1.定义集合\n        ArrayList<String> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,"范闲","范建","范统","杜子腾","杜琦燕","宋合泛","侯笼藤","朱益群","朱穆朗玛峰","袁明媛");\n        //3.随机点名\n        /* Random r = new Random();\n        int index = r.nextInt(list.size());\n        String name = list.get(index);\n        System.out.println(name);*/\n\n        //打乱\n        Collections.shuffle(list);\n\n        String name = list.get(0);\n        System.out.println(name);\n\n\n    }\n}\n```\n\n### 练习2：带概率的随机\n\n需求：\n\n​\t班级里有N个学生\n\n​\t要求在随机的时候，70%的概率随机到男生，30%的概率随机到女生\n\n代码实现：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生\n        要求：\n        70%的概率随机到男生\n        30%的概率随机到女生\n\n        "范闲","范建","范统","杜子腾","宋合泛","侯笼藤","朱益群","朱穆朗玛峰",\n        "杜琦燕","袁明媛","李猜","田蜜蜜",\n        */\n        //1.创建集合\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,1,1,1,1,1,1,1);\n        Collections.addAll(list,0,0,0);\n        //3.打乱集合中的数据\n        Collections.shuffle(list);\n        //4.从list集合中随机抽取0或者1\n        Random r = new Random();\n        int index = r.nextInt(list.size());\n        int number = list.get(index);\n        System.out.println(number);\n        //5.创建两个集合分别存储男生和女生的名字\n        ArrayList<String> boyList = new ArrayList<>();\n        ArrayList<String> girlList = new ArrayList<>();\n\n        Collections.addAll(boyList,"范闲","范建","范统","杜子腾","宋合泛","侯笼藤","朱益群","朱穆朗玛峰");\n        Collections.addAll(girlList,"杜琦燕","袁明媛","李猜","田蜜蜜");\n\n        //6.判断此时是从boyList里面抽取还是从girlList里面抽取\n        if(number == 1){\n            //boyList\n            int boyIndex = r.nextInt(boyList.size());\n            String name = boyList.get(boyIndex);\n            System.out.println(name);\n        }else{\n            //girlList\n            int girlIndex = r.nextInt(girlList.size());\n            String name = girlList.get(girlIndex);\n            System.out.println(name);\n        }\n\n\n    }\n}\n```\n\n### 练习3：随机不重复\n\n需求：\n\n​\t班级里有N个学生，被点到的学生不会再被点到。但是如果班级中所有的学生都点完了， 需要重新开启第二轮点名。\n\n代码实现：\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n       /* 班级里有5个学生\n        要求：\n        被点到的学生不会再被点到。\n        但是如果班级中所有的学生都点完了，需要重新开启第二轮点名。*/\n\n\n        //1.定义集合\n        ArrayList<String> list1 = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list1, "范闲", "范建", "范统", "杜子腾", "杜琦燕", "宋合泛", "侯笼藤", "朱益群", "朱穆朗玛峰", "袁明媛");\n        //创建一个临时的集合，用来存已经被点到学生的名字\n        ArrayList<String> list2 = new ArrayList<>();\n        //外循环：表示轮数\n        for (int i = 1; i <= 10; i++) {\n            System.out.println("=========第" + i + "轮点名开始了======================");\n            //3.获取集合的长度\n            int count = list1.size();\n            //4.随机点名\n            Random r = new Random();\n            //内循环：每一轮中随机循环抽取的过程\n            for (int j = 0; j < count; j++) {\n                int index = r.nextInt(list1.size());\n                String name = list1.remove(index);\n                list2.add(name);\n                System.out.println(name);\n            }\n            //此时表示一轮点名结束\n            //list1 空了 list2 10个学生的名字\n            list1.addAll(list2);\n            list2.clear();\n\n        }\n    }\n}\n```\n\n## 练习4：集合的嵌套\n\n需求：\n\n​\t定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\n\n添加完毕后，遍历结果格式如下：\n\n​\t江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\n\n  \t湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\n\n  \t河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市\n\n代码实现：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        /* 需求\n        定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\n        添加完毕后，遍历结果格式如下：\n                江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\n                湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\n                河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市*/\n\n\n        //1.创建Map集合\n        HashMap<String, ArrayList<String>> hm = new HashMap<>();\n\n        //2.创建单列集合存储市\n        ArrayList<String> city1 = new ArrayList<>();\n        city1.add("南京市");\n        city1.add("扬州市");\n        city1.add("苏州市");\n        city1.add("无锡市");\n        city1.add("常州市");\n\n        ArrayList<String> city2 = new ArrayList<>();\n        city2.add("武汉市");\n        city2.add("孝感市");\n        city2.add("十堰市");\n        city2.add("宜昌市");\n        city2.add("鄂州市");\n\n        ArrayList<String> city3 = new ArrayList<>();\n        city3.add("石家庄市");\n        city3.add("唐山市");\n        city3.add("邢台市");\n        city3.add("保定市");\n        city3.add("张家口市");\n\n        //3.把省份和多个市添加到map集合\n        hm.put("江苏省",city1);\n        hm.put("湖北省",city2);\n        hm.put("河北省",city3);\n\n        Set<Map.Entry<String, ArrayList<String>>> entries = hm.entrySet();\n        for (Map.Entry<String, ArrayList<String>> entry : entries) {\n            //entry依次表示每一个键值对对象\n            String key = entry.getKey();\n            ArrayList<String> value = entry.getValue();\n            StringJoiner sj = new StringJoiner(", ","","");\n            for (String city : value) {\n                sj.add(city);\n            }\n            System.out.println(key + " = " + sj);\n\n        }\n    }\n}\n```\n\n# 4. 斗地主发牌\n\n## 4.1 案例介绍\n\n按照斗地主的规则，完成洗牌发牌的动作。\n具体规则：\n\n使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。\n\n## 4.2 案例分析\n\n- 准备牌：\n\n  牌可以设计为一个`ArrayList<String>`,每个字符串为一张牌。\n  每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。\n  牌由Collections类的shuffle方法进行随机排序。\n\n- 发牌\n\n  将每个人以及底牌设计为`ArrayList<String>`,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。\n\n- 看牌\n\n  直接打印每个集合。\n\n## 4.3 代码实现\n\n```java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的三步：\n          准备牌\n          洗牌\n          发牌\n       */\n        //从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\npublic class PokerGame {\n    //牌盒\n    //♥3 ♣3\n    static ArrayList<String> list = new ArrayList<>();\n\n    //静态代码块\n    //特点：随着类的加载而在加载的，而且只执行一次。\n    static {\n        //准备牌\n        // "♦", "♣", "♥", "♠"\n        // "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"\n        String[] color = {"♦", "♣", "♥", "♠" };\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        for (String c : color) {\n            //c依次表示每一种花色\n            for (String n : number) {\n                //n 依次表示每一个数字\n                list.add(c + n);\n            }\n        }\n        list.add("小王");\n        list.add("大王");\n    }\n\n    public PokerGame(){\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        //遍历牌盒得到每一张牌\n        for (int i = 0; i < list.size(); i++) {\n            //i：索引\n            String poker = list.get(i);\n            if(i <= 2){\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if(i % 3 == 0){\n                player1.add(poker);\n            }else if(i % 3 == 1){\n                player2.add(poker);\n            }else{\n                player3.add(poker);\n            }\n        }\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：每位玩家的牌\n    * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + ": ");\n        for (String poker : list) {\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n    }\n}\n```\n\n## 4.4 排序（第一种排序方式）\n\n```java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的四步：\n          准备牌\n          洗牌\n          发牌\n          排序\n\n       */\n\n\t\t//从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒 Map\n    //此时我们只要把牌跟序号产生对应关系就可以了，不需要按照序号进行排序，所以只要HashMap就可以了\n    static HashMap<Integer, String> hm = new HashMap<>();\n    static ArrayList<Integer> list = new ArrayList<>();\n\n    static {\n        String[] color = {"♦", "♣", "♥", "♠"};\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        //序号\n        int serialNumber = 1;\n        //细节\n        for (String n : number) {\n            //依次表示每一个数字\n            for (String c : color) {\n                //依次表示每一个花色\n                hm.put(serialNumber, c + n);\n                list.add(serialNumber);\n                serialNumber++;\n            }\n        }\n\n        hm.put(serialNumber, "小王");\n        list.add(serialNumber);\n        serialNumber++;\n        hm.put(serialNumber, "大王");\n        list.add(serialNumber);\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        TreeSet<Integer> lord = new TreeSet<>();\n        TreeSet<Integer> player1 = new TreeSet<>();\n        TreeSet<Integer> player2 = new TreeSet<>();\n        TreeSet<Integer> player3 = new TreeSet<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            //i :依次表示集合中的每一个索引\n            //list.get(i)元素：牌的序号\n            int serialNumber = list.get(i);\n\n            if(i <= 2){\n                lord.add(serialNumber);\n                continue;\n            }\n\n            if(i % 3 == 0){\n                player1.add(serialNumber);\n            }else if(i % 3 == 1){\n                player2.add(serialNumber);\n            }else{\n                player3.add(serialNumber);\n            }\n        }\n\n\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：牌的序号\n    * */\n    public void lookPoker(String name, TreeSet<Integer> ts){\n        System.out.print(name + ": ");\n        //遍历TreeSet集合得到每一个序号，再拿着序号到Map集合中去找真正的牌\n        for (int serialNumber : ts) {\n            String poker = hm.get(serialNumber);\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n    }\n}\n```\n\n## 4.5 排序（第二种排序方式）\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒\n    static ArrayList<String> list = new ArrayList<>();\n\n    //创建一个集合，用来添加牌的价值\n    static HashMap<String, Integer> hm = new HashMap<>();\n\n    static {\n        //准备牌\n        String[] color = {"♦", "♣", "♥", "♠"};\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        for (String c : color) {\n            for (String n : number) {\n                list.add(c + n);\n            }\n        }\n        list.add(" 小王");\n        list.add(" 大王");\n\n\n        //指定牌的价值\n        //牌上的数字到Map集合中判断是否存在\n        //存在，获取价值\n        //不存在，本身的数字就是价值\n        hm.put("J", 11);\n        hm.put("Q", 12);\n        hm.put("K", 13);\n        hm.put("A", 14);\n        hm.put("2", 15);\n        hm.put("小王", 50);\n        hm.put("大王", 100);\n\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            String poker = list.get(i);\n            //发底牌\n            if (i <= 2) {\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if (i % 3 == 0) {\n                player1.add(poker);\n            } else if (i % 3 == 1) {\n                player2.add(poker);\n            } else {\n                player3.add(poker);\n            }\n        }\n\n\n        //排序\n        order(lord);\n        order(player1);\n        order(player2);\n        order(player3);\n\n\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n    }\n\n\n    /*\n     * 参数一：玩家的名字\n     * 参数二：每位玩家的牌\n     * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + ": ");\n        for (String poker : list) {\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n\n    }\n\n\n    //利用牌的价值进行排序\n    //参数：集合\n    //♥5 ♥3 ♥6 ♥7 ♥9\n    public void order(ArrayList<String> list){\n        Collections.sort(list, new Comparator<String>() {\n            //Array.sort （插入排序 + 二分查找）\n            @Override\n            public int compare(String o1, String o2) {\n                //o1：表示当前要插入到有序序列中的牌\n                //o2：表示已经在有序序列中存在的牌\n\n                //负数：o1小 插入到前面\n                //正数：o1大 插入到后面\n                //0：o1的数字跟o2的数字是一样的，需要按照花色再次排序\n\n                //1.计算o1的花色和价值   大王\n                String color1 = o1.substring(0, 1);\n                int value1 = getValue(o1);\n\n                //2.计算o2的花色和价值\n                String color2 = o2.substring(0, 1);\n                int value2 = getValue(o2);\n\n                //3.比较o1和o2的价值    ♥3  ♠3\n                int i = value1 - value2;\n                return i == 0 ? color1.compareTo(color2) : i;\n\n            }\n        });\n    }\n\n    //计算牌的价值\n    //参数：牌\n    //返回值：价值\n    public int getValue(String poker){//♥3\n        //获取牌上的数字\n        String number = poker.substring(1);//把这里截取出来的结果，让这个结果再Map集合中存在 “ 大王”\n        //拿着数字到map集合中判断是否存在\n        if(hm.containsKey(number)){\n            //存在，获取价值\n            return hm.get(number);\n        }else{\n            //不存在，类型转换\n            return Integer.parseInt(number);\n        }\n    }\n}\n```\n\n'},{title:"stream流和方法引用",headers:[{level:2,title:"1.不可变集合",slug:"_1-不可变集合",link:"#_1-不可变集合",children:[{level:3,title:"1.1 什么是不可变集合",slug:"_1-1-什么是不可变集合",link:"#_1-1-什么是不可变集合",children:[]},{level:3,title:"1.2 使用场景",slug:"_1-2-使用场景",link:"#_1-2-使用场景",children:[]},{level:3,title:"1.3 不可变集合分类",slug:"_1-3-不可变集合分类",link:"#_1-3-不可变集合分类",children:[]},{level:3,title:"1.4 不可变的list集合",slug:"_1-4-不可变的list集合",link:"#_1-4-不可变的list集合",children:[]},{level:3,title:"1.5 不可变的Set集合",slug:"_1-5-不可变的set集合",link:"#_1-5-不可变的set集合",children:[]},{level:3,title:"1.6 不可变的Map集合",slug:"_1-6-不可变的map集合",link:"#_1-6-不可变的map集合",children:[]}]},{level:2,title:"2.Stream流",slug:"_2-stream流",link:"#_2-stream流",children:[{level:3,title:"2.1体验Stream流【理解】",slug:"_2-1体验stream流【理解】",link:"#_2-1体验stream流【理解】",children:[]},{level:3,title:"2.2Stream流的常见生成方式【应用】",slug:"_2-2stream流的常见生成方式【应用】",link:"#_2-2stream流的常见生成方式【应用】",children:[]},{level:3,title:"2.3Stream流中间操作方法【应用】",slug:"_2-3stream流中间操作方法【应用】",link:"#_2-3stream流中间操作方法【应用】",children:[]},{level:3,title:"2.4Stream流终结操作方法【应用】",slug:"_2-4stream流终结操作方法【应用】",link:"#_2-4stream流终结操作方法【应用】",children:[]},{level:3,title:"2.5Stream流的收集操作【应用】",slug:"_2-5stream流的收集操作【应用】",link:"#_2-5stream流的收集操作【应用】",children:[]},{level:3,title:"2.6Stream流综合练习【应用】",slug:"_2-6stream流综合练习【应用】",link:"#_2-6stream流综合练习【应用】",children:[]}]},{level:2,title:"3.方法引用",slug:"_3-方法引用",link:"#_3-方法引用",children:[{level:3,title:"3.1体验方法引用【理解】",slug:"_3-1体验方法引用【理解】",link:"#_3-1体验方法引用【理解】",children:[]},{level:3,title:"3.2方法引用符【理解】",slug:"_3-2方法引用符【理解】",link:"#_3-2方法引用符【理解】",children:[]},{level:3,title:"3.3引用类方法【应用】",slug:"_3-3引用类方法【应用】",link:"#_3-3引用类方法【应用】",children:[]},{level:3,title:"3.4引用对象的实例方法【应用】",slug:"_3-4引用对象的实例方法【应用】",link:"#_3-4引用对象的实例方法【应用】",children:[]},{level:3,title:"3.5引用类的实例方法【应用】",slug:"_3-5引用类的实例方法【应用】",link:"#_3-5引用类的实例方法【应用】",children:[]},{level:3,title:"3.6引用构造器【应用】",slug:"_3-6引用构造器【应用】",link:"#_3-6引用构造器【应用】",children:[]}]}],path:"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html",pathLocale:"/",extraFields:'---\ntitle: stream流和方法引用\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nstream流和方法引用\n\n\x3c!-- more --\x3e\n## 1.不可变集合\n\n### 1.1 什么是不可变集合\n\n​\t是一个长度不可变，内容也无法修改的集合\n\n### 1.2 使用场景\n\n​\t如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。\n\n​\t当集合对象被不可信的库调用时，不可变形式是安全的。\n\n简单理解：\n\n​\t不想让别人修改集合中的内容\n\n比如说：\n\n1，斗地主的54张牌，是不能添加，不能删除，不能修改的\n\n2，斗地主的打牌规则：单张，对子，三张，顺子等，也是不能修改的\n\n3，用代码获取的操作系统硬件信息，也是不能被修改的\n\n### 1.3 不可变集合分类\n\n* 不可变的list集合\n* 不可变的set集合\n* 不可变的map集合\n\n### 1.4 不可变的list集合\n\n```java\npublic class ImmutableDemo1 {\n    public static void main(String[] args) {\n        /*\n            创建不可变的List集合\n            "张三", "李四", "王五", "赵六"\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        List<String> list = List.of("张三", "李四", "王五", "赵六");\n\n        System.out.println(list.get(0));\n        System.out.println(list.get(1));\n        System.out.println(list.get(2));\n        System.out.println(list.get(3));\n\n        System.out.println("---------------------------");\n\n        for (String s : list) {\n            System.out.println(s);\n        }\n\n        System.out.println("---------------------------");\n\n\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("---------------------------");\n\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            System.out.println(s);\n        }\n        System.out.println("---------------------------");\n\n        //list.remove("李四");\n        //list.add("aaa");\n        list.set(0,"aaa");\n    }\n}\n```\n\n### 1.5 不可变的Set集合\n\n```java\npublic class ImmutableDemo2 {\n    public static void main(String[] args) {\n        /*\n           创建不可变的Set集合\n           "张三", "李四", "王五", "赵六"\n\n\n           细节：\n                当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");\n\n        for (String s : set) {\n            System.out.println(s);\n        }\n\n        System.out.println("-----------------------");\n\n        Iterator<String> it = set.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n\n        System.out.println("-----------------------");\n        //set.remove("王五");\n    }\n}\n```\n\n### 1.6 不可变的Map集合\n\n#### 1.6.1：键值对个数小于等于10\n\n```java\npublic class ImmutableDemo3 {\n    public static void main(String[] args) {\n       /*\n        创建Map的不可变集合\n            细节1：\n                键是不能重复的\n            细节2：\n                Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对\n            细节3：\n                如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",\n                "赵六", "广州", "孙七", "深圳", "周八", "杭州",\n                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",\n                "陈二", "嘉兴");\n\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            String value = map.get(key);\n            System.out.println(key + "=" + value);\n        }\n\n        System.out.println("--------------------------");\n\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            System.out.println(key + "=" + value);\n        }\n        System.out.println("--------------------------");\n    }\n}\n```\n\n#### 1.6.2：键值对个数大于10\n\n```java\npublic class ImmutableDemo4 {\n    public static void main(String[] args) {\n\n        /*\n            创建Map的不可变集合,键值对的数量超过10个\n        */\n\n        //1.创建一个普通的Map集合\n        HashMap<String, String> hm = new HashMap<>();\n        hm.put("张三", "南京");\n        hm.put("李四", "北京");\n        hm.put("王五", "上海");\n        hm.put("赵六", "北京");\n        hm.put("孙七", "深圳");\n        hm.put("周八", "杭州");\n        hm.put("吴九", "宁波");\n        hm.put("郑十", "苏州");\n        hm.put("刘一", "无锡");\n        hm.put("陈二", "嘉兴");\n        hm.put("aaa", "111");\n\n        //2.利用上面的数据来获取一个不可变的集合\n/*\n        //获取到所有的键值对对象（Entry对象）\n        Set<Map.Entry<String, String>> entries = hm.entrySet();\n        //把entries变成一个数组\n        Map.Entry[] arr1 = new Map.Entry[0];\n        //toArray方法在底层会比较集合的长度跟数组的长度两者的大小\n        //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组\n        //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用\n        Map.Entry[] arr2 = entries.toArray(arr1);\n        //不可变的map集合\n        Map map = Map.ofEntries(arr2);\n        map.put("bbb","222");*/\n\n\n        //Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));\n\n        Map<String, String> map = Map.copyOf(hm);\n        map.put("bbb","222");\n    }\n}\n```\n\n## 2.Stream流\n\n### 2.1体验Stream流【理解】\n\n- 案例需求\n\n  按照下面的要求完成集合的创建和遍历\n\n  - 创建一个集合，存储多个字符串元素\n  - 把集合中所有以"张"开头的元素存储到一个新的集合\n  - 把"张"开头的集合中的长度为3的元素存储到一个新的集合\n  - 遍历上一步得到的集合\n\n- 原始方式示例代码\n\n  ```java\n  public class MyStream1 {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of("张三丰","张无忌","张翠山","王二麻子","张良","谢广坤"));\n          //list.add()\n\n          //遍历list1把以张开头的元素添加到list2中。\n          ArrayList<String> list2 = new ArrayList<>();\n          for (String s : list1) {\n              if(s.startsWith("张")){\n                  list2.add(s);\n              }\n          }\n          //遍历list2集合，把其中长度为3的元素，再添加到list3中。\n          ArrayList<String> list3 = new ArrayList<>();\n          for (String s : list2) {\n              if(s.length() == 3){\n                  list3.add(s);\n              }\n          }\n          for (String s : list3) {\n              System.out.println(s);\n          }      \n      }\n  }\n  ```\n\n- 使用Stream流示例代码\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of("张三丰","张无忌","张翠山","王二麻子","张良","谢广坤"));\n\n          //Stream流\n          list1.stream().filter(s->s.startsWith("张"))\n                  .filter(s->s.length() == 3)\n                  .forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n- Stream流的好处\n\n  - 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印\n  - Stream流把真正的函数式编程风格引入到Java中\n  - 代码简洁\n\n### 2.2Stream流的常见生成方式【应用】\n\n- Stream流的思想\n\n  ![01_Stream流思想](.\\img\\01_Stream流思想.png)\n\n- Stream流的三类方法\n\n  - 获取Stream流\n    - 创建一条流水线,并把数据放到流水线上准备进行操作\n  - 中间方法\n    - 流水线上的操作\n    - 一次操作完毕之后,还可以继续进行其他操作\n  - 终结方法\n    - 一个Stream流只能有一个终结方法\n    - 是流水线上的最后一个操作\n\n- 生成Stream流的方式\n\n  - Collection体系集合\n\n    使用默认方法stream()生成流， `default Stream<E> stream()`\n\n  - Map体系集合\n\n    把Map转成Set集合，间接的生成流\n\n  - 数组\n\n    通过Arrays中的静态方法stream生成流\n\n  - 同种数据类型的多个数据\n\n    通过Stream接口的静态方法of(T... values)生成流\n\n- 代码演示\n\n  ```java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n  \n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n  \n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n  \n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {"hello","world","java"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }\n  ```\n\n### 2.3Stream流中间操作方法【应用】\n\n- 概念\n\n  中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作\n\n- 常见方法\n\n  | 方法名                                      | 说明                                       |\n  | ---------------------------------------- | ---------------------------------------- |\n  | `Stream<T> filter(Predicate predicate)`    | 用于对流中的数据进行过滤                             |\n  | `Stream<T> limit(long maxSize)`            | 返回此流中的元素组成的流，截取前指定参数个数的数据                |\n  | `Stream<T> skip(long n)`                  | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流               |\n  | `static <T> Stream<T> concat(Stream a, Stream b)` | 合并a和b两个流为一个流                             |\n  | `Stream<T> distinct()`                     | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n\n- filter代码演示\n\n  ```java\n  public class MyStream3 {\n      public static void main(String[] args) {\n  //        Stream<T> filter(Predicate predicate)：过滤\n  //        Predicate接口中的方法\tboolean test(T t)：对给定的参数进行判断，返回一个布尔值\n\n          ArrayList<String> list = new ArrayList<>();\n          list.add("张三丰");\n          list.add("张无忌");\n          list.add("张翠山");\n          list.add("王二麻子");\n          list.add("张良");\n          list.add("谢广坤");\n\n          //filter方法获取流中的 每一个数据.\n          //而test方法中的s,就依次表示流中的每一个数据.\n          //我们只要在test方法中对s进行判断就可以了.\n          //如果判断的结果为true,则当前的数据留下\n          //如果判断的结果为false,则当前数据就不要.\n  //        list.stream().filter(\n  //                new Predicate<String>() {\n  //                    @Override\n  //                    public boolean test(String s) {\n  //                        boolean result = s.startsWith("张");\n  //                        return result;\n  //                    }\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          //因为Predicate接口中只有一个抽象方法test\n          //所以我们可以使用lambda表达式来简化\n  //        list.stream().filter(\n  //                (String s)->{\n  //                    boolean result = s.startsWith("张");\n  //                        return result;\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          list.stream().filter(s ->s.startsWith("张")).forEach(s-> System.out.println(s));\n\n      }\n  }\n  ```\n\n- limit&skip代码演示\n\n  ```java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(s-> System.out.println(s));\n          System.out.println("--------");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(s-> System.out.println(s));\n          System.out.println("--------");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n- concat&distinct代码演示\n\n  ```java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n  \n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n  \n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n  \n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n  \n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(s-> System.out.println(s));\n  \n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(s-> System.out.println(s));\n      }\n  }\n  ```\n\n### 2.4Stream流终结操作方法【应用】\n\n- 概念\n\n  终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\n\n- 常见方法\n\n  | 方法名                           | 说明           |\n  | ----------------------------- | ------------ |\n  | void forEach(Consumer action) | 对此流的每个元素执行操作 |\n  | long count()                  | 返回此流中的元素数    |\n\n- 代码演示\n\n  ```java\n  public class MyStream5 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("张三丰");\n          list.add("张无忌");\n          list.add("张翠山");\n          list.add("王二麻子");\n          list.add("张良");\n          list.add("谢广坤");\n  \n          //method1(list);\n          \n  //        long count()：返回此流中的元素数\n          long count = list.stream().count();\n          System.out.println(count);\n      }\n  \n      private static void method1(ArrayList<String> list) {\n          //  void forEach(Consumer action)：对此流的每个元素执行操作\n          //  Consumer接口中的方法void accept(T t)：对给定的参数执行此操作\n          //在forEach方法的底层,会循环获取到流中的每一个数据.\n          //并循环调用accept方法,并把每一个数据传递给accept方法\n          //s就依次表示了流中的每一个数据.\n          //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了.\n          list.stream().forEach(\n                  new Consumer<String>() {\n                      @Override\n                      public void accept(String s) {\n                          System.out.println(s);\n                      }\n                  }\n          );\n        \n          System.out.println("====================");\n          //lambda表达式的简化格式\n          //是因为Consumer接口中,只有一个accept方法\n          list.stream().forEach(\n                  (String s)->{\n                      System.out.println(s);\n                  }\n          );\n          System.out.println("====================");\n          //lambda表达式还是可以进一步简化的.\n          list.stream().forEach(s->System.out.println(s));\n      }\n  }\n  ```\n\n### 2.5Stream流的收集操作【应用】\n\n- 概念\n\n  对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\n\n- 常用方法\n\n  | 方法名                            | 说明        |\n  | ------------------------------ | --------- |\n  | R collect(Collector collector) | 把结果收集到集合中 |\n\n- 工具类Collectors提供了具体的收集方式\n\n  | 方法名                                                       | 说明                   |\n  | ------------------------------------------------------------ | ---------------------- |\n  | `public static <T> Collector toList()`                         | 把元素收集到List集合中 |\n  | `public static <T> Collector toSet()`                          | 把元素收集到Set集合中  |\n  | `public static  Collector toMap(Function keyMapper,Function valueMapper)` | 把元素收集到Map集合中  |\n\n- 代码演示\n\n  ```java\n  // toList和toSet方法演示 \n  public class MyStream7 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          for (int i = 1; i <= 10; i++) {\n              list1.add(i);\n          }\n  \n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n  \n          //filter负责过滤数据的.\n          //collect负责收集数据.\n                  //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中.\n          //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中.\n          List<Integer> list = list1.stream().filter(number -> number % 2 == 0)\n                  .collect(Collectors.toList());\n  \n          System.out.println(list);\n  \n      Set<Integer> set = list1.stream().filter(number -> number % 2 == 0)\n              .collect(Collectors.toSet());\n      System.out.println(set);\n  }\n  }\n  /**\n  Stream流的收集方法 toMap方法演示\n  创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄\n  "zhangsan,23"\n  "lisi,24"\n  "wangwu,25"\n  保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值\n  */\n  public class MyStream8 {\n  \tpublic static void main(String[] args) {\n        \tArrayList<String> list = new ArrayList<>();\n          list.add("zhangsan,23");\n          list.add("lisi,24");\n          list.add("wangwu,25");\n  \n          Map<String, Integer> map = list.stream().filter(\n                  s -> {\n                      String[] split = s.split(",");\n                      int age = Integer.parseInt(split[1]);\n                      return age >= 24;\n                  }\n  \n           //   collect方法只能获取到流中剩余的每一个数据.\n           //在底层不能创建容器,也不能把数据添加到容器当中\n  \n           //Collectors.toMap 创建一个map集合并将数据添加到集合当中\n  \n            // s 依次表示流中的每一个数据\n  \n            //第一个lambda表达式就是如何获取到Map中的键\n            //第二个lambda表达式就是如何获取Map中的值\n          ).collect(Collectors.toMap(\n                  s -> s.split(",")[0],\n                  s -> Integer.parseInt(s.split(",")[1]) ));\n  \n          System.out.println(map);\n  \t}\n  }\n  ```\n\n### 2.6Stream流综合练习【应用】\n\n- 案例需求\n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\n\n  - 男演员只要名字为3个字的前三人\n  - 女演员只要姓林的，并且不要第一个\n  - 把过滤后的男演员姓名和女演员姓名合并到一起\n  - 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n- 代码实现\n\n  演员类\n  ```java\n  public class Actor {\n      private String name;\n  \n      public Actor(String name) {\n          this.name = name;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  }\n  ```\n\n  测试类\n\n  ```java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add("周润发");\n          manList.add("成龙");\n          manList.add("刘德华");\n          manList.add("吴京");\n          manList.add("周星驰");\n          manList.add("李连杰");\n    \n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add("林心如");\n          womanList.add("张曼玉");\n          womanList.add("林青霞");\n          womanList.add("柳岩");\n          womanList.add("林志玲");\n          womanList.add("王祖贤");\n    \n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith("林")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n        \t// 将流中的数据封装成Actor对象之后打印\n        \tstream.forEach(name -> {\n              Actor actor = new Actor(name);\n              System.out.println(actor);\n          }); \n      }\n  }\n  ```\n\n## 3.方法引用\n\n### 3.1体验方法引用【理解】\n\n- 方法引用的出现原因\n\n  在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作\n\n  那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要\n\n  那我们又是如何使用已经存在的方案的呢？\n\n  这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案\n\n- 代码演示\n\n  ```java\n  public interface Printable {\n      void printString(String s);\n  }\n  \n  public class PrintableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用usePrintable方法\n  //        usePrintable((String s) -> {\n  //            System.out.println(s);\n  //        });\n  \t    //Lambda简化写法\n          usePrintable(s -> System.out.println(s));\n  \n          //方法引用\n          usePrintable(System.out::println);\n  \n      }\n  \n      private static void usePrintable(Printable p) {\n          p.printString("爱生活爱Java");\n      }\n  }\n  \n  ```\n\n### 3.2方法引用符【理解】\n\n- 方法引用符\n\n  ::  该符号为引用运算符，而它所在的表达式被称为方法引用\n\n- 推导与省略\n\n  - 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导\n  - 如果使用方法引用，也是同样可以根据上下文进行推导\n  - 方法引用是Lambda的孪生兄弟\n\n### 3.3引用类方法【应用】\n\n​\t引用类方法，其实就是引用类的静态方法\n\n- 格式\n\n  类名::静态方法\n\n- 范例\n\n  Integer::parseInt\n\n  Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据\n\n- 练习描述\n\n  - 定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s);\n  - 定义一个测试类(ConverterDemo)，在测试类中提供两个方法\n    - 一个方法是：useConverter(Converter c)\n    - 一个方法是主方法，在主方法中调用useConverter方法\n\n- 代码演示\n\n  ```java\n  public interface Converter {\n      int convert(String s);\n  }\n  \n  public class ConverterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda写法\n          useConverter(s -> Integer.parseInt(s));\n  \n          //引用类方法\n          useConverter(Integer::parseInt);\n  \n      }\n  \n      private static void useConverter(Converter c) {\n          int number = c.convert("666");\n          System.out.println(number);\n      }\n  }\n  ```\n\n- 使用说明\n\n  Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数\n\n### 3.4引用对象的实例方法【应用】\n\n​\t引用对象的实例方法，其实就引用类中的成员方法\n\n- 格式\n\n  对象::成员方法\n\n- 范例\n\n  "HelloWorld"::toUpperCase\n\n    String类中的方法：public String toUpperCase() 将此String所有字符转换为大写\n\n- 练习描述\n\n  - 定义一个类(PrintString)，里面定义一个方法\n\n    public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出\n\n  - 定义一个接口(Printer)，里面定义一个抽象方法\n\n    void printUpperCase(String s)\n\n  - 定义一个测试类(PrinterDemo)，在测试类中提供两个方法\n\n    - 一个方法是：usePrinter(Printer p)\n    - 一个方法是主方法，在主方法中调用usePrinter方法\n\n- 代码演示\n\n  ```java\n  public class PrintString {\n      //把字符串参数变成大写的数据，然后在控制台输出\n      public void printUpper(String s) {\n          String result = s.toUpperCase();\n          System.out.println(result);\n      }\n  }\n  \n  public interface Printer {\n      void printUpperCase(String s);\n  }\n  \n  public class PrinterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          usePrinter(s -> System.out.println(s.toUpperCase()));\n  \n          //引用对象的实例方法\n          PrintString ps = new PrintString();\n          usePrinter(ps::printUpper);\n  \n      }\n  \n      private static void usePrinter(Printer p) {\n          p.printUpperCase("HelloWorld");\n      }\n  }\n  \n  ```\n\n- 使用说明\n\n  Lambda表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数\n\n### 3.5引用类的实例方法【应用】\n\n​\t引用类的实例方法，其实就是引用类中的成员方法\n\n- 格式\n\n  类名::成员方法\n\n- 范例\n\n  String::substring\n\n  public String substring(int beginIndex,int endIndex) \n\n  从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex\n\n- 练习描述\n\n  - 定义一个接口(MyString)，里面定义一个抽象方法：\n\n    String mySubString(String s,int x,int y);\n\n  - 定义一个测试类(MyStringDemo)，在测试类中提供两个方法\n\n    - 一个方法是：useMyString(MyString my)\n    - 一个方法是主方法，在主方法中调用useMyString方法\n\n- 代码演示\n\n  ```java\n  public interface MyString {\n      String mySubString(String s,int x,int y);\n  }\n  \n  public class MyStringDemo {\n      public static void main(String[] args) {\n  \t\t//Lambda简化写法\n          useMyString((s,x,y) -> s.substring(x,y));\n  \n          //引用类的实例方法\n          useMyString(String::substring);\n  \n      }\n  \n      private static void useMyString(MyString my) {\n          String s = my.mySubString("HelloWorld", 2, 5);\n          System.out.println(s);\n      }\n  }\n  ```\n\n- 使用说明\n\n  ​    Lambda表达式被类的实例方法替代的时候\n  ​    第一个参数作为调用者\n  ​    后面的参数全部传递给该方法作为参数\n\n### 3.6引用构造器【应用】\n\n​\t引用构造器，其实就是引用构造方法\n\n- l格式\n\n  类名::new\n\n- 范例\n\n  Student::new\n\n- 练习描述\n\n  - 定义一个类(Student)，里面有两个成员变量(name,age)\n\n    并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法\n\n  - 定义一个接口(StudentBuilder)，里面定义一个抽象方法\n\n    Student build(String name,int age);\n\n  - 定义一个测试类(StudentDemo)，在测试类中提供两个方法\n\n    - 一个方法是：useStudentBuilder(StudentBuilder s)\n    - 一个方法是主方法，在主方法中调用useStudentBuilder方法\n\n- 代码演示\n\n  ```java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  \n  public interface StudentBuilder {\n      Student build(String name,int age);\n  }\n  \n  public class StudentDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          useStudentBuilder((name,age) -> new Student(name,age));\n  \n          //引用构造器\n          useStudentBuilder(Student::new);\n  \n      }\n  \n      private static void useStudentBuilder(StudentBuilder sb) {\n          Student s = sb.build("林青霞", 30);\n          System.out.println(s.getName() + "," + s.getAge());\n      }\n  }\n  ```\n\n- 使用说明\n\n  Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数\n\n'},{title:"IO(异常&File&综合案例）",headers:[{level:2,title:"1.1 异常概念",slug:"_1-1-异常概念",link:"#_1-1-异常概念",children:[]},{level:2,title:"1.2 异常体系",slug:"_1-2-异常体系",link:"#_1-2-异常体系",children:[]},{level:2,title:"1.3 异常分类",slug:"_1-3-异常分类",link:"#_1-3-异常分类",children:[]},{level:2,title:"1.4 异常的产生过程解析",slug:"_1-4-异常的产生过程解析",link:"#_1-4-异常的产生过程解析",children:[]},{level:2,title:"1.5 抛出异常throw",slug:"_1-5-抛出异常throw",link:"#_1-5-抛出异常throw",children:[]},{level:2,title:"1.6 声明异常throws",slug:"_1-6-声明异常throws",link:"#_1-6-声明异常throws",children:[]},{level:2,title:"1.7 捕获异常try…catch",slug:"_1-7-捕获异常try-catch",link:"#_1-7-捕获异常try-catch",children:[]},{level:2,title:"1.8 finally 代码块",slug:"_1-8-finally-代码块",link:"#_1-8-finally-代码块",children:[]},{level:2,title:"1.9 异常注意事项",slug:"_1-9-异常注意事项",link:"#_1-9-异常注意事项",children:[]},{level:2,title:"1.10 概述",slug:"_1-10-概述",link:"#_1-10-概述",children:[]},{level:2,title:"1.11 自定义异常的练习",slug:"_1-11-自定义异常的练习",link:"#_1-11-自定义异常的练习",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 构造方法",slug:"_2-2-构造方法",link:"#_2-2-构造方法",children:[]},{level:2,title:"2.3 常用方法",slug:"_2-3-常用方法",link:"#_2-3-常用方法",children:[{level:3,title:"获取功能的方法",slug:"获取功能的方法",link:"#获取功能的方法",children:[]},{level:3,title:"绝对路径和相对路径",slug:"绝对路径和相对路径",link:"#绝对路径和相对路径",children:[]},{level:3,title:"判断功能的方法",slug:"判断功能的方法",link:"#判断功能的方法",children:[]},{level:3,title:"创建删除功能的方法",slug:"创建删除功能的方法",link:"#创建删除功能的方法",children:[]}]},{level:2,title:"2.4 目录的遍历",slug:"_2-4-目录的遍历",link:"#_2-4-目录的遍历",children:[]},{level:2,title:"2.5 综合练习",slug:"_2-5-综合练习",link:"#_2-5-综合练习",children:[{level:3,title:"练习3：（考虑子文件夹）",slug:"练习3-考虑子文件夹",link:"#练习3-考虑子文件夹",children:[]},{level:3,title:"练习4：删除多级文件夹",slug:"练习4-删除多级文件夹",link:"#练习4-删除多级文件夹",children:[]},{level:3,title:"练习5：统计大小",slug:"练习5-统计大小",link:"#练习5-统计大小",children:[]},{level:3,title:"练习6：统计文件个数",slug:"练习6-统计文件个数",link:"#练习6-统计文件个数",children:[]}]}],path:"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html",pathLocale:"/",extraFields:'---\ntitle: IO(异常&File&综合案例）\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nIO(异常&File&综合案例）\n\n\x3c!-- more --\x3e\n# 1. 异常\n\n## 1.1 异常概念\n\n异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：\n\n* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\n\n在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\n\n> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\n\n## 1.2 异常体系\n\n异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。\n\n![](imgs\\异常体系.png)\n\n**Throwable体系：**\n\n* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\n* **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\n\n**Throwable中的常用方法：**\n\n* `public void printStackTrace()`:打印异常的详细信息。\n\n  *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n* `public String getMessage()`:获取发生异常的原因。\n\n  *提示给用户的时候,就提示错误原因。*\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n\n***出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。***\n\n![](imgs\\简单的异常查看.png)\n\n## 1.3 异常分类\n\n我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\n\n**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?\n\n* **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\n* **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n\n​    ![](imgs\\异常的分类.png)\n\n## 1.4 异常的产生过程解析\n\n先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。\n\n 工具类\n\n```java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n 测试类\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println("num=" + num);\n        System.out.println("over");\n    }\n}\n```\n\n上述程序执行过程图解：\n\n ![](imgs\\异常产生过程.png)\n\n## 1.5 抛出异常throw\n\n在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。\n\n在java中，提供了一个**throw**关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\n\n1. 创建一个异常对象。封装一些提示信息(信息可以自己编写)。\n\n2. 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\n\n   throw**用在方法内**，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\n\n**使用格式：**\n\n```\nthrow new 异常类名(参数);\n```\n\n 例如：\n\n```java\nthrow new NullPointerException("要访问的arr数组不存在");\n\nthrow new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");\n```\n\n学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\n\n```java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println("over");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException("哥们，角标越界了```");\n        }\n        int element = arr[index];\n        return element;\n    }\n}\n```\n\n> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 1.6 声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**\n\n```\n修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }\t\n```\n\n声明异常的代码演示：\n\n```java\npublic class ThrowsDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        read("a.txt");\n    }\n\n    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException("文件不存在");\n        }\n    }\n}\n```\n\nthrows用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\n\n```java\npublic class ThrowsDemo2 {\n    public static void main(String[] args) throws IOException {\n        read("a.txt");\n    }\n\n    public static void read(String path)throws FileNotFoundException, IOException {\n        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException("文件不存在");\n        }\n        if (!path.equals("b.txt")) {\n            throw new IOException();\n        }\n    }\n}\n```\n\n## 1.7 捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n* **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型  e){\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：\n\n```java\npublic class TryCatchDemo {\n    public static void main(String[] args) {\n        try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。\n            read("b.txt");\n        } catch (FileNotFoundException e) {// 括号中需要定义什么呢？\n          \t//try中抛出的是什么异常，在括号中就定义什么异常类型\n            System.out.println(e);\n        }\n        System.out.println("over");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException("文件不存在");\n        }\n    }\n}\n```\n\n如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n* `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n* `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n在开发中呢也可以在catch将编译期异常转换成运行期异常处理。\n\n多个异常使用捕获又该如何处理呢？\n\n1. 多个异常分别处理。\n2. 多个异常一次捕获，多次处理。\n3. 多个异常一次捕获一次处理。\n\n一般我们是使用一次捕获多次处理方式，格式如下：\n\n```java\ntry{\n     编写可能会出现异常的代码\n}catch(异常类型A  e){  当try中出现A类型异常,就用该catch来捕获.\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}catch(异常类型B  e){  当try中出现B类型异常,就用该catch来捕获.\n     处理异常的代码\n     //记录日志/打印异常信息/继续抛出异常\n}\n```\n\n> 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n## 1.8 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：\n\n```java\npublic class TryCatchDemo4 {\n    public static void main(String[] args) {\n        try {\n            read("a.txt");\n        } catch (FileNotFoundException e) {\n            //抓取到的是编译期异常  抛出去的是运行期 \n            throw new RuntimeException(e);\n        } finally {\n            System.out.println("不管程序怎样，这里都将会被执行。");\n        }\n        System.out.println("over");\n    }\n    /*\n     *\n     * 我们 当前的这个方法中 有异常  有编译期异常\n     */\n    public static void read(String path) throws FileNotFoundException {\n        if (!path.equals("a.txt")) {//如果不是 a.txt这个文件 \n            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw\n            throw new FileNotFoundException("文件不存在");\n        }\n    }\n}\n```\n\n> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n## 1.9 异常注意事项\n\n* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n* 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。\n* 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n* 当多异常处理时，捕获处理，前边的类不能是后边类的父类\n* 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。\n\n## 1.10 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **LoginException**。一个登陆异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 1.11 自定义异常的练习\n\n要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类LoginException：\n\n```java\n// 业务逻辑异常\npublic class LoginException extends Exception {\n    /**\n     * 空参构造\n     */\n    public LoginException() {\n    }\n\n    /**\n     *\n     * @param message 表示异常提示\n     */\n    public LoginException(String message) {\n        super(message);\n    }\n}\n```\n\n模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。\n\n```java\npublic class Demo {\n    // 模拟数据库中已存在账号\n    private static String[] names = {"bill","hill","jill"};\n   \n    public static void main(String[] args) {     \n        //调用方法\n        try{\n            // 可能出现异常的代码\n            checkUsername("nill");\n            System.out.println("注册成功");//如果没有异常就是注册成功\n        } catch(LoginException e) {\n            //处理异常\n            e.printStackTrace();\n        }\n    }\n\n    //判断当前注册账号是否存在\n    //因为是编译期异常，又想调用者去处理 所以声明该异常\n    public static boolean checkUsername(String uname) throws LoginException {\n        for (String name : names) {\n            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常\n                throw new LoginException("亲"+name+"已经被注册了！");\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 2. File类\n\n## 2.1 概述\n\n`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n## 2.2 构造方法\n\n- `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n- `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n- `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n- 构造举例，代码如下：\n\n```java\n// 文件路径名\nString pathname = "D:\\\\aaa.txt";\nFile file1 = new File(pathname); \n\n// 文件路径名\nString pathname2 = "D:\\\\aaa\\\\bbb.txt";\nFile file2 = new File(pathname2); \n\n// 通过父路径和子路径字符串\n String parent = "d:\\\\aaa";\n String child = "bbb.txt";\n File file3 = new File(parent, child);\n\n// 通过父级File对象和子路径字符串\nFile parentDir = new File("d:\\\\aaa");\nString child = "bbb.txt";\nFile file4 = new File(parentDir, child);\n```\n\n> 小贴士：\n>\n> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n## 2.3 常用方法\n\n### 获取功能的方法\n\n- `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。\n\n- ` public String getPath() ` ：将此File转换为路径名字符串。 \n\n- `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n- `public long length()`  ：返回由此File表示的文件的长度。 \n\n  方法演示，代码如下：\n\n  ```java\n  public class FileGet {\n      public static void main(String[] args) {\n          File f = new File("d:/aaa/bbb.java");     \n          System.out.println("文件绝对路径:"+f.getAbsolutePath());\n          System.out.println("文件构造路径:"+f.getPath());\n          System.out.println("文件名称:"+f.getName());\n          System.out.println("文件长度:"+f.length()+"字节");\n  \n          File f2 = new File("d:/aaa");     \n          System.out.println("目录绝对路径:"+f2.getAbsolutePath());\n          System.out.println("目录构造路径:"+f2.getPath());\n          System.out.println("目录名称:"+f2.getName());\n          System.out.println("目录长度:"+f2.length());\n      }\n  }\n  输出结果：\n  文件绝对路径:d:\\aaa\\bbb.java\n  文件构造路径:d:\\aaa\\bbb.java\n  文件名称:bbb.java\n  文件长度:636字节\n  \n  目录绝对路径:d:\\aaa\n  目录构造路径:d:\\aaa\n  目录名称:aaa\n  目录长度:4096\n  ```\n\n> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n### 绝对路径和相对路径\n\n- **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n- **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。\n\n```java\npublic class FilePath {\n    public static void main(String[] args) {\n      \t// D盘下的bbb.java文件\n        File f = new File("D:\\\\bbb.java");\n        System.out.println(f.getAbsolutePath());\n      \t\n\t\t// 项目下的bbb.java文件\n        File f2 = new File("bbb.java");\n        System.out.println(f2.getAbsolutePath());\n    }\n}\n输出结果：\nD:\\bbb.java\nD:\\idea_project_test4\\bbb.java\n```\n\n### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n方法演示，代码如下：\n\n```java\npublic class FileIs {\n    public static void main(String[] args) {\n        File f = new File("d:\\\\aaa\\\\bbb.java");\n        File f2 = new File("d:\\\\aaa");\n      \t// 判断是否存在\n        System.out.println("d:\\\\aaa\\\\bbb.java 是否存在:"+f.exists());\n        System.out.println("d:\\\\aaa 是否存在:"+f2.exists());\n      \t// 判断是文件还是目录\n        System.out.println("d:\\\\aaa 文件?:"+f2.isFile());\n        System.out.println("d:\\\\aaa 目录?:"+f2.isDirectory());\n    }\n}\n输出结果：\nd:\\aaa\\bbb.java 是否存在:true\nd:\\aaa 是否存在:true\nd:\\aaa 文件?:false\nd:\\aaa 目录?:true\n```\n\n### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n方法演示，代码如下：\n\n```java\npublic class FileCreateDelete {\n    public static void main(String[] args) throws IOException {\n        // 文件的创建\n        File f = new File("aaa.txt");\n        System.out.println("是否存在:"+f.exists()); // false\n        System.out.println("是否创建:"+f.createNewFile()); // true\n        System.out.println("是否存在:"+f.exists()); // true\n\t\t\n     \t// 目录的创建\n      \tFile f2= new File("newDir");\t\n        System.out.println("是否存在:"+f2.exists());// false\n        System.out.println("是否创建:"+f2.mkdir());\t// true\n        System.out.println("是否存在:"+f2.exists());// true\n\n\t\t// 创建多级目录\n      \tFile f3= new File("newDira\\\\newDirb");\n        System.out.println(f3.mkdir());// false\n        File f4= new File("newDira\\\\newDirb");\n        System.out.println(f4.mkdirs());// true\n      \n      \t// 文件的删除\n       \tSystem.out.println(f.delete());// true\n      \n      \t// 目录的删除\n        System.out.println(f2.delete());// true\n        System.out.println(f4.delete());// false\n    }\n}\n```\n\n> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n## 2.4 目录的遍历\n\n- `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n- `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  \n\n```java\npublic class FileFor {\n    public static void main(String[] args) {\n        File dir = new File("d:\\\\java_code");\n      \n      \t//获取当前目录下的文件以及文件夹的名称。\n\t\tString[] names = dir.list();\n\t\tfor(String name : names){\n\t\t\tSystem.out.println(name);\n\t\t}\n        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            System.out.println(file);\n        }\n    }\n}\n```\n\n> 小贴士：\n>\n> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。\n\n## 2.5 综合练习\n\n#### 练习1：创建文件夹\n\n​\t在当前模块下的aaa文件夹中创建一个a.txt文件\n\n代码实现：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) throws IOException {\n        //需求：在当前模块下的aaa文件夹中创建一个a.txt文件\n\n        //1.创建a.txt的父级路径\n        File file = new File("myfile\\\\aaa");\n        //2.创建父级路径\n        //如果aaa是存在的，那么此时创建失败的。\n        //如果aaa是不存在的，那么此时创建成功的。\n        file.mkdirs();\n        //3.拼接父级路径和子级路径\n        File src = new File(file,"a.txt");\n        boolean b = src.createNewFile();\n        if(b){\n            System.out.println("创建成功");\n        }else{\n            System.out.println("创建失败");\n        }\n    }\n}\n```\n\n#### 练习2：查找文件（不考虑子文件夹）\n\n​\t定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹）\n\n代码示例：\n\n```java\npublic class Test2 {\n    public static void main(String[] args) {\n        /*需求：\n             定义一个方法找某一个文件夹中，是否有以avi结尾的电影。\n\t        （暂时不需要考虑子文件夹）\n        */\n\n        File file = new File("D:\\\\aaa\\\\bbb");\n        boolean b = haveAVI(file);\n        System.out.println(b);\n    }\n    /*\n    * 作用：用来找某一个文件夹中，是否有以avi结尾的电影\n    * 形参：要查找的文件夹\n    * 返回值：查找的结果  存在true  不存在false\n    * */\n    public static boolean haveAVI(File file){// D:\\\\aaa\n        //1.进入aaa文件夹，而且要获取里面所有的内容\n        File[] files = file.listFiles();\n        //2.遍历数组获取里面的每一个元素\n        for (File f : files) {\n            //f：依次表示aaa文件夹里面每一个文件或者文件夹的路径\n            if(f.isFile() && f.getName().endsWith(".avi")){\n                return true;\n            }\n        }\n        //3.如果循环结束之后还没有找到，直接返回false\n        return false;\n    }\n}\n```\n\n### 练习3：（考虑子文件夹）\n\n​\t找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）\n\n代码示例：\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n        /* 需求：\n        找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）\n\n\n        套路：\n            1，进入文件夹\n            2，遍历数组\n            3，判断\n            4，判断\n\n        */\n\n        findAVI();\n\n    }\n\n    public static void findAVI(){\n        //获取本地所有的盘符\n        File[] arr = File.listRoots();\n        for (File f : arr) {\n            findAVI(f);\n        }\n    }\n\n    public static void findAVI(File src){//"C:\\\\\n        //1.进入文件夹src\n        File[] files = src.listFiles();\n        //2.遍历数组,依次得到src里面每一个文件或者文件夹\n        if(files != null){\n            for (File file : files) {\n                if(file.isFile()){\n                    //3，判断，如果是文件，就可以执行题目的业务逻辑\n                    String name = file.getName();\n                    if(name.endsWith(".avi")){\n                        System.out.println(file);\n                    }\n                }else{\n                    //4，判断，如果是文件夹，就可以递归\n                    //细节：再次调用本方法的时候，参数一定要是src的次一级路径\n                    findAVI(file);\n                }\n            }\n        }\n    }\n}\n```\n\n### 练习4：删除多级文件夹\n\n需求： 如果我们要删除一个有内容的文件夹\n\t   1.先删除文件夹里面所有的内容\n           2.再删除自己\n\n代码示例：\n\n```java\npublic class Test4 {\n    public static void main(String[] args) {\n        /*\n           删除一个多级文件夹\n           如果我们要删除一个有内容的文件夹\n           1.先删除文件夹里面所有的内容\n           2.再删除自己\n        */\n\n        File file = new File("D:\\\\aaa\\\\src");\n        delete(file);\n\n    }\n\n    /*\n    * 作用：删除src文件夹\n    * 参数：要删除的文件夹\n    * */\n    public static void delete(File src){\n        //1.先删除文件夹里面所有的内容\n        //进入src\n        File[] files = src.listFiles();\n        //遍历\n        for (File file : files) {\n            //判断,如果是文件，删除\n            if(file.isFile()){\n                file.delete();\n            }else {\n                //判断,如果是文件夹，就递归\n                delete(file);\n            }\n        }\n        //2.再删除自己\n        src.delete();\n    }\n}\n```\n\n### 练习5：统计大小\n\n​\t需求：统计一个文件夹的总大小\n\n代码示例：\n\n```java\npublic class Test5 {\n    public static void main(String[] args) {\n       /*需求：\n            统计一个文件夹的总大小\n      */\n\n\n        File file = new File("D:\\\\aaa\\\\src");\n\n        long len = getLen(file);\n        System.out.println(len);//4919189\n    }\n\n    /*\n    * 作用：\n    *       统计一个文件夹的总大小\n    * 参数：\n    *       表示要统计的那个文件夹\n    * 返回值：\n    *       统计之后的结果\n    *\n    * 文件夹的总大小：\n    *       说白了，文件夹里面所有文件的大小\n    * */\n    public static long getLen(File src){\n        //1.定义变量进行累加\n        long len = 0;\n        //2.进入src文件夹\n        File[] files = src.listFiles();\n        //3.遍历数组\n        for (File file : files) {\n            //4.判断\n            if(file.isFile()){\n                //我们就把当前文件的大小累加到len当中\n                len = len + file.length();\n            }else{\n                //判断，如果是文件夹就递归\n                len = len + getLen(file);\n            }\n        }\n        return len;\n    }\n}\n```\n\n### 练习6：统计文件个数\n\n  需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）\n            打印格式如下：\n            txt:3个\n            doc:4个\n            jpg:6个\n\n代码示例：\n\n```java\npublic class Test6 {\n    public static void main(String[] args) throws IOException {\n        /*\n            需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）\n            打印格式如下：\n            txt:3个\n            doc:4个\n            jpg:6个\n        */\n        File file = new File("D:\\\\aaa\\\\src");\n        HashMap<String, Integer> hm = getCount(file);\n        System.out.println(hm);\n    }\n\n    /*\n    * 作用：\n    *       统计一个文件夹中每种文件的个数\n    * 参数：\n    *       要统计的那个文件夹\n    * 返回值：\n    *       用来统计map集合\n    *       键：后缀名 值：次数\n    *\n    *       a.txt\n    *       a.a.txt\n    *       aaa（不需要统计的）\n    *\n    *\n    * */\n    public static HashMap<String,Integer> getCount(File src){\n        //1.定义集合用来统计\n        HashMap<String,Integer> hm = new HashMap<>();\n        //2.进入src文件夹\n        File[] files = src.listFiles();\n        //3.遍历数组\n        for (File file : files) {\n            //4.判断，如果是文件，统计\n            if(file.isFile()){\n                //a.txt\n                String name = file.getName();\n                String[] arr = name.split("\\\\.");\n                if(arr.length >= 2){\n                    String endName = arr[arr.length - 1];\n                    if(hm.containsKey(endName)){\n                        //存在\n                        int count = hm.get(endName);\n                        count++;\n                        hm.put(endName,count);\n                    }else{\n                        //不存在\n                        hm.put(endName,1);\n                    }\n                }\n            }else{\n                //5.判断，如果是文件夹，递归\n                //sonMap里面是子文件中每一种文件的个数\n                HashMap<String, Integer> sonMap = getCount(file);\n                //hm:  txt=1  jpg=2  doc=3\n                //sonMap: txt=3 jpg=1\n                //遍历sonMap把里面的值累加到hm当中\n                Set<Map.Entry<String, Integer>> entries = sonMap.entrySet();\n                for (Map.Entry<String, Integer> entry : entries) {\n                    String key = entry.getKey();\n                    int value = entry.getValue();\n                    if(hm.containsKey(key)){\n                        //存在\n                        int count = hm.get(key);\n                        count = count + value;\n                        hm.put(key,count);\n                    }else{\n                        //不存在\n                        hm.put(key,value);\n                    }\n                }\n            }\n        }\n        return hm;\n    }\n}\n```\n\n\n\n\n\n'},{title:"IO流（字节流&字符流）",headers:[{level:2,title:"1.1 什么是IO",slug:"_1-1-什么是io",link:"#_1-1-什么是io",children:[]},{level:2,title:"1.2 IO的分类",slug:"_1-2-io的分类",link:"#_1-2-io的分类",children:[]},{level:2,title:"1.3 IO的流向说明图解",slug:"_1-3-io的流向说明图解",link:"#_1-3-io的流向说明图解",children:[]},{level:2,title:"1.4 顶级父类们",slug:"_1-4-顶级父类们",link:"#_1-4-顶级父类们",children:[]},{level:2,title:"2.1 一切皆为字节",slug:"_2-1-一切皆为字节",link:"#_2-1-一切皆为字节",children:[]},{level:2,title:"2.2 字节输出流【OutputStream】",slug:"_2-2-字节输出流【outputstream】",link:"#_2-2-字节输出流【outputstream】",children:[]},{level:2,title:"2.3 FileOutputStream类",slug:"_2-3-fileoutputstream类",link:"#_2-3-fileoutputstream类",children:[{level:3,title:"构造方法",slug:"构造方法",link:"#构造方法",children:[]},{level:3,title:"写出字节数据",slug:"写出字节数据",link:"#写出字节数据",children:[]},{level:3,title:"数据追加续写",slug:"数据追加续写",link:"#数据追加续写",children:[]},{level:3,title:"写出换行",slug:"写出换行",link:"#写出换行",children:[]}]},{level:2,title:"2.4 字节输入流【InputStream】",slug:"_2-4-字节输入流【inputstream】",link:"#_2-4-字节输入流【inputstream】",children:[]},{level:2,title:"2.5 FileInputStream类",slug:"_2-5-fileinputstream类",link:"#_2-5-fileinputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-1",link:"#构造方法-1",children:[]},{level:3,title:"读取字节数据",slug:"读取字节数据",link:"#读取字节数据",children:[]}]},{level:2,title:"2.6 字节流练习：图片复制",slug:"_2-6-字节流练习-图片复制",link:"#_2-6-字节流练习-图片复制",children:[{level:3,title:"复制原理图解",slug:"复制原理图解",link:"#复制原理图解",children:[]},{level:3,title:"案例实现",slug:"案例实现",link:"#案例实现",children:[]}]},{level:2,title:"3.1 字符输入流【Reader】",slug:"_3-1-字符输入流【reader】",link:"#_3-1-字符输入流【reader】",children:[]},{level:2,title:"3.2 FileReader类",slug:"_3-2-filereader类",link:"#_3-2-filereader类",children:[{level:3,title:"构造方法",slug:"构造方法-2",link:"#构造方法-2",children:[]},{level:3,title:"读取字符数据",slug:"读取字符数据",link:"#读取字符数据",children:[]}]},{level:2,title:"3.3 字符输出流【Writer】",slug:"_3-3-字符输出流【writer】",link:"#_3-3-字符输出流【writer】",children:[]},{level:2,title:"3.4 FileWriter类",slug:"_3-4-filewriter类",link:"#_3-4-filewriter类",children:[{level:3,title:"构造方法",slug:"构造方法-3",link:"#构造方法-3",children:[]},{level:3,title:"基本写出数据",slug:"基本写出数据",link:"#基本写出数据",children:[]},{level:3,title:"关闭和刷新",slug:"关闭和刷新",link:"#关闭和刷新",children:[]},{level:3,title:"写出其他数据",slug:"写出其他数据",link:"#写出其他数据",children:[]},{level:3,title:"JDK7前处理",slug:"jdk7前处理",link:"#jdk7前处理",children:[]},{level:3,title:"JDK7的处理(扩展知识点了解内容)",slug:"jdk7的处理-扩展知识点了解内容",link:"#jdk7的处理-扩展知识点了解内容",children:[]},{level:3,title:"JDK9的改进(扩展知识点了解内容)",slug:"jdk9的改进-扩展知识点了解内容",link:"#jdk9的改进-扩展知识点了解内容",children:[]}]},{level:2,title:"练习1：拷贝文件夹",slug:"练习1-拷贝文件夹",link:"#练习1-拷贝文件夹",children:[]},{level:2,title:"练习2：文件加密",slug:"练习2-文件加密",link:"#练习2-文件加密",children:[]},{level:2,title:"练习3：数字排序",slug:"练习3-数字排序",link:"#练习3-数字排序",children:[]}],path:"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html",pathLocale:"/",extraFields:'---\ntitle: IO流（字节流&字符流）\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nIO流（字节流&字符流）\n\n\x3c!-- more --\x3e\n# 1. IO概述\n\n## 1.1 什么是IO\n\n生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。\n\n## 1.2 IO的分类\n\n根据数据的流向分为：**输入流**和**输出流**。\n\n* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 \n* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。\n\n格局数据的类型分为：**字节流**和**字符流**。\n\n* **字节流** ：以字节为单位，读写数据的流。\n* **字符流** ：以字符为单位，读写数据的流。\n\n## 1.3 IO的流向说明图解\n\n![](img/1_io.jpg)\n\n## 1.4 顶级父类们\n\n|         |          **输入流**           |             输出流             |\n| :-----: | :------------------------: | :-------------------------: |\n| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |\n| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |\n\n# 2. 字节流\n\n## 2.1 一切皆为字节\n\n一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n\n## 2.2 字节输出流【OutputStream】\n\n`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  \n* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  \n* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  \n* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  \n* `public abstract void write(int b)` ：将指定的字节输出流。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.3 FileOutputStream类\n\n`OutputStream`有很多子类，我们从最简单的一个子类开始。\n\n`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。\n\n### 构造方法\n\n* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 \n* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n\n* 构造举例，代码如下：\n\n```java\npublic class FileOutputStreamConstructor throws IOException {\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileOutputStream fos = new FileOutputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("b.txt");\n    }\n}\n```\n\n### 写出字节数据\n\n1. **写出字节**：`write(int b)` 方法，每次可以写出一个字节数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 写出数据\n      \tfos.write(97); // 写出第1个字节\n      \tfos.write(98); // 写出第2个字节\n      \tfos.write(99); // 写出第3个字节\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\nabc\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **写出字节数组**：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "黑马程序员".getBytes();\n      \t// 写出字节数组数据\n      \tfos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\n黑马程序员\n```\n\n3. **写出指定长度字节数组**：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "abcde".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\ncd\n```\n\n### 数据追加续写\n\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\n\n- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  \n- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  \n\n这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt"，true);     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "abcde".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n文件操作前：cd\n文件操作后：cdabcde\n```\n\n### 写出换行\n\nWindows系统里，换行符号是`\\r\\n` 。把\n\n以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");  \n      \t// 定义字节数组\n      \tbyte[] words = {97,98,99,100,101};\n      \t// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          \t// 写出一个字节\n            fos.write(words[i]);\n          \t// 写出一个换行, 换行符号转成数组写出\n            fos.write("\\r\\n".getBytes());\n        }\n      \t// 关闭资源\n        fos.close();\n    }\n}\n\n输出结果：\na\nb\nc\nd\ne\n```\n\n> * 回车符`\\r`和换行符`\\n` ：\n>   * 回车符：回到一行的开头（return）。\n>   * 换行符：下一行（newline）。\n> * 系统中的换行：\n>   * Windows系统里，每行结尾是 `回车+换行` ，即`\\r\\n`；\n>   * Unix系统里，每行结尾只有 `换行` ，即`\\n`；\n>   * Mac系统里，每行结尾是 `回车` ，即`\\r`。从 Mac OS X开始与Linux统一。\n\n## 2.4 字节输入流【InputStream】\n\n`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \n- `public abstract int read()`： 从输入流读取数据的下一个字节。 \n- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.5 FileInputStream类\n\n`java.io.FileInputStream `类是文件输入流，从文件中读取字节。\n\n### 构造方法\n\n* `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 \n* `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileInputStreamConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileInputStream fos = new FileInputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileInputStream fos = new FileInputStream("b.txt");\n    }\n}\n```\n\n### 读取字节数据\n\n1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream("read.txt");\n      \t// 读取数据，返回一个字节\n        int read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n      \t// 读取到末尾,返回-1\n       \tread = fis.read();\n        System.out.println( read);\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n-1\n```\n\n循环改进读取方式，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream("read.txt");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fis.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n```\n\n> 小贴士：\n>\n> 1. 虽然读取了一个字节，但是会自动提升为int类型。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组变成字符串打印\n            System.out.println(new String(b));\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ned\n```\n\n错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne\n```\n\n> 小贴士：\n>\n> 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\n\n## 2.6 字节流练习：图片复制\n\n### 复制原理图解\n\n![](img/2_copy.jpg)\n\n### 案例实现\n\n复制图片文件，代码使用演示：\n\n```java\npublic class Copy {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 指定数据源\n        FileInputStream fis = new FileInputStream("D:\\\\test.jpg");\n        // 1.2 指定目的地\n        FileOutputStream fos = new FileOutputStream("test_copy.jpg");\n\n        // 2.读写数据\n        // 2.1 定义数组\n        byte[] b = new byte[1024];\n        // 2.2 定义长度\n        int len;\n        // 2.3 循环读取\n        while ((len = fis.read(b))!=-1) {\n            // 2.4 写出数据\n            fos.write(b, 0 , len);\n        }\n\n        // 3.关闭资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n> 小贴士：\n>\n> 流的关闭原则：先开后关，后开先关。\n\n# 3. 字符流\n\n当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n\n## 3.1 字符输入流【Reader】\n\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \n- `public int read()`： 从输入流读取一个字符。 \n- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n## 3.2 FileReader类  \n\n`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n> 小贴士：\n>\n> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\n>\n>    idea中UTF-8\n>\n> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。\n\n### 构造方法\n\n- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   \n- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileReaderConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileReader fr = new FileReader(file);\n      \n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader("b.txt");\n    }\n}\n```\n\n### 读取字符数据\n\n1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fr.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑\n马\n程\n序\n员\n```\n\n> 小贴士：虽然读取了一个字符，但是会自动提升为int类型。\n>\n\n2. **使用字符数组读取**：`read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n         char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf));\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑马\n程序\n员序\n```\n\n获取有效的字符改进，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n        char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf,0,len));\n        }\n    \t// 关闭资源\n        fr.close();\n    }\n}\n\n输出结果：\n黑马\n程序\n员\n```\n\n## 3.3 字符输出流【Writer】\n\n`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- `void write(int c)` 写入单个字符。\n- `void write(char[] cbuf) `写入字符数组。 \n- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 \n- `void write(String str) `写入字符串。 \n- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n- `void flush() `刷新该流的缓冲。  \n- `void close()` 关闭此流，但要先刷新它。 \n\n## 3.4 FileWriter类\n\n`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n### 构造方法\n\n- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   \n- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileWriterConstructor {\n    public static void main(String[] args) throws IOException {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileWriter fw = new FileWriter(file);\n      \n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("b.txt");\n    }\n}\n```\n\n### 基本写出数据\n\n**写出字符**：`write(int b)` 方法，每次可以写出一个字符数据，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("fw.txt");     \n      \t// 写出数据\n      \tfw.write(97); // 写出第1个字符\n      \tfw.write(\'b\'); // 写出第2个字符\n      \tfw.write(\'C\'); // 写出第3个字符\n      \tfw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。\n      \n      \t/*\n        【注意】关闭资源时,与FileOutputStream不同。\n      \t 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n        */\n        // fw.close();\n    }\n}\n输出结果：\nabC田\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。\n> 2. 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。\n\n### 关闭和刷新\n\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。\n\n* `flush` ：刷新缓冲区，流对象可以继续使用。\n* `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("fw.txt");\n        // 写出数据，通过flush\n        fw.write(\'刷\'); // 写出第1个字符\n        fw.flush();\n        fw.write(\'新\'); // 继续写出第2个字符，写出成功\n        fw.flush();\n      \n      \t// 写出数据，通过close\n        fw.write(\'关\'); // 写出第1个字符\n        fw.close();\n        fw.write(\'闭\'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n        fw.close();\n    }\n}\n```\n\n> 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n\n### 写出其他数据\n\n1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("fw.txt");     \n      \t// 字符串转换为字节数组\n      \tchar[] chars = "黑马程序员".toCharArray();\n      \n      \t// 写出字符数组\n      \tfw.write(chars); // 黑马程序员\n        \n\t\t// 写出从索引2开始，2个字节。索引2是\'程\'，两个字节，也就是\'程序\'。\n        fw.write(b,2,2); // 程序\n      \n      \t// 关闭资源\n        fos.close();\n    }\n}\n```\n\n2. **写出字符串**：`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("fw.txt");     \n      \t// 字符串\n      \tString msg = "黑马程序员";\n      \n      \t// 写出字符数组\n      \tfw.write(msg); //黑马程序员\n      \n\t\t// 写出从索引2开始，2个字节。索引2是\'程\'，两个字节，也就是\'程序\'。\n        fw.write(msg,2,2);\t// 程序\n      \t\n        // 关闭资源\n        fos.close();\n    }\n}\n```\n\n3. **续写和换行**：操作类似于FileOutputStream。\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter("fw.txt"，true);     \n      \t// 写出字符串\n        fw.write("黑马");\n      \t// 写出换行\n      \tfw.write("\\r\\n");\n      \t// 写出字符串\n  \t\tfw.write("程序员");\n      \t// 关闭资源\n        fw.close();\n    }\n}\n输出结果:\n黑马\n程序员\n```\n\n> 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n>\n> 当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流\n\n# 4. IO异常的处理\n\n### JDK7前处理\n\n之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用`try...catch...finally` 代码块，处理异常部分，代码使用演示：\n\n```java  \npublic class HandleException1 {\n    public static void main(String[] args) {\n      \t// 声明变量\n        FileWriter fw = null;\n        try {\n            //创建流对象\n            fw = new FileWriter("fw.txt");\n            // 写出数据\n            fw.write("黑马程序员"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### JDK7的处理(扩展知识点了解内容)\n\n还可以使用JDK7优化后的`try-with-resource` 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n\n格式：\n\n```java\ntry (创建流对象语句，如果多个,使用\';\'隔开) {\n\t// 读写数据\n} catch (IOException e) {\n\te.printStackTrace();\n}\n```\n\n代码使用演示：\n\n```java\npublic class HandleException2 {\n    public static void main(String[] args) {\n      \t// 创建流对象\n        try ( FileWriter fw = new FileWriter("fw.txt"); ) {\n            // 写出数据\n            fw.write("黑马程序员"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### JDK9的改进(扩展知识点了解内容)\n\nJDK9中`try-with-resource` 的改进，对于**引入对象**的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。\n\n改进前格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource("resource1");\n// 普通对象\nResource resource2 = new Resource("resource2");\n// 引入方式：创建新的变量保存\ntry (Resource r1 = resource1;\n     Resource r2 = resource2) {\n     // 使用对象\n}\n```\n\n改进后格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource("resource1");\n// 普通对象\nResource resource2 = new Resource("resource2");\n\n// 引入方式：直接引入\ntry (resource1; resource2) {\n     // 使用对象\n}\n```\n\n改进后，代码使用演示：\n\n```java\npublic class TryDemo {\n    public static void main(String[] args) throws IOException {\n       \t// 创建流对象\n        final  FileReader fr  = new FileReader("in.txt");\n        FileWriter fw = new FileWriter("out.txt");\n       \t// 引入到try中\n        try (fr; fw) {\n          \t// 定义变量\n            int b;\n          \t// 读取数据\n          \twhile ((b = fr.read())!=-1) {\n            \t// 写出数据\n            \tfw.write(b);\n          \t}\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 5. 综合练习\n\n## 练习1：拷贝文件夹\n\n```java\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        //拷贝一个文件夹，考虑子文件夹\n\n        //1.创建对象表示数据源\n        File src = new File("D:\\\\aaa\\\\src");\n        //2.创建对象表示目的地\n        File dest = new File("D:\\\\aaa\\\\dest");\n\n        //3.调用方法开始拷贝\n        copydir(src,dest);\n\n\n\n    }\n\n    /*\n    * 作用：拷贝文件夹\n    * 参数一：数据源\n    * 参数二：目的地\n    *\n    * */\n    private static void copydir(File src, File dest) throws IOException {\n        dest.mkdirs();\n        //递归\n        //1.进入数据源\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断文件，拷贝\n                FileInputStream fis = new FileInputStream(file);\n                FileOutputStream fos = new FileOutputStream(new File(dest,file.getName()));\n                byte[] bytes = new byte[1024];\n                int len;\n                while((len = fis.read(bytes)) != -1){\n                    fos.write(bytes,0,len);\n                }\n                fos.close();\n                fis.close();\n            }else {\n                //4.判断文件夹，递归\n                copydir(file, new File(dest,file.getName()));\n            }\n        }\n    }\n}\n\n```\n\n## 练习2：文件加密\n\n```java\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        /*\n            为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。\n            加密原理：\n                对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。\n            解密原理：\n                读取加密之后的文件，按照加密的规则反向操作，变成原始文件。\n\n             ^ : 异或\n                 两边相同：false\n                 两边不同：true\n\n                 0：false\n                 1：true\n\n               100:1100100\n               10: 1010\n\n               1100100\n             ^ 0001010\n             __________\n               1101110\n             ^ 0001010\n             __________\n               1100100\n\n        */\n    }\n\n    public static void encryptionAndReduction(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while ((b = fis.read()) != -1) {\n            fos.write(b ^ 2);\n        }\n        //4.释放资源\n        fos.close();\n        fis.close();\n    }\n\n\n}\n\n```\n\n## 练习3：数字排序\n\n文本文件中有以下的数据：\n                2-1-9-4-7-8\n 将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n\n实现方式一：\n\n```java\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n        */\n\n\n        //1.读取数据\n        FileReader fr = new FileReader("myio\\\\a.txt");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        String str = sb.toString();\n        String[] arrStr = str.split("-");//2-1-9-4-7-8\n\n        ArrayList<Integer> list = new ArrayList<>();\n        for (String s : arrStr) {\n            int i = Integer.parseInt(s);\n            list.add(i);\n        }\n        Collections.sort(list);\n        System.out.println(list);\n        //3.写出\n        FileWriter fw = new FileWriter("myio\\\\a.txt");\n        for (int i = 0; i < list.size(); i++) {\n            if(i == list.size() - 1){\n                fw.write(list.get(i) + "");\n            }else{\n                fw.write(list.get(i) + "-");\n            }\n        }\n        fw.close();\n    }\n}\n```\n\n实现方式二：\n\n```java\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n\n           细节1：\n                文件中的数据不要换行\n\n            细节2:\n                bom头\n        */\n        //1.读取数据\n        FileReader fr = new FileReader("myio\\\\a.txt");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        Integer[] arr = Arrays.stream(sb.toString()\n                                      .split("-"))\n            .map(Integer::parseInt)\n            .sorted()\n            .toArray(Integer[]::new);\n        //3.写出\n        FileWriter fw = new FileWriter("myio\\\\a.txt");\n        String s = Arrays.toString(arr).replace(", ","-");\n        String result = s.substring(1, s.length() - 1);\n        fw.write(result);\n        fw.close();\n    }\n}\n```\n\n'},{title:"IO流（其他流）",headers:[{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:2,title:"1.2 字节缓冲流",slug:"_1-2-字节缓冲流",link:"#_1-2-字节缓冲流",children:[{level:3,title:"构造方法",slug:"构造方法",link:"#构造方法",children:[]},{level:3,title:"效率测试",slug:"效率测试",link:"#效率测试",children:[]}]},{level:2,title:"1.3 字符缓冲流",slug:"_1-3-字符缓冲流",link:"#_1-3-字符缓冲流",children:[{level:3,title:"构造方法",slug:"构造方法-1",link:"#构造方法-1",children:[]},{level:3,title:"特有方法",slug:"特有方法",link:"#特有方法",children:[]}]},{level:2,title:"1.4 练习:文本排序",slug:"_1-4-练习-文本排序",link:"#_1-4-练习-文本排序",children:[{level:3,title:"案例分析",slug:"案例分析",link:"#案例分析",children:[]},{level:3,title:"案例实现",slug:"案例实现",link:"#案例实现",children:[]}]},{level:2,title:"2.1 字符编码和字符集",slug:"_2-1-字符编码和字符集",link:"#_2-1-字符编码和字符集",children:[{level:3,title:"字符编码",slug:"字符编码",link:"#字符编码",children:[]},{level:3,title:"字符集",slug:"字符集",link:"#字符集",children:[]}]},{level:2,title:"2.2 编码引出的问题",slug:"_2-2-编码引出的问题",link:"#_2-2-编码引出的问题",children:[]},{level:2,title:"2.3 InputStreamReader类",slug:"_2-3-inputstreamreader类",link:"#_2-3-inputstreamreader类",children:[{level:3,title:"构造方法",slug:"构造方法-2",link:"#构造方法-2",children:[]},{level:3,title:"指定编码读取",slug:"指定编码读取",link:"#指定编码读取",children:[]}]},{level:2,title:"2.4 OutputStreamWriter类",slug:"_2-4-outputstreamwriter类",link:"#_2-4-outputstreamwriter类",children:[{level:3,title:"构造方法",slug:"构造方法-3",link:"#构造方法-3",children:[]},{level:3,title:"指定编码写出",slug:"指定编码写出",link:"#指定编码写出",children:[]},{level:3,title:"转换流理解图解",slug:"转换流理解图解",link:"#转换流理解图解",children:[]}]},{level:2,title:"2.5 练习：转换文件编码",slug:"_2-5-练习-转换文件编码",link:"#_2-5-练习-转换文件编码",children:[{level:3,title:"案例分析",slug:"案例分析-1",link:"#案例分析-1",children:[]},{level:3,title:"案例实现",slug:"案例实现-1",link:"#案例实现-1",children:[]}]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 ObjectOutputStream类",slug:"_3-2-objectoutputstream类",link:"#_3-2-objectoutputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-4",link:"#构造方法-4",children:[]},{level:3,title:"序列化操作",slug:"序列化操作",link:"#序列化操作",children:[]}]},{level:2,title:"3.3 ObjectInputStream类",slug:"_3-3-objectinputstream类",link:"#_3-3-objectinputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-5",link:"#构造方法-5",children:[]},{level:3,title:"反序列化操作1",slug:"反序列化操作1",link:"#反序列化操作1",children:[]},{level:3,title:"反序列化操作2",slug:"反序列化操作2",link:"#反序列化操作2",children:[]}]},{level:2,title:"3.4 练习：序列化集合",slug:"_3-4-练习-序列化集合",link:"#_3-4-练习-序列化集合",children:[{level:3,title:"案例分析",slug:"案例分析-2",link:"#案例分析-2",children:[]},{level:3,title:"案例实现",slug:"案例实现-2",link:"#案例实现-2",children:[]}]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 PrintStream类",slug:"_4-2-printstream类",link:"#_4-2-printstream类",children:[{level:3,title:"构造方法",slug:"构造方法-6",link:"#构造方法-6",children:[]},{level:3,title:"改变打印流向",slug:"改变打印流向",link:"#改变打印流向",children:[]}]}],path:"/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html",pathLocale:"/",extraFields:'---\ntitle: IO流（其他流）\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nIO流（其他流）\n\n\x3c!-- more --\x3e\n# 1. 缓冲流\n\n昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。\n\n## 1.1 概述\n\n缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：\n\n* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` \n* **字符缓冲流**：`BufferedReader`，`BufferedWriter`\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n## 1.2 字节缓冲流\n\n### 构造方法\n\n* `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));\n```\n\n### 效率测试\n\n查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。\n\n1. 基本流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tFileInputStream fis = new FileInputStream("jdk9.exe");\n        \tFileOutputStream fos = new FileOutputStream("copy.exe")\n        ){\n        \t// 读写数据\n            int b;\n            while ((b = fis.read()) != -1) {\n                fos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("普通流复制时间:"+(end - start)+" 毫秒");\n    }\n}\n\n十几分钟过去了...\n```\n\n2. 缓冲流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tBufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));\n\t     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));\n        ){\n        // 读写数据\n            int b;\n            while ((b = bis.read()) != -1) {\n                bos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("缓冲流复制时间:"+(end - start)+" 毫秒");\n    }\n}\n\n缓冲流复制时间:8016 毫秒\n```\n如何更快呢？\n\n使用数组的方式，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n      \t// 记录开始时间\n        long start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));\n\t\t BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));\n        ){\n          \t// 读写数据\n            int len;\n            byte[] bytes = new byte[8*1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0 , len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("缓冲流使用数组复制时间:"+(end - start)+" 毫秒");\n    }\n}\n缓冲流使用数组复制时间:666 毫秒\n```\n\n## 1.3 字符缓冲流\n\n### 构造方法\n\n* `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader("br.txt"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));\n```\n\n### 特有方法\n\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\n* BufferedReader：`public String readLine()`: 读一行文字。 \n* BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 \n\n`readLine`方法演示，代码如下：\n\n```java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      \t // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader("in.txt"));\n\t\t// 定义字符串,保存读取的一行文字\n        String line  = null;\n      \t// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println("------");\n        }\n\t\t// 释放资源\n        br.close();\n    }\n}\n```\n\n`newLine`方法演示，代码如下：\n\n  ```java\npublic class BufferedWriterDemo throws IOException {\n    public static void main(String[] args) throws IOException  {\n      \t// 创建流对象\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter("out.txt"));\n      \t// 写出数据\n        bw.write("黑马");\n      \t// 写出换行\n        bw.newLine();\n        bw.write("程序");\n        bw.newLine();\n        bw.write("员");\n        bw.newLine();\n\t\t// 释放资源\n        bw.close();\n    }\n}\n输出效果:\n黑马\n程序\n员\n  ```\n\n## 1.4 练习:文本排序\n\n请将文本信息恢复顺序。\n\n```\n3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n```\n\n### 案例分析\n\n1. 逐行读取文本信息。\n2. 把读取到的文本存储到集合中\n3. 对集合中的文本进行排序\n4. 遍历集合，按顺序，写出文本信息。\n\n### 案例实现\n\n```java\npublic class Demo05Test {\n    public static void main(String[] args) throws IOException {\n        //1.创建ArrayList集合,泛型使用String\n        ArrayList<String> list = new ArrayList<>();\n        //2.创建BufferedReader对象,构造方法中传递FileReader对象\n        BufferedReader br = new BufferedReader(new FileReader("10_IO\\\\in.txt"));\n        //3.创建BufferedWriter对象,构造方法中传递FileWriter对象\n        BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\\\out.txt"));\n        //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本\n        String line;\n        while((line = br.readLine())!=null){\n            //5.把读取到的文本存储到ArrayList集合中\n            list.add(line);\n        }\n        //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序\n        Collections.sort(list, new Comparator<String>() {\n            /*\n                o1-o2:升序\n                o2-o1:降序\n             */\n            @Override\n            public int compare(String o1, String o2) {\n                //依次比较集合中两个元素的首字母,升序排序\n                return o1.charAt(0)-o2.charAt(0);\n            }\n        });\n        //7.遍历ArrayList集合,获取每一个元素\n        for (String s : list) {\n            //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中)\n            bw.write(s);\n            //9.写换行\n            bw.newLine();\n        }\n        //10.释放资源\n        bw.close();\n        br.close();\n    }\n}\n```\n\n\n\n# 2. 转换流\n\n## 2.1 字符编码和字符集\n\n### 字符编码\n\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)--\x3e字符(能看懂的)\n\n* **字符编码`Character Encoding`** : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n  编码表:生活中文字和计算机中二进制的对应规则\n\n### 字符集\n\n* **字符集 `Charset`**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。![](img/1_charset.jpg)\n\n可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。\n\n* **ASCII字符集** ：\n  * ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n  * 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n* **ISO-8859-1字符集**：\n  * 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\n  * ISO-8859-1使用单字节编码，兼容ASCII编码。\n* **GBxxx字符集**：\n  * GB就是国标的意思，是为了显示中文而设计的一套字符集。\n  * **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。\n  * **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n  * **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n* **Unicode字符集** ：\n  * Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n  * 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\n  * UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n    1. 128个US-ASCII字符，只需一个字节编码。\n    2. 拉丁文等字符，需要二个字节编码。 \n    3. 大部分常用字（含中文），使用三个字节编码。\n    4. 其他极少使用的Unicode辅助字符，使用四字节编码。\n\n## 2.2 编码引出的问题\n\n在IDEA中，使用`FileReader` 读取项目中的文本文件。由于IDEA的设置，都是默认的`UTF-8`编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n```java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader("E:\\\\File_GBK.txt");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：\n���\n```\n\n那么如何读取GBK编码的文件呢？ \n\n## 2.3 InputStreamReader类  \n\n转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n* `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \n* `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nInputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");\n```\n\n### 指定编码读取\n\n```java\npublic class ReaderDemo2 {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径,文件为gbk编码\n        String FileName = "E:\\\\file_gbk.txt";\n      \t// 创建流对象,默认UTF8编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n      \t// 创建流对象,指定GBK编码\n        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK");\n\t\t// 定义变量,保存字符\n        int read;\n      \t// 使用默认编码字符流读取,乱码\n        while ((read = isr.read()) != -1) {\n            System.out.print((char)read); // ��Һ�\n        }\n        isr.close();\n      \n      \t// 使用指定编码字符流读取,正常解析\n        while ((read = isr2.read()) != -1) {\n            System.out.print((char)read);// 大家好\n        }\n        isr2.close();\n    }\n}\n```\n\n## 2.4 OutputStreamWriter类\n\n转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \n- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK");\n```\n\n### 指定编码写出\n\n```java\npublic class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径\n        String FileName = "E:\\\\out.txt";\n      \t// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      \tosw.write("你好"); // 保存为6个字节\n        osw.close();\n      \t\n\t\t// 定义文件路径\n\t\tString FileName2 = "E:\\\\out2.txt";\n     \t// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK");\n        // 写出数据\n      \tosw2.write("你好");// 保存为4个字节\n        osw2.close();\n    }\n}\n```\n\n### 转换流理解图解\n\n**转换流是字节与字符间的桥梁！**![](img/2_zhuanhuan.jpg)\n\n## 2.5 练习：转换文件编码\n\n将GBK编码的文本文件，转换为UTF-8编码的文本文件。\n\n### 案例分析\n\n1. 指定GBK编码的转换流，读取文本文件。\n2. 使用UTF-8编码的转换流，写出文本文件。\n\n### 案例实现\n\n```java\npublic class TransDemo {\n   public static void main(String[] args) {      \n    \t// 1.定义文件路径\n     \tString srcFile = "file_gbk.txt";\n        String destFile = "file_utf8.txt";\n\t\t// 2.创建流对象\n    \t// 2.1 转换输入流,指定GBK编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK");\n    \t// 2.2 转换输出流,默认utf8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));\n\t\t// 3.读写数据\n    \t// 3.1 定义数组\n        char[] cbuf = new char[1024];\n    \t// 3.2 定义长度\n        int len;\n    \t// 3.3 循环读取\n        while ((len = isr.read(cbuf))!=-1) {\n            // 循环写出\n          \tosw.write(cbuf,0,len);\n        }\n    \t// 4.释放资源\n        osw.close();\n        isr.close();\n  \t}\n}\n```\n\n# 3. 序列化\n\n## 3.1 概述\n\nJava 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 \n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。看图理解序列化： ![](img/3_xuliehua.jpg)\n\n## 3.2 ObjectOutputStream类\n\n`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n### 构造方法\n\n* `public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。\n\n构造举例，代码如下：  \n\n```java\nFileOutputStream fileOut = new FileOutputStream("employee.txt");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n### 序列化操作\n\n1. 一个对象要想序列化，必须满足两个条件:\n\n* 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。\n* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。\n\n```java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age; // transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n      \tSystem.out.println("Address  check : " + name + " -- " + address);\n    }\n}\n```\n\n2.写出对象方法\n\n* `public final void writeObject (Object obj)` : 将指定的对象写出。\n\n```java\npublic class SerializeDemo{\n   \tpublic static void main(String [] args)   {\n    \tEmployee e = new Employee();\n    \te.name = "zhangsan";\n    \te.address = "beiqinglu";\n    \te.age = 20; \n    \ttry {\n      \t\t// 创建序列化流对象\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt"));\n        \t// 写出对象\n        \tout.writeObject(e);\n        \t// 释放资源\n        \tout.close();\n        \tfileOut.close();\n        \tSystem.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。\n        } catch(IOException i)   {\n            i.printStackTrace();\n        }\n   \t}\n}\n输出结果：\nSerialized data is saved\n```\n\n## 3.3 ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n\n### 构造方法\n\n* `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。\n\n### 反序列化操作1\n\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：\n\n- `public final Object readObject ()` : 读取一个对象。\n\n```java\npublic class DeserializeDemo {\n   public static void main(String [] args)   {\n        Employee e = null;\n        try {\t\t\n             // 创建反序列化流\n             FileInputStream fileIn = new FileInputStream("employee.txt");\n             ObjectInputStream in = new ObjectInputStream(fileIn);\n             // 读取一个对象\n             e = (Employee) in.readObject();\n             // 释放资源\n             in.close();\n             fileIn.close();\n        }catch(IOException i) {\n             // 捕获其他异常\n             i.printStackTrace();\n             return;\n        }catch(ClassNotFoundException c)  {\n        \t// 捕获类找不到异常\n             System.out.println("Employee class not found");\n             c.printStackTrace();\n             return;\n        }\n        // 无异常,直接打印输出\n        System.out.println("Name: " + e.name);\t// zhangsan\n        System.out.println("Address: " + e.address); // beiqinglu\n        System.out.println("age: " + e.age); // 0\n    }\n}\n```\n\n**对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。**  \n\n### **反序列化操作2**\n\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：\n\n* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n* 该类包含未知数据类型 \n* 该类没有可访问的无参数构造方法 \n\n`Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n```java\npublic class Employee implements java.io.Serializable {\n     // 加入序列版本号\n     private static final long serialVersionUID = 1L;\n     public String name;\n     public String address;\n     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n     public int eid; \n\n     public void addressCheck() {\n         System.out.println("Address  check : " + name + " -- " + address);\n     }\n}\n```\n\n\n\n## 3.4 练习：序列化集合\n\n1. 将存有多个自定义对象的集合序列化操作，保存到`list.txt`文件中。\n2. 反序列化`list.txt` ，并遍历集合，打印对象信息。\n\n### 案例分析\n\n1. 把若干学生对象 ，保存到集合中。\n2. 把集合序列化。\n3. 反序列化读取时，只需要读取一次，转换为集合类型。\n4. 遍历集合，可以打印所有的学生信息\n\n### 案例实现\n\n```java\npublic class SerTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 创建 学生对象\n\t\tStudent student = new Student("老王", "laow");\n\t\tStudent student2 = new Student("老张", "laoz");\n\t\tStudent student3 = new Student("老李", "laol");\n\n\t\tArrayList<Student> arrayList = new ArrayList<>();\n\t\tarrayList.add(student);\n\t\tarrayList.add(student2);\n\t\tarrayList.add(student3);\n\t\t// 序列化操作\n\t\t// serializ(arrayList);\n\t\t\n\t\t// 反序列化  \n\t\tObjectInputStream ois  = new ObjectInputStream(new FileInputStream("list.txt"));\n\t\t// 读取对象,强转为ArrayList类型\n\t\tArrayList<Student> list  = (ArrayList<Student>)ois.readObject();\n\t\t\n      \tfor (int i = 0; i < list.size(); i++ ){\n          \tStudent s = list.get(i);\n        \tSystem.out.println(s.getName()+"--"+ s.getPwd());\n      \t}\n\t}\n\n\tprivate static void serializ(ArrayList<Student> arrayList) throws Exception {\n\t\t// 创建 序列化流 \n\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("list.txt"));\n\t\t// 写出对象\n\t\toos.writeObject(arrayList);\n\t\t// 释放资源\n\t\toos.close();\n\t}\n}\n```\n\n\n#  4. 打印流\n\n## 4.1 概述\n\n平时我们在控制台打印输出，是调用`print`方法和`println`方法完成的，这两个方法都来自于`java.io.PrintStream`类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n\n## 4.2 PrintStream类\n\n### 构造方法\n\n* `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的打印流。\n\n构造举例，代码如下：  \n\n```java\nPrintStream ps = new PrintStream("ps.txt")；\n```\n\n### 改变打印流向\n\n`System.out`就是`PrintStream`类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个"小把戏"，改变它的流向。\n\n```java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n\t\t// 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n      \n\t\t// 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream("ps.txt");\n      \t\n      \t// 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n      \t// 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n# 5. 压缩流和解压缩流\n\n压缩流：\n\n​\t负责压缩文件或者文件夹\n\n解压缩流：\n\n​\t负责把压缩包中的文件和文件夹解压出来\n\n```java\n/*\n*   解压缩流\n*\n* */\npublic class ZipStreamDemo1 {\n    public static void main(String[] args) throws IOException {\n\n        //1.创建一个File表示要解压的压缩包\n        File src = new File("D:\\\\aaa.zip");\n        //2.创建一个File表示解压的目的地\n        File dest = new File("D:\\\\");\n\n        //调用方法\n        unzip(src,dest);\n\n    }\n\n    //定义一个方法用来解压\n    public static void unzip(File src,File dest) throws IOException {\n        //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中\n        //创建一个解压缩流用来读取压缩包中的数据\n        ZipInputStream zip = new ZipInputStream(new FileInputStream(src));\n        //要先获取到压缩包里面的每一个zipentry对象\n        //表示当前在压缩包中获取到的文件或者文件夹\n        ZipEntry entry;\n        while((entry = zip.getNextEntry()) != null){\n            System.out.println(entry);\n            if(entry.isDirectory()){\n                //文件夹：需要在目的地dest处创建一个同样的文件夹\n                File file = new File(dest,entry.toString());\n                file.mkdirs();\n            }else{\n                //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）\n                FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));\n                int b;\n                while((b = zip.read()) != -1){\n                    //写到目的地\n                    fos.write(b);\n                }\n                fos.close();\n                //表示在压缩包中的一个文件处理完毕了。\n                zip.closeEntry();\n            }\n        }\n        zip.close();\n    }\n}\n```\n\n```java\npublic class ZipStreamDemo2 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\a.txt打包成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件\n        File src = new File("D:\\\\a.txt");\n        //2.创建File对象表示压缩包的位置\n        File dest = new File("D:\\\\");\n        //3.调用方法用来压缩\n        toZip(src,dest);\n    }\n\n    /*\n    *   作用：压缩\n    *   参数一：表示要压缩的文件\n    *   参数二：表示压缩包的位置\n    * */\n    public static void toZip(File src,File dest) throws IOException {\n        //1.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,"a.zip")));\n        //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹\n        //参数：压缩包里面的路径\n        ZipEntry entry = new ZipEntry("aaa\\\\bbb\\\\a.txt");\n        //3.把ZipEntry对象放到压缩包当中\n        zos.putNextEntry(entry);\n        //4.把src文件中的数据写到压缩包当中\n        FileInputStream fis = new FileInputStream(src);\n        int b;\n        while((b = fis.read()) != -1){\n            zos.write(b);\n        }\n        zos.closeEntry();\n        zos.close();\n    }\n}\n```\n\n```java\npublic class ZipStreamDemo3 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\aaa文件夹压缩成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件夹\n        File src = new File("D:\\\\aaa");\n        //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）\n        File destParent = src.getParentFile();//D:\\\\\n        //3.创建File对象表示压缩包的路径\n        File dest = new File(destParent,src.getName() + ".zip");\n        //4.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));\n        //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n        toZip(src,zos,src.getName());//aaa\n        //6.释放资源\n        zos.close();\n    }\n\n    /*\n    *   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n    *   参数一：数据源\n    *   参数二：压缩流\n    *   参数三：压缩包内部的路径\n    * */\n    public static void toZip(File src,ZipOutputStream zos,String name) throws IOException {\n        //1.进入src文件夹\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断-文件，变成ZipEntry对象，放入到压缩包当中\n                ZipEntry entry = new ZipEntry(name + "\\\\" + file.getName());//aaa\\\\no1\\\\a.txt\n                zos.putNextEntry(entry);\n                //读取文件中的数据，写到压缩包\n                FileInputStream fis = new FileInputStream(file);\n                int b;\n                while((b = fis.read()) != -1){\n                    zos.write(b);\n                }\n                fis.close();\n                zos.closeEntry();\n            }else{\n                //4.判断-文件夹，递归\n                toZip(file,zos,name + "\\\\" + file.getName());\n                //     no1            aaa   \\\\   no1\n            }\n        }\n    }\n}\n```\n\n# 6. 工具包（Commons-io）\n\n介绍：\n\n​\tCommons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API\n\n比如：\n\n​\tStringUtils   字符串工具类\n\n​\tNumberUtils   数字工具类 \n\n​\tArrayUtils   数组工具类  \n\n​\tRandomUtils   随机数工具类\n\n​\tDateUtils   日期工具类 \n\n​\tStopWatch   秒表工具类 \n\n​\tClassUtils   反射工具类  \n\n​\tSystemUtils   系统工具类  \n\n​\tMapUtils   集合工具类\n\n​\tBeanutils   bean工具类\n\n​\tCommons-io io的工具类\n\n​\t等等.....\n\n其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。\n\n作用：提高IO流的开发效率。\n\n使用方式：\n\n1，新建lib文件夹\n\n2，把第三方jar包粘贴到文件夹中\n\n3，右键点击add as a library\n\n代码示例：\n\n```java\npublic class CommonsIODemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n          FileUtils类\n                static void copyFile(File srcFile, File destFile)                   复制文件\n                static void copyDirectory(File srcDir, File destDir)                复制文件夹\n                static void copyDirectoryToDirectory(File srcDir, File destDir)     复制文件夹\n                static void deleteDirectory(File directory)                         删除文件夹\n                static void cleanDirectory(File directory)                          清空文件夹\n                static String readFileToString(File file, Charset encoding)         读取文件中的数据变成成字符串\n                static void write(File file, CharSequence data, String encoding)    写出数据\n\n            IOUtils类\n                public static int copy(InputStream input, OutputStream output)      复制文件\n                public static int copyLarge(Reader input, Writer output)            复制大文件\n                public static String readLines(Reader input)                        读取数据\n                public static void write(String data, OutputStream output)          写出数据\n         */\n\n\n        /* File src = new File("myio\\\\a.txt");\n        File dest = new File("myio\\\\copy.txt");\n        FileUtils.copyFile(src,dest);*/\n\n\n        /*File src = new File("D:\\\\aaa");\n        File dest = new File("D:\\\\bbb");\n        FileUtils.copyDirectoryToDirectory(src,dest);*/\n\n        /*File src = new File("D:\\\\bbb");\n        FileUtils.cleanDirectory(src);*/\n\n\n\n    }\n}\n\n```\n\n# 7. 工具包（hutool）\n\n介绍：\n\n​\tCommons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API\n\n比如：\n\n​\tDateUtil  日期时间工具类 \n\n​\tTimeInterval  计时器工具类 \n\n​\tStrUtil  字符串工具类\n\n​\tHexUtil   16进制工具类\n\n​\tHashUtil   Hash算法类\n\n​\tObjectUtil  对象工具类\n\n​\tReflectUtil   反射工具类\n\n​\tTypeUtil  泛型类型工具类\n\n​\tPageUtil  分页工具类\n\n​\tNumberUtil  数字工具类\n\n使用方式：\n\n1，新建lib文件夹\n\n2，把第三方jar包粘贴到文件夹中\n\n3，右键点击add as a library\n\n代码示例：\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n    /*\n        FileUtil类:\n                file：根据参数创建一个file对象\n                touch：根据参数创建文件\n\n                writeLines：把集合中的数据写出到文件中，覆盖模式。\n                appendLines：把集合中的数据写出到文件中，续写模式。\n                readLines：指定字符编码，把文件中的数据，读到集合中。\n                readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中\n\n                copy：拷贝文件或者文件夹\n    */\n\n\n       /* File file1 = FileUtil.file("D:\\\\", "aaa", "bbb", "a.txt");\n        System.out.println(file1);//D:\\aaa\\bbb\\a.txt\n\n        File touch = FileUtil.touch(file1);\n        System.out.println(touch);\n\n\n        ArrayList<String> list = new ArrayList<>();\n        list.add("aaa");\n        list.add("aaa");\n        list.add("aaa");\n\n        File file2 = FileUtil.writeLines(list, "D:\\\\a.txt", "UTF-8");\n        System.out.println(file2);*/\n\n      /*  ArrayList<String> list = new ArrayList<>();\n        list.add("aaa");\n        list.add("aaa");\n        list.add("aaa");\n        File file3 = FileUtil.appendLines(list, "D:\\\\a.txt", "UTF-8");\n        System.out.println(file3);*/\n        List<String> list = FileUtil.readLines("D:\\\\a.txt", "UTF-8");\n        System.out.println(list);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n'},{title:"实现多线程",headers:[{level:2,title:"1.实现多线程",slug:"_1-实现多线程",link:"#_1-实现多线程",children:[{level:3,title:"1.1简单了解多线程【理解】",slug:"_1-1简单了解多线程【理解】",link:"#_1-1简单了解多线程【理解】",children:[]},{level:3,title:"1.2并发和并行【理解】",slug:"_1-2并发和并行【理解】",link:"#_1-2并发和并行【理解】",children:[]},{level:3,title:"1.3进程和线程【理解】",slug:"_1-3进程和线程【理解】",link:"#_1-3进程和线程【理解】",children:[]},{level:3,title:"1.4实现多线程方式一：继承Thread类【应用】",slug:"_1-4实现多线程方式一-继承thread类【应用】",link:"#_1-4实现多线程方式一-继承thread类【应用】",children:[]},{level:3,title:"1.5实现多线程方式二：实现Runnable接口【应用】",slug:"_1-5实现多线程方式二-实现runnable接口【应用】",link:"#_1-5实现多线程方式二-实现runnable接口【应用】",children:[]},{level:3,title:"1.6实现多线程方式三: 实现Callable接口【应用】",slug:"_1-6实现多线程方式三-实现callable接口【应用】",link:"#_1-6实现多线程方式三-实现callable接口【应用】",children:[]},{level:3,title:"1.7设置和获取线程名称【应用】",slug:"_1-7设置和获取线程名称【应用】",link:"#_1-7设置和获取线程名称【应用】",children:[]},{level:3,title:"1.8线程休眠【应用】",slug:"_1-8线程休眠【应用】",link:"#_1-8线程休眠【应用】",children:[]},{level:3,title:"1.9线程优先级【应用】",slug:"_1-9线程优先级【应用】",link:"#_1-9线程优先级【应用】",children:[]},{level:3,title:"1.10守护线程【应用】",slug:"_1-10守护线程【应用】",link:"#_1-10守护线程【应用】",children:[]}]},{level:2,title:"2.线程同步",slug:"_2-线程同步",link:"#_2-线程同步",children:[{level:3,title:"2.1卖票【应用】",slug:"_2-1卖票【应用】",link:"#_2-1卖票【应用】",children:[]},{level:3,title:"2.2卖票案例的问题【理解】",slug:"_2-2卖票案例的问题【理解】",link:"#_2-2卖票案例的问题【理解】",children:[]},{level:3,title:"2.3同步代码块解决数据安全问题【应用】",slug:"_2-3同步代码块解决数据安全问题【应用】",link:"#_2-3同步代码块解决数据安全问题【应用】",children:[]},{level:3,title:"2.4同步方法解决数据安全问题【应用】",slug:"_2-4同步方法解决数据安全问题【应用】",link:"#_2-4同步方法解决数据安全问题【应用】",children:[]},{level:3,title:"2.5Lock锁【应用】",slug:"_2-5lock锁【应用】",link:"#_2-5lock锁【应用】",children:[]},{level:3,title:"2.6死锁【理解】",slug:"_2-6死锁【理解】",link:"#_2-6死锁【理解】",children:[]}]},{level:2,title:"3.生产者消费者",slug:"_3-生产者消费者",link:"#_3-生产者消费者",children:[{level:3,title:"3.1生产者和消费者模式概述【应用】",slug:"_3-1生产者和消费者模式概述【应用】",link:"#_3-1生产者和消费者模式概述【应用】",children:[]},{level:3,title:"3.2生产者和消费者案例【应用】",slug:"_3-2生产者和消费者案例【应用】",link:"#_3-2生产者和消费者案例【应用】",children:[]},{level:3,title:"3.3生产者和消费者案例优化【应用】",slug:"_3-3生产者和消费者案例优化【应用】",link:"#_3-3生产者和消费者案例优化【应用】",children:[]},{level:3,title:"3.4阻塞队列基本使用【理解】",slug:"_3-4阻塞队列基本使用【理解】",link:"#_3-4阻塞队列基本使用【理解】",children:[]},{level:3,title:"3.5阻塞队列实现等待唤醒机制【理解】",slug:"_3-5阻塞队列实现等待唤醒机制【理解】",link:"#_3-5阻塞队列实现等待唤醒机制【理解】",children:[]}]}],path:"/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html",pathLocale:"/",extraFields:'---\ntitle: 实现多线程\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n实现多线程\n\n\x3c!-- more --\x3e\n## 1.实现多线程\n\n### 1.1简单了解多线程【理解】\n\n是指从软件或者硬件上实现多个线程并发执行的技术。\n具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n\n![01_简单了解多线程](.\\img\\01_简单了解多线程.png)\n\n### 1.2并发和并行【理解】\n\n+ 并行：在同一时刻，有多个指令在多个CPU上同时执行。\n\n  ![02_并行](.\\img\\02_并行.png)\n\n+ 并发：在同一时刻，有多个指令在单个CPU上交替执行。\n\n  ![03_并发](.\\img\\03_并发.png)\n\n### 1.3进程和线程【理解】\n\n- 进程：是正在运行的程序\n\n  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位\n  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的\n  并发性：任何进程都可以同其他进程一起并发执行\n\n- 线程：是进程中的单个顺序控制流，是一条执行路径\n\n  ​\t单线程：一个进程如果只有一条执行路径，则称为单线程程序\n\n  ​\t多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n  ​\t![04_多线程示例](.\\img\\04_多线程示例.png)\n\n### 1.4实现多线程方式一：继承Thread类【应用】\n\n- 方法介绍\n\n  | 方法名          | 说明                         |\n  | ------------ | -------------------------- |\n  | void run()   | 在线程开启后，此方法将被调用执行           |\n  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n- 实现步骤\n  - 定义一个类MyThread继承Thread类\n  - 在MyThread类中重写run()方法\n  - 创建MyThread类的对象\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }\n  ```\n\n- 两个小问题\n\n  - 为什么要重写run()方法？\n\n    因为run()是用来封装被线程执行的代码\n\n  - run()方法和start()方法的区别？\n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用\n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n### 1.5实现多线程方式二：实现Runnable接口【应用】\n\n- Thread构造方法\n\n  | 方法名                                  | 说明             |\n  | ------------------------------------ | -------------- |\n  | Thread(Runnable target)              | 分配一个新的Thread对象 |\n  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n- 实现步骤\n\n  - 定义一个类MyRunnable实现Runnable接口\n  - 在MyRunnable类中重写run()方法\n  - 创建MyRunnable类的对象\n  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n  - 启动线程\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+":"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n\n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,"坦克");\n          Thread t2 = new Thread(my,"飞机");\n\n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.6实现多线程方式三: 实现Callable接口【应用】\n\n+ 方法介绍\n\n  | 方法名                              | 说明                                  |\n  | -------------------------------- | ----------------------------------- |\n  | V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               |\n  | `FutureTask(Callable<V> callable)` | 创建一个 FutureTask，一旦运行就执行给定的 Callable |\n  | V get()                          | 如有必要，等待计算完成，然后获取其结果                 |\n\n+ 实现步骤\n\n  + 定义一个类MyCallable实现Callable接口\n  + 在MyCallable类中重写call()方法\n  + 创建MyCallable类的对象\n  + 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数\n  + 创建Thread类的对象，把FutureTask对象作为构造方法的参数\n  + 启动线程\n  + 再调用get方法，就可以获取线程结束之后的结果。\n\n+ 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println("跟女孩表白" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return "答应";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }\n  ```\n\n+ 三种实现方式的对比\n  + 实现Runnable、Callable接口\n    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类\n    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法\n  + 继承Thread类\n    + 好处: 编程比较简单，可以直接使用Thread类中的方法\n    + 缺点: 可以扩展性较差，不能再继承其他的类\n\n### 1.7设置和获取线程名称【应用】\n\n- 方法介绍\n\n  | 方法名                        | 说明                 |\n  | -------------------------- | ------------------ |\n  | void  setName(String name) | 将此线程的名称更改为等于参数name |\n  | String  getName()          | 返回此线程的名称           |\n  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |\n\n- 代码演示\n\n  ```java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+":"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName("高铁");\n          my2.setName("飞机");\n\n          //Thread(String name)\n          MyThread my1 = new MyThread("高铁");\n          MyThread my2 = new MyThread("飞机");\n\n          my1.start();\n          my2.start();\n\n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }\n  ```\n\n### 1.8线程休眠【应用】\n\n+ 相关方法\n\n  | 方法名                            | 说明                       |\n  | ------------------------------ | ------------------------ |\n  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |\n\n+ 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println("睡觉前");\n          Thread.sleep(3000);\n          System.out.println("睡醒了");*/\n\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n### 1.9线程优先级【应用】\n\n- 线程调度\n\n  - 两种调度方式\n    - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\n    - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\n\n  - Java使用的是抢占式调度模型\n\n  - 随机性\n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n    ![05_多线程示例图](.\\img\\05_多线程示例图.png)\n\n- 优先级相关方法\n\n  | 方法名                                     | 说明                                |\n  | --------------------------------------- | --------------------------------- |\n  | final int getPriority()                 | 返回此线程的优先级                         |\n  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |\n\n- 代码演示\n\n  ```java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n          return "线程执行完毕了";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          Thread t1 = new Thread(ft);\n          t1.setName("飞机");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n\n          MyCallable mc2 = new MyCallable();\n\n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n\n          Thread t2 = new Thread(ft2);\n          t2.setName("坦克");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }\n  ```\n\n### 1.10守护线程【应用】\n\n- 相关方法\n\n  | 方法名                        | 说明                                   |\n  | -------------------------- | ------------------------------------ |\n  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n- 代码演示\n\n  ```java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n\n          t1.setName("女神");\n          t2.setName("备胎");\n\n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n\n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n## 2.线程同步\n\n### 2.1卖票【应用】\n\n- 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n- 实现步骤\n\n  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;\n\n  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下\n\n  - 判断票数大于0，就卖票，并告知是哪个窗口卖的\n  - 卖了票之后，总票数要减1\n  - 票卖没了，线程停止\n  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下\n  - 创建SellTicket类的对象\n  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n  - 启动线程\n\n- 代码实现\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n\n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,"窗口1");\n          Thread t2 = new Thread(st,"窗口2");\n          Thread t3 = new Thread(st,"窗口3");\n\n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n\n### 2.2卖票案例的问题【理解】\n\n- 卖票出现了问题\n\n  - 相同的票出现了多次\n\n  - 出现了负数的票\n\n- 问题产生原因\n\n  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题\n\n\n### 2.3同步代码块解决数据安全问题【应用】\n\n- 安全问题出现的条件\n\n  - 是多线程环境\n\n  - 有共享数据\n\n  - 有多条语句操作共享数据\n\n- 如何解决多线程安全问题呢?\n\n  - 基本思想：让程序没有安全问题的环境\n\n- 怎么实现呢?\n\n  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可\n\n  - Java提供了同步代码块的方式来解决\n\n- 同步代码块格式：\n\n  ```java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }\n  ```\n\n  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁\n\n- 同步的好处和弊端  \n\n  - 好处：解决了多线程的数据安全问题\n\n  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率\n\n- 代码演示\n\n  ```java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n\n          Thread t1 = new Thread(st, "窗口1");\n          Thread t2 = new Thread(st, "窗口2");\n          Thread t3 = new Thread(st, "窗口3");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.4同步方法解决数据安全问题【应用】\n\n- 同步方法的格式\n\n  同步方法：就是把synchronized关键字加到方法上\n\n  ```java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步方法的锁对象是什么呢?\n\n  ​\tthis\n\n- 静态同步方法\n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n  ```java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }\n  ```\n\n  同步静态方法的锁对象是什么呢?\n\n  ​\t类名.class\n\n- 代码演示\n\n  ```java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n  \n      @Override\n      public void run() {\n          while(true){\n              if("窗口一".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n  \n              if("窗口二".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n                      }\n                  }\n              }\n  \n          }\n      }\n  \n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n              return false;\n          }\n      }\n  }\n  ```\n\n\n  public class Demo {\n      public static void main(String[] args) {\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n    \n          t1.setName("窗口一");\n          t2.setName("窗口二");\n    \n          t1.start();\n          t2.start();\n      }\n  }\n  ```\n\n\n### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示\n\n  ```java\n  public class Ticket implements Runnable {\n      //票的数量\n      private int ticket = 100;\n      private Object obj = new Object();\n      private ReentrantLock lock = new ReentrantLock();\n\n      @Override\n      public void run() {\n          while (true) {\n              //synchronized (obj){//多个线程必须使用同一把锁.\n              try {\n                  lock.lock();\n                  if (ticket <= 0) {\n                      //卖完了\n                      break;\n                  } else {\n                      Thread.sleep(100);\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              } finally {\n                  lock.unlock();\n              }\n              // }\n          }\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          Ticket ticket = new Ticket();\n\n          Thread t1 = new Thread(ticket);\n          Thread t2 = new Thread(ticket);\n          Thread t3 = new Thread(ticket);\n\n          t1.setName("窗口一");\n          t2.setName("窗口二");\n          t3.setName("窗口三");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }\n  ```\n\n### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示\n\n  ```java\n  public class Demo {\n      public static void main(String[] args) {\n          Object objA = new Object();\n          Object objB = new Object();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objA){\n                      //线程一\n                      synchronized (objB){\n                          System.out.println("小康同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n\n          new Thread(()->{\n              while(true){\n                  synchronized (objB){\n                      //线程二\n                      synchronized (objA){\n                          System.out.println("小薇同学正在走路");\n                      }\n                  }\n              }\n          }).start();\n      }\n  }\n  ```\n\n## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      public static boolean flag = false;\n\n      //汉堡包的总数量\n      public static int count = 10;\n\n      //锁对象\n      public static final Object lock = new Object();\n  }\n\n  public class Cooker extends Thread {\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n      @Override\n      public void run() {\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(!Desk.flag){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          Desk.flag = true;\n                          Desk.lock.notifyAll();\n                      }else{\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (Desk.lock){\n                  if(Desk.count == 0){\n                      break;\n                  }else{\n                      if(Desk.flag){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          Desk.flag = false;\n                          Desk.lock.notifyAll();\n                          Desk.count--;\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              Desk.lock.wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Foodie f = new Foodie();\n          Cooker c = new Cooker();\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Desk {\n\n      //定义一个标记\n      //true 就表示桌子上有汉堡包的,此时允许吃货执行\n      //false 就表示桌子上没有汉堡包的,此时允许厨师执行\n      //public static boolean flag = false;\n      private boolean flag;\n\n      //汉堡包的总数量\n      //public static int count = 10;\n      //以后我们在使用这种必须有默认值的变量\n     // private int count = 10;\n      private int count;\n\n      //锁对象\n      //public static final Object lock = new Object();\n      private final Object lock = new Object();\n\n      public Desk() {\n          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了\n      }\n\n      public Desk(boolean flag, int count) {\n          this.flag = flag;\n          this.count = count;\n      }\n\n      public boolean isFlag() {\n          return flag;\n      }\n\n      public void setFlag(boolean flag) {\n          this.flag = flag;\n      }\n\n      public int getCount() {\n          return count;\n      }\n\n      public void setCount(int count) {\n          this.count = count;\n      }\n\n      public Object getLock() {\n          return lock;\n      }\n\n      @Override\n      public String toString() {\n          return "Desk{" +\n                  "flag=" + flag +\n                  ", count=" + count +\n                  ", lock=" + lock +\n                  \'}\';\n      }\n  }\n\n  public class Cooker extends Thread {\n\n      private Desk desk;\n\n      public Cooker(Desk desk) {\n          this.desk = desk;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n\n      @Override\n      public void run() {\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(!desk.isFlag()){\n                          //生产\n                          System.out.println("厨师正在生产汉堡包");\n                          desk.setFlag(true);\n                          desk.getLock().notifyAll();\n                      }else{\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n  public class Foodie extends Thread {\n      private Desk desk;\n\n      public Foodie(Desk desk) {\n          this.desk = desk;\n      }\n\n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n\n          //套路:\n              //1. while(true)死循环\n              //2. synchronized 锁,锁对象要唯一\n              //3. 判断,共享数据是否结束. 结束\n              //4. 判断,共享数据是否结束. 没有结束\n          while(true){\n              synchronized (desk.getLock()){\n                  if(desk.getCount() == 0){\n                      break;\n                  }else{\n                      //System.out.println("验证一下是否执行了");\n                      if(desk.isFlag()){\n                          //有\n                          System.out.println("吃货在吃汉堡包");\n                          desk.setFlag(false);\n                          desk.getLock().notifyAll();\n                          desk.setCount(desk.getCount() - 1);\n                      }else{\n                          //没有就等待\n                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.\n                          try {\n                              desk.getLock().wait();\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                      }\n                  }\n              }\n          }\n\n      }\n  }\n\n  public class Demo {\n      public static void main(String[] args) {\n          /*消费者步骤：\n          1，判断桌子上是否有汉堡包。\n          2，如果没有就等待。\n          3，如果有就开吃\n          4，吃完之后，桌子上的汉堡包就没有了\n                  叫醒等待的生产者继续生产\n          汉堡包的总数量减一*/\n\n          /*生产者步骤：\n          1，判断桌子上是否有汉堡包\n          如果有就等待，如果没有才生产。\n          2，把汉堡包放在桌子上。\n          3，叫醒等待的消费者开吃。*/\n\n          Desk desk = new Desk();\n\n          Foodie f = new Foodie(desk);\n          Cooker c = new Cooker(desk);\n\n          f.start();\n          c.start();\n\n      }\n  }\n  ```\n\n### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](.\\img\\06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例\n\n  ```java\n  public class Demo02 {\n      public static void main(String[] args) throws Exception {\n          // 创建阻塞队列的对象,容量为 1\n          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);\n\n          // 存储元素\n          arrayBlockingQueue.put("汉堡包");\n\n          // 取元素\n          System.out.println(arrayBlockingQueue.take());\n          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞\n\n          System.out.println("程序结束了");\n      }\n  }\n  ```\n\n### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现\n\n  ```java\n  public class Cooker extends Thread {\n  \n      private ArrayBlockingQueue<String> bd;\n  \n      public Cooker(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  //    生产者步骤：\n  //            1，判断桌子上是否有汉堡包\n  //    如果有就等待，如果没有才生产。\n  //            2，把汉堡包放在桌子上。\n  //            3，叫醒等待的消费者开吃。\n  \n      @Override\n      public void run() {\n          while (true) {\n              try {\n                  bd.put("汉堡包");\n                  System.out.println("厨师放入一个汉堡包");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n      }\n  }\n  \n  public class Foodie extends Thread {\n      private ArrayBlockingQueue<String> bd;\n  \n      public Foodie(ArrayBlockingQueue<String> bd) {\n          this.bd = bd;\n      }\n  \n      @Override\n      public void run() {\n  //        1，判断桌子上是否有汉堡包。\n  //        2，如果没有就等待。\n  //        3，如果有就开吃\n  //        4，吃完之后，桌子上的汉堡包就没有了\n  //                叫醒等待的生产者继续生产\n  //        汉堡包的总数量减一\n  \n          //套路:\n          //1. while(true)死循环\n          //2. synchronized 锁,锁对象要唯一\n          //3. 判断,共享数据是否结束. 结束\n          //4. 判断,共享数据是否结束. 没有结束\n          while (true) {\n              try {\n                  String take = bd.take();\n                  System.out.println("吃货将" + take + "拿出来吃了");\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n          }\n  \n      }\n  }\n  \n  public class Demo {\n      public static void main(String[] args) {\n          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);\n  \n          Foodie f = new Foodie(bd);\n          Cooker c = new Cooker(bd);\n  \n          f.start();\n          c.start();\n      }\n  }\n  ```\n\n'},{title:"线程池",headers:[{level:2,title:"1. 线程池",slug:"_1-线程池",link:"#_1-线程池",children:[{level:3,title:"1.1 线程状态介绍",slug:"_1-1-线程状态介绍",link:"#_1-1-线程状态介绍",children:[]},{level:3,title:"1.2 线程池-基本原理",slug:"_1-2-线程池-基本原理",link:"#_1-2-线程池-基本原理",children:[]},{level:3,title:"1.3 线程池-Executors默认线程池",slug:"_1-3-线程池-executors默认线程池",link:"#_1-3-线程池-executors默认线程池",children:[]},{level:3,title:"1.4 线程池-Executors创建指定上限的线程池",slug:"_1-4-线程池-executors创建指定上限的线程池",link:"#_1-4-线程池-executors创建指定上限的线程池",children:[]},{level:3,title:"1.5 线程池-ThreadPoolExecutor",slug:"_1-5-线程池-threadpoolexecutor",link:"#_1-5-线程池-threadpoolexecutor",children:[]},{level:3,title:"1.6 线程池-参数详解",slug:"_1-6-线程池-参数详解",link:"#_1-6-线程池-参数详解",children:[]},{level:3,title:"1.7 线程池-非默认任务拒绝策略",slug:"_1-7-线程池-非默认任务拒绝策略",link:"#_1-7-线程池-非默认任务拒绝策略",children:[]}]},{level:2,title:"2. 多线程综合练习",slug:"_2-多线程综合练习",link:"#_2-多线程综合练习",children:[{level:3,title:"练习一：售票",slug:"练习一-售票",link:"#练习一-售票",children:[]},{level:3,title:"练习二：赠送礼物",slug:"练习二-赠送礼物",link:"#练习二-赠送礼物",children:[]},{level:3,title:"练习三：打印数字",slug:"练习三-打印数字",link:"#练习三-打印数字",children:[]},{level:3,title:"练习四：抢红包",slug:"练习四-抢红包",link:"#练习四-抢红包",children:[]},{level:3,title:"练习五：抽奖箱",slug:"练习五-抽奖箱",link:"#练习五-抽奖箱",children:[]},{level:3,title:"练习六：多线程统计并求最大值",slug:"练习六-多线程统计并求最大值",link:"#练习六-多线程统计并求最大值",children:[]},{level:3,title:"练习七：多线程之间的比较",slug:"练习七-多线程之间的比较",link:"#练习七-多线程之间的比较",children:[]}]},{level:2,title:"2. 原子性",slug:"_2-原子性",link:"#_2-原子性",children:[{level:3,title:"2.1 volatile-问题",slug:"_2-1-volatile-问题",link:"#_2-1-volatile-问题",children:[]},{level:3,title:"2.2 volatile解决",slug:"_2-2-volatile解决",link:"#_2-2-volatile解决",children:[]},{level:3,title:"2.3 synchronized解决",slug:"_2-3-synchronized解决",link:"#_2-3-synchronized解决",children:[]},{level:3,title:"2.4 原子性",slug:"_2-4-原子性",link:"#_2-4-原子性",children:[]},{level:3,title:"2.5 volatile关键字不能保证原子性",slug:"_2-5-volatile关键字不能保证原子性",link:"#_2-5-volatile关键字不能保证原子性",children:[]},{level:3,title:"2.6 原子性_AtomicInteger",slug:"_2-6-原子性-atomicinteger",link:"#_2-6-原子性-atomicinteger",children:[]},{level:3,title:"2.7 AtomicInteger-内存解析",slug:"_2-7-atomicinteger-内存解析",link:"#_2-7-atomicinteger-内存解析",children:[]},{level:3,title:"2.8 AtomicInteger-源码解析",slug:"_2-8-atomicinteger-源码解析",link:"#_2-8-atomicinteger-源码解析",children:[]},{level:3,title:"2.9 悲观锁和乐观锁",slug:"_2-9-悲观锁和乐观锁",link:"#_2-9-悲观锁和乐观锁",children:[]}]},{level:2,title:"3. 并发工具类",slug:"_3-并发工具类",link:"#_3-并发工具类",children:[{level:3,title:"3.1 并发工具类-Hashtable",slug:"_3-1-并发工具类-hashtable",link:"#_3-1-并发工具类-hashtable",children:[]},{level:3,title:"3.2 并发工具类-ConcurrentHashMap基本使用",slug:"_3-2-并发工具类-concurrenthashmap基本使用",link:"#_3-2-并发工具类-concurrenthashmap基本使用",children:[]},{level:3,title:"3.3 并发工具类-ConcurrentHashMap1.7原理",slug:"_3-3-并发工具类-concurrenthashmap1-7原理",link:"#_3-3-并发工具类-concurrenthashmap1-7原理",children:[]},{level:3,title:"3.4 并发工具类-ConcurrentHashMap1.8原理",slug:"_3-4-并发工具类-concurrenthashmap1-8原理",link:"#_3-4-并发工具类-concurrenthashmap1-8原理",children:[]},{level:3,title:"3.5 并发工具类-CountDownLatch",slug:"_3-5-并发工具类-countdownlatch",link:"#_3-5-并发工具类-countdownlatch",children:[]},{level:3,title:"3.6 并发工具类-Semaphore",slug:"_3-6-并发工具类-semaphore",link:"#_3-6-并发工具类-semaphore",children:[]}]}],path:"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html",pathLocale:"/",extraFields:'---\ntitle: 线程池\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n线程池\n\n\x3c!-- more --\x3e\n## 1. 线程池\n\n### 1.1 线程状态介绍\n\n当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\n\n状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\n\n```java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}\n```\n\n通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\n\n| 线程状态          | 具体含义                                     |\n| ------------- | ---------------------------------------- |\n| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |\n| RUNNABLE      | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |\n| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |\n| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |\n| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |\n| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态             |\n\n各个状态的转换，如下图所示：\n\n![1591163781941](.\\img\\1591163781941.png)\n\n### 1.2 线程池-基本原理\n\n**概述 :** \n\n​\t提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。\n\n线程池存在的意义：\n\n​\t系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系\n\n​\t统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就\n\n​\t会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。\n\n**线程池的设计思路 :**\n\n1. 准备一个任务容器\n2. 一次性启动多个(2个)消费者线程\n3. 刚开始任务容器是空的，所以线程都在wait\n4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒\n5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来\n\n### 1.3 线程池-Executors默认线程池\n\n概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。\n\n我们可以使用Executors中所提供的**静态**方法来创建线程池\n\n​\tstatic ExecutorService newCachedThreadPool()   创建一个默认的线程池\n\tstatic newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.4 线程池-Executors创建指定上限的线程池\n\n**使用Executors中所提供的静态方法来创建线程池**\n\n​\tstatic ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}\n\n```\n\n\n\n### 1.5 线程池-ThreadPoolExecutor\n\n**创建线程池对象 :** \n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);\n\n**代码实现 :** \n\n```java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}\n```\n\n### 1.6 线程池-参数详解\n\n![1591165506516](.\\img\\1591165506516.png)\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null  \n```\n\n\n\n### 1.7 线程池-非默认任务拒绝策略\n\nRejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。\n\n```java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。\n```\n\n注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数\n\n**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\n```\n\n控制台报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\n```\n\n控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了\n\n\n\n**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务" + y);\n            });     \n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-2----\x3e> 执行了任务2\npool-1-thread-1----\x3e> 执行了任务0\npool-1-thread-3----\x3e> 执行了任务3\npool-1-thread-1----\x3e> 执行了任务4\n```\n\n由于任务1在线程池中等待时间最长，因此任务1被丢弃。\n\n\n\n**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略\n\n```java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}\n```\n\n**控制台输出结果**\n\n```java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\nmain----\x3e> 执行了任务\n```\n\n通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。\n\n## 2. 多线程综合练习\n\n### 练习一：售票\n\n需求：\n\n​\t一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,\n\n​\t请用多线程模拟卖票过程并打印剩余电影票的数量\n\n代码示例：\n\n```java\npublic class MyThread extends Thread {\n\n    //第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static\n    static int ticket = 1000;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (ticket == 0) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    try {\n                        Thread.sleep(3000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    ticket--;\n                    System.out.println(getName() + "在卖票，还剩下" + ticket + "张票!!!");\n                }\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n       /*\n            一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,\n            要求:请用多线程模拟卖票过程并打印剩余电影票的数量\n        */\n\n        //创建线程对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n\n        //给线程设置名字\n        t1.setName("窗口1");\n        t2.setName("窗口2");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n    }\n}\n\n```\n\n\n\n### 练习二：赠送礼物\n\n需求：\n\n​\t有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出。\n\n​\t利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.\n\n```java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int count = 100;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (count < 10) {\n                    System.out.println("礼物还剩下" + count + "不再赠送");\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + "在赠送礼物，还剩下" + count + "个礼物!!!");\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出，\n            利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.\n        */\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,"窗口1");\n        Thread t2 = new Thread(mr,"窗口2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n\n\n### 练习三：打印数字\n\n需求：\n\n​\t同时开启两个线程，共同获取1-100之间的所有数字。\n\n​\t将输出所有的奇数。\n\n```java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int number = 1;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (number > 100) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    if(number % 2 == 1){\n                        System.out.println(Thread.currentThread().getName() + "打印数字" + number);\n                    }\n                    number++;\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n           同时开启两个线程，共同获取1-100之间的所有数字。\n           要求：将输出所有的奇数。\n        */\n\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,"线程A");\n        Thread t2 = new Thread(mr,"线程B");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n### 练习四：抢红包\n\n需求：\n\n​\t抢红包也用到了多线程。\n\n​\t假设：100块，分成了3个包，现在有5个人去抢。\n\n​\t其中，红包是共享数据。\n\n​\t5个人是5条线程。\n\n​\t打印结果如下：\n\n​\t\t  XXX抢到了XXX元\n\n​\t\t  XXX抢到了XXX元\n\n \t\t XXX抢到了XXX元\n\n  \t\tXXX没抢到\n\n  \t\tXXX没抢到\n\n解决方案一：\n\n```java\npublic class MyThread extends Thread{\n\n    //共享数据\n    //100块，分成了3个包\n    static double money = 100;\n    static int count = 3;\n\n    //最小的中奖金额\n    static final double MIN = 0.01;\n\n    @Override\n    public void run() {\n        //同步代码块\n        synchronized (MyThread.class){\n            if(count == 0){\n                //判断，共享数据是否到了末尾（已经到末尾）\n                System.out.println(getName() + "没有抢到红包！");\n            }else{\n                //判断，共享数据是否到了末尾（没有到末尾）\n                //定义一个变量，表示中奖的金额\n                double prize = 0;\n                if(count == 1){\n                    //表示此时是最后一个红包\n                    //就无需随机，剩余所有的钱都是中奖金额\n                    prize = money;\n                }else{\n                    //表示第一次，第二次（随机）\n                    Random r = new Random();\n                    //100 元   3个包\n                    //第一个红包：99.98\n                    //100 - (3-1) * 0.01\n                    double bounds = money - (count - 1) * MIN;\n                    prize = r.nextDouble(bounds);\n                    if(prize < MIN){\n                        prize = MIN;\n                    }\n                }\n                //从money当中，去掉当前中奖的金额\n                money = money - prize;\n                //红包的个数-1\n                count--;\n                //本次红包的信息进行打印\n                System.out.println(getName() + "抢到了" + prize + "元");\n            }\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n        //创建线程的对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        //给线程设置名字\n        t1.setName("小A");\n        t2.setName("小QQ");\n        t3.setName("小哈哈");\n        t4.setName("小诗诗");\n        t5.setName("小丹丹");\n\n        //启动线程\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}\n```\n\n解决方案二：\n\n```java\npublic class MyThread extends Thread{\n\n    //总金额\n    static BigDecimal money = BigDecimal.valueOf(100.0);\n    //个数\n    static int count = 3;\n    //最小抽奖金额\n    static final BigDecimal MIN = BigDecimal.valueOf(0.01);\n\n    @Override\n    public void run() {\n        synchronized (MyThread.class){\n            if(count == 0){\n                System.out.println(getName() + "没有抢到红包！");\n            }else{\n                //中奖金额\n                BigDecimal prize;\n                if(count == 1){\n                    prize = money;\n                }else{\n                    //获取抽奖范围\n                    double bounds = money.subtract(BigDecimal.valueOf(count-1).multiply(MIN)).doubleValue();\n                    Random r = new Random();\n                    //抽奖金额\n                    prize = BigDecimal.valueOf(r.nextDouble(bounds));\n                }\n                //设置抽中红包，小数点保留两位，四舍五入\n                prize = prize.setScale(2,RoundingMode.HALF_UP);\n                //在总金额中去掉对应的钱\n                money = money.subtract(prize);\n                //红包少了一个\n                count--;\n                //输出红包信息\n                System.out.println(getName() + "抽中了" + prize + "元");\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        t1.setName("小A");\n        t2.setName("小QQ");\n        t3.setName("小哈哈");\n        t4.setName("小诗诗");\n        t5.setName("小丹丹");\n\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}\n```\n\n### 练习五：抽奖箱\n\n需求：\n\n​\t有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700}; \n\n创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” \n\n随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n\n​               每次抽出一个奖项就打印一个(随机)\n\n​\t\t抽奖箱1 又产生了一个 10 元大奖\n\n  \t\t抽奖箱1 又产生了一个 100 元大奖\n\n  \t\t抽奖箱1 又产生了一个 200 元大奖\n\n  \t\t抽奖箱1 又产生了一个 800 元大奖  \n\n​\t\t抽奖箱2 又产生了一个 700 元大奖  \n\n \t\t .....\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        //1.循环\n        //2.同步代码块\n        //3.判断\n        //4.判断\n\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    System.out.println(getName() + "又产生了一个" + prize + "元大奖");\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n                             每次抽出一个奖项就打印一个(随机)\n            \t抽奖箱1 又产生了一个 10 元大奖\n            \t抽奖箱1 又产生了一个 100 元大奖\n            \t抽奖箱1 又产生了一个 200 元大奖\n            \t抽奖箱1 又产生了一个 800 元大奖\n            \t抽奖箱2 又产生了一个 700 元大奖\n            \t.....\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n\n\n### 练习六：多线程统计并求最大值\n\n需求：\n\n​\t在上一题基础上继续完成如下需求：\n\n​     每次抽的过程中，不打印，抽完时一次性打印(随机)\n\n​     在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n\n​              分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n\n​     在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n\n​              分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n\n解决方案一：\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    //线程一\n    static ArrayList<Integer> list1 = new ArrayList<>();\n    //线程二\n    static ArrayList<Integer> list2 = new ArrayList<>();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    if("抽奖箱1".equals(getName())){\n                        System.out.println("抽奖箱1" + list1);\n                    }else {\n                        System.out.println("抽奖箱2" + list2);\n                    }\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    if("抽奖箱1".equals(getName())){\n                        list1.add(prize);\n                    }else {\n                        list2.add(prize);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n解决方案二：\n\n```java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    System.out.println(getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n\n        //启动线程\n        t1.start();\n        t2.start();\n\n    }\n}\n```\n\n\n\n### 练习七：多线程之间的比较 \n\n需求：\n\n​\t在上一题基础上继续完成如下需求：\n\n​\t在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300\n\n  \t最高奖项为300元，总计额为932元\n\n​\t在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700\n\n  \t最高奖项为800元，总计额为1835元\n\n​\t在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n\n​\t以上打印效果只是数据模拟,实际代码运行的效果会有差异\n\n```java\npublic class MyCallable implements Callable<Integer> {\n\n    ArrayList<Integer> list;\n\n    public MyCallable(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyCallable.class) {\n                if (list.size() == 0) {\n                    System.out.println(Thread.currentThread().getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            Thread.sleep(10);\n        }\n        //把集合中的最大值返回\n        if(boxList.size() == 0){\n            return null;\n        }else{\n            return Collections.max(boxList);\n        }\n    }\n}\n\npackage com.itheima.test7;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Test {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为    "抽奖箱1", "抽奖箱2"\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n\n            在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300\n        \t    最高奖项为300元，总计额为932元\n\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700\n            \t最高奖项为800元，总计额为1835元\n\n            在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n            核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果）\n\n\n            以上打印效果只是数据模拟,实际代码运行的效果会有差异\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建多线程要运行的参数对象\n        MyCallable mc = new MyCallable(list);\n\n        //创建多线程运行结果的管理者对象\n        //线程一\n        FutureTask<Integer> ft1 = new FutureTask<>(mc);\n        //线程二\n        FutureTask<Integer> ft2 = new FutureTask<>(mc);\n\n        //创建线程对象\n        Thread t1 = new Thread(ft1);\n        Thread t2 = new Thread(ft2);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n\n        Integer max1 = ft1.get();\n        Integer max2 = ft2.get();\n\n        System.out.println(max1);\n        System.out.println(max2);\n\n        //在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n        if(max1 == null){\n            System.out.println("在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为"+max2+"元");\n        }else if(max2 == null){\n            System.out.println("在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为"+max1+"元");\n        }else if(max1 > max2){\n            System.out.println("在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为"+max1+"元");\n        }else if(max1 < max2){\n            System.out.println("在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为"+max2+"元");\n        }else{\n            System.out.println("两者的最大奖项是一样的");\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n## 2. 原子性\n\n### 2.1 volatile-问题\n\n**代码分析 :** \n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。\n\n\n\n### 2.2 volatile解决\n\n**以上案例出现的问题 :**\n\n​\t当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 \n\n​\t1，堆内存是唯一的，每一个线程都有自己的线程栈。\n\n​\t2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。\n\n​\t3 ，在线程中，每一次使用是从变量的副本中获取的。\n\n**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值\n\n**代码实现 :** **使用volatile关键字解决**\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}\n\n```\n\n```java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}\n\n```\n\n\n\n### 2.3 synchronized解决\n\n**synchronized解决 :** \n\n​\t1 ，线程获得锁\n\n​\t2 ，清空变量副本\n\n​\t3 ，拷贝共享变量最新的值到变量副本中\n\n​\t4 ，执行代码\n\n​\t5 ，将修改后变量副本中的值赋值给共享数据\n\n​\t6 ，释放锁\n\n**代码实现 :** \n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println("结婚基金已经不是十万了");\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}\n```\n\n\n\n### 2.4 原子性\n\n**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。\n\n**代码实现 :** \n\n```java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println("已经送了" + count + "个冰淇淋");\n        }\n    }\n}\n```\n\n**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断\n\n\n\n### 2.5 volatile关键字不能保证原子性\n\n解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。\n\n```java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println("已经送了" + count + "个冰淇淋");\n            }\n        }\n    }\n}\n```\n\n\n\n### 2.6 原子性_AtomicInteger\n\n概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变\n\n量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解\n\n使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：\n\nAtomicBoolean： 原子更新布尔类型\n\nAtomicInteger：   原子更新整型\n\nAtomicLong：\t原子更新长整型\n\n以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：\n\n```java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。\n```\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}\n```\n\n```java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}\n```\n\n\n\n### 2.7 AtomicInteger-内存解析\n\n**AtomicInteger原理 :** 自旋锁  + CAS 算法\n\n**CAS算法：**\n\n​\t有3个操作数（内存值V， 旧的预期值A，要修改的值B）\n\n​\t当旧的预期值A == 内存值   此时修改成功，将V改为B                 \n\n​\t当旧的预期值A！=内存值   此时修改失败，不做任何操作                 \n\n​\t并重新获取现在的最新值（这个重新获取的动作就是自旋）\n\n### 2.8 AtomicInteger-源码解析\n\n**代码实现 :**\n\n```java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\n```\n\n```java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println("已经送了" + count + "个冰淇淋");\n           // }\n        }\n    }\n}\n\n```\n\n**源码解析 :** \n\n```java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}\n```\n\n\n\n### 2.9 悲观锁和乐观锁\n\n**synchronized和CAS的区别 :** \n\n**相同点：**在多线程情况下，都可以保证共享数据的安全性。\n\n**不同点：**synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）\n\n​\tcas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。\n\n​\t如果别人修改过，那么我再次获取现在最新的值。            \n\n​\t 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）\n\n\n\n## 3. 并发工具类\n\n### 3.1 并发工具类-Hashtable\n\n​\t**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n\n\n    }\n}\n```\n\n\n\n### 3.2 并发工具类-ConcurrentHashMap基本使用\n\n​\t**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。\n\n基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。\n\n**体系结构 :** \n\n![1591168965857](.\\img\\1591168965857.png)\n\n**总结 :** \n\n​\t1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题\n\n​\t2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下\n\n​\t3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。\n\n**代码实现 :** \n\n```java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n    }\n}\n```\n\n\n\n### 3.3 并发工具类-ConcurrentHashMap1.7原理\n\n![1591169254280](.\\img\\1591169254280.png)\n\n### 3.4 并发工具类-ConcurrentHashMap1.8原理\n\n![1591169338256](.\\img\\1591169338256.png)\n\n**总结 :** \n\n​\t1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表\n\n​\t2，计算当前元素应存入的索引。\n\n​\t3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。\n\n​\t4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。\t\t\n\n​\t5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性\n\n### 3.5 并发工具类-CountDownLatch\n\n**CountDownLatch类 :** \t\t\n\n| 方法                               | 解释               |\n| -------------------------------- | ---------------- |\n| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |\n| public void await()              | 让线程等待            |\n| public void countDown()          | 当前线程执行完毕         |\n\n**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行\n\n**代码实现 :** \n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println("妈妈在收拾碗筷");\n    }\n}\n\n```\n\n```java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName("小明");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName("小红");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName("小刚");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n**总结 :** \n\n​\t1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。\n\n​\t2. await()：让线程等待，当计数器为0时，会唤醒等待的线程\n\n​\t3. countDown()： 线程执行完毕时调用，会将计数器-1。\n\n### 3.6 并发工具类-Semaphore\n\n**使用场景 :** \n\n​\t可以控制访问特定资源的线程数量。\n\n**实现步骤 :** \n\n​\t1，需要有人管理这个通道\n\n​\t2，当有车进来了，发通行许可证\n\n​\t3，当车出去了，收回通行许可证\n\n​\t4，如果通行许可证发完了，那么其他车辆只能等着\n\n**代码实现 :** \n\n```java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println("获得了通行证开始行驶");\n            Thread.sleep(2000);\n            System.out.println("归还通行证");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n```java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}\n```\n\n\n\n'},{title:"网络编程入门",headers:[{level:2,title:"1. 网络编程入门",slug:"_1-网络编程入门",link:"#_1-网络编程入门",children:[{level:3,title:"1.1 网络编程概述",slug:"_1-1-网络编程概述",link:"#_1-1-网络编程概述",children:[]},{level:3,title:"1.2 网络编程三要素",slug:"_1-2-网络编程三要素",link:"#_1-2-网络编程三要素",children:[]},{level:3,title:"1.3 IP地址",slug:"_1-3-ip地址",link:"#_1-3-ip地址",children:[]},{level:3,title:"1.4 InetAddress",slug:"_1-4-inetaddress",link:"#_1-4-inetaddress",children:[]},{level:3,title:"1.5 端口和协议",slug:"_1-5-端口和协议",link:"#_1-5-端口和协议",children:[]}]},{level:2,title:"2.UDP通信程序",slug:"_2-udp通信程序",link:"#_2-udp通信程序",children:[{level:3,title:"2.1 UDP发送数据",slug:"_2-1-udp发送数据",link:"#_2-1-udp发送数据",children:[]},{level:3,title:"2.2UDP接收数据",slug:"_2-2udp接收数据",link:"#_2-2udp接收数据",children:[]},{level:3,title:"2.3UDP通信程序练习",slug:"_2-3udp通信程序练习",link:"#_2-3udp通信程序练习",children:[]},{level:3,title:"2.4UDP三种通讯方式",slug:"_2-4udp三种通讯方式",link:"#_2-4udp三种通讯方式",children:[]},{level:3,title:"2.5UDP组播实现",slug:"_2-5udp组播实现",link:"#_2-5udp组播实现",children:[]},{level:3,title:"2.6UDP广播实现",slug:"_2-6udp广播实现",link:"#_2-6udp广播实现",children:[]},{level:3,title:"3.1TCP发送数据",slug:"_3-1tcp发送数据",link:"#_3-1tcp发送数据",children:[]},{level:3,title:"3.2TCP接收数据",slug:"_3-2tcp接收数据",link:"#_3-2tcp接收数据",children:[]},{level:3,title:"3.3TCP程序练习（传输中文）",slug:"_3-3tcp程序练习-传输中文",link:"#_3-3tcp程序练习-传输中文",children:[]}]},{level:2,title:"4. 综合练习",slug:"_4-综合练习",link:"#_4-综合练习",children:[{level:3,title:"练习一：多发多收",slug:"练习一-多发多收",link:"#练习一-多发多收",children:[]},{level:3,title:"练习二：接收并反馈",slug:"练习二-接收并反馈",link:"#练习二-接收并反馈",children:[]},{level:3,title:"练习三：上传练习（TCP协议）",slug:"练习三-上传练习-tcp协议",link:"#练习三-上传练习-tcp协议",children:[]},{level:3,title:"练习四：文件名重复",slug:"练习四-文件名重复",link:"#练习四-文件名重复",children:[]},{level:3,title:"练习五：服务器改写为多线程",slug:"练习五-服务器改写为多线程",link:"#练习五-服务器改写为多线程",children:[]},{level:3,title:"练习六：线程池改进",slug:"练习六-线程池改进",link:"#练习六-线程池改进",children:[]}]}],path:"/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html",pathLocale:"/",extraFields:'---\ntitle: 网络编程入门\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n网络编程入门\n\n\x3c!-- more --\x3e\n## 1. 网络编程入门\n\n### 1.1 网络编程概述\n\n- 计算机网络\n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统\n\n- 网络编程\n\n  在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\n\n### 1.2 网络编程三要素\n\n- IP地址\n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\n\n- 端口\n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\n\n- 协议\n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n### 1.3 IP地址\n\nIP地址：是网络中设备的唯一标识\n\n- IP地址分为两大类\n  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多\n  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题\n- DOS常用命令：\n  - ipconfig：查看本机IP地址\n  - ping IP地址：检查网络是否连通\n- 特殊IP地址：\n  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n### 1.4 InetAddress\n\nInetAddress：此类表示Internet协议（IP）地址\n\n- 相关方法\n\n  | 方法名                                    | 说明                                                         |\n  | ----------------------------------------- | ------------------------------------------------------------ |\n  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |\n  | String getHostName()                      | 获取此IP地址的主机名                                         |\n  | String getHostAddress()                   | 返回文本显示中的IP地址字符串                                 |\n\n- 代码演示\n\n  ```java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName("itheima");\n          InetAddress address = InetAddress.getByName("192.168.1.66");\n  \n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n  \n          System.out.println("主机名：" + name);\n          System.out.println("IP地址：" + ip);\n      }\n  }\n  ```\n\n### 1.5 端口和协议\n\n- 端口\n\n  - 设备上应用程序的唯一标识\n\n- 端口号\n\n  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n- 协议\n\n  - 计算机网络中，连接和通信的规则被称为网络通信协议\n\n- UDP协议\n\n  - 用户数据报协议(User Datagram Protocol)\n  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。\n  - 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输\n  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议\n\n- TCP协议\n\n  - 传输控制协议 (Transmission Control Protocol)\n\n  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”\n\n  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n    第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n\n    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n\n    第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等\n\n## 2.UDP通信程序\n\n### 2.1 UDP发送数据\n\n- Java中的UDP通信\n\n  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念\n  - Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n- 构造方法\n\n  | 方法名                                                      | 说明                                                 |\n  | ----------------------------------------------------------- | ---------------------------------------------------- |\n  | DatagramSocket()                                            | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 |\n  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n- 相关方法\n\n  | 方法名                         | 说明                   |\n  | ------------------------------ | ---------------------- |\n  | void send(DatagramPacket p)    | 发送数据报包           |\n  | void close()                   | 关闭数据报套接字       |\n  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n- 发送数据的步骤\n\n  - 创建发送端的Socket对象(DatagramSocket)\n  - 创建数据，并把数据打包\n  - 调用DatagramSocket对象的方法发送数据\n  - 关闭发送端\n\n- 代码演示\n\n  ```java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n  \n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = "hello,udp,我来了".getBytes();\n  \n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);\n  \n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n  \n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }\n  ```\n\n### 2.2UDP接收数据\n\n- 接收数据的步骤\n\n  - 创建接收端的Socket对象(DatagramSocket)\n  - 创建一个数据包，用于接收数据\n  - 调用DatagramSocket对象的方法接收数据\n  - 解析数据包，并把数据在控制台显示\n  - 关闭接收端\n\n- 构造方法\n\n  | 方法名                              | 说明                                            |\n  | ----------------------------------- | ----------------------------------------------- |\n  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n- 相关方法\n\n  | 方法名            | 说明                                     |\n  | ----------------- | ---------------------------------------- |\n  | byte[]  getData() | 返回数据缓冲区                           |\n  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n- 示例代码\n\n  ```java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n  \n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n  \n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n  \n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println("数据是：" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }\n  ```\n\n### 2.3UDP通信程序练习\n\n- 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束\n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n- 代码实现\n\n  ```java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if ("886".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);\n  \n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n  \n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }\n  ```\n\n### 2.4UDP三种通讯方式\n\n- 单播\n\n  单播用于两个主机之间的端对端通信\n\n- 组播\n\n  组播用于对一组特定的主机进行通信\n\n- 广播\n\n  广播用于一个主机对整个局域网上所有主机上的数据通信\n\n### 2.5UDP组播实现\n\n- 实现步骤\n\n  - 发送端\n    1. 创建发送端的Socket对象(DatagramSocket)\n    2. 创建数据，并把数据打包(DatagramPacket)\n    3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n    4. 释放资源\n  - 接收端\n    1. 创建接收端Socket对象(MulticastSocket)\n    2. 创建一个箱子,用于接收数据\n    3. 把当前计算机绑定一个组播地址\n    4. 将数据接收到箱子中\n    5. 解析数据包,并打印数据\n    6. 释放资源\n\n- 代码实现\n\n  ```java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = "hello 组播";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("224.0.1.0");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName("224.0.1.0"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }\n  ```\n\n### 2.6UDP广播实现\n\n- 实现步骤\n\n  - 发送端\n    1. 创建发送端Socket对象(DatagramSocket)\n    2. 创建存储数据的箱子,将广播地址封装进去\n    3. 发送数据\n    4. 释放资源\n  - 接收端\n    1. 创建接收端的Socket对象(DatagramSocket)\n    2. 创建一个数据包，用于接收数据\n    3. 调用DatagramSocket对象的方法接收数据\n    4. 解析数据包，并把数据在控制台显示\n    5. 关闭接收端\n\n- 代码实现\n\n  ```java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = "广播 hello";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("255.255.255.255");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  \n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }\n  ```\n\n##3. TCP通信程序\n\n### 3.1TCP发送数据\n\n- Java中的TCP通信\n\n  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。\n  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n- 构造方法\n\n  | 方法名                               | 说明                                           |\n  | ------------------------------------ | ---------------------------------------------- |\n  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号       |\n  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n- 相关方法\n\n  | 方法名                         | 说明                 |\n  | ------------------------------ | -------------------- |\n  | InputStream  getInputStream()  | 返回此套接字的输入流 |\n  | OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n- 示例代码\n\n  ```java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，发送数据\n  \n          //1.创建Socket对象\n          //细节：在创建对象的同时会连接服务端\n          //      如果连接不上，代码会报错\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          //2.可以从连接通道中获取输出流\n          OutputStream os = socket.getOutputStream();\n          //写出数据\n          os.write("aaa".getBytes());\n  \n          //3.释放资源\n          os.close();\n          socket.close();\n      }\n  }\n  ```\n\n### 3.2TCP接收数据\n\n- 构造方法\n\n  | 方法名                  | 说明                             |\n  | ----------------------- | -------------------------------- |\n  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n- 相关方法\n\n  | 方法名          | 说明                           |\n  | --------------- | ------------------------------ |\n  | Socket accept() | 监听要连接到此的套接字并接受它 |\n\n- 注意事项\n\n  1. accept方法是阻塞的,作用就是等待客户端连接\n  2. 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接\n  3. 针对客户端来讲,是往外写的,所以是输出流\n     针对服务器来讲,是往里读的,所以是输入流\n  4. read方法也是阻塞的\n  5. 客户端在关流的时候,还多了一个往服务器写结束标记的动作\n  6. 最后一步断开连接,通过四次挥手协议保证连接终止\n\n- 三次握手和四次挥手\n\n  - 三次握手\n\n    ![07_TCP三次握手](/img/07_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)\n\n  - 四次挥手\n\n    ![08_TCP四次挥手](img/08_TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)\n\n- 示例代码\n\n  ```java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，接收数据\n  \n          //1.创建对象ServerSocker\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.监听客户端的链接\n          Socket socket = ss.accept();\n  \n          //3.从连接通道中获取输入流读取数据\n          InputStream is = socket.getInputStream();\n          int b;\n          while ((b = is.read()) != -1){\n              System.out.println((char) b);\n          }\n  \n          //4.释放资源\n          socket.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 3.3TCP程序练习（传输中文）\n\n发送端：\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，发送数据\n\n        //1.创建Socket对象\n        //细节：在创建对象的同时会连接服务端\n        //      如果连接不上，代码会报错\n        Socket socket = new Socket("127.0.0.1",10000);\n\n\n        //2.可以从连接通道中获取输出流\n        OutputStream os = socket.getOutputStream();\n        //写出数据\n        os.write("你好你好".getBytes());//12字节\n\n        //3.释放资源\n        os.close();\n        socket.close();\n\n    }\n}\n\n```\n\n接收端：\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，接收数据\n\n        //1.创建对象ServerSocker\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.监听客户端的链接\n        Socket socket = ss.accept();\n\n        //3.从连接通道中获取输入流读取数据\n        InputStream is = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(isr);\n\n        // BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        int b;\n        while ((b = br.read()) != -1){\n            System.out.print((char) b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n\n    }\n}\n```\n\n## 4. 综合练习\n\n### 练习一：多发多收\n\n需求：\n\n​\t客户端：多次发送数据\n\n​\t服务器：接收多次接收数据，并打印\n\n代码示例：\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1. 创建Socket对象并连接服务端\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.写出数据\n        Scanner sc = new Scanner(System.in);\n        OutputStream os = socket.getOutputStream();\n\n        while (true) {\n            System.out.println("请输入您要发送的信息");\n            String str = sc.nextLine();\n            if("886".equals(str)){\n                break;\n            }\n            os.write(str.getBytes());\n        }\n        //3.释放资源\n        socket.close();\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1.创建对象绑定10000端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据\n        InputStreamReader isr = new InputStreamReader(socket.getInputStream());\n        int b;\n        while ((b = isr.read()) != -1){\n            System.out.print((char)b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n    }\n}\n```\n\n\n\n### 练习二：接收并反馈\n\n- 案例需求\n\n  客户端：发送数据，接受服务器反馈\n\n  服务器：收到消息后给出反馈\n\n- 案例分析\n\n  - 客户端创建对象，使用输出流输出数据\n  - 服务端创建对象，使用输入流接受数据\n  - 服务端使用输出流给出反馈数据\n  - 客户端使用输入流接受反馈数据\n\n- 代码实现\n\n  ```java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          OutputStream os = socket.getOutputStream();\n          os.write("hello".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n  \n          Socket accept = ss.accept();\n  \n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n  \n          System.out.println("看看我执行了吗?");\n  \n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("你谁啊?");\n          bw.newLine();\n          bw.flush();\n  \n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 练习三：上传练习（TCP协议）\n\n- 案例需求\n\n  客户端：数据来自于本地文件，接收服务器反馈\n\n  服务器：接收到的数据写入本地文件，给出反馈\n\n- 案例分析\n\n  - 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束\n  - 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息\n  - 客户端接受服务端的回馈信息\n\n- 相关方法\n\n  | 方法名                | 说明                               |\n  | --------------------- | ---------------------------------- |\n  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n  | void shutdownOutput() | 禁止用此套接字的输出流             |\n\n- 代码实现\n\n  ```java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1. 创建Socket对象，并连接服务器\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          //2.读取本地文件中的数据，并写到服务器当中\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n          BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n          byte[] bytes = new byte[1024];\n          int len;\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n  \n          //往服务器写出结束标记\n          socket.shutdownOutput();\n  \n  \n          //3.接收服务器的回写数据\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line = br.readLine();\n          System.out.println(line);\n  \n  \n          //4.释放资源\n          socket.close();\n  \n      }\n  }\n  ```\n\n  ```java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1.创建对象并绑定端口\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.等待客户端来连接\n          Socket socket = ss.accept();\n  \n          //3.读取数据并保存到本地文件中\n          BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\a.jpg"));\n          int len;\n          byte[] bytes = new byte[1024];\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n          bos.close();\n          //4.回写数据\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n          bw.write("上传成功");\n          bw.newLine();\n          bw.flush();\n  \n          //5.释放资源\n          socket.close();\n          ss.close();\n      }\n  }\n  ```\n\n### 练习四：文件名重复\n\n     ```java\npublic class UUIDTest {\n    public static void main(String[] args) {\n        String str = UUID.randomUUID().toString().replace("-", "");\n        System.out.println(str);//9f15b8c356c54f55bfcb0ee3023fce8a\n    }\n}\n     ```\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据并保存到本地文件中\n        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n        String name = UUID.randomUUID().toString().replace("-", "");\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes)) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        bos.close();\n        //4.回写数据\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write("上传成功");\n        bw.newLine();\n        bw.flush();\n\n        //5.释放资源\n        socket.close();\n        ss.close();\n    }\n}\n```\n\n### 练习五：服务器改写为多线程\n\n服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。\n\n优化方案一：\n\n​\t使用循环\n\n弊端：\n\n​\t第一个用户正在上传数据，第二个用户就来访问了，此时第二个用户是无法成功上传的。\n\n​\t所以，使用多线程改进\n\n优化方案二：\n\n​\t每来一个用户，就开启多线程处理\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            new Thread(new MyRunnable(socket)).start();\n        }\n\n    }\n}\n\n\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace("-", "");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write("上传成功");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}\n```\n\n### 练习六：线程池改进\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}\n```\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //创建线程池对象\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                3,//核心线程数量\n                16,//线程池总大小\n                60,//空闲时间\n                TimeUnit.SECONDS,//空闲时间（单位）\n                new ArrayBlockingQueue<>(2),//队列\n                Executors.defaultThreadFactory(),//线程工厂，让线程池如何创建线程对象\n                new ThreadPoolExecutor.AbortPolicy()//阻塞队列\n        );\n\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            //new Thread(new MyRunnable(socket)).start();\n            pool.submit(new MyRunnable(socket));\n        }\n\n    }\n}\n```\n\n```java\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace("-", "");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write("上传成功");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}\n```\n\n'},{title:"反射&动态代理",headers:[{level:2,title:"1.1 反射的概述：",slug:"_1-1-反射的概述",link:"#_1-1-反射的概述",children:[]},{level:2,title:"1.2 学习反射到底学什么？",slug:"_1-2-学习反射到底学什么",link:"#_1-2-学习反射到底学什么",children:[]},{level:2,title:"1.3 获取字节码文件对象的三种方式",slug:"_1-3-获取字节码文件对象的三种方式",link:"#_1-3-获取字节码文件对象的三种方式",children:[]},{level:2,title:"1.4 字节码文件和字节码文件对象",slug:"_1-4-字节码文件和字节码文件对象",link:"#_1-4-字节码文件和字节码文件对象",children:[]},{level:2,title:"1.5 获取构造方法",slug:"_1-5-获取构造方法",link:"#_1-5-获取构造方法",children:[]},{level:2,title:"1.6 获取构造方法并创建对象",slug:"_1-6-获取构造方法并创建对象",link:"#_1-6-获取构造方法并创建对象",children:[]},{level:2,title:"1.7 获取成员变量",slug:"_1-7-获取成员变量",link:"#_1-7-获取成员变量",children:[]},{level:2,title:"1.8 获取成员变量并获取值和修改值",slug:"_1-8-获取成员变量并获取值和修改值",link:"#_1-8-获取成员变量并获取值和修改值",children:[]},{level:2,title:"1.9 获取成员方法",slug:"_1-9-获取成员方法",link:"#_1-9-获取成员方法",children:[]},{level:2,title:"1.10 获取成员方法并运行",slug:"_1-10-获取成员方法并运行",link:"#_1-10-获取成员方法并运行",children:[]},{level:2,title:"面试题：",slug:"面试题",link:"#面试题",children:[]},{level:2,title:"1.11 练习泛型擦除（掌握概念，了解代码）",slug:"_1-11-练习泛型擦除-掌握概念-了解代码",link:"#_1-11-练习泛型擦除-掌握概念-了解代码",children:[]},{level:2,title:"1.12 练习：修改字符串的内容（掌握概念，了解代码）",slug:"_1-12-练习-修改字符串的内容-掌握概念-了解代码",link:"#_1-12-练习-修改字符串的内容-掌握概念-了解代码",children:[]},{level:2,title:"1.13 练习，反射和配置文件结合动态获取的练习（重点）",slug:"_1-13-练习-反射和配置文件结合动态获取的练习-重点",link:"#_1-13-练习-反射和配置文件结合动态获取的练习-重点",children:[]},{level:2,title:"1.14 利用发射保存对象中的信息（重点）",slug:"_1-14-利用发射保存对象中的信息-重点",link:"#_1-14-利用发射保存对象中的信息-重点",children:[]},{level:2,title:"2.1 好处：",slug:"_2-1-好处",link:"#_2-1-好处",children:[]},{level:2,title:"2.2 动态代理三要素：",slug:"_2-2-动态代理三要素",link:"#_2-2-动态代理三要素",children:[]},{level:2,title:"2.3 代码实现：",slug:"_2-3-代码实现",link:"#_2-3-代码实现",children:[]},{level:2,title:"2.4 额外扩展",slug:"_2-4-额外扩展",link:"#_2-4-额外扩展",children:[]},{level:2,title:"2.5 动态代理的练习",slug:"_2-5-动态代理的练习",link:"#_2-5-动态代理的练习",children:[]}],path:"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",pathLocale:"/",extraFields:'---\ntitle: 反射&动态代理\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n反射&动态代理\n\n\x3c!-- more --\x3e\n# 1. 反射\n\n## 1.1 反射的概述：\n\n​\t**专业的解释（了解一下）：**\n\n​       是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\n\n​       对于任意一个对象，都能够调用它的任意属性和方法；\n\n​       这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\n\n​\t**通俗的理解：（掌握）**\n\n* 利用**反射**创建的对象**可以无视修饰符**调用类里面的内容\n\n* 可以跟**配置文件结合起来使用**，把要创建的对象信息和方法写在配置文件中。\n\n  读取到什么类，就创建什么类的对象\n\n  读取到什么方法，就调用什么方法\n\n  此时当需求变更的时候不需要修改代码，只要修改配置文件即可。\n\n## 1.2 学习反射到底学什么？\n\n反射都是从class字节码文件中获取的内容。\n\n* 如何获取class字节码文件的对象\n* 利用反射如何获取构造方法（创建对象）\n* 利用反射如何获取成员变量（赋值，获取值）\n* 利用反射如何获取成员方法（运行）\n\n## 1.3 获取字节码文件对象的三种方式\n\n* Class这个类里面的静态方法forName（“全类名”）**（最常用）**\n* 通过class属性获取  \n* 通过对象获取字节码文件对象\n\n代码示例：\n\n```java\n//1.Class这个类里面的静态方法forName\n//Class.forName("类的全类名")： 全类名 = 包名 + 类名\nClass clazz1 = Class.forName("com.itheima.reflectdemo.Student");\n//源代码阶段获取 --- 先把Student加载到内存中，再获取字节码文件的对象\n//clazz 就表示Student这个类的字节码文件对象。\n//就是当Student.class这个文件加载到内存之后，产生的字节码文件对象\n\n\n//2.通过class属性获取\n//类名.class\nClass clazz2 = Student.class;\n\n//因为class文件在硬盘中是唯一的，所以，当这个文件加载到内存之后产生的对象也是唯一的\nSystem.out.println(clazz1 == clazz2);//true\n\n\n//3.通过Student对象获取字节码文件对象\nStudent s = new Student();\nClass clazz3 = s.getClass();\nSystem.out.println(clazz1 == clazz2);//true\nSystem.out.println(clazz2 == clazz3);//true\n```\n\n## 1.4 字节码文件和字节码文件对象\n\njava文件：就是我们自己编写的java代码。\n\n字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的）\n\n字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。\n\n​\t\t\t\t这个对象里面至少包含了：构造方法，成员变量，成员方法。\n\n而我们的反射获取的是什么？字节码文件对象，这个对象在内存中是唯一的。\n\n## 1.5 获取构造方法\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n| 方法名                                                       | 说明                              |\n| ------------------------------------------------------------ | --------------------------------- |\n| `Constructor<?>[] getConstructors()    `                       | 获得所有的构造（只能public修饰）  |\n| `Constructor<?>[] getDeclaredConstructors() `                  | 获得所有的构造（包含private修饰） |\n| `Constructor<T> getConstructor(Class<?>... parameterTypes)`    | 获取指定构造（只能public修饰）    |\n|` Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)` | 获取指定构造（包含private修饰）   |\n\n代码示例：\n\n```java\npublic class ReflectDemo2 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获得整体（class字节码文件对象）\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n\n        //2.获取构造方法对象\n        //获取所有构造方法（public）\n        Constructor[] constructors1 = clazz.getConstructors();\n        for (Constructor constructor : constructors1) {\n            System.out.println(constructor);\n        }\n\n        System.out.println("=======================");\n\n        //获取所有构造（带私有的）\n        Constructor[] constructors2 = clazz.getDeclaredConstructors();\n\n        for (Constructor constructor : constructors2) {\n            System.out.println(constructor);\n        }\n        System.out.println("=======================");\n\n        //获取指定的空参构造\n        Constructor con1 = clazz.getConstructor();\n        System.out.println(con1);\n\n        Constructor con2 = clazz.getConstructor(String.class,int.class);\n        System.out.println(con2);\n\n        System.out.println("=======================");\n        //获取指定的构造(所有构造都可以获取到，包括public包括private)\n        Constructor con3 = clazz.getDeclaredConstructor();\n        System.out.println(con3);\n        //了解 System.out.println(con3 == con1);\n        //每一次获取构造方法对象的时候，都会新new一个。\n\n        Constructor con4 = clazz.getDeclaredConstructor(String.class);\n        System.out.println(con4);\n    }\n}\n```\n\n## 1.6 获取构造方法并创建对象\n\n涉及到的方法：newInstance\n\n代码示例：\n\n```java\n//首先要有一个javabean类\npublic class Student {\n    private String name;\n\n    private int age;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + "}";\n    }\n}\n\n\n\n//测试类中的代码：\n//需求1：\n//获取空参，并创建对象\n\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n//2.获取空参的构造方法\nConstructor con = clazz.getConstructor();\n//3.利用空参构造方法创建对象\nStudent stu = (Student) con.newInstance();\nSystem.out.println(stu);\n\n\nSystem.out.println("=============================================");\n\n\n//测试类中的代码：\n//需求2：\n//获取带参构造，并创建对象\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n//2.获取有参构造方法\nConstructor con = clazz.getDeclaredConstructor(String.class, int.class);\n//3.临时修改构造方法的访问权限（暴力反射）\ncon.setAccessible(true);\n//4.直接创建对象\nStudent stu = (Student) con.newInstance("zhangsan", 23);\nSystem.out.println(stu);\n```\n\n## 1.7 获取成员变量\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n方法名：\n\n| 方法名                              | 说明                                         |\n| ----------------------------------- | -------------------------------------------- |\n| Field[] getFields()                 | 返回所有成员变量对象的数组（只能拿public的） |\n| Field[] getDeclaredFields()         | 返回所有成员变量对象的数组，存在就能拿到     |\n| Field getField(String name)         | 返回单个成员变量对象（只能拿public的）       |\n| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到           |\n\n代码示例：\n\n```java\npublic class ReflectDemo4 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        //获取成员变量对象\n\n        //1.获取class对象\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n        //2.获取成员变量的对象（Field对象)只能获取public修饰的\n        Field[] fields1 = clazz.getFields();\n        for (Field field : fields1) {\n            System.out.println(field);\n        }\n\n        System.out.println("===============================");\n\n        //获取成员变量的对象（public + private）\n        Field[] fields2 = clazz.getDeclaredFields();\n        for (Field field : fields2) {\n            System.out.println(field);\n        }\n\n        System.out.println("===============================");\n        //获得单个成员变量对象\n        //如果获取的属性是不存在的，那么会报异常\n        //Field field3 = clazz.getField("aaa");\n        //System.out.println(field3);//NoSuchFieldException\n\n        Field field4 = clazz.getField("gender");\n        System.out.println(field4);\n\n        System.out.println("===============================");\n        //获取单个成员变量（私有）\n        Field field5 = clazz.getDeclaredField("name");\n        System.out.println(field5);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n\n    private int age;\n\n    public String gender;\n\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", address = " + address + "}";\n    }\n}\n\n```\n\n## 1.8 获取成员变量并获取值和修改值\n\n| 方法                                | 说明   |\n| ----------------------------------- | ------ |\n| void set(Object obj, Object value） | 赋值   |\n| Object get(Object obj)              | 获取值 |\n\n代码示例：\n\n```java\npublic class ReflectDemo5 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        Student s = new Student("zhangsan",23,"广州");\n        Student ss = new Student("lisi",24,"北京");\n\n        //需求：\n        //利用反射获取成员变量并获取值和修改值\n\n        //1.获取class对象\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n        //2.获取name成员变量\n        //field就表示name这个属性的对象\n        Field field = clazz.getDeclaredField("name");\n        //临时修饰他的访问权限\n        field.setAccessible(true);\n\n        //3.设置(修改)name的值\n        //参数一：表示要修改哪个对象的name？\n        //参数二：表示要修改为多少？\n        field.set(s,"wangwu");\n\n        //3.获取name的值\n        //表示我要获取这个对象的name的值\n        String result = (String)field.get(s);\n\n        //4.打印结果\n        System.out.println(result);\n\n        System.out.println(s);\n        System.out.println(ss);\n\n    }\n}\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", address = " + address + "}";\n    }\n}\n\n```\n\n## 1.9 获取成员方法\n\n规则：\n\n​\tget表示获取\n\n​\tDeclared表示私有\n\n​\t最后的s表示所有，复数形式\n\n​\t如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用\n\n| 方法名                                                       | 说明                                         |\n| ------------------------------------------------------------ | -------------------------------------------- |\n| Method[] getMethods()                                        | 返回所有成员方法对象的数组（只能拿public的） |\n| Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，存在就能拿到     |\n| Method getMethod(String name, Class<?>... parameterTypes)    | 返回单个成员方法对象（只能拿public的）       |\n| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |\n\n代码示例：\n\n```java\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获取class对象\n        Class<?> clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n\n        //2.获取方法\n        //getMethods可以获取父类中public修饰的方法\n        Method[] methods1 = clazz.getMethods();\n        for (Method method : methods1) {\n            System.out.println(method);\n        }\n\n        System.out.println("===========================");\n        //获取所有的方法（包含私有）\n        //但是只能获取自己类中的方法\n        Method[] methods2 = clazz.getDeclaredMethods();\n        for (Method method : methods2) {\n            System.out.println(method);\n        }\n\n        System.out.println("===========================");\n        //获取指定的方法（空参）\n        Method method3 = clazz.getMethod("sleep");\n        System.out.println(method3);\n\n        Method method4 = clazz.getMethod("eat",String.class);\n        System.out.println(method4);\n\n        //获取指定的私有方法\n        Method method5 = clazz.getDeclaredMethod("playGame");\n        System.out.println(method5);\n    }\n}\n\n```\n\n## 1.10 获取成员方法并运行\n\n方法\n\n Object invoke(Object obj, Object... args) ：运行方法\n\n参数一：用obj对象调用该方法\n\n参数二：调用方法的传递的参数（如果没有就不写）\n\n返回值：方法的返回值（如果没有就不写）\n\n代码示例：\n\n```java\npackage com.itheima.a02reflectdemo1;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.获取字节码文件对象\n        Class clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n\t\t\n        //2.获取一个对象\n        //需要用这个对象去调用方法\n        Student s = new Student();\n        \n        //3.获取一个指定的方法\n        //参数一：方法名\n        //参数二：参数列表，如果没有可以不写\n        Method eatMethod = clazz.getMethod("eat",String.class);\n        \n        //运行\n        //参数一：表示方法的调用对象\n        //参数二：方法在运行时需要的实际参数\n        //注意点：如果方法有返回值，那么需要接收invoke的结果\n        //如果方法没有返回值，则不需要接收\n        String result = (String) eatMethod.invoke(s, "重庆小面");\n        System.out.println(result);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + "}";\n    }\n\n    private void study(){\n        System.out.println("学生在学习");\n    }\n\n    private void sleep(){\n        System.out.println("学生在睡觉");\n    }\n\n    public String eat(String something){\n        System.out.println("学生在吃" + something);\n        return "学生已经吃完了，非常happy";\n    }\n}\n```\n\n## 面试题：\n\n​\t你觉得反射好不好？好，有两个方向\n\n​\t第一个方向：无视修饰符访问类中的内容。但是这种操作在开发中一般不用，都是框架底层来用的。\n\n​\t第二个方向：反射可以跟配置文件结合起来使用，动态的创建对象，动态的调用方法。\n\n## 1.11 练习泛型擦除（掌握概念，了解代码）\n\n理解：（掌握）\n\n​\t集合中的泛型只在java文件中存在，当编译成class文件之后，就没有泛型了。\n\n代码示例：（了解）\n\n```java\npackage com.itheima.reflectdemo;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\n\npublic class ReflectDemo8 {\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.创建集合对象\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(123);\n//        list.add("aaa");\n\n        //2.利用反射运行add方法去添加字符串\n        //因为反射使用的是class字节码文件\n\n        //获取class对象\n        Class clazz = list.getClass();\n\n        //获取add方法对象\n        Method method = clazz.getMethod("add", Object.class);\n\n        //运行方法\n        method.invoke(list,"aaa");\n\n        //打印集合\n        System.out.println(list);\n    }\n}\n\n```\n\n## 1.12 练习：修改字符串的内容（掌握概念，了解代码）\n\n在这个练习中，我需要你掌握的是字符串不能修改的真正原因。\n\n字符串，在底层是一个byte类型的字节数组，名字叫做value\n\n```java\nprivate final byte[] value;\n```\n\n真正不能被修改的原因：final和private\n\nfinal修饰value表示value记录的地址值不能修改。\n\nprivate修饰value而且没有对外提供getvalue和setvalue的方法。所以，在外界不能获取或修改value记录的地址值。\n\n如果要强行修改可以用反射：\n\n代码示例：（了解）\n\n```java\nString s = "abc";\nString ss = "abc";\n// private final byte[] value= {97,98,99};\n// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值\n// 如果我们利用反射获取了value的地址值。\n// 也是可以修改的，final修饰的value\n// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险\n\n//1.获取class对象\nClass clazz = s.getClass();\n\n//2.获取value成员变量（private）\nField field = clazz.getDeclaredField("value");\n//但是这种操作非常危险\n//JDK高版本已经屏蔽了这种操作，低版本还是可以的\n//临时修改权限\nfield.setAccessible(true);\n\n//3.获取value记录的地址值\nbyte[] bytes = (byte[]) field.get(s);\nbytes[0] = 100;\n\nSystem.out.println(s);//dbc\nSystem.out.println(ss);//dbc\n```\n\n## 1.13 练习，反射和配置文件结合动态获取的练习（重点）\n\n需求: 利用反射根据文件中的不同类名和方法名，创建不同的对象并调用方法。\n\n分析:\n\n①通过Properties加载配置文件\n\n②得到类名和方法名\n\n③通过类名反射得到Class对象\n\n④通过Class对象创建一个对象\n\n⑤通过Class对象得到方法\n\n⑥调用方法\n\n代码示例：\n\n```java\npublic class ReflectDemo9 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //1.读取配置文件的信息\n        Properties prop = new Properties();\n        FileInputStream fis = new FileInputStream("day14-code\\\\prop.properties");\n        prop.load(fis);\n        fis.close();\n        System.out.println(prop);\n\n        String classname = prop.get("classname") + "";\n        String methodname = prop.get("methodname") + "";\n\n        //2.获取字节码文件对象\n        Class clazz = Class.forName(classname);\n\n        //3.要先创建这个类的对象\n        Constructor con = clazz.getDeclaredConstructor();\n        con.setAccessible(true);\n        Object o = con.newInstance();\n        System.out.println(o);\n\n        //4.获取方法的对象\n        Method method = clazz.getDeclaredMethod(methodname);\n        method.setAccessible(true);\n\n        //5.运行方法\n        method.invoke(o);\n\n\n    }\n}\n\n配置文件中的信息：\nclassname=com.itheima.a02reflectdemo1.Student\nmethodname=sleep\n```\n\n## 1.14 利用发射保存对象中的信息（重点）\n\n```java\npublic class MyReflectDemo {\n    public static void main(String[] args) throws IllegalAccessException, IOException {\n    /*\n        对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去\n    */\n       Student s = new Student("小A",23,\'女\',167.5,"睡觉");\n       Teacher t = new Teacher("播妞",10000);\n       saveObject(s);\n    }\n\n    //把对象里面所有的成员变量名和值保存到本地文件中\n    public static void saveObject(Object obj) throws IllegalAccessException, IOException {\n        //1.获取字节码文件的对象\n        Class clazz = obj.getClass();\n        //2. 创建IO流\n        BufferedWriter bw = new BufferedWriter(new FileWriter("myreflect\\\\a.txt"));\n        //3. 获取所有的成员变量\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            field.setAccessible(true);\n            //获取成员变量的名字\n            String name = field.getName();\n            //获取成员变量的值\n            Object value = field.get(obj);\n            //写出数据\n            bw.write(name + "=" + value);\n            bw.newLine();\n        }\n\n        bw.close();\n\n    }\n}\n```\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private char gender;\n    private double height;\n    private String hobby;\n\n    public Student() {\n    }\n\n    public Student(String name, int age, char gender, double height, String hobby) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.height = height;\n        this.hobby = hobby;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public char getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return height\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * 设置\n     * @param height\n     */\n    public void setHeight(double height) {\n        this.height = height;\n    }\n\n    /**\n     * 获取\n     * @return hobby\n     */\n    public String getHobby() {\n        return hobby;\n    }\n\n    /**\n     * 设置\n     * @param hobby\n     */\n    public void setHobby(String hobby) {\n        this.hobby = hobby;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", height = " + height + ", hobby = " + hobby + "}";\n    }\n}\n```\n\n```java\npublic class Teacher {\n    private String name;\n    private double salary;\n\n    public Teacher() {\n    }\n\n    public Teacher(String name, double salary) {\n        this.name = name;\n        this.salary = salary;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return salary\n     */\n    public double getSalary() {\n        return salary;\n    }\n\n    /**\n     * 设置\n     * @param salary\n     */\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public String toString() {\n        return "Teacher{name = " + name + ", salary = " + salary + "}";\n    }\n}\n\n```\n\n# 2. 动态代理\n\n## 2.1 好处：\n\n​\t无侵入式的给方法增强功能\n\n## 2.2 动态代理三要素：\n\n1，真正干活的对象\n\n2，代理对象\n\n3，利用代理调用方法\n\n切记一点：代理可以增强或者拦截的方法都在接口中，接口需要写在newProxyInstance的第二个参数里。\n\n## 2.3 代码实现：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n    /*\n        需求：\n            外面的人想要大明星唱一首歌\n             1. 获取代理的对象\n                代理对象 = ProxyUtil.createProxy(大明星的对象);\n             2. 再调用代理的唱歌方法\n                代理对象.唱歌的方法("只因你太美");\n     */\n        //1. 获取代理的对象\n        BigStar bigStar = new BigStar("鸡哥");\n        Star proxy = ProxyUtil.createProxy(bigStar);\n\n        //2. 调用唱歌的方法\n        String result = proxy.sing("只因你太美");\n        System.out.println(result);\n    }\n}\n```\n\n```java\n/*\n*\n* 类的作用：\n*       创建一个代理\n*\n* */\npublic class ProxyUtil {\n    /*\n    *\n    * 方法的作用：\n    *       给一个明星的对象，创建一个代理\n    *\n    *  形参：\n    *       被代理的明星对象\n    *\n    *  返回值：\n    *       给明星创建的代理\n    *\n    *\n    *\n    * 需求：\n    *   外面的人想要大明星唱一首歌\n    *   1. 获取代理的对象\n    *      代理对象 = ProxyUtil.createProxy(大明星的对象);\n    *   2. 再调用代理的唱歌方法\n    *      代理对象.唱歌的方法("只因你太美");\n    * */\n    public static Star createProxy(BigStar bigStar){\n       /* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\n\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        参数一：用于指定用哪个类加载器，去加载生成的代理类\n        参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n        参数三：用来指定生成的代理对象要干什么事情*/\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),//参数一：用于指定用哪个类加载器，去加载生成的代理类\n                new Class[]{Star.class},//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n                //参数三：用来指定生成的代理对象要干什么事情\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        /*\n                        * 参数一：代理的对象\n                        * 参数二：要运行的方法 sing\n                        * 参数三：调用sing方法时，传递的实参\n                        * */\n                        if("sing".equals(method.getName())){\n                            System.out.println("准备话筒，收钱");\n                        }else if("dance".equals(method.getName())){\n                            System.out.println("准备场地，收钱");\n                        }\n                        //去找大明星开始唱歌或者跳舞\n                        //代码的表现形式：调用大明星里面唱歌或者跳舞的方法\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}\n```\n\n```java\npublic interface Star {\n    //我们可以把所有想要被代理的方法定义在接口当中\n    //唱歌\n    public abstract String sing(String name);\n    //跳舞\n    public abstract void dance();\n}\n```\n\n```java\npublic class BigStar implements Star {\n    private String name;\n\n\n    public BigStar() {\n    }\n\n    public BigStar(String name) {\n        this.name = name;\n    }\n\n    //唱歌\n    @Override\n    public String sing(String name){\n        System.out.println(this.name + "正在唱" + name);\n        return "谢谢";\n    }\n\n    //跳舞\n    @Override\n    public void dance(){\n        System.out.println(this.name + "正在跳舞");\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String toString() {\n        return "BigStar{name = " + name + "}";\n    }\n}\n\n```\n\n## 2.4 额外扩展\n\n动态代理，还可以拦截方法\n\n比如：\n\n​\t在这个故事中，经济人作为代理，如果别人让邀请大明星去唱歌，打篮球，经纪人就增强功能。\n\n​\t但是如果别人让大明星去扫厕所，经纪人就要拦截，不会去调用大明星的方法。\n\n```java\n/*\n* 类的作用：\n*       创建一个代理\n* */\npublic class ProxyUtil {\n    public static Star createProxy(BigStar bigStar){\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),\n                new Class[]{Star.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        if("cleanWC".equals(method.getName())){\n                            System.out.println("拦截，不调用大明星的方法");\n                            return null;\n                        }\n                        //如果是其他方法，正常执行\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}\n```\n\n## 2.5 动态代理的练习\n\n​\t 对add方法进行增强，对remove方法进行拦截，对其他方法不拦截也不增强\n\n```java\npublic class MyProxyDemo1 {\n    public static void main(String[] args) {\n        //动态代码可以增强也可以拦截\n        //1.创建真正干活的人\n        ArrayList<String> list = new ArrayList<>();\n\n        //2.创建代理对象\n        //参数一：类加载器。当前类名.class.getClassLoader()\n        //                 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存\n\n        //参数二：是一个数组，在数组里面写接口的字节码文件对象。\n        //                  如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截\n        //                  但是，一定要写ArrayList真实实现的接口\n        //                  假设在第二个参数中，写了MyInter接口，那么是错误的。\n        //                  因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截\n        //参数三：用来创建代理对象的匿名内部类\n        List proxyList = (List) Proxy.newProxyInstance(\n                //参数一：类加载器\n                MyProxyDemo1.class.getClassLoader(),\n                //参数二：是一个数组，表示代理对象能代理的方法范围\n                new Class[]{List.class},\n                //参数三：本质就是代理对象\n                new InvocationHandler() {\n                    @Override\n                    //invoke方法参数的意义\n                    //参数一：表示代理对象，一般不用（了解）\n                    //参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截\n                    //参数三：就是下面第三步调用方法时，传递的参数。\n                    //举例1：\n                    //list.add("阿玮好帅");\n                    //此时参数二就是add这个方法名\n                    //此时参数三 args[0] 就是 阿玮好帅\n                    //举例2：\n                    //list.set(1, "aaa");\n                    //此时参数二就是set这个方法名\n                    //此时参数三  args[0] 就是 1  args[1]"aaa"\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        //对add方法做一个增强，统计耗时时间\n                        if (method.getName().equals("add")) {\n                            long start = System.currentTimeMillis();\n                            //调用集合的方法，真正的添加数据\n                            method.invoke(list, args);\n                            long end = System.currentTimeMillis();\n                            System.out.println("耗时时间：" + (end - start));\n                            //需要进行返回，返回值要跟真正增强或者拦截的方法保持一致\n                            return true;\n                        }else if(method.getName().equals("remove") && args[0] instanceof Integer){\n                            System.out.println("拦截了按照索引删除的方法");\n                            return null;\n                        }else if(method.getName().equals("remove")){\n                            System.out.println("拦截了按照对象删除的方法");\n                            return false;\n                        }else{\n                            //如果当前调用的是其他方法,我们既不增强，也不拦截\n                            method.invoke(list,args);\n                            return null;\n                        }\n                    }\n                }\n        );\n\n        //3.调用方法\n        //如果调用者是list，就好比绕过了第二步的代码，直接添加元素\n        //如果调用者是代理对象，此时代理才能帮我们增强或者拦截\n\n        //每次调用方法的时候，都不会直接操作集合\n        //而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截\n        proxyList.add("aaa");\n        proxyList.add("bbb");\n        proxyList.add("ccc");\n        proxyList.add("ddd");\n\n        proxyList.remove(0);\n        proxyList.remove("aaa");\n\n\n        //打印集合\n        System.out.println(list);\n    }\n}\n```\n\n'},{title:"Spring Framework 综述",headers:[{level:2,title:"Spring Framework 简介",slug:"spring-framework-简介",link:"#spring-framework-简介",children:[]},{level:2,title:"为什么使用 Spring",slug:"为什么使用-spring",link:"#为什么使用-spring",children:[]},{level:2,title:"核心思想",slug:"核心思想",link:"#核心思想",children:[{level:3,title:"IoC",slug:"ioc",link:"#ioc",children:[]},{level:3,title:"Aop",slug:"aop",link:"#aop",children:[]}]},{level:2,title:"Spring 体系结构",slug:"spring-体系结构",link:"#spring-体系结构",children:[{level:3,title:"Core Container",slug:"core-container",link:"#core-container",children:[]},{level:3,title:"AOP and Instrumentation",slug:"aop-and-instrumentation",link:"#aop-and-instrumentation",children:[]},{level:3,title:"Messaging",slug:"messaging",link:"#messaging",children:[]},{level:3,title:"Data Access / Integaration",slug:"data-access-integaration",link:"#data-access-integaration",children:[]},{level:3,title:"Web",slug:"web",link:"#web",children:[]},{level:3,title:"Test",slug:"test",link:"#test",children:[]}]},{level:2,title:"术语",slug:"术语",link:"#术语",children:[]}],path:"/pages/9d3091/",pathLocale:"/",extraFields:'---\ntitle: Spring Framework 综述\ndate: 2019-11-22 10:46:02\norder: 1\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring综合\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/9d3091/\n---\n\n# Spring Framework 综述\n\n## Spring Framework 简介\n\nSpring Framework 是最受欢迎的企业级 Java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。\n\n当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。\n\nSpring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。\n\nSpring Framework 设计理念如下：\n\n- 力争让选择无处不在\n- 体现海纳百川的精神\n- 保持后向兼容性\n- 专注 API 设计\n- 追求严苛的代码质量\n\n## 为什么使用 Spring\n\n下面列出的是使用 Spring 框架主要的好处：\n\n- Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。\n- Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只需要选择你需要的部分，而忽略剩余的那部分。\n- Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。\n- 测试一个用 Spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。\n- Spring 的 web 框架是一个设计良好的 web MVC 框架，它为 web 框架，比如 Structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。\n- 为将特定技术的异常（例如，由 JDBC、Hibernate，或者 JDO 抛出的异常）翻译成一致的， Spring 提供了一个方便的 API，而这些都是未经检验的异常。\n- 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。\n- Spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 JTA）。\n\n## 核心思想\n\nSpring 最核心的两个技术思想是：IoC 和 Aop\n\n### IoC\n\n`IoC` 即 `Inversion of Control` ，意为控制反转。\n\nSpring 最认同的技术是控制反转的**依赖注入（DI）**模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。\n\n当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。\n\n到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。\n\n依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。\n\n### Aop\n\nSpring 框架的一个关键组件是**面向方面的程序设计（AOP）**框架。一个程序中跨越多个点的功能被称为**横切关注点**，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。\n\n在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。\n\nSpring 框架的 AOP 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 Spring AOP 的概念。\n\n## Spring 体系结构\n\nSpring 当前框架有**20**个 jar 包，大致可以分为**6**大模块:\n\n- 1. 为什么使用 Spring\n- 2. 核心思想\n  - 2.1. IoC\n  - 2.2. Aop\n- 3. Spring 体系结构\n  - 3.1. Core Container\n    - 3.1.1. BeanFactory\n    - 3.1.2. ApplicationContext\n  - 3.2. AOP and Instrumentation\n  - 3.3. Messaging\n  - 3.4. Data Access / Integaration\n  - 3.5. Web\n  - 3.6. Test\n- 4. 术语\n\nSpring 框架提供了非常丰富的功能，因此整个架构也很庞大。\n在我们实际的应用开发中，并不一定要使用所有的功能，而是可以根据需要选择合适的 Spring 模块。\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/spring-framework.png)\n\n### Core Container\n\nIoC 容器是 Spring 框架的核心。spring 容器使用依赖注入管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更容易理解，也更容易重用和测试。\nSpring 自带了几种容器的实现，可归纳为两种类型：\n\n#### BeanFactory\n\n由 org.springframework.beans.factory.BeanFactory 接口定义。\n它是最简单的容器，提供基本的 DI 支持。\n\n#### ApplicationContext\n\n由 org.springframework.context.ApplicationContext 接口定义。\n它是基于 BeanFactory 之上构建，并提供面向应用的服务，例如从属性文件解析文本信息的能力，以及发布应用事件给感兴趣的事件监听者的能力。\n**_注：Bean 工厂对于大多数应用来说往往太低级了，所以应用上下文使用更广泛。推荐在开发中使用应用上下文容器。_**\n\nSpring 自带了多种应用上下文，最可能遇到的有以下几种：\n`ClassPathXmlApplicationContext`：从类路径下的 XML 配置文件中加载上下文定义，把应用上下文定义文件当做类资源。\n`FileSystemXmlApplicationContext`：读取文件系统下的 XML 配置文件并加载上下文定义。\n`XmlWebApplicationContext`：读取 Web 应用下的 XML 配置文件并装载上下文定义。\n\n**_范例_**\n\n```java\nApplicationContext context = new FileSystemXmlApplicationContext("D:\\Temp\\build.xml");\nApplicationContext context2 = new ClassPathXmlApplicationContext("build.xml");\n```\n\n可以看到，加载 `FileSystemXmlApplicationContext` 和 `ClassPathXmlApplicationContext` 十分相似。\n差异在于：前者在指定文件系统路径下查找 build.xml 文件；而后在所有类路径（包含 JAR 文件）下查找 build.xml 文件。\n通过引用应用上下文，可以很方便的调用 getBean() 方法从 Spring 容器中获取 Bean。\n\n**相关 jar 包**\n\n- `spring-core`, `spring-beans`, 提供框架的基础部分，包括 IoC 和依赖注入特性。\n\n- `spring-context`, 在`spring-core`, `spring-beans`基础上构建。它提供一种框架式的访问对象的方法。它也支持类似 Java EE 特性，例如：EJB，JMX 和基本 remoting。ApplicationContext 接口是它的聚焦点。\n- `springcontext-support`, 集成第三方库到 Spring application context。\n- `spring-expression`，提供一种强有力的表达语言在运行时来查询和操纵一个对象图。\n\n### AOP and Instrumentation\n\n**相关 jar 包**\n\n- `spring-aop`，提供了对面向切面编程的丰富支持。\n- `spring-aspects`，提供了对 AspectJ 的集成。\n- `spring-instrument`，提供了对类 instrumentation 的支持和类加载器。\n- `spring-instrument-tomcat`，包含了 Spring 对 Tomcat 的 instrumentation 代理。\n\n### Messaging\n\n**相关 jar 包**\n\n- `spring-messaging`，包含 spring 的消息处理功能，如 Message，MessageChannel，MessageHandler。\n\n### Data Access / Integaration\n\nData Access/Integration 层包含了 JDBC / ORM / OXM / JMS 和 Transaction 模块。\n\n**相关 jar 包**\n\n- `spring-jdbc`，提供了一个 JDBC 抽象层。\n\n- `spring-tx`，支持编程和声明式事务管理类。\n- `spring-orm`，提供了流行的对象关系型映射 API 集，如 JPA，JDO，Hibernate。\n- `spring-oxm`，提供了一个抽象层以支持对象/XML 映射的实现，如 JAXB，Castor，XMLBeans，JiBX 和 XStream.\n- `spring-jms`，包含了生产和消费消息的功能。\n\n### Web\n\n**相关 jar 包**\n\n- `spring-web`，提供了基本的面向 web 的功能，如多文件上传、使用 Servlet 监听器的 Ioc 容器的初始化。一个面向 web 的应用层上下文。\n\n- `spring-webmvc`，包括 MVC 和 REST web 服务实现。\n- `spring-webmvc-portlet`，提供在 Protlet 环境的 MVC 实现和`spring-webmvc`功能的镜像。\n\n### Test\n\n**相关 jar 包**\n\n- `spring-test`，以 Junit 和 TestNG 来支持 spring 组件的单元测试和集成测试。\n\n## 术语\n\n- **应用程序**：是能完成我们所需要功能的成品，比如购物网站、OA 系统。\n- **框架**：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。\n- **非侵入式设计**：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。\n- **轻量级及重量级**：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。\n- **POJO**：POJO（Plain Old Java Objects）简单的 Java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。\n- **容器**：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。\n- **控制反转：**即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。\n- **JavaBean**：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。'},{title:"SpringBoot 知识图谱",headers:[{level:2,title:"一、抛砖引玉：探索 Spring IoC 容器",slug:"一、抛砖引玉-探索-spring-ioc-容器",link:"#一、抛砖引玉-探索-spring-ioc-容器",children:[{level:3,title:"1.1、Spring IoC 容器",slug:"_1-1、spring-ioc-容器",link:"#_1-1、spring-ioc-容器",children:[]},{level:3,title:"1.2、Spring 容器扩展机制",slug:"_1-2、spring-容器扩展机制",link:"#_1-2、spring-容器扩展机制",children:[]}]},{level:2,title:"二、夯实基础：JavaConfig 与常见 Annotation",slug:"二、夯实基础-javaconfig-与常见-annotation",link:"#二、夯实基础-javaconfig-与常见-annotation",children:[{level:3,title:"2.1、JavaConfig",slug:"_2-1、javaconfig",link:"#_2-1、javaconfig",children:[]},{level:3,title:"2.2、@ComponentScan",slug:"_2-2、-componentscan",link:"#_2-2、-componentscan",children:[]},{level:3,title:"2.3、@Import",slug:"_2-3、-import",link:"#_2-3、-import",children:[]},{level:3,title:"2.4、@Conditional",slug:"_2-4、-conditional",link:"#_2-4、-conditional",children:[]},{level:3,title:"2.5、@ConfigurationProperties 与@EnableConfigurationProperties",slug:"_2-5、-configurationproperties-与-enableconfigurationproperties",link:"#_2-5、-configurationproperties-与-enableconfigurationproperties",children:[]}]},{level:2,title:"三、削铁如泥：SpringFactoriesLoader 详解",slug:"三、削铁如泥-springfactoriesloader-详解",link:"#三、削铁如泥-springfactoriesloader-详解",children:[]},{level:2,title:"四、另一件武器：Spring 容器的事件监听机制",slug:"四、另一件武器-spring-容器的事件监听机制",link:"#四、另一件武器-spring-容器的事件监听机制",children:[]},{level:2,title:"五、出神入化：揭秘自动配置原理",slug:"五、出神入化-揭秘自动配置原理",link:"#五、出神入化-揭秘自动配置原理",children:[]},{level:2,title:"六、启动引导：Spring Boot 应用启动的秘密",slug:"六、启动引导-spring-boot-应用启动的秘密",link:"#六、启动引导-spring-boot-应用启动的秘密",children:[{level:3,title:"6.1 SpringApplication 初始化",slug:"_6-1-springapplication-初始化",link:"#_6-1-springapplication-初始化",children:[]},{level:3,title:"6.2 Spring Boot 启动流程",slug:"_6-2-spring-boot-启动流程",link:"#_6-2-spring-boot-启动流程",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/430f53/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 知识图谱\ndate: 2020-08-12 07:01:26\norder: 1\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring综合\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/430f53/\n---\n\n# SpringBoot 知识图谱\n\n> 1. 预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章\n> 2. 说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。\n\n在过去两三年的 Spring 生态圈，最让人兴奋的莫过于 Spring Boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 Spring 应用。因而 Spring Boot 应用本质上就是一个基于 Spring 框架的应用，它是 Spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 Spring 生态圈的应用。\n\n那 Spring Boot 有何魔法？**自动配置**、**起步依赖**、**Actuator**、**命令行界面(CLI)** 是 Spring Boot 最重要的 4 大核心特性，其中 CLI 是 Spring Boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 Spring Boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 Spring 框架的基础知识，将会让你事半功倍。\n\n## 一、抛砖引玉：探索 Spring IoC 容器\n\n如果有看过`SpringApplication.run()`方法的源码，Spring Boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，SpringApplication 只是将一个典型的 Spring 应用的启动流程进行了扩展，因此，透彻理解 Spring 容器是打开 Spring Boot 大门的一把钥匙。\n\n### 1.1、Spring IoC 容器\n\n可以把 Spring IoC 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。IoC 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。\n\n作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，IoC 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。`BeanDefinition`对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 BeanDefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。\n\n原材料已经准备好（把 BeanDefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，`BeanDefinitionRegistry`和`BeanFactory`就是这份菜谱，BeanDefinitionRegistry 抽象出 bean 的注册逻辑，而 BeanFactory 则抽象出了 bean 的管理逻辑，而各个 BeanFactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：\n\n![img](https://user-gold-cdn.xitu.io/2018/9/9/165bd49d06649b0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) _BeanFactory、BeanDefinitionRegistry 关系图（来自：Spring 揭秘）_\n\n`DefaultListableBeanFactory`作为一个比较通用的 BeanFactory 实现，它同时也实现了 BeanDefinitionRegistry 接口，因此它就承担了 Bean 的注册管理工作。从图中也可以看出，BeanFactory 接口中主要包含 getBean、containBean、getType、getAliases 等管理 bean 的方法，而 BeanDefinitionRegistry 接口则包含 registerBeanDefinition、removeBeanDefinition、getBeanDefinition 等注册管理 BeanDefinition 的方法。\n\n下面通过一段简单的代码来模拟 BeanFactory 底层是如何工作的：\n\n```\n// 默认容器实现\nDefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();\n// 根据业务对象构造相应的BeanDefinition\nAbstractBeanDefinition definition = new RootBeanDefinition(Business.class,true);\n// 将bean定义注册到容器中\nbeanRegistry.registerBeanDefinition("beanName",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，\n// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n```\n\n这段代码仅为了说明 BeanFactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(XML/Properties)中、也可能是注解方式。Spring IoC 容器的整个工作流程大致可以分为两个阶段：\n\n①、容器启动阶段\n\n容器启动时，会通过某种途径加载`Configuration MetaData`。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：`BeanDefinitionReader`，BeanDefinitionReader 会对加载的`Configuration MetaData`进行解析和分析，并将分析后的信息组装为相应的 BeanDefinition，最后把这些保存了 bean 定义的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。\n\n来看一个简单的例子吧，过往，所有的 bean 都定义在 XML 配置文件中，下面的代码将模拟 BeanFactory 如何从配置文件中加载 bean 的定义以及依赖关系：\n\n```\n// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例\nBeanDefinitionRegistry beanRegistry = new DefaultListableBeanFactory();\n// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件\nXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReaderImpl(beanRegistry);\n// 加载配置文件\nbeanDefinitionReader.loadBeanDefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n```\n\n②、Bean 的实例化阶段\n\n经过第一阶段，所有 bean 定义都通过 BeanDefinition 的方式注册到 BeanDefinitionRegistry 中，当某个请求通过容器的 getBean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getBean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 BeanDefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。\n\nBeanFactory 只是 Spring IoC 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：`ApplicationContext`，它构建在 BeanFactory 之上，属于更高级的容器，除了具有 BeanFactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。\n\n### 1.2、Spring 容器扩展机制\n\nIoC 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，Spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，`BeanFactoryPostProcessor`允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。\n\n如果要自定义扩展类，通常需要实现`org.springframework.beans.factory.config.BeanFactoryPostProcessor`接口，与此同时，因为容器中可能有多个 BeanFactoryPostProcessor，可能还需要实现`org.springframework.core.Ordered`接口，以保证 BeanFactoryPostProcessor 按照顺序执行。Spring 提供了为数不多的 BeanFactoryPostProcessor 实现，我们以`PropertyPlaceholderConfigurer`来说明其大致的工作流程。\n\n在 Spring 项目的 XML 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 XML 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer 负责实现的。\n\n根据前文，当 BeanFactory 在第一阶段加载完所有配置信息时，BeanFactory 中保存的对象的属性还是以占位符方式存在的，比如`${jdbc.mysql.url}`。当 PropertyPlaceholderConfigurer 作为 BeanFactoryPostProcessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 BeanDefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。\n\n与之相似的，还有`BeanPostProcessor`，其存在于对象实例化阶段。跟 BeanFactoryPostProcessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor 处理 bean 的定义，而 BeanPostProcessor 则处理 bean 完成实例化后的对象。BeanPostProcessor 定义了两个接口：\n\n```\npublic interface BeanPostProcessor {\n    // 前置处理\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n    // 后置处理\n    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n```\n\n为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：\n\n`postProcessBeforeInitialization()`方法与`postProcessAfterInitialization()`分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、AOP 等功能的实现均大量使用了`BeanPostProcessor`，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？\n\n再来看一个更常见的例子，在 Spring 中经常能够看到各种各样的 Aware 接口，其作用就是在对象实例化完成以后将 Aware 接口定义中规定的依赖注入到当前实例中。比如最常见的`ApplicationContextAware`接口，实现了这个接口的类都可以获取到一个 ApplicationContext 对象。当容器中每个对象的实例化过程走到 BeanPostProcessor 前置处理这一步时，容器会检测到之前注册到容器的 ApplicationContextAwareProcessor，然后就会调用其 postProcessBeforeInitialization()方法，检查并设置 Aware 相关依赖。看看代码吧，是不是很简单：\n\n```\n// 代码来自：org.springframework.context.support.ApplicationContextAwareProcessor\n// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof EnvironmentAware) {\n        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n    }\n    if (bean instanceof ApplicationContextAware) {\n        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n    }\n    // ......\n}\n```\n\n最后总结一下，本小节内容和你一起回顾了 Spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 Spring Boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 Spring 的核心知识，也许有意想不到的效果。也许 Spring Boot 的中文资料很少，但 Spring 的中文资料和书籍有太多太多，总有东西能给你启发。\n\n## 二、夯实基础：JavaConfig 与常见 Annotation\n\n### 2.1、JavaConfig\n\n我们知道`bean`是 Spring IOC 中非常核心的概念，Spring 容器负责 bean 的生命周期的管理。在最初，Spring 使用 XML 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 Spring 的发展，越来越多的人对这种方式表示不满，因为 Spring 项目的所有业务类均以 bean 的形式配置在 XML 文件中，造成了大量的 XML 文件，使项目变得复杂且难以管理。\n\n后来，基于纯 Java Annotation 依赖注入框架`Guice`出世，其性能明显优于采用 XML 方式的 Spring，甚至有部分人认为，`Guice`可以完全取代 Spring（`Guice`仅是一个轻量级 IOC 框架，取代 Spring 还差的挺远）。正是这样的危机感，促使 Spring 及社区推出并持续完善了`JavaConfig`子项目，它基于 Java 代码和 Annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 XML 配置方式来描述 bean 的定义：\n\n```\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl"></bean>\n```\n\n而基于 JavaConfig 的配置形式是这样的：\n\n```\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中\n    // 方法名默认成为该bean定义的id\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n```\n\n如果两个 bean 之间有依赖关系的话，在 XML 配置中应该是这样：\n\n```\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="otherService" class="cn.moondev.service.OtherServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"/>\n```\n\n而在 JavaConfig 中则是这样：\n\n```\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyService()\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public OtherService otherService() {\n        return new OtherServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService() {\n        return new DependencyServiceImpl();\n    }\n}\n```\n\n你可能注意到这个示例中，有两个 bean 都依赖于 dependencyService，也就是说当初始化 bookService 时会调用`dependencyService()`，在初始化 otherService 时也会调用`dependencyService()`，那么问题来了？这时候 IOC 容器中是有一个 dependencyService 实例还是两个？这个问题留着大家思考吧，这里不再赘述。\n\n### 2.2、@ComponentScan\n\n`@ComponentScan`注解对应 XML 配置形式中的``元素，表示启用组件扫描，Spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 IOC 容器中。我们可以通过`basePackages`等属性来指定`@ComponentScan`自动扫描的范围，如果不指定，默认从声明`@ComponentScan`所在类的`package`进行扫描。正因为如此，SpringBoot 的启动类都默认在`src/main/java`下。\n\n### 2.3、@Import\n\n`@Import`注解用于导入配置类，举个简单的例子：\n\n```\n@Configuration\npublic class MoonBookConfiguration {\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n```\n\n现在有另外一个配置类，比如：`MoonUserConfiguration`，这个配置类中有一个 bean 依赖于`MoonBookConfiguration`中的 bookService，如何将这两个 bean 组合在一起？借助`@Import`即可：\n\n```\n@Configuration\n// 可以同时导入多个配置类，比如：@Import({A.class,B.class})\n@Import(MoonBookConfiguration.class)\npublic class MoonUserConfiguration {\n    @Bean\n    public UserService userService(BookService bookService) {\n        return new BookServiceImpl(bookService);\n    }\n}\n```\n\n需要注意的是，在 4.2 之前，`@Import`注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 IOC 容器中。\n\n### 2.4、@Conditional\n\n`@Conditional`注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由`@Component`、`@Service`、`@Configuration`等注解标识的类上面，或者由`@Bean`标记的方法上。如果一个`@Configuration`类标记了`@Conditional`，则该类中所有标识了`@Bean`的方法和`@Import`注解导入的相关类将遵从这些条件。\n\n在 Spring 里可以很方便的编写你自己的条件类，所要做的就是实现`Condition`接口，并覆盖它的`matches()`方法。举个例子，下面的简单条件类表示只有在`Classpath`里存在`JdbcTemplate`类时才生效：\n\n```\npublic class JdbcTemplateCondition implements Condition {\n\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n        try {\n        conditionContext.getClassLoader().loadClass("org.springframework.jdbc.core.JdbcTemplate");\n            return true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n```\n\n当你用 Java 来声明 bean 的时候，可以使用这个自定义条件类：\n\n```\n@Conditional(JdbcTemplateCondition.class)\n@Service\npublic MyService service() {\n    ......\n}\n```\n\n这个例子中只有当`JdbcTemplateCondition`类的条件成立时才会创建 MyService 这个 bean。也就是说 MyService 这 bean 的创建条件是`classpath`里面包含`JdbcTemplate`，否则这个 bean 的声明就会被忽略掉。\n\n`Spring Boot`定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了`Spring Boot`的自动配置的基础。`Spring Boot`运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了`Spring Boot`提供的部分条件化注解：\n\n| 条件化注解                      | 配置生效条件                                            |\n| ------------------------------- | ------------------------------------------------------- |\n| @ConditionalOnBean              | 配置了某个特定 bean                                     |\n| @ConditionalOnMissingBean       | 没有配置特定的 bean                                     |\n| @ConditionalOnClass             | Classpath 里有指定的类                                  |\n| @ConditionalOnMissingClass      | Classpath 里没有指定的类                                |\n| @ConditionalOnExpression        | 给定的 Spring Expression Language 表达式计算结果为 true |\n| @ConditionalOnJava              | Java 的版本匹配特定指或者一个范围值                     |\n| @ConditionalOnProperty          | 指定的配置属性要有一个明确的值                          |\n| @ConditionalOnResource          | Classpath 里有指定的资源                                |\n| @ConditionalOnWebApplication    | 这是一个 Web 应用程序                                   |\n| @ConditionalOnNotWebApplication | 这不是一个 Web 应用程序                                 |\n\n### 2.5、@ConfigurationProperties 与@EnableConfigurationProperties\n\n当某些属性的值需要配置的时候，我们一般会在`application.properties`文件中新建配置项，然后在 bean 中使用`@Value`注解来获取配置的值，比如下面配置数据源的代码。\n\n```\n// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @Value("jdbc.mysql.url")\n    public String url;\n    @Value("jdbc.mysql.username")\n    public String user;\n    @Value("jdbc.mysql.password")\n    public String password;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(url);\n        hikariConfig.setUsername(user);\n        hikariConfig.setPassword(password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n```\n\n使用`@Value`注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot 提供了更优雅的实现方式，那就是`@ConfigurationProperties`注解。我们可以通过下面的方式来改写上面的代码：\n\n```\n@Component\n//  还可以通过@PropertySource("classpath:jdbc.properties")来指定配置文件\n@ConfigurationProperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class JdbcConfig {\n    public String url;\n    public String username;\n    public String password;\n}\n\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @AutoWired\n    public JdbcConfig config;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(config.url);\n        hikariConfig.setUsername(config.username);\n        hikariConfig.setPassword(config.password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n```\n\n`@ConfigurationProperties`对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：\n\n```\n#App\napp.menus[0].title=Home\napp.menus[0].name=Home\napp.menus[0].path=/\napp.menus[1].title=Login\napp.menus[1].name=Login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/\n```\n\n可以定义如下配置类来接收这些属性\n\n```\n@Component\n@ConfigurationProperties("app")\npublic class AppProperties {\n\n    public String error;\n    public List<Menu> menus = new ArrayList<>();\n    public Compiler compiler = new Compiler();\n\n    public static class Menu {\n        public String name;\n        public String path;\n        public String title;\n    }\n\n    public static class Compiler {\n        public String timeout;\n        public String outputFolder;\n    }\n}\n```\n\n`@EnableConfigurationProperties`注解表示对`@ConfigurationProperties`的内嵌支持，默认会将对应 Properties Class 作为 bean 注入的 IOC 容器中，即在相应的 Properties 类上不用加`@Component`注解。\n\n## 三、削铁如泥：SpringFactoriesLoader 详解\n\nJVM 提供了 3 种类加载器：`BootstrapClassLoader`、`ExtClassLoader`、`AppClassLoader`分别加载 Java 核心类库、扩展类库以及应用的类路径(`CLASSPATH`)下的类库。JVM 通过双亲委派模型进行类的加载，我们也可以通过继承`java.lang.classloader`实现自己的类加载器。\n\n何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。\n\n采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于 rt.jar 包中的`java.lang.Object`类，不管是哪个加载器加载这个类，最终都是委托给顶层的 BootstrapClassLoader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 Object 对象。查看 ClassLoader 的源码，对双亲委派模型会有更直观的认识：\n\n```\nprotected Class<?> loadClass(String name, boolean resolve) {\n    synchronized (getClassLoadingLock(name)) {\n    // 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回\n    Class<?> c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是BootstrapClassLoader为止\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findClass方法去寻找\n            // findClass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findClass(name);\n        }\n    }\n    if (resolve) {\n        resolveClass(c);\n    }\n    return c;\n    }\n}\n```\n\n但双亲委派模型并不能解决所有的类加载器问题，比如，Java 提供了很多服务提供者接口(`Service Provider Interface`，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些 SPI 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由 BootstrapClassLoader 加载的；SPI 实现的 Java 类一般是由 AppClassLoader 来加载的。BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。\n\n线程上下文类加载器(`ContextClassLoader`)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 Thread 类的一个变量而已，可以通过`setContextClassLoader(ClassLoader cl)`和`getContextClassLoader()`来设置和获取该对象。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是 AppClassLoader。在核心类库使用 SPI 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。但在 JDBC 中，你可能会看到一种更直接的实现方式，比如，JDBC 驱动管理`java.sql.Driver`中的`loadInitialDrivers()`方法中，你可以直接看到 JDK 是如何加载驱动的：\n\n```\nfor (String aDriver : driversList) {\n    try {\n        // 直接使用AppClassLoader\n        Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());\n    } catch (Exception ex) {\n        println("DriverManager.Initialize: load failed: " + ex);\n    }\n}\n```\n\n其实讲解线程上下文类加载器，最主要是让大家在看到`Thread.currentThread().getClassLoader()`和`Thread.currentThread().getContextClassLoader()`时不会一脸懵逼，这两者除了在许多底层框架中取得的 ClassLoader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。\n\n类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，`ClassLoader.getResources(String name)`方法就是用于读取 jar 包中的资源文件，其代码如下：\n\n```\npublic Enumeration<URL> getResources(String name) throws IOException {\n    Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getResources(name);\n    } else {\n        tmp[0] = getBootstrapResources(name);\n    }\n    tmp[1] = findResources(name);\n    return new CompoundEnumeration<>(tmp);\n}\n```\n\n是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 BootstrapClassLoader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。\n\n类加载器的`findResources(name)`方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 Array.class 文件：\n\n```\n// 寻找Array.class文件\npublic static void main(String[] args) throws Exception{\n    // Array.class的完整路径\n    String name = "java/sql/Array.class";\n    Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(name);\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        System.out.println(url.toString());\n    }\n}\n```\n\n运行后可以得到如下结果：\n\n```\n$JAVA_HOME/jre/lib/rt.jar!/java/sql/Array.class\n```\n\n根据资源文件的 URL，可以构造相应的文件来读取资源内容。\n\n看到这里，你可能会感到挺奇怪的，你不是要详解`SpringFactoriesLoader`吗？上来讲了一堆 ClassLoader 是几个意思？看下它的源码你就知道了：\n\n```\npublic static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到META-INF/spring.factories文件\n// 然后从文件中解析出key=factoryClass类名称的所有value值\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    // 取得资源文件的URL\n    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    List<String> result = new ArrayList<String>();\n    // 遍历所有的URL\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // 根据资源文件URL解析properties文件\n        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n        String factoryClassNames = properties.getProperty(factoryClassName);\n        // 组装数据，并返回\n        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n    }\n    return result;\n}\n```\n\n有了前面关于 ClassLoader 的知识，再来理解这段代码，是不是感觉豁然开朗：从`CLASSPATH`下的每个 Jar 包中搜寻所有`META-INF/spring.factories`配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 ClassPath 路径下查找，会扫描所有路径下的 Jar 包，只不过这个文件只会在 Classpath 下的 jar 包中。来简单看下`spring.factories`文件的内容吧：\n\n```\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n```\n\n执行`loadFactoryNames(EnableAutoConfiguration.class, classLoader)`后，得到对应的一组`@Configuration`类，\n我们就可以通过反射实例化这些类然后注入到 IOC 容器中，最后容器里就有了一系列标注了`@Configuration`的 JavaConfig 形式的配置类。\n\n这就是`SpringFactoriesLoader`，它本质上属于 Spring 框架私有的一种扩展方案，类似于 SPI，Spring Boot 在 Spring 基础上的很多核心功能都是基于此，希望大家可以理解。\n\n## 四、另一件武器：Spring 容器的事件监听机制\n\n过去，事件监听机制多用于图形界面编程，比如：**点击**按钮、在文本框**输入**内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。Java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自`java.util.EventObject`、事件的监听器扩展自`java.util.EventListener`。来看一个简单的实例：简单的监控一个方法的耗时。\n\n首先定义事件类型，通常的做法是扩展 EventObject，随着事件的发生，相应的状态通常都封装在此类中：\n\n```\npublic class MethodMonitorEvent extends EventObject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public MethodMonitorEvent(Object source) {\n        super(source);\n    }\n}\n```\n\n事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：\n\n```\n// 1、定义事件监听接口\npublic interface MethodMonitorEventListener extends EventListener {\n    // 处理方法执行之前发布的事件\n    public void onMethodBegin(MethodMonitorEvent event);\n    // 处理方法结束时发布的事件\n    public void onMethodEnd(MethodMonitorEvent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class AbstractMethodMonitorEventListener implements MethodMonitorEventListener {\n\n    @Override\n    public void onMethodBegin(MethodMonitorEvent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void onMethodEnd(MethodMonitorEvent event) {\n        // 计算方法耗时\n        long duration = System.currentTimeMillis() - event.timestamp;\n        System.out.println("耗时：" + duration);\n    }\n}\n```\n\n事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 MethodMonitorEvent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：\n\n```\npublic class MethodMonitorEventPublisher {\n\n    private List<MethodMonitorEventListener> listeners = new ArrayList<MethodMonitorEventListener>();\n\n    public void methodMonitor() {\n        MethodMonitorEvent eventObject = new MethodMonitorEvent(this);\n        publishEvent("begin",eventObject);\n        // 模拟方法执行：休眠5秒钟\n        TimeUnit.SECONDS.sleep(5);\n        publishEvent("end",eventObject);\n\n    }\n\n    private void publishEvent(String status,MethodMonitorEvent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        List<MethodMonitorEventListener> copyListeners = ➥ new ArrayList<MethodMonitorEventListener>(listeners);\n        for (MethodMonitorEventListener listener : copyListeners) {\n            if ("begin".equals(status)) {\n                listener.onMethodBegin(event);\n            } else {\n                listener.onMethodEnd(event);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MethodMonitorEventPublisher publisher = new MethodMonitorEventPublisher();\n        publisher.addEventListener(new AbstractMethodMonitorEventListener());\n        publisher.methodMonitor();\n    }\n    // 省略实现\n    public void addEventListener(MethodMonitorEventListener listener) {}\n    public void removeEventListener(MethodMonitorEventListener listener) {}\n    public void removeAllListeners() {}\n```\n\n对于事件发布者（事件源）通常需要关注两点：\n\n1. 在合适的时机发布事件。此例中的 methodMonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 MethodMonitorEvent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。\n2. 事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 MethodMonitorEventPublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。\n\n#### Spring 容器内的事件监听机制\n\nSpring 的 ApplicationContext 容器内部中的所有事件类型均继承自`org.springframework.context.ApplicationEvent`，容器中的所有监听器都实现`org.springframework.context.ApplicationListener`接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 ApplicationEvent 及其子类型的事件，注册到容器的 ApplicationListener 就会对这些事件进行处理。\n\n你应该已经猜到是怎么回事了。\n\nApplicationEvent 继承自 EventObject，Spring 提供了一些默认的实现，比如：`ContextClosedEvent`表示容器在即将关闭时发布的事件类型，`ContextRefreshedEvent`表示容器在初始化或者刷新的时候发布的事件类型......\n\n容器内部使用 ApplicationListener 作为事件监听器接口定义，它继承自 EventListener。ApplicationContext 容器在启动时，会自动识别并加载 EventListener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 EventListener。\n\nApplicationContext 接口继承了 ApplicationEventPublisher 接口，该接口提供了`void publishEvent(ApplicationEvent event)`方法定义，不难看出，ApplicationContext 容器担当的就是事件发布者的角色。如果有兴趣可以查看`AbstractApplicationContext.publishEvent(ApplicationEvent event)`方法的源码：ApplicationContext 将事件的发布以及监听器的管理工作委托给`ApplicationEventMulticaster`接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationEventMulticaster 的 ApplicationEventMulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 SimpleApplicationEventMulticaster 作为实现。\n\n最后，如果我们业务需要在容器内部发布事件，只需要为其注入 ApplicationEventPublisher 依赖即可：实现 ApplicationEventPublisherAware 接口或者 ApplicationContextAware 接口(Aware 接口相关内容请回顾上文)。\n\n## 五、出神入化：揭秘自动配置原理\n\n典型的 Spring Boot 应用的启动类一般均位于`src/main/java`根路径下，比如`MoonApplication`类：\n\n```\n@SpringBootApplication\npublic class MoonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MoonApplication.class, args);\n    }\n}\n```\n\n其中`@SpringBootApplication`开启组件扫描和自动配置，而`SpringApplication.run`则负责启动引导应用程序。`@SpringBootApplication`是一个复合`Annotation`，它将三个有用的注解组合在一起：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ......\n}\n```\n\n`@SpringBootConfiguration`就是`@Configuration`，它是 Spring 框架的注解，标明该类是一个`JavaConfig`配置类。而`@ComponentScan`启用组件扫描，前文已经详细讲解过，这里着重关注`@EnableAutoConfiguration`。\n\n`@EnableAutoConfiguration`注解表示开启 Spring Boot 自动配置功能，Spring Boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 IOC 容器中。那`@EnableAutoConfiguration`是如何推算出你的需求？首先看下它的定义：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    // ......\n}\n```\n\n你的关注点应该在`@Import(EnableAutoConfigurationImportSelector.class)`上了，前文说过，`@Import`注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把`EnableAutoConfigurationImportSelector`作为 bean 注入到容器中，而这个类会将所有符合条件的@Configuration 配置都加载到容器中，看看它的代码：\n\n```\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中\n    // SpringFactoriesLoader相关知识请参考前文\n    List<String> factories = new ArrayList<String>(new LinkedHashSet<String>(\n        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, this.beanClassLoader)));\n}\n```\n\n这个类会扫描所有的 jar 包，将所有符合条件的@Configuration 配置类注入的容器中，何为符合条件，看看`META-INF/spring.factories`的文件内容：\n\n```\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// 配置的key = EnableAutoConfiguration，与代码中一致\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n.....\n```\n\n以`DataSourceAutoConfiguration`为例，看看 Spring Boot 是如何自动配置的：\n\n```\n@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n}\n```\n\n分别说一说：\n\n- `@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })`：当 Classpath 中存在 DataSource 或者 EmbeddedDatabaseType 类时才启用这个配置，否则这个配置将被忽略。\n- `@EnableConfigurationProperties(DataSourceProperties.class)`：将 DataSource 的默认配置类注入到 IOC 容器中，DataSourceproperties 定义为：\n\n```\n// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@ConfigurationProperties(prefix = "spring.datasource")\npublic class DataSourceProperties  {\n    private ClassLoader classLoader;\n    private Environment environment;\n    private String name = "testdb";\n    ......\n}\n```\n\n- `@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })`：导入其他额外的配置，就以`DataSourcePoolMetadataProvidersConfiguration`为例吧。\n\n```\n@Configuration\npublic class DataSourcePoolMetadataProvidersConfiguration {\n\n    @Configuration\n    @ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)\n    static class TomcatDataSourcePoolMetadataProviderConfiguration {\n        @Bean\n        public DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {\n            .....\n        }\n    }\n  ......\n}\n```\n\nDataSourcePoolMetadataProvidersConfiguration 是数据库连接池提供者的一个配置类，即 Classpath 中存在`org.apache.tomcat.jdbc.pool.DataSource.class`，则使用 tomcat-jdbc 连接池，如果 Classpath 中存在`HikariDataSource.class`则使用 Hikari 连接池。\n\n这里仅描述了 DataSourceAutoConfiguration 的冰山一角，但足以说明 Spring Boot 如何利用条件话配置来实现自动配置的。回顾一下，`@EnableAutoConfiguration`中导入了 EnableAutoConfigurationImportSelector 类，而这个类的`selectImports()`通过 SpringFactoriesLoader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。\n\n整个流程很清晰，但漏了一个大问题：`EnableAutoConfigurationImportSelector.selectImports()`是何时执行的？其实这个方法会在容器启动过程中执行：`AbstractApplicationContext.refresh()`，更多的细节在下一小节中说明。\n\n## 六、启动引导：Spring Boot 应用启动的秘密\n\n### 6.1 SpringApplication 初始化\n\nSpringBoot 整个启动流程分为两个步骤：初始化一个 SpringApplication 对象、执行该对象的 run 方法。看下 SpringApplication 的初始化流程，SpringApplication 的构造方法中调用 initialize(Object[] sources)方法，其代码如下：\n\n```\nprivate void initialize(Object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addAll(Arrays.asList(sources));\n     }\n     // 判断是否是Web项目\n     this.webEnvironment = deduceWebEnvironment();\n     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n     // 找到入口类\n     this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n初始化流程中最重要的就是通过 SpringFactoriesLoader 找到`spring.factories`文件中配置的`ApplicationContextInitializer`和`ApplicationListener`两个接口的实现类名称，以便后期构造相应的实例。`ApplicationContextInitializer`的主要目的是在`ConfigurableApplicationContext`做 refresh 之前，对 ConfigurableApplicationContext 实例做进一步的设置或处理。ConfigurableApplicationContext 继承自 ApplicationContext，其主要提供了对 ApplicationContext 进行设置的能力。\n\n实现一个 ApplicationContextInitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 ApplicationContextInitializer，即便是 Spring Boot 框架，它默认也只是注册了两个实现，毕竟 Spring 的容器已经非常成熟和稳定，你没有必要来改变它。\n\n而`ApplicationListener`的目的就没什么好说的了，它是 Spring 框架对 Java 事件监听机制的一种框架实现，具体内容在前文 Spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 Spring Boot 应用添加监听器，该如何实现？\n\nSpring Boot 提供两种方式来添加自定义监听器：\n\n- 通过`SpringApplication.addListeners(ApplicationListener... listeners)`或者`SpringApplication.setListeners(Collection> listeners)`两个方法来添加一个或者多个自定义监听器\n- 既然 SpringApplication 的初始化流程中已经从`spring.factories`中获取到`ApplicationListener`的实现类，那么我们直接在自己的 jar 包的`META-INF/spring.factories`文件中新增配置即可：\n\n```\norg.springframework.context.ApplicationListener=\\\ncn.moondev.listeners.xxxxListener\\\n```\n\n关于 SpringApplication 的初始化，我们就说这么多。\n\n### 6.2 Spring Boot 启动流程\n\nSpring Boot 应用的整个启动流程都封装在 SpringApplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 Spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：\n\n```\npublic ConfigurableApplicationContext run(String... args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        ConfigurableApplicationContext context = null;\n        FailureAnalyzers analyzers = null;\n        configureHeadlessProperty();\n        // ①\n        SpringApplicationRunListeners listeners = getRunListeners(args);\n        listeners.starting();\n        try {\n            // ②\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);\n            // ③\n            Banner printedBanner = printBanner(environment);\n            // ④\n            context = createApplicationContext();\n            // ⑤\n            analyzers = new FailureAnalyzers(context);\n            // ⑥\n            prepareContext(context, environment, listeners, applicationArguments,printedBanner);\n            // ⑦\n            refreshContext(context);\n            // ⑧\n            afterRefresh(context, applicationArguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopWatch.stop();\n            return context;\n        }\n        catch (Throwable ex) {\n            handleRunFailure(context, listeners, analyzers, ex);\n            throw new IllegalStateException(ex);\n        }\n    }\n```\n\n① 通过 SpringFactoriesLoader 查找并加载所有的`SpringApplicationRunListeners`，通过调用 starting()方法通知所有的 SpringApplicationRunListeners：应用开始启动了。SpringApplicationRunListeners 其本质上就是一个事件发布者，它在 SpringBoot 应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication 加载了一系列 ApplicationListener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 SpringApplicationRunListeners 这儿实现了。\n\n简单的分析一下其实现流程，首先看下 SpringApplicationRunListener 的源码：\n\n```\npublic interface SpringApplicationRunListener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // Environment准备好后，并且ApplicationContext创建之前调用\n    void environmentPrepared(ConfigurableEnvironment environment);\n\n    // ApplicationContext创建好后立即调用\n    void contextPrepared(ConfigurableApplicationContext context);\n\n    // ApplicationContext加载完成，在refresh之前调用\n    void contextLoaded(ConfigurableApplicationContext context);\n\n    // 当run方法结束之前调用\n    void finished(ConfigurableApplicationContext context, Throwable exception);\n\n}\n```\n\nSpringApplicationRunListener 只有一个实现类：`EventPublishingRunListener`。① 处的代码只会获取到一个 EventPublishingRunListener 的实例，我们来看看 starting()方法的内容：\n\n```\npublic void starting() {\n    // 发布一个ApplicationStartedEvent\n    this.initialMulticaster.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}\n```\n\n顺着这个逻辑，你可以在 ② 处的`prepareEnvironment()`方法的源码中找到`listeners.environmentPrepared(environment);`即 SpringApplicationRunListener 接口的第二个方法，那不出你所料，`environmentPrepared()`又发布了另外一个事件`ApplicationEnvironmentPreparedEvent`。接下来会发生什么，就不用我多说了吧。\n\n② 创建并配置当前应用将要使用的`Environment`，Environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 Environment 准备好后，在整个应用的任何时候，都可以从 Environment 中获取资源。\n\n总结起来，② 处的两句代码，主要完成以下几件事：\n\n- 判断 Environment 是否存在，不存在就创建（如果是 web 项目就创建`StandardServletEnvironment`，否则创建`StandardEnvironment`）\n- 配置 Environment：配置 profile 以及 properties\n- 调用 SpringApplicationRunListener 的`environmentPrepared()`方法，通知事件监听者：应用的 Environment 已经准备好\n\n③、SpringBoot 应用在启动时会输出这样的东西：\n\n```\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.6.RELEASE)\n```\n\n如果想把这个东西改成自己的涂鸦，你可以研究以下 Banner 的实现，这个任务就留给你们吧。\n\n④、根据是否是 web 项目，来创建不同的 ApplicationContext 容器。\n\n⑤、创建一系列`FailureAnalyzer`，创建流程依然是通过 SpringFactoriesLoader 获取到所有实现 FailureAnalyzer 接口的 class，然后在创建对应的实例。FailureAnalyzer 用于分析故障并提供相关诊断信息。\n\n⑥、初始化 ApplicationContext，主要完成以下工作：\n\n- 将准备好的 Environment 设置给 ApplicationContext\n- 遍历调用所有的 ApplicationContextInitializer 的`initialize()`方法来对已经创建好的 ApplicationContext 进行进一步的处理\n- 调用 SpringApplicationRunListener 的`contextPrepared()`方法，通知所有的监听者：ApplicationContext 已经准备完毕\n- 将所有的 bean 加载到容器中\n- 调用 SpringApplicationRunListener 的`contextLoaded()`方法，通知所有的监听者：ApplicationContext 已经装载完毕\n\n⑦、调用 ApplicationContext 的`refresh()`方法，完成 IoC 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：\n\n```\n// 摘自refresh()方法中一句代码\ninvokeBeanFactoryPostProcessors(beanFactory);\n```\n\n看看这个方法的实现：\n\n```\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n    ......\n}\n```\n\n获取到所有的`BeanFactoryPostProcessor`来对容器做一些额外的操作。BeanFactoryPostProcessor 允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作。这里的 getBeanFactoryPostProcessors()方法可以获取到 3 个 Processor：\n\n```\nConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor\nSharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor\nConfigFileApplicationListener$PropertySourceOrderingPostProcessor\n```\n\n不是有那么多 BeanFactoryPostProcessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 ApplicationContextInitializer 和 ApplicationListener 中，只有上文 3 个做了类似于如下操作：\n\n```\npublic void initialize(ConfigurableApplicationContext context) {\n    context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));\n}\n```\n\n然后你就可以进入到`PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()`方法了，这个方法除了会遍历上面的 3 个 BeanFactoryPostProcessor 处理外，还会获取类型为`BeanDefinitionRegistryPostProcessor`的 bean：`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`，对应的 Class 为`ConfigurationClassPostProcessor`。`ConfigurationClassPostProcessor`用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理`@import`注解的时候，就会调用自动配置这一小节中的`EnableAutoConfigurationImportSelector.selectImports()`来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。\n\n⑧、查找当前 context 中是否注册有 CommandLineRunner 和 ApplicationRunner，如果有则遍历执行它们。\n\n⑨、执行所有 SpringApplicationRunListener 的 finished()方法。\n\n这就是 Spring Boot 的整个启动流程，其核心就是在 Spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、ApplicationListener 以及各种 BeanFactoryPostProcessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。\n\n整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，Spring 才是核心，理解清楚 Spring 容器的启动流程，那 Spring Boot 启动流程就不在话下了。\n\n## 参考资料\n\n[1][王福强 著；springboot 揭秘：快速构建微服务体系; 机械工业出版社, 2016](https://link.jianshu.com/?t=http%3A%2F%2Funion-click.jd.com%2Fjdc%3Fd%3D4jESQ9)\n[2][王福强 著；spring 揭秘; 人民邮件出版社, 2009](https://link.jianshu.com/?t=http%3A%2F%2Funion-click.jd.com%2Fjdc%3Fd%3DyzfgeF)\n[3][craig walls 著；丁雪丰 译；spring boot 实战；中国工信出版集团 人民邮电出版社，2016](https://link.jianshu.com/?t=http%3A%2F%2Funion-click.jd.com%2Fjdc%3Fd%3DAQ6oHO)\n[4][深入探讨 java 类加载器](https://link.jianshu.com/?t=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fjava%2Fj-lo-classloader%2F) : [www.ibm.com/developerwo…](https://link.jianshu.com/?t=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fjava%2Fj-lo-classloader%2F)\n[5][spring boot 实战：自动配置原理分析](https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fliaokailin%2Farticle%2Fdetails%2F49559951) : [blog.csdn.net/liaokailin/…](https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fliaokailin%2Farticle%2Fdetails%2F49559951)\n[6][spring boot实战：spring boot bean加载源码分析](https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fliaokailin%2Farticle%2Fdetails%2F49107209)： [blog.csdn.net/liaokailin/…](https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fliaokailin%2Farticle%2Fdetails%2F49107209)'},{title:"SpringBoot 基本原理",headers:[{level:2,title:"SpringBootApplication 背后的秘密",slug:"springbootapplication-背后的秘密",link:"#springbootapplication-背后的秘密",children:[]},{level:2,title:"@Configuration",slug:"configuration",link:"#configuration",children:[]},{level:2,title:"@ComponentScan",slug:"componentscan",link:"#componentscan",children:[]},{level:2,title:"@EnableAutoConfiguration",slug:"enableautoconfiguration",link:"#enableautoconfiguration",children:[{level:3,title:"自动配置幕后英雄：SpringFactoriesLoader 详解",slug:"自动配置幕后英雄-springfactoriesloader-详解",link:"#自动配置幕后英雄-springfactoriesloader-详解",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/dbf521/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 基本原理\ndate: 2020-08-12 07:01:26\norder: 1\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring综合\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/dbf521/\n---\n\n# SpringBoot 基本原理\n\nSpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-ebcb376f96103703.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n---\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n从上面代码可以看出，**Annotation 定义（@SpringBootApplication）和类定义（SpringApplication.run）**最为耀眼，所以要揭开 SpringBoot 的神秘面纱，我们要从这两位开始就可以了。\n\n## SpringBootApplication 背后的秘密\n\n```kotlin\n@Target(ElementType.TYPE)            // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明\n@Retention(RetentionPolicy.RUNTIME)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@Documented                          // 表明这个注解应该被javadoc记录\n@Inherited                           // 子类可以继承该注解\n@SpringBootConfiguration             // 继承了Configuration，表示当前是注解类\n@EnableAutoConfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@ComponentScan(excludeFilters = {    // 扫描路径设置（具体使用待确认）\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n```\n\n虽然定义使用了多个 Annotation 进行了原信息标注，但实际上重要的只有三个 Annotation：\n\n**@Configuration**（@SpringBootConfiguration 点开查看发现里面还是应用了@Configuration）\n**@EnableAutoConfiguration\n@ComponentScan**\n所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：\n\n```java\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n每次写这 3 个比较累，所以写一个@SpringBootApplication 方便点。接下来分别介绍这 3 个 Annotation。\n\n## @Configuration\n\n这里的@Configuration 对我们来说不陌生，**它就是 JavaConfig 形式的 Spring Ioc 容器的配置类使用的那个@Configuration**，SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，这里的启动类标注了@Configuration 之后，本身其实也是一个 IoC 容器的配置类。\n举几个简单例子回顾下，XML 跟 config 配置方式的区别：\n\n表达形式层面\n基于 XML 配置的方式是这样：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>\n```\n\n而基于 JavaConfig 的配置方式是这样：\n\n```java\n@Configuration\npublic class MockConfiguration{\n    //bean定义\n}\n```\n\n**任何一个标注了@Configuration 的 Java 类定义都是一个 JavaConfig 配置类。**\n\n注册 bean 定义层面\n基于 XML 的配置形式是这样：\n\n```csharp\n<bean id="mockService" class="..MockServiceImpl">\n    ...\n</bean>\n```\n\n而基于 JavaConfig 的配置形式是这样的：\n\n```java\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl();\n    }\n}\n```\n\n**任何一个标注了@Bean 的方法，其返回值将作为一个 bean 定义注册到 Spring 的 IoC 容器，方法名将默认成该 bean 定义的 id。**\n\n表达依赖注入关系层面\n为了表达 bean 与 bean 之间的依赖关系，在 XML 形式中一般是这样：\n\n```jsx\n<bean id="mockService" class="..MockServiceImpl">\n    <propery name ="dependencyService" ref="dependencyService" />\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"></bean>\n```\n\n而基于 JavaConfig 的配置形式是这样的：\n\n```java\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}\n```\n\n**如果一个 bean 的定义依赖其他 bean,则直接调用对应的 JavaConfig 类中依赖 bean 的创建方法就可以了。**\n\n## @ComponentScan\n\n**@ComponentScan 这个注解在 Spring 中很重要，它对应 XML 配置中的元素，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件（比如@Component 和@Repository 等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。**\n\n我们可以通过 basePackages 等属性来细粒度的定制@ComponentScan 自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明@ComponentScan 所在类的 package 进行扫描。\n\n> 注：所以 SpringBoot 的启动类最好是放在 root package 下，因为默认不指定 basePackages。\n\n## @EnableAutoConfiguration\n\n个人感觉**@EnableAutoConfiguration 这个 Annotation 最为重要**，所以放在最后来解读，大家是否还记得 Spring 框架提供的各种名字为@Enable 开头的 Annotation 定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport 等，@EnableAutoConfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import 的支持，收集和注册特定场景相关的 bean 定义。\n\n**@EnableScheduling**是通过@Import 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。\n**@EnableMBeanExport**是通过@Import 将 JMX 相关的 bean 定义加载到 IoC 容器。\n而**@EnableAutoConfiguration**也是借助@Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！\n\n@EnableAutoConfiguration 作为一个复合 Annotation,其自身定义关键信息如下：\n\n```kotlin\n@SuppressWarnings("deprecation")\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    ...\n}\n```\n\n两个比较重要的注解：\n\n**@AutoConfigurationPackage：自动配置包**\n\n**@Import: 导入自动配置的组件**\n\n#### AutoConfigurationPackage 注解：\n\n```java\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata metadata,\n                BeanDefinitionRegistry registry) {\n            register(registry, new PackageImport(metadata).getPackageName());\n        }\n```\n\n它其实是注册了一个 Bean 的定义。\n\nnew PackageImport(metadata).getPackageName()，它其实返回了当前主程序类的 同级以及子级 的包组件。\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-439283a70a24c7a0.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/281/format/webp)\n\n以上图为例，DemoApplication 是和 demo 包同级，但是 demo2 这个类是 DemoApplication 的父级，和 example 包同级\n\n也就是说，DemoApplication 启动加载的 Bean 中，并不会加载 demo2，这也就是为什么，我们要把 DemoApplication 放在项目的最高级中。\n\n#### Import(AutoConfigurationImportSelector.class)注解：\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-1c448a69c41dc35c.png?imageMogr2/auto-orient/strip|imageView2/2/w/877/format/webp)\n\n可以从图中看出 AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector\n\nImportSelector 有一个方法为：selectImports。\n\n```dart\n@Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) {\n        if (!isEnabled(annotationMetadata)) {\n            return NO_IMPORTS;\n        }\n        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n                .loadMetadata(this.beanClassLoader);\n        AnnotationAttributes attributes = getAttributes(annotationMetadata);\n        List<String> configurations = getCandidateConfigurations(annotationMetadata,\n                attributes);\n        configurations = removeDuplicates(configurations);\n        Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n        checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = filter(configurations, autoConfigurationMetadata);\n        fireAutoConfigurationImportEvents(configurations, exclusions);\n        return StringUtils.toStringArray(configurations);\n    }\n```\n\n可以看到第九行，它其实是去加载 public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";外部文件。这个外部文件，有很多自动配置的类。如下：\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-250f3320c15e5c99.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\nimage\n\n其中，最关键的要属**@Import(EnableAutoConfigurationImportSelector.class)**，借助**EnableAutoConfigurationImportSelector**，**@EnableAutoConfiguration**可以帮助 SpringBoot 应用将所有符合条件的**@Configuration**配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。就像一只“八爪鱼”一样。\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-6f3a835755ee7710.png?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)\n\n### 自动配置幕后英雄：SpringFactoriesLoader 详解\n\n借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，@EnableAutoConfiguration 可以智能的自动配置功效才得以大功告成！\n\nSpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 META-INF/spring.factories 加载配置。\n\n```php\npublic abstract class SpringFactoriesLoader {\n    //...\n    public static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n        ...\n    }\n\n\n    public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n        ....\n    }\n}\n```\n\n配合**@EnableAutoConfiguration**使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration 的完整类名 org.springframework.boot.autoconfigure.EnableAutoConfiguration 作为查找的 Key,获取对应的一组**@Configuration**类\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-fcdfcb56828a015a?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n上图就是从 SpringBoot 的 autoconfigure 依赖包中的 META-INF/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。\n\n所以，@EnableAutoConfiguration 自动配置的魔法骑士就变成了：**从 classpath 中搜寻所有的 META-INF/spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.EnableutoConfiguration 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。**\n\n![img](https:////upload-images.jianshu.io/upload_images/6430208-10850d62d44c95ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/822/format/webp)\n\n## 参考资料\n\n- [一文搞懂 springboot 启动原理](https://www.jianshu.com/p/943650ab7dfd)'},{title:"Spring 面试",headers:[{level:2,title:"综合篇",slug:"综合篇",link:"#综合篇",children:[{level:3,title:"不同版本的 Spring Framework 有哪些主要功能？",slug:"不同版本的-spring-framework-有哪些主要功能",link:"#不同版本的-spring-framework-有哪些主要功能",children:[]},{level:3,title:"什么是 Spring Framework？",slug:"什么是-spring-framework",link:"#什么是-spring-framework",children:[]},{level:3,title:"列举 Spring Framework 的优点。",slug:"列举-spring-framework-的优点。",link:"#列举-spring-framework-的优点。",children:[]},{level:3,title:"Spring Framework 有哪些不同的功能？",slug:"spring-framework-有哪些不同的功能",link:"#spring-framework-有哪些不同的功能",children:[]},{level:3,title:"Spring Framework 中有多少个模块，它们分别是什么？",slug:"spring-framework-中有多少个模块-它们分别是什么",link:"#spring-framework-中有多少个模块-它们分别是什么",children:[]},{level:3,title:"什么是 Spring 配置文件？",slug:"什么是-spring-配置文件",link:"#什么是-spring-配置文件",children:[]},{level:3,title:"Spring 应用程序有哪些不同组件？",slug:"spring-应用程序有哪些不同组件",link:"#spring-应用程序有哪些不同组件",children:[]},{level:3,title:"使用 Spring 有哪些方式？",slug:"使用-spring-有哪些方式",link:"#使用-spring-有哪些方式",children:[]}]},{level:2,title:"核心篇",slug:"核心篇",link:"#核心篇",children:[{level:3,title:"IoC",slug:"ioc",link:"#ioc",children:[]},{level:3,title:"Bean",slug:"bean",link:"#bean",children:[]},{level:3,title:"AOP",slug:"aop",link:"#aop",children:[]}]},{level:2,title:"注解",slug:"注解",link:"#注解",children:[{level:3,title:"你用过哪些重要的 Spring 注解？",slug:"你用过哪些重要的-spring-注解",link:"#你用过哪些重要的-spring-注解",children:[]},{level:3,title:"如何在 spring 中启动注解装配？",slug:"如何在-spring-中启动注解装配",link:"#如何在-spring-中启动注解装配",children:[]},{level:3,title:"@Component, @Controller, @Repository, @Service 有何区别？",slug:"component-controller-repository-service-有何区别",link:"#component-controller-repository-service-有何区别",children:[]},{level:3,title:"@Required 注解有什么用？",slug:"required-注解有什么用",link:"#required-注解有什么用",children:[]},{level:3,title:"@Autowired 注解有什么用？",slug:"autowired-注解有什么用",link:"#autowired-注解有什么用",children:[]},{level:3,title:"@Qualifier 注解有什么用？",slug:"qualifier-注解有什么用",link:"#qualifier-注解有什么用",children:[]},{level:3,title:"@RequestMapping 注解有什么用？",slug:"requestmapping-注解有什么用",link:"#requestmapping-注解有什么用",children:[]}]},{level:2,title:"数据篇",slug:"数据篇",link:"#数据篇",children:[{level:3,title:"spring DAO 有什么用？",slug:"spring-dao-有什么用",link:"#spring-dao-有什么用",children:[]},{level:3,title:"列举 Spring DAO 抛出的异常。",slug:"列举-spring-dao-抛出的异常。",link:"#列举-spring-dao-抛出的异常。",children:[]},{level:3,title:"spring JDBC API 中存在哪些类？",slug:"spring-jdbc-api-中存在哪些类",link:"#spring-jdbc-api-中存在哪些类",children:[]},{level:3,title:"使用 Spring 访问 Hibernate 的方法有哪些？",slug:"使用-spring-访问-hibernate-的方法有哪些",link:"#使用-spring-访问-hibernate-的方法有哪些",children:[]},{level:3,title:"列举 spring 支持的事务管理类型",slug:"列举-spring-支持的事务管理类型",link:"#列举-spring-支持的事务管理类型",children:[]},{level:3,title:"spring 支持哪些 ORM 框架",slug:"spring-支持哪些-orm-框架",link:"#spring-支持哪些-orm-框架",children:[]}]},{level:2,title:"MVC",slug:"mvc",link:"#mvc",children:[{level:3,title:"Spring MVC 框架有什么用？",slug:"spring-mvc-框架有什么用",link:"#spring-mvc-框架有什么用",children:[]},{level:3,title:"描述一下 DispatcherServlet 的工作流程",slug:"描述一下-dispatcherservlet-的工作流程",link:"#描述一下-dispatcherservlet-的工作流程",children:[]},{level:3,title:"介绍一下 WebApplicationContext",slug:"介绍一下-webapplicationcontext",link:"#介绍一下-webapplicationcontext",children:[]}]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/db33b0/",pathLocale:"/",extraFields:'---\ntitle: Spring 面试\ndate: 2018-08-02 17:33:32\norder: 1\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring综合\ntags:\n  - Java\n  - 框架\n  - Spring\n  - 面试\npermalink: /pages/db33b0/\n---\n\n# Spring 面试\n\n## 综合篇\n\n### 不同版本的 Spring Framework 有哪些主要功能？\n\n| Version    | Feature                                                             |\n| ---------- | ------------------------------------------------------------------- |\n| Spring 2.5 | 发布于 2007 年。这是第一个支持注解的版本。                          |\n| Spring 3.0 | 发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。 |\n| Spring 4.0 | 发布于 2013 年。这是第一个完全支持 JAVA8 的版本。                   |\n\n### 什么是 Spring Framework？\n\n- Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。\n- 它是轻量级、松散耦合的。\n- 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。\n- 它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。\n\n### 列举 Spring Framework 的优点。\n\n- 由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。\n- Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。\n- 由于依赖注入和控制反转，JDBC 得以简化。\n- 它是开源免费的。\n\n### Spring Framework 有哪些不同的功能？\n\n- **轻量级** - Spring 在代码量和透明度方面都很轻便。\n- **IOC** - 控制反转\n- **AOP** - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。\n- **容器** - Spring 负责创建和管理对象（Bean）的生命周期和配置。\n- **MVC** - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。\n- **事务管理** - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。\n- **JDBC 异常** - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。\n\n### Spring Framework 中有多少个模块，它们分别是什么？\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/spring-framework.png)\n\n- **Spring 核心容器** – 该层基本上是 Spring Framework 的核心。它包含以下模块：\n  - Spring Core\n  - Spring Bean\n  - SpEL (Spring Expression Language)\n  - Spring Context\n- **数据访问/集成** – 该层提供与数据库交互的支持。它包含以下模块：\n  - JDBC (Java DataBase Connectivity)\n  - ORM (Object Relational Mapping)\n  - OXM (Object XML Mappers)\n  - JMS (Java Messaging Service)\n  - Transaction\n- **Web** – 该层提供了创建 Web 应用程序的支持。它包含以下模块：\n  - Web\n  - Web – Servlet\n  - Web – Socket\n  - Web – Portlet\n- **AOP** – 该层支持面向切面编程\n- **Instrumentation** – 该层为类检测和类加载器实现提供支持。\n- **Test** – 该层为使用 JUnit 和 TestNG 进行测试提供支持。\n- **几个杂项模块:**\n  - Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。\n  - Aspects – 该模块为与 AspectJ 的集成提供支持。\n\n### 什么是 Spring 配置文件？\n\nSpring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。\n\n### Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n- **接口** - 定义功能。\n- **Bean 类** - 它包含属性，setter 和 getter 方法，函数等。\n- **Spring 面向切面编程（AOP）** - 提供面向切面编程的功能。\n- **Bean 配置文件** - 包含类的信息以及如何配置它们。\n- **用户程序** - 它使用接口。\n\n### 使用 Spring 有哪些方式？\n\n使用 Spring 有以下方式：\n\n- 作为一个成熟的 Spring Web 应用程序。\n- 作为第三方 Web 框架，使用 Spring Frameworks 中间层。\n- 用于远程使用。\n- 作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。\n\n## 核心篇\n\n### IoC\n\n#### 什么是 IoC？什么是依赖注入？什么是 Spring IoC？\n\n**IoC** 即**控制反转**（Inversion of Control，缩写为 IoC）。IoC 又称为**依赖倒置原则**（设计模式六大原则之一），它的要点在于：**程序要依赖于抽象接口，不要依赖于具体实现**。它的作用就是**用于降低代码间的耦合度**。\n\nIoC 的实现方式有两种：\n\n- **依赖注入**（Dependency Injection，简称 DI）：不通过 `new()` 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。\n- **依赖查找**（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\nSpring IoC 是 IoC 的一种实现。DI 是 Spring IoC 的主要实现原则。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20221005163639.png)\n\n#### 依赖注入有哪些实现方式？\n\n依赖注入有如下方式：\n\n| 依赖注入方式    | 配置元数据举例                                     |\n| --------------- | -------------------------------------------------- |\n| Setter 方法注入 | `<proeprty name="user" ref="userBean"/>`           |\n| 构造器注入      | `<constructor-arg name="user" ref="userBean" />`   |\n| 字段注入        | `@Autowired User user;`                            |\n| 方法注入        | `@Autowired public void user(User user) { ... }`   |\n| 接口回调注入    | `class MyBean implements BeanFactoryAware { ... }` |\n\n#### 构造器注入 VS. setter 注入\n\n| 构造器注入                 | setter 注入                |\n| -------------------------- | -------------------------- |\n| 没有部分注入               | 有部分注入                 |\n| 不会覆盖 setter 属性       | 会覆盖 setter 属性         |\n| 任意修改都会创建一个新实例 | 任意修改不会创建一个新实例 |\n| 适用于设置很多属性         | 适用于设置少量属性         |\n\n官方推荐使用构造器注入。\n\n#### BeanFactory VS. ApplicationContext\n\n在 Spring 中，有两种 IoC 容器：`BeanFactory` 和 `ApplicationContext`。\n\n- `BeanFactory`：**`BeanFactory` 是 Spring 基础 IoC 容器**。`BeanFactory` 提供了 Spring 容器的配置框架和基本功能。\n- `ApplicationContext`：**`ApplicationContext` 是具备应用特性的 `BeanFactory` 的子接口**。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 `ApplicationContext` 作为 IoC 容器，因为它的功能远多于 `BeanFactory`。\n\n#### BeanFactory VS. FactoryBean\n\n**`BeanFactory` 是 Spring 基础 IoC 容器**。\n\n`FactoryBean` 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑。\n\n#### Spring IoC 启动时做了哪些准备\n\nIoC 配置元信息读取和解析\n\nIoC 容器生命周期管理\n\nSpring 事件发布\n\n国际化\n\n等等\n\n#### Spring IoC 的实现机制是什么\n\nSpring 中的 IoC 的实现原理就是工厂模式加反射机制。\n\n示例：\n\n```java\ninterface Fruit {\n     public abstract void eat();\n}\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println("Apple");\n    }\n}\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println("Orange");\n    }\n}\nclass Factory {\n    public static Fruit getInstance(String ClassName) {\n        Fruit f=null;\n        try {\n            f=(Fruit)Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\nclass Client {\n    public static void main(String[] a) {\n        Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n```\n\n### Bean\n\n#### 什么是 Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。**Bean 是由 Spring IoC 容器实例化、装配和管理的对象**。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——`BeanDefinition` 对象。\n\n**`BeanDefinition` 是 Spring 中定义 Bean 的配置元信息接口**，它包含：\n\n- Bean 类名\n- Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n- 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n- 配置设置，如 Bean 属性（Properties）\n\n#### 如何注册 Spring Bean\n\n通过 `BeanDefinition` 和外部单例对象来注册。\n\n#### spring 提供了哪些配置方式？\n\n- 基于 xml 配置\n\nbean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\n\n```xml\n<bean id="studentbean" class="org.edureka.firstSpring.StudentBean">\n <property name="name" value="Edureka"></property>\n</bean>\n```\n\n- 基于注解配置\n\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：\n\n```xml\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>\n```\n\n- 基于 Java API 配置\n\nSpring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。\n\n1.  @Bean 注解扮演与 `<bean />` 元素相同的角色。\n2.  @Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。\n\n例如：\n\n```java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n```\n\n#### spring 支持集中 bean scope？\n\nSpring bean 支持 5 种 scope：\n\n- **Singleton** - 每个 Spring IoC 容器仅有一个单实例。\n- **Prototype** - 每次请求都会产生一个新的实例。\n- **Request** - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。\n- **Session** - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。\n- **Global-session** - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\n\n仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。\n\n#### Spring Bean 的生命周期\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20211201102734.png)\n\nspring bean 容器的生命周期如下：\n\n1. Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n2. Spring 将值和引用注入到 Bean 对应的属性中\n\n3. 如果 Bean 实现了 `BeanNameAware` 接口，Spring 将 Bean 的 ID 传递给 `setBeanName` 方法\n   - 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n4. 如果 Bean 实现了 `BeanFactoryAware` 接口，Spring 将调用 `setBeanDactory` 方法，并把 `BeanFactory` 容器实例作为参数传入。\n   - 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n5. 如果 Bean 实现了 `ApplicationContextAware` 接口，Spring 容器将调用 `setApplicationContext` 方法，把应用上下文作为参数传入\n   - 作用与 `BeanFactory` 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 `setApplicationContext` 方法时会把它自己作为 `setApplicationContext` 的参数传入，而 Spring 容器在调用 `setBeanFactory` 前需要使用者自己指定（注入）`setBeanFactory` 里的参数 `BeanFactory`\n6. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessBeforeInitialization` 方法\n   - 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n7. 如果 Bean 实现了 `InitializingBean` 接口，Spring 将调用 `afterPropertiesSet` 方法，作用与在配置文件中对 Bean 使用 `init-method` 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n8. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessAfterInitialization` 方法\n   - `postProcessBeforeInitialization` 是在 Bean 初始化前执行的，而 `postProcessAfterInitialization` 是在 Bean 初始化后执行的\n9. 经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n10. 如果 Bean 实现了 `DispostbleBean` 接口，Spring 将调用它的 `destory` 方法，作用与在配置文件中对 Bean 使用 `destory-method` 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n#### 什么是 spring 的内部 bean？\n\n只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 `<property>` 或 `<constructor-arg>` 中提供了 `<bean>` 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\n\n例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。\n\nStudent.java\n\n```java\npublic class Student {\n    private Person person;\n    //Setters and Getters\n}\npublic class Person {\n    private String name;\n    private String address;\n    //Setters and Getters\n}\n```\n\nbean.xml\n\n```xml\n<bean id=“StudentBean" class="com.edureka.Student">\n    <property name="person">\n        \x3c!--This is inner bean --\x3e\n        <bean class="com.edureka.Person">\n            <property name="name" value=“Scott"></property>\n            <property name="address" value=“Bangalore"></property>\n        </bean>\n    </property>\n</bean>\n```\n\n#### 什么是 spring 装配\n\n当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\n\n#### 自动装配有哪些方式？\n\nSpring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。\n\n自动装配的不同模式：\n\n- **no** - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\n- **byName** - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。\n- **byType** - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。\n- **构造器** - 它通过调用类的构造器来注入依赖项。它有大量的参数。\n- **autodetect** - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。\n\n#### 自动装配有什么局限？\n\n- 覆盖的可能性 - 您始终可以使用 `<constructor-arg>` 和 `<property>` 设置指定依赖项，这将覆盖自动装配。\n- 基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\n- 令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\n\n### AOP\n\n#### 什么是 AOP？\n\nAOP(Aspect-Oriented Programming), 即 **面向切面编程**, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.\n在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 **Aspect(切面)**\n\n#### AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/core/spring-aop.png)\n\n- **Aspect** - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。\n- **Advice** - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。\n- **Advice Arguments** - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。\n- **Pointcut** - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。 Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。\n- **JoinPoint** - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。\n\n#### 什么是通知（Advice）？\n\n特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。\n\n#### 有哪些类型的通知（Advice）？\n\n- **Before** - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。\n- **After Returning** - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。\n- **After Throwing** - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。\n- **After (finally)** - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。\n- **Around** - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。\n\n#### 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。\n\nconcern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。\n\ncross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。\n\n#### AOP 有哪些实现方式？\n\n实现 AOP 的技术，主要分为两大类：\n\n- 静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；\n  - 编译时编织（特殊编译器实现）\n  - 类加载时编织（特殊的类加载器实现）。\n- 动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。\n  - JDK 动态代理\n  - CGLIB\n\n#### Spring AOP and AspectJ AOP 有什么区别？\n\nSpring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。\nSpring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。\n\n#### 如何理解 Spring 中的代理？\n\n将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。\n\n```\nAdvice + Target Object = Proxy\n```\n\n#### 什么是编织（Weaving）？\n\n为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：\n\n![img](https://upload-images.jianshu.io/upload_images/3101171-cfaa92f0e4115b4a.png)\n\n## 注解\n\n### 你用过哪些重要的 Spring 注解？\n\n- **@Controller** - 用于 Spring MVC 项目中的控制器类。\n- **@Service** - 用于服务类。\n- **@RequestMapping** - 用于在控制器处理程序方法中配置 URI 映射。\n- **@ResponseBody** - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。\n- **@PathVariable** - 用于将动态值从 URI 映射到处理程序方法参数。\n- **@Autowired** - 用于在 spring bean 中自动装配依赖项。\n- **@Qualifier** - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。\n- **@Scope** - 用于配置 spring bean 的范围。\n- **@Configuration**，**@ComponentScan** 和 **@Bean** - 用于基于 java 的配置。\n- **@Aspect**，**@Before**，**@After**，**@Around**，**@Pointcut** - 用于切面编程（AOP）。\n\n### 如何在 spring 中启动注解装配？\n\n默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置`<context：annotation-config />` 元素在 Spring 配置文件中启用它。\n\n### @Component, @Controller, @Repository, @Service 有何区别？\n\n- @Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。\n- @Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n- @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n- @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n### @Required 注解有什么用？\n\n@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。\n\n示例：\n\n```java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Autowired 注解有什么用？\n\n@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。\n\n```java\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Qualifier 注解有什么用？\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。\n\nEmployee.java\n\n```java\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName() {\n        return name;\n    }\n}\n```\n\nEmpAccount.java\n\n```java\npublic class EmpAccount {\n    private Employee emp;\n\n    @Autowired\n    @Qualifier(emp1)\n    public void showName() {\n        System.out.println(“Employee name : ”+emp.getName);\n    }\n}\n```\n\n### @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：\n\n- 类级别：映射请求的 URL\n- 方法级别：映射 URL 以及 HTTP 请求方法\n\n## 数据篇\n\n### spring DAO 有什么用？\n\nSpring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。\n\n### 列举 Spring DAO 抛出的异常。\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/data-access/spring-data-access-exception.png)\n\n### spring JDBC API 中存在哪些类？\n\n- JdbcTemplate\n- SimpleJdbcTemplate\n- NamedParameterJdbcTemplate\n- SimpleJdbcInsert\n- SimpleJdbcCall\n\n### 使用 Spring 访问 Hibernate 的方法有哪些？\n\n我们可以通过两种方式使用 Spring 访问 Hibernate：\n\n1.  使用 Hibernate 模板和回调进行控制反转\n2.  扩展 HibernateDAOSupport 并应用 AOP 拦截器节点\n\n### 列举 spring 支持的事务管理类型\n\nSpring 支持两种类型的事务管理：\n\n1.  程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。\n2.  声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。\n\n### spring 支持哪些 ORM 框架\n\n- Hibernate\n- iBatis\n- JPA\n- JDO\n- OJB\n\n## MVC\n\n### Spring MVC 框架有什么用？\n\nSpring Web MVC 框架提供 **模型-视图-控制器** 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。\n\n### 描述一下 DispatcherServlet 的工作流程\n\nDispatcherServlet 的工作流程可以用一幅图来说明：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png)\n\n1.  向服务器发送 HTTP 请求，请求被前端控制器 `DispatcherServlet` 捕获。\n2.  `DispatcherServlet` 根据 **`<servlet-name>-servlet.xml`** 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 `HandlerMapping` 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以`HandlerExecutionChain` 对象的形式返回。\n3.  `DispatcherServlet` 根据获得的`Handler`，选择一个合适的 `HandlerAdapter`。（附注：如果成功获得`HandlerAdapter`后，此时将开始执行拦截器的 preHandler(...)方法）。\n4.  提取`Request`中的模型数据，填充`Handler`入参，开始执行`Handler`（`Controller`)。 在填充`Handler`的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    - HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    - 数据转换：对请求消息进行数据转换。如`String`转换成`Integer`、`Double`等。\n    - 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    - 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到`BindingResult`或`Error`中。\n5.  Handler(Controller)执行完成后，向 `DispatcherServlet` 返回一个 `ModelAndView` 对象；\n6.  根据返回的`ModelAndView`，选择一个适合的 `ViewResolver`（必须是已经注册到 Spring 容器中的`ViewResolver`)返回给`DispatcherServlet`。\n7.  `ViewResolver` 结合`Model`和`View`，来渲染视图。\n8.  视图负责将渲染结果返回给客户端。\n\n### 介绍一下 WebApplicationContext\n\nWebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。\n\n（完）\n\n---\n\n:point_right: 想学习更多 Spring 内容可以访问我的 Spring 教程：**[spring-notes](https://github.com/dunwu/spring-notes)**\n\n## 资料\n\n- [Top 50 Spring Interview Questions You Must Prepare In 2018](https://www.edureka.co/blog/interview-questions/spring-interview-questions/)\n- [Spring Interview Questions and Answers](https://www.journaldev.com/2696/spring-interview-questions-and-answers)'},{title:"Spring 综述",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/9e0b67/",pathLocale:"/",extraFields:"---\ntitle: Spring 综述\ndate: 2020-02-26 23:48:06\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring综合\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/9e0b67/\nhidden: true\nindex: false\n---\n\n# Spring 综述\n\n## 📖 内容\n\n- [Spring 概述](01.Spring概述.md)\n- [SpringBoot 知识图谱](21.SpringBoot知识图谱.md)\n- [SpringBoot 基本原理](22.SpringBoot基本原理.md)\n- [Spring 面试](99.Spring面试.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾"},{title:"Spring Bean",headers:[{level:2,title:"Spring Bean 定义",slug:"spring-bean-定义",link:"#spring-bean-定义",children:[{level:3,title:"BeanDefinition",slug:"beandefinition",link:"#beandefinition",children:[]},{level:3,title:"Spring Bean 命名",slug:"spring-bean-命名",link:"#spring-bean-命名",children:[]}]},{level:2,title:"Spring Bean 生命周期",slug:"spring-bean-生命周期",link:"#spring-bean-生命周期",children:[]},{level:2,title:"Spring Bean 注册",slug:"spring-bean-注册",link:"#spring-bean-注册",children:[{level:3,title:"XML 配置元信息",slug:"xml-配置元信息",link:"#xml-配置元信息",children:[]},{level:3,title:"注解配置元信息",slug:"注解配置元信息",link:"#注解配置元信息",children:[]},{level:3,title:"Java API 配置元信息",slug:"java-api-配置元信息",link:"#java-api-配置元信息",children:[]}]},{level:2,title:"Spring Bean 实例化",slug:"spring-bean-实例化",link:"#spring-bean-实例化",children:[]},{level:2,title:"Spring Bean 初始化和销毁",slug:"spring-bean-初始化和销毁",link:"#spring-bean-初始化和销毁",children:[]},{level:2,title:"Spring Bean 垃圾回收",slug:"spring-bean-垃圾回收",link:"#spring-bean-垃圾回收",children:[]},{level:2,title:"Spring Bean 作用范围",slug:"spring-bean-作用范围",link:"#spring-bean-作用范围",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/68097d/",pathLocale:"/",extraFields:'---\ntitle: Spring Bean\ndate: 2021-12-10 19:15:42\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Bean\n  - BeanDefinition\npermalink: /pages/68097d/\n---\n\n# Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。**Bean 是由 Spring IoC 容器实例化、装配和管理的对象**。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\n## Spring Bean 定义\n\n### BeanDefinition\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——`BeanDefinition` 对象。\n\n**`BeanDefinition` 是 Spring 中定义 Bean 的配置元信息接口**，它包含：\n\n- Bean 类名\n- Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n- 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n- 配置设置，如 Bean 属性（Properties）\n\n#### BeanDefinition 元信息\n\n`BeanDefinition` 元信息如下：\n\n| 属性（Property）                                                                                                                                | 说明                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |\n| [Class](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class)                                      | 全类名，必须是具体类，不能用抽象类或接口         |\n| [Name](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname)                                            | Bean 的名称或者 ID                               |\n| [Scope](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes)                                     | Bean 的作用域（如：`singleton`、`prototype` 等） |\n| [Constructor arguments](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)              | Bean 构造器参数（用于依赖注入）                  |\n| [Properties](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)                         | Bean 属性设置（用于依赖注入）                    |\n| [Autowiring mode](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)                         | Bean 自动绑定模式（如：通过名称 byName）         |\n| [Lazy initialization mode](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lazy-init)               | Bean 延迟初始化模式（延迟和非延迟）              |\n| [Initialization method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) | Bean 初始化回调方法名称                          |\n| [Destruction method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean)      | Bean 销毁回调方法名称                            |\n\n#### BeanDefinition 构建\n\nBeanDefinition 构建方式：\n\n- 通过 `BeanDefinitionBuilder`\n\n- 通过 `AbstractBeanDefinition` 以及派生类\n\n> 💻 Spring Bean 定义示例源码：[BeanDefinitionTests](https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanDefinitionTests.java)\n\n### Spring Bean 命名\n\n#### Spring Bean 命名规则\n\n每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。\n\n在基于 XML 的配置元信息中，开发人员**可以使用 `id` 属性、`name` 属性或来指定 Bean 标识符**。通常，Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 `name` 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\n\nSpring 中，**为 Bean 指定 `id` 和 `name` 属性不是必须的**。如果不指定，Spring 会自动为 Bean 分配一个唯一的名称。尽管 Bean 的命名没有限制，不过**官方建议采用驼峰命名法来命名 Bean**。\n\n#### Spring Bean 命名生成器\n\nSpring 提供了两种 Spring Bean 命名生成器：\n\n- `DefaultBeanNameGenerator`：默认通用 `BeanNameGenerator` 实现。\n- `AnnotationBeanNameGenerator`：基于注解扫描的 `BeanNameGenerator` 实现。\n\n```java\npublic interface BeanNameGenerator {\n   String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);\n}\n```\n\n#### Spring Bean 别名\n\nSpring 支持通过 `<alias>` 属性为 Bean 设置别名。\n\nBean 别名（Alias）的作用：\n\n- 复用现有的 `BeanDefinition`\n- 更具有场景化的命名方法，比如：\n  - `<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>`\n  - `<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>`\n\n```xml\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.User">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasUser" />\n```\n\n## Spring Bean 生命周期\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20211201102734.png)\n\n1. Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n2. Spring 将值和引用注入到 Bean 对应的属性中\n\n3. 如果 Bean 实现了 `BeanNameAware` 接口，Spring 将 Bean 的 ID 传递给 `setBeanName` 方法\n   - 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n4. 如果 Bean 实现了 `BeanFactoryAware` 接口，Spring 将调用 `setBeanDactory` 方法，并把 `BeanFactory` 容器实例作为参数传入。\n   - 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n5. 如果 Bean 实现了 `ApplicationContextAware` 接口，Spring 容器将调用 `setApplicationContext` 方法，把应用上下文作为参数传入\n   - 作用与 `BeanFactory` 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 `setApplicationContext` 方法时会把它自己作为 `setApplicationContext` 的参数传入，而 Spring 容器在调用 `setBeanFactory` 前需要使用者自己指定（注入）`setBeanFactory` 里的参数 `BeanFactory`\n6. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessBeforeInitialization` 方法\n   - 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n7. 如果 Bean 实现了 `InitializingBean` 接口，Spring 将调用 `afterPropertiesSet` 方法，作用与在配置文件中对 Bean 使用 `init-method` 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n8. 如果 Bean 实现了 `BeanPostProcess` 接口，Spring 将调用 `postProcessAfterInitialization` 方法\n   - `postProcessBeforeInitialization` 是在 Bean 初始化前执行的，而 `postProcessAfterInitialization` 是在 Bean 初始化后执行的\n9. 经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n10. 如果 Bean 实现了 `DispostbleBean` 接口，Spring 将调用它的 `destory` 方法，作用与在配置文件中对 Bean 使用 `destory-method` 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n## Spring Bean 注册\n\n注册 Spring Bean 实际上是将 `BeanDefinition` 注册到 IoC 容器中。\n\n### XML 配置元信息\n\nSpring 的传统配置方式。在 `<bean>` 标签中配置元数据内容。\n\n缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。\n\n### 注解配置元信息\n\n使用 `@Bean`、`@Component`、`@Import` 注解注册 Spring Bean。\n\n### Java API 配置元信息\n\n- 命名方式：`BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)`\n- 非命名方式：`BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,BeanDefinitionRegistry)`\n- 配置类方式：`AnnotatedBeanDefinitionReader#register(Class...)`\n\n> 💻 Spring Bean 注册示例源码：[BeanRegistryTests](https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanRegistryTests.java)\n\n## Spring Bean 实例化\n\nSpring Bean 实例化方式：\n\n- 常规方式\n  - 通过构造器（配置元信息：XML、Java 注解和 Java API）\n  - 通过静态方法（配置元信息：XML、Java 注解和 Java API）\n  - 通过 Bean 工厂方法（配置元信息：XML、Java 注解和 Java API）\n  - 通过 `FactoryBean`（配置元信息：XML、Java 注解和 Java API）\n- 特殊方式\n  - 通过 `ServiceLoaderFactoryBean`（配置元信息：XML、Java 注解和 Java API ）\n  - 通过 `AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)`\n  - 通过 `BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)`\n\n> 💻 Spring Bean 实例化示例源码：[BeanInstantiationTests](https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInstantiationTests.java)、[BeanInstantiationSpecialTests](https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInstantiationSpecialTests.java)\n\n## Spring Bean 初始化和销毁\n\nSpring Bean 初始化和销毁的方式有以下几种：\n\n1. 使用 `@PostConstruct` 和 `@PreDestroy` 注解分别指定相应的初始化方法和销毁方法。\n2. 实现 `InitializingBean` 接口的 `afterPropertiesSet()` 方法来编写初始化方法；实现 `DisposableBean` 接口的 `destroy()` 方法来编写销毁方法。\n\n   - `InitializingBean` 接口包含一个 `afterPropertiesSet` 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\n   - `DisposableBean`接口包含一个 `destory` 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\n\n3. 自定义初始化方法\n   - XML 配置：`<bean init-method="init" destroy="destroy" ... />`\n   - Java 注解：`@Bean(initMethod = "init", destroyMethod = "destroy")`\n   - Java API：`AbstractBeanDefinition#setInitMethodName(String)` 和 `AbstractBeanDefinition#setDestroyMethodName(String)` 分别定义初始化和销毁方法\n\n注意：如果同时存在，执行顺序会按照序列执行。\n\nBean 的延迟初始化\n\n- xml 方式：`<bean lazy-init="true" ... />`\n- 注解方式：`@Lazy`\n\nSpring 提供了一个 `BeanPostProcessor` 接口，提供了两个方法 `postProcessBeforeInitialization` 和 `postProcessAfterInitialization`。其中`postProcessBeforeInitialization` 在组件的初始化方法调用之前执行，`postProcessAfterInitialization` 在组件的初始化方法调用之后执行。它们都包含两个入参：\n\n- `bean`：当前组件对象；\n- `beanName`：当前组件在容器中的名称。\n\n> 💻 Spring Bean 初始化和销毁示例源码：[BeanInitDestroyTests](https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInitDestroyTests.java)\n\n## Spring Bean 垃圾回收\n\nSpring Bean 垃圾回收步骤：\n\n1. 关闭 Spring 容器（应用上下文）\n2. 执行 GC\n3. Spring Bean 覆盖的 `finalize()` 方法被回调\n\n## Spring Bean 作用范围\n\n| Scope                                                                                                                         | Description                                                                                                                                                                                                                                                  |\n| :---------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton)     | (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.                                                                                                                                                         |\n| [prototype](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype)     | Scopes a single bean definition to any number of object instances.                                                                                                                                                                                           |\n| [request](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request)         | Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring `ApplicationContext`. |\n| [session](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session)         | Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in the context of a web-aware Spring `ApplicationContext`.                                                                                                                 |\n| [application](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application) | Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in the context of a web-aware Spring `ApplicationContext`.                                                                                                                |\n| [websocket](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope)     | Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in the context of a web-aware Spring `ApplicationContext`.                                                                                                                     |\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring IoC",headers:[{level:2,title:"IoC 简介",slug:"ioc-简介",link:"#ioc-简介",children:[{level:3,title:"IoC 是什么",slug:"ioc-是什么",link:"#ioc-是什么",children:[]},{level:3,title:"IoC 能做什么",slug:"ioc-能做什么",link:"#ioc-能做什么",children:[]},{level:3,title:"IoC 和 DI",slug:"ioc-和-di",link:"#ioc-和-di",children:[]},{level:3,title:"IoC 容器",slug:"ioc-容器",link:"#ioc-容器",children:[]},{level:3,title:"Bean",slug:"bean",link:"#bean",children:[]},{level:3,title:"Spring IoC",slug:"spring-ioc-1",link:"#spring-ioc-1",children:[]}]},{level:2,title:"IoC 容器",slug:"ioc-容器-1",link:"#ioc-容器-1",children:[{level:3,title:"配置元数据",slug:"配置元数据",link:"#配置元数据",children:[]},{level:3,title:"实例化容器",slug:"实例化容器",link:"#实例化容器",children:[]},{level:3,title:"使用容器",slug:"使用容器",link:"#使用容器",children:[]}]},{level:2,title:"IoC 依赖来源",slug:"ioc-依赖来源",link:"#ioc-依赖来源",children:[]},{level:2,title:"IoC 配置元数据",slug:"ioc-配置元数据",link:"#ioc-配置元数据",children:[{level:3,title:"Xml 配置",slug:"xml-配置",link:"#xml-配置",children:[]},{level:3,title:"注解配置",slug:"注解配置",link:"#注解配置",children:[]},{level:3,title:"Java 配置",slug:"java-配置",link:"#java-配置",children:[]}]},{level:2,title:"依赖解决过程",slug:"依赖解决过程",link:"#依赖解决过程",children:[]},{level:2,title:"最佳实践",slug:"最佳实践",link:"#最佳实践",children:[{level:3,title:"singleton 的 Bean 如何注入 prototype 的 Bean",slug:"singleton-的-bean-如何注入-prototype-的-bean",link:"#singleton-的-bean-如何注入-prototype-的-bean",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/915530/",pathLocale:"/",extraFields:'---\ntitle: Spring IoC\ndate: 2020-08-30 16:06:10\norder: 02\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - IOC\npermalink: /pages/915530/\n---\n\n# Spring IoC\n\n## IoC 简介\n\n### IoC 是什么\n\n**IoC** 即**控制反转**（Inversion of Control，缩写为 IoC）。IoC 又称为**依赖倒置原则**（设计模式六大原则之一），它的要点在于：**程序要依赖于抽象接口，不要依赖于具体实现**。它的作用就是**用于降低代码间的耦合度**。\n\nIoC 的实现方式有两种：\n\n- **依赖注入**（Dependency Injection，简称 DI）：不通过 `new()` 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n- **依赖查找**（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\n理解 Ioc 的关键是要明确两个要点：\n\n- **谁控制谁，控制什么**：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n- **为何是反转，哪些方面反转了**：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20221006120112.png)\n\n### IoC 能做什么\n\nIoC 不是一种技术，而是编程思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。\n\nIoC 很好的体现了面向对象设计法则之一—— **好莱坞法则：“别找我们，我们找你”**；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n### IoC 和 DI\n\n其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。\n\n> 注：如果想要更加深入的了解 IoC 和 DI，请参考大师级人物 Martin Fowler 的一篇经典文章 [Inversion of Control Containers and the Dependency Injection pattern](http://www.martinfowler.com/articles/injection.html) 。\n\n### IoC 容器\n\nIoC 容器就是具有依赖注入功能的容器。IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。\n\nSpring IoC 容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。\n\n### Bean\n\n> **JavaBean** 是一种 JAVA 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 对外部通过提供 getter / setter 方法来访问其成员。\n\n由 IoC 容器管理的那些组成你应用程序的对象我们就叫它 Bean。Bean 就是由 Spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。那 IoC 怎样确定如何实例化 Bean、管理 Bean 之间的依赖关系以及管理 Bean 呢？这就需要配置元数据，在 Spring 中由 BeanDefinition 代表，后边会详细介绍，配置元数据指定如何实例化 Bean、如何组装 Bean 等。\n\n### Spring IoC\n\nSpring IoC 容器中的对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即与它们一起工作的其他对象）。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆过程（因此称为控制反转）。\n\n`org.springframework.beans` 和 `org.springframework.context` 是 IoC 容器的基础。\n\n## IoC 容器\n\n在 Spring 中，有两种 IoC 容器：`BeanFactory` 和 `ApplicationContext`。\n\n- `BeanFactory`：**`BeanFactory` 是 Spring 基础 IoC 容器**。`BeanFactory` 提供了 Spring 容器的配置框架和基本功能。\n- `ApplicationContext`：**`ApplicationContext` 是具备应用特性的 `BeanFactory` 的子接口**。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 `ApplicationContext` 作为 IoC 容器，因为它的功能远多于 `BeanFactory`。\n\n`org.springframework.context.ApplicationContext` 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。配置元数据以 XML、Java 注释或 Java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\n\nSpring 提供了 `ApplicationContext` 接口的几个实现，例如：\n\n- **[ClassPathXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html)**：`ApplicationContext` 的实现，从 classpath 获取配置信息。\n\n```java\nBeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath.xml");\n```\n\n- **[FileSystemXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html)**：`ApplicationContext` 的实现，从文件系统获取配置信息。\n\n```java\nBeanFactory beanFactory = new FileSystemXmlApplicationContext("fileSystemConfig.xml");\n```\n\n在大多数应用场景中，不需要显式通过用户代码来实例化 Spring IoC 容器的一个或多个实例。\n\n下图显示了 Spring IoC 容器的工作步骤\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200723102456.png)\n\n使用 IoC 容器可分为三步骤：\n\n1.  **配置元数据**：需要配置一些元数据来告诉 Spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 JavaBean 对象。\n2.  **实例化容器**：由 IoC 容器解析配置的元数据。IoC 容器的 Bean Reader 读取并解析配置文件，根据定义生成 BeanDefinition 配置元数据对象，IoC 容器根据 `BeanDefinition` 进行实例化、配置及组装 Bean。\n3.  **使用容器**：由客户端实例化容器，获取需要的 Bean。\n\n### 配置元数据\n\n**元数据（Metadata）**又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。\n\n配置元数据的方式：\n\n- **基于 xml 配置**：Spring 的传统配置方式。通常是在顶级元素 `<beans>` 中通过 `<bean>`元素配置元数据。这种方式的缺点是：如果 JavaBean 过多，则产生的配置文件足以让你眼花缭乱。\n- **[基于注解配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)**：Spring 2.5 引入了对基于注解的配置元数据的支持。可以大大简化你的配置。\n- **[基于 Java 配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java)**：从 Spring 3.0 开始，Spring 支持使用 Java 代码来配置元数据。通常是在 `@Configuration` 修饰的类中通过 `@Bean` 指定实例化 Bean 的方法。更多详情，可以参阅 [`@Configuration`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)、[`@Bean`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)、[`@Import`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html) 和 [`@DependsOn`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html) 注释。\n\n这些 bean 定义对应于构成应用程序的实际对象。例如：定义服务层对象、数据访问对象 (DAO)、表示对象（如 Struts Action 实例）、基础设施对象（如 Hibernate SessionFactories、JMS 队列等）。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控制之外创建的对象。\n\n以下示例显示了基于 XML 的配置元数据的基本结构：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 Bean 定义 --\x3e\n\n</beans>\n```\n\n### 实例化容器\n\n可以通过为 `ApplicationContext` 的构造函数指定外部资源路径，来加载配置元数据。\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n```\n\n以下示例显示了服务层对象 (services.xml) 配置文件：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n        <property name="itemDao" ref="itemDao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>\n```\n\n以下示例显示了数据访问对象 (daos.xml) 配置文件：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountDao"\n        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>\n```\n\n上面的示例中，服务层由 `PetStoreServiceImpl` 类和类型为 `JpaAccountDao` 和 `JpaItemDao` 的两个数据访问对象（基于 JPA 对象关系映射标准）组成。 `property name` 元素指的是 JavaBean 属性的名称，`ref` 元素指的是另一个 bean 定义的名称。 `id` 和 `ref` 元素之间的这种联系表达了协作对象之间的依赖关系。\n\n**Spring 支持通过多个 xml 文件来定义 Bean，每个单独的 XML 配置文件都代表架构中的一个逻辑层或模块。可以使用 `ApplicationContext` 构造函数从所有这些 XML 片段加载 bean 定义。或者，使用 `<import/>` 元素从另一个或多个文件加载 bean 定义**。如下所示：\n\n```xml\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messageSource.xml"/>\n    <import resource="/resources/themeSource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>\n```\n\n在上面的示例中，外部 bean 定义从三个文件加载：`services.xml`、`messageSource.xml` 和 `themeSource.xml`。`services.xml` 文件必须和当前 xml 文件位于同一目录或类路径位置；而 `messageSource.xml` 和 `themeSource.xml` 必须位于当前文件所在目录的子目录 `resources` 下。`/resources` 的 `/` 会被忽略。但是，鉴于这些路径是相对的，最好不要使用 `/`。根据 Spring Schema，被导入文件的内容，包括顶级 `<beans/>` 元素，必须是有效的 XML bean 定义。\n\n> 注意：\n>\n> 可以，但不推荐使用相对 `“../”` 路径来引用父目录中的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，不建议将此引用用于 `classpath`：URL（例如， `classpath:../services.xml`），其中运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n>\n> 可以使用完全限定的资源位置而不是相对路径：例如，`file:C:/config/services.xml` 或 `classpath:/config/services.xml`。建议为此类绝对路径保留一定的间接性  —  例如，通过 `“${...}”` 占位符来引用运行时指定 的 JVM 参数。\n\n命名空间本身提供了导入指令功能。 Spring 提供的一系列 XML 命名空间中提供了除了普通 bean 定义之外的更多配置特性  —  例如，`context` 和 `util` 命名空间。\n\n### 使用容器\n\n`ApplicationContext` 能够维护不同 bean 及其依赖项的注册表。通过**使用方法 `T getBean(String name, Class T requiredType)`，可以检索并获取 bean 的实例**。\n\n`ApplicationContext` 允许读取 bean 定义并访问它们，如以下示例所示：\n\n```java\n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n\n// use configured instance\nList<String> userList = service.getUsernameList();\n```\n\n最灵活的变体是 `GenericApplicationContext` 结合阅读器委托  —  例如，结合 XML 文件的 `XmlBeanDefinitionReader`，如下例所示：\n\n```java\nGenericApplicationContext context = new GenericApplicationContext();\nnew XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");\ncontext.refresh();\n```\n\n可以在同一个 `ApplicationContext` 上混合和匹配此类读取器委托，从不同的配置源读取 bean 定义。\n\n然后，可以使用 `getBean` 检索 bean 的实例。 `ApplicationContext` 接口还有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应该使用它们。实际上，应用程序代码根本不应该调用 `getBean()` 方法，因此根本不依赖 Spring API。例如，Spring 与 Web 框架的集成为各种 Web 框架组件（例如控制器和 JSF 管理的 bean）提供了依赖注入，让您可以通过元数据（例如自动装配注释）声明对特定 bean 的依赖。\n\n## IoC 依赖来源\n\n自定义 Bean\n\n容器内建 Bean 对象\n\n容器内建依赖\n\n## IoC 配置元数据\n\nIoC 容器的配置有三种方式：\n\n- 基于 xml 配置\n- 基于 properties 配置\n- 基于注解配置\n- 基于 Java 配置\n\n作为 Spring 传统的配置方式，xml 配置方式一般为大家所熟知。\n\n如果厌倦了 xml 配置，Spring 也提供了注解配置方式或 Java 配置方式来简化配置。\n\n**本文，将对 Java 配置 IoC 容器做详细的介绍。**\n\n### Xml 配置\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>\n```\n\n标签说明：\n\n- `<beans>` 是 Spring 配置文件的根节点。\n- `<bean>` 用来定义一个 JavaBean。`id` 属性是它的标识，在文件中必须唯一；`class` 属性是它关联的类。\n- `<alias>` 用来定义 Bean 的别名。\n- `<import>` 用来导入其他配置文件的 Bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new String[] {“config1.xml”, config2.xml}）传给 `ApplicationContext` 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 Bean Definition Reader 读取 Bean 定义，内部实现没有任何区别。`<import>` 标签可以放在 `<beans>` 下的任何位置，没有顺序关系。\n\n#### 实例化容器\n\n实例化容器的过程：\n定位资源（XML 配置文件）\n读取配置信息(Resource)\n转化为 Spring 可识别的数据形式（BeanDefinition）\n\n```java\nApplicationContext context =\n      new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n```\n\n组合 xml 配置文件\n配置的 Bean 功能各不相同，都放在一个 xml 文件中，不便管理。\nJava 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 JavaBean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。\n\n```xml\n<import resource="classpath:spring/applicationContext.xml"/>\n<import resource="/WEB-INF/spring/service.xml"/>\n```\n\n#### 使用容器\n\n使用容器的方式就是通过`getBean`获取 IoC 容器中的 JavaBean。\nSpring 也有其他方法去获得 JavaBean，但是 Spring 并不推荐其他方式。\n\n```java\n// create and configure beans\nApplicationContext context =\nnew ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n// use configured instance\nList<String> userList = service.getUsernameList();\n```\n\n### 注解配置\n\nSpring2.5 引入了注解。\n于是，一个问题产生了：**使用注解方式注入 JavaBean 是不是一定完爆 xml 方式？**\n未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点：\n**优点**：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。\n**缺点**：使用注解，不可避免产生了侵入式编程，也产生了一些问题。\n\n- 你需要将注解加入你的源码并编译它；\n\n- 注解往往比较分散，不易管控。\n\n> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。\n\n#### 启动注解\n\nSpring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。\n启动方式：在 xml 中加入一个标签，很简单吧。\n\n```xml\n<context:annotation-config/>\n```\n\n> 注：`<context:annotation-config/>` 只会检索定义它的上下文。什么意思呢？就是说，如果你\n> 为 DispatcherServlet 指定了一个`WebApplicationContext`，那么它只在 controller 中查找`@Autowired`注解，而不会检查其它的路径。\n\n#### `@Required`\n\n`@Required` 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出`BeanInitializationException`。\n\n```java\npublic class AnnotationRequired {\n    private String name;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @Required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出BeanInitializationException。\n     */\n    @Required\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}\n```\n\n#### `@Autowired`\n\n`@Autowired`注解可用于修饰属性、setter 方法、构造方法。\n\n@Autowired 注入过程\n\n- 元信息解析\n- 依赖查找\n- 依赖注入（字段、方法）\n\n> 注：`@Autowired`注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。\n\n可以使用 JSR330 的注解`@Inject`来替代`@Autowired`。\n\n**_范例_**\n\n```java\npublic class AnnotationAutowired {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationRequired.class);\n\n    @Autowired\n    private Apple fieldA;\n\n    private Banana fieldB;\n\n    private Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Autowired\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public void setFieldC(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public AnnotationAutowired() {}\n\n    @Autowired\n    public AnnotationAutowired(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationAutowired annotationAutowired =\n                        (AnnotationAutowired) ctx.getBean("annotationAutowired");\n        log.debug("fieldA: {}, fieldB:{}, fieldC:{}", annotationAutowired.getFieldA().getName(),\n                        annotationAutowired.getFieldB().getName(),\n                        annotationAutowired.getFieldC().getName());\n        ctx.close();\n    }\n}\n```\n\nxml 中的配置\n\n```xml\n\x3c!-- 测试@Autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.Apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.Banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.Orange"/>\n<bean id="annotationAutowired" class="org.zp.notes.spring.beans.annotation.sample.AnnotationAutowired"/>\n```\n\n#### `@Qualifier`\n\n在`@Autowired`注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，Spring 就会抓瞎了。\n\n那么，如何解决这个问题。\n\n可以通过`@Qualifier`指定 bean 名称来锁定真正需要的那个 bean。\n\n**_范例_**\n\n```java\npublic class AnnotationQualifier {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationQualifier.class);\n\n    @Autowired\n    @Qualifier("dog") /** 去除这行，会报异常 */\n    Animal dog;\n\n    Animal cat;\n\n    public Animal getDog() {\n        return dog;\n    }\n\n    public void setDog(Animal dog) {\n        this.dog = dog;\n    }\n\n    public Animal getCat() {\n        return cat;\n    }\n\n    @Autowired\n    public void setCat(@Qualifier("cat") Animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationQualifier annotationQualifier =\n                (AnnotationQualifier) ctx.getBean("annotationQualifier");\n\n        log.debug("Dog name: {}", annotationQualifier.getDog().getName());\n        log.debug("Cat name: {}", annotationQualifier.getCat().getName());\n        ctx.close();\n    }\n}\n\nabstract class Animal {\n    public String getName() {\n        return null;\n    }\n}\n\nclass Dog extends Animal {\n    public String getName() {\n        return "狗";\n    }\n}\n\nclass Cat extends Animal {\n    public String getName() {\n        return "猫";\n    }\n}\n```\n\nxml 中的配置\n\n```xml\n\x3c!-- 测试@Qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.Dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.Cat"/>\n<bean id="annotationQualifier" class="org.zp.notes.spring.beans.annotation.sample.AnnotationQualifier"/>\n```\n\n#### `@Resource`\n\nSpring 支持 JSP250 规定的注解`@Resource`。这个注解根据指定的名称来注入 bean。\n\n如果没有为`@Resource`指定名称，它会像`@Autowired`一样按照类型去寻找匹配。\n\n在 Spring 中，由`CommonAnnotationBeanPostProcessor`来处理`@Resource`注解。\n\n**_范例_**\n\n```java\npublic class AnnotationResource {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationResource.class);\n\n    @Resource(name = "flower")\n    Plant flower;\n\n    @Resource(name = "tree")\n    Plant tree;\n\n    public Plant getFlower() {\n        return flower;\n    }\n\n    public void setFlower(Plant flower) {\n        this.flower = flower;\n    }\n\n    public Plant getTree() {\n        return tree;\n    }\n\n    public void setTree(Plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationResource annotationResource =\n                        (AnnotationResource) ctx.getBean("annotationResource");\n        log.debug("type: {}, name: {}", annotationResource.getFlower().getClass(), annotationResource.getFlower().getName());\n        log.debug("type: {}, name: {}", annotationResource.getTree().getClass(), annotationResource.getTree().getName());\n        ctx.close();\n    }\n}\n```\n\nxml 的配置\n\n```xml\n\x3c!-- 测试@Resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.Flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.Tree"/>\n<bean id="annotationResource" class="org.zp.notes.spring.beans.annotation.sample.AnnotationResource"/>\n```\n\n#### `@PostConstruct` 和 `@PreDestroy`\n\n`@PostConstruct` 和 `@PreDestroy` 是 JSR 250 规定的用于生命周期的注解。\n\n从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。\n\n```java\npublic class AnnotationPostConstructAndPreDestroy {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationPostConstructAndPreDestroy.class);\n\n    @PostConstruct\n    public void init() {\n        log.debug("call @PostConstruct method");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug("call @PreDestroy method");\n    }\n}\n```\n\n#### `@Inject`\n\n从 Spring3.0 开始，Spring 支持 JSR 330 标准注解（依赖注入）。\n\n注：如果要使用 JSR 330 注解，需要使用外部 jar 包。\n\n若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：\n\n```xml\n<dependency>\n  <groupId>javax.inject</groupId>\n  <artifactId>javax.inject</artifactId>\n  <version>1</version>\n</dependency>\n```\n\n`@Inject` 和 `@Autowired` 一样，可以修饰属性、setter 方法、构造方法。\n\n**_范例_**\n\n```java\npublic class AnnotationInject {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationInject.class);\n    @Inject\n    Apple fieldA;\n\n    Banana fieldB;\n\n    Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Inject\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public AnnotationInject() {}\n\n    @Inject\n    public AnnotationInject(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n        AnnotationInject annotationInject = (AnnotationInject) ctx.getBean("annotationInject");\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldA().getClass(),\n                        annotationInject.getFieldA().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldB().getClass(),\n                        annotationInject.getFieldB().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldC().getClass(),\n                        annotationInject.getFieldC().getName());\n\n        ctx.close();\n    }\n}\n```\n\n### Java 配置\n\n基于 Java 配置 Spring IoC 容器，实际上是**Spring 允许用户定义一个类，在这个类中去管理 IoC 容器的配置**。\n\n为了让 Spring 识别这个定义类为一个 Spring 配置类，需要用到两个注解：`@Configuration`和`@Bean`。\n\n如果你熟悉 Spring 的 xml 配置方式，你可以将`@Configuration`等价于`<beans>`标签；将`@Bean`等价于`<bean>`标签。\n\n#### `@Bean`\n\n@Bean 的修饰目标只能是方法或注解。\n\n@Bean 只能定义在 `@Configuration` 或 `@Component` 注解修饰的类中。\n\n#### 声明一个 bean\n\n此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。\n\n声明一个 bean，只需要在 bean 属性的 set 方法上标注@Bean 即可。\n\n```java\n@Configuration\npublic class AnnotationConfiguration {\n    private static final Logger log = LoggerFactory.getLogger(JavaComponentScan.class);\n\n    @Bean\n    public Job getPolice() {\n        return new Police();\n    }\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AnnotationConfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        Job job = (Job) ctx.getBean("police");\n        log.debug("job: {}, work: {}", job.getClass(), job.work());\n    }\n}\n\npublic interface Job {\n    String work();\n}\n\n@Component("police")\npublic class Police implements Job {\n    @Override\n    public String work() {\n        return "抓罪犯";\n    }\n}\n```\n\n这等价于配置\n\n```xml\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.Police"/>\n</beans>\n```\n\n@Bean 注解用来表明一个方法实例化、配置合初始化一个被 Spring IoC 容器管理的新对象。\n\n如果你熟悉 Spring 的 xml 配置，你可以将@Bean 视为等价于`<beans>`标签。\n\n@Bean 注解可以用于任何的 Spring `@Component` bean，然而，通常被用于`@Configuration` bean。\n\n#### `@Configuration`\n\n`@Configuration` 是一个类级别的注解，用来标记被修饰类的对象是一个`BeanDefinition`。\n\n`@Configuration` 声明 bean 是通过被 `@Bean` 修饰的公共方法。此外，`@Configuration` 允许在同一个类中通过 `@Bean` 定义内部 bean 依赖。\n\n```java\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n```\n\n这等价于配置\n\n```xml\n<beans>\n\t<bean id="myService" class="com.acme.services.MyServiceImpl"/>\n</beans>\n```\n\n用 `AnnotationConfigApplicationContext` 实例化 IoC 容器。\n\n## 依赖解决过程\n\n容器执行 bean 依赖解析如下：\n\n- `ApplicationContext` 使用配置元数据创建和初始化 Bean。配置元数据可以由 XML、Java 代码或注解指定。\n- 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示。这些依赖项在实际创建 bean 时提供给 bean。\n- 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。\n- 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如 int、long、String、boolean 等。\n\nSpring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身。在创建容器时会创建 singleton 型的实例并设置为默认的 Bean。否则，只有在请求时才会创建 bean。\n\n需注意：构造器注入，可能会导致无法解决循环依赖问题。\n\n例如：A 类通过构造器注入需要 B 类的实例，B 类通过构造器注入需要 A 类的实例。Spring IoC 容器会在运行时检测到此循环引用，并抛出 `BeanCurrentlyInCreationException`。\n\n一种解决方案是使用 setter 方法注入替代构造器注入。\n\n另一种解决方案是：bean A 和 bean B 之间的循环依赖关系，强制其中一个 bean 在完全初始化之前注入另一个 bean（典型的先有鸡还是先有蛋的场景）。\n\nSpring 会在容器加载时检测配置问题，例如引用不存在的 bean 或循环依赖。在实际创建 bean 时，Spring 会尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项之一时出现问题，则正确加载的 Spring 容器稍后可以在您请求对象时生成异常  —  例如，bean 由于丢失或无效而引发异常。某些配置问题的这种潜在的延迟可见性是默认情况下 ApplicationContext 实现预实例化单例 bean 的原因。以在实际需要之前创建这些 bean 的一些前期时间和内存为代价，您会在创建 ApplicationContext 时发现配置问题，而不是稍后。您仍然可以覆盖此默认行为，以便单例 bean 延迟初始化，而不是急切地预先实例化。\n\n## 最佳实践\n\n### singleton 的 Bean 如何注入 prototype 的 Bean\n\nSpring 创建的 Bean 默认是单例的，但当 Bean 遇到继承的时候，可能会忽略这一点。\n\n假设有一个 SayService 抽象类，其中维护了一个类型是 ArrayList 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 SayService 是有状态，如果 SayService 是单例的话必然会 OOM。\n\n```java\n/**\n * SayService 是有状态，如果 SayService 是单例的话必然会 OOM\n */\n@Slf4j\npublic abstract class SayService {\n\n   List<String> data = new ArrayList<>();\n\n   public void say() {\n      data.add(IntStream.rangeClosed(1, 1000000)\n         .mapToObj(__ -> "a")\n         .collect(Collectors.joining("")) + UUID.randomUUID().toString());\n      log.info("I\'m {} size:{}", this, data.size());\n   }\n\n}\n```\n\n但实际开发的时候，开发同学没有过多思考就把 SayHello 和 SayBye 类加上了 @Service 注解，让它们成为了 Bean，也没有考虑到父类是有状态的。\n\n```java\n@Service\n@Slf4j\npublic class SayBye extends SayService {\n\n   @Override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@Service\n@Slf4j\npublic class SayHello extends SayService {\n\n\t@Override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}\n```\n\n在为类标记上 @Service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 Bean 设置合适的 Scope。\n\n调用代码：\n\n```java\n@Slf4j\n@RestController\n@RequestMapping("beansingletonandorder")\npublic class BeanSingletonAndOrderController {\n\n   @Autowired\n   List<SayService> sayServiceList;\n   @Autowired\n   private ApplicationContext applicationContext;\n\n   @GetMapping("test")\n   public void test() {\n      log.info("====================");\n      sayServiceList.forEach(SayService::say);\n   }\n\n}\n```\n\n可能有人认为，为 SayHello 和 SayBye 两个类都标记了 @Scope 注解，设置了 PROTOTYPE 的生命周期就可以解决上面的问题。\n\n```java\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n```\n\n但实际上还是有问题。因为@RestController 注解 =@Controller 注解 +@ResponseBody 注解，又因为 @Controller 标记了 @Component 元注解，所以 @RestController 注解其实也是一个 Spring Bean。\n\nBean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。\n\n修复方式是，让 Service 以代理方式注入。这样虽然 Controller 本身是单例的，但每次都能从代理获取 Service。这样一来，prototype 范围的配置才能真正生效。\n\n```java\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProx)\n```\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring 依赖查找",headers:[{level:2,title:"单一类型依赖查找",slug:"单一类型依赖查找",link:"#单一类型依赖查找",children:[]},{level:2,title:"集合类型依赖查找",slug:"集合类型依赖查找",link:"#集合类型依赖查找",children:[]},{level:2,title:"层次性依赖查找",slug:"层次性依赖查找",link:"#层次性依赖查找",children:[]},{level:2,title:"延迟依赖查找",slug:"延迟依赖查找",link:"#延迟依赖查找",children:[]},{level:2,title:"安全依赖查找",slug:"安全依赖查找",link:"#安全依赖查找",children:[]},{level:2,title:"内建可查找的依赖",slug:"内建可查找的依赖",link:"#内建可查找的依赖",children:[]},{level:2,title:"依赖查找中的经典异常",slug:"依赖查找中的经典异常",link:"#依赖查找中的经典异常",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/9a6f6b/",pathLocale:"/",extraFields:"---\ntitle: Spring 依赖查找\ndate: 2020-08-30 16:06:10\norder: 03\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - IOC\n  - 依赖查找\npermalink: /pages/9a6f6b/\n---\n\n# Spring 依赖查找\n\n**依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现**。\n\nIoC 依赖查找大致可以分为以下几类：\n\n- 根据 Bean 名称查找\n- 根据 Bean 类型查找\n- 根据 Bean 名称 + 类型查找\n- 根据 Java 注解查找\n\n此外，根据查找的 Bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 API。\n\n## 单一类型依赖查找\n\n单一类型依赖查找接口- `BeanFactory`\n\n- 根据 Bean 名称查找\n  - `getBean(String)`\n  - Spring 2.5 覆盖默认参数：`getBean(String,Object...)`\n- 根据 Bean 类型查找\n  - Bean 实时查找\n    - Spring 3.0 `getBean(Class)`\n    - Spring 4.1 覆盖默认参数：`getBean(Class,Object...)`\n  - Spring 5.1 Bean 延迟查找\n    - `getBeanProvider(Class)`\n    - `getBeanProvider(ResolvableType)`\n- 根据 Bean 名称 + 类型查找：`getBean(String,Class)`\n\n## 集合类型依赖查找\n\n集合类型依赖查找接口- `ListableBeanFactory`\n\n- 根据 Bean 类型查找\n  - 获取同类型 Bean 名称列表\n    - `getBeanNamesForType(Class)`\n    - Spring 4.2 `getBeanNamesForType(ResolvableType)`\n  - 获取同类型 Bean 实例列表\n    - `getBeansOfType(Class)` 以及重载方法\n- 通过注解类型查找\n\n  - Spring 3.0 获取标注类型 Bean 名称列表\n\n    - `getBeanNamesForAnnotation(Class<? extends Annotation>)`\n\n  - Spring 3.0 获取标注类型 Bean 实例列表\n\n    - `getBeansWithAnnotation(Class<? extends Annotation>)`\n\n  - Spring 3.0 获取指定名称+ 标注类型 Bean 实例\n\n    - `findAnnotationOnBean(String,Class<? extends Annotation>)`\n\n## 层次性依赖查找\n\n层次性依赖查找接口- `HierarchicalBeanFactory`\n\n- 双亲 `BeanFactory`：`getParentBeanFactory()`\n- 层次性查找\n  - 根据 Bean 名称查找\n    - 基于 `containsLocalBean` 方法实现\n  - 根据 Bean 类型查找实例列表\n    - 单一类型：`BeanFactoryUtils#beanOfType`\n    - 集合类型：`BeanFactoryUtils#beansOfTypeIncludingAncestors`\n  - 根据 Java 注解查找名称列表\n    - `BeanFactoryUtils#beanNamesForTypeIncludingAncestors`\n\n## 延迟依赖查找\n\nBean 延迟依赖查找接口\n\n- `org.springframework.beans.factory.ObjectFactory`\n- `org.springframework.beans.factory.ObjectProvider`（Spring 5 对 Java 8 特性扩展）\n- 函数式接口\n  - `getIfAvailable(Supplier)`\n  - `ifAvailable(Consumer)`\n- Stream 扩展- stream()\n\n## 安全依赖查找\n\n| 依赖查找类型 | 代表实现                             | 是否安全 |\n| ------------ | ------------------------------------ | -------- |\n| 单一类型查找 | `BeanFactory#getBean`                | 否       |\n|              | `ObjectFactory#getObject`            | 否       |\n|              | `ObjectProvider#getIfAvailable`      | 是       |\n|              |                                      |          |\n| 集合类型查找 | `ListableBeanFactory#getBeansOfType` | 是       |\n|              | `ObjectProvider#stream`              | 是       |\n\n注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 `BeanFactory` 接口\n\n## 内建可查找的依赖\n\n`AbstractApplicationContext` 内建可查找的依赖\n\n| Bean                        | 名称 Bean                        | 实例使用场景            |\n| --------------------------- | -------------------------------- | ----------------------- |\n| environment                 | Environment 对象                 | 外部化配置以及 Profiles |\n| systemProperties            | java.util.Properties 对象        | Java 系统属性           |\n| systemEnvironment           | java.util.Map 对象               | 操作系统环境变量        |\n| messageSource               | MessageSource 对象               | 国际化文案              |\n| lifecycleProcessor          | LifecycleProcessor 对象          | Lifecycle Bean 处理器   |\n| applicationEventMulticaster | ApplicationEventMulticaster 对象 | Spring 事件广播器       |\n\n注解驱动 Spring 应用上下文内建可查找的依赖（部分）\n\n| Bean 名称                                                                       | Bean 实例                                   | 使用场景                                              |\n| ------------------------------------------------------------------------------- | ------------------------------------------- | ----------------------------------------------------- |\n| org.springframework.context.annotation.internalConfigurationAnnotationProcessor | ConfigurationClassPostProcessor 对象        | 处理 Spring 配置类                                    |\n| org.springframework.context.annotation.internalAutowiredAnnotationProcessor     | AutowiredAnnotationBeanPostProcessor 对象   | 处理@Autowired 以及@Value 注解                        |\n| org.springframework.context.annotation.internalCommonAnnotationProcessor        | CommonAnnotationBeanPostProcessor 对象      | （条件激活）处理 JSR-250 注解，如@PostConstruct 等    |\n| org.springframework.context.event.internalEventListenerProcessor                | EventListenerMethodProcessor 对象           | 处理标注@EventListener 的 Spring 事件监听方法         |\n| org.springframework.context.event.internalEventListenerFactory                  | DefaultEventListenerFactory 对象            | @EventListener 事件监听方法适配为 ApplicationListener |\n| org.springframework.context.annotation.internalPersistenceAnnotationProcessor   | PersistenceAnnotationBeanPostProcessor 对象 | （条件激活）处理 JPA 注解场景                         |\n\n## 依赖查找中的经典异常\n\n`BeansException` 子类型\n\n| 异常类型                          | 触发条件（举例）                           | 场景举例                                     |\n| --------------------------------- | ------------------------------------------ | -------------------------------------------- |\n| `NoSuchBeanDefinitionException`   | 当查找 Bean 不存在于 IoC 容器时            | `BeanFactory#getBeanObjectFactory#getObject` |\n| `NoUniqueBeanDefinitionException` | 类型依赖查找时，IoC 容器存在多个 Bean 实例 | `BeanFactory#getBean(Class)`                 |\n| `BeanInstantiationException`      | 当 Bean 所对应的类型非具体类时             | `BeanFactory#getBean`                        |\n| `BeanCreationException`           | 当 Bean 初始化过程中                       | Bean 初始化方法执行异常时                    |\n| `BeanDefinitionStoreException`    | 当 `BeanDefinition` 配置元信息非法时       | XML 配置资源无法打开时                       |\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring 依赖注入",headers:[{level:2,title:"IoC 依赖注入 API",slug:"ioc-依赖注入-api",link:"#ioc-依赖注入-api",children:[]},{level:2,title:"依赖注入模式",slug:"依赖注入模式",link:"#依赖注入模式",children:[{level:3,title:"手动注入模式",slug:"手动注入模式",link:"#手动注入模式",children:[]},{level:3,title:"自动注入模式",slug:"自动注入模式",link:"#自动注入模式",children:[]}]},{level:2,title:"依赖注入方式",slug:"依赖注入方式",link:"#依赖注入方式",children:[{level:3,title:"构造器注入",slug:"构造器注入",link:"#构造器注入",children:[]},{level:3,title:"Setter 方法注入",slug:"setter-方法注入",link:"#setter-方法注入",children:[]},{level:3,title:"字段注入",slug:"字段注入",link:"#字段注入",children:[]},{level:3,title:"方法注入",slug:"方法注入",link:"#方法注入",children:[]},{level:3,title:"接口回调注入",slug:"接口回调注入",link:"#接口回调注入",children:[]},{level:3,title:"依赖注入选型",slug:"依赖注入选型",link:"#依赖注入选型",children:[]}]},{level:2,title:"限定注入和延迟注入",slug:"限定注入和延迟注入",link:"#限定注入和延迟注入",children:[{level:3,title:"限定注入",slug:"限定注入",link:"#限定注入",children:[]},{level:3,title:"延迟注入",slug:"延迟注入",link:"#延迟注入",children:[]}]},{level:2,title:"依赖注入数据类型",slug:"依赖注入数据类型",link:"#依赖注入数据类型",children:[{level:3,title:"基础类型",slug:"基础类型",link:"#基础类型",children:[]},{level:3,title:"集合类型",slug:"集合类型",link:"#集合类型",children:[]}]},{level:2,title:"依赖处理过程",slug:"依赖处理过程",link:"#依赖处理过程",children:[]},{level:2,title:"依赖查找 VS. 依赖注入",slug:"依赖查找-vs-依赖注入",link:"#依赖查找-vs-依赖注入",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/f61a1c/",pathLocale:"/",extraFields:'---\ntitle: Spring 依赖注入\ndate: 2020-08-30 16:06:10\norder: 04\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - IOC\n  - 依赖注入\npermalink: /pages/f61a1c/\n---\n\n# Spring 依赖注入\n\nDI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API。\n\n依赖注入 (Dependency Injection，简称 DI) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。\n\n使用 DI，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。\n\n**容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象**。\n\nDI 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n\n- **谁依赖于谁：**当然是应用程序依赖于 IoC 容器；\n- **为什么需要依赖：**应用程序需要 IoC 容器来提供对象需要的外部资源；\n- **谁注入谁：**很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；\n- **注入了什么**：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n## IoC 依赖注入 API\n\n- 根据 Bean 名称注入\n- 根据 Bean 类型注入\n- 注入容器内建 Bean 对象\n- 注入非 Bean 对象\n- 注入类型\n  - 实时注入\n  - 延迟注入\n\n## 依赖注入模式\n\n依赖注入模式可以分为手动注入模式和自动注入模式。\n\n### 手动注入模式\n\n手动注入模式：配置或者编程的方式，提前安排注入规则\n\n- XML 资源配置元信息\n- Java 注解配置元信息\n- API 配置元信息\n\n### 自动注入模式\n\n自动注入模式即自动装配。自动装配（Autowiring）是指 Spring 容器可以自动装配 Bean 之间的关系。Spring 可以通过检查 `ApplicationContext` 的内容，自动解析合作者（其他 Bean）。\n\n- 自动装配可以显著减少属性或构造函数参数的配置。\n- 随着对象的发展，自动装配可以更新配置。\n\n> 注：由于自动装配存在一些限制和不足，官方不推荐使用。\n\n#### 自动装配策略\n\n当使用基于 XML 的配置元数据时，可以使用 `<bean/>` 元素的 `autowire` 属性为 Bean 指定自动装配模式。自动装配模式有以下类型：\n\n| 模式          | 说明                                                                   |\n| ------------- | ---------------------------------------------------------------------- |\n| `no`          | 默认值，未激活 Autowiring，需要手动指定依赖注入对象。                  |\n| `byName`      | 根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性。 |\n| `byType`      | 根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。       |\n| `constructor` | 特殊 byType 类型，用于构造器参数。                                     |\n\n`org.springframework.beans.factory.config.AutowireCapableBeanFactory` 是 `BeanFactory` 的子接口，它是 Spring 中用于实现自动装配的容器。\n\n#### @Autowired 注入过程\n\n- 元信息解析\n- 依赖查找\n- 依赖注入（字段、方法）\n\n#### 自动装配的限制和不足\n\n自动装配有以下限制和不足：\n\n- 属性和构造函数参数设置中的显式依赖项会覆盖自动装配。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。\n- 自动装配不如显式装配精准。Spring 会尽量避免猜测可能存在歧义的结果。\n- Spring 容器生成文档的工具可能无法解析自动装配信息。\n- 如果同一类型存在多个 Bean 时，自动装配时会存在歧义。容器内的多个 Bean 定义可能与要自动装配的 Setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 Map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 Bean 定义可用，则会引发异常。\n\n> 自动装配的限制和不足，详情可以参考官方文档：[Limitations and Disadvantages of Autowiring 小节](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-frameworkreference/core.html#beans-autowired-exceptions)\n\n## 依赖注入方式\n\n依赖注入有如下方式：\n\n| 依赖注入方式    | 配置元数据举例                                     |\n| --------------- | -------------------------------------------------- |\n| Setter 方法注入 | `<proeprty name="user" ref="userBean"/>`           |\n| 构造器注入      | `<constructor-arg name="user" ref="userBean" />`   |\n| 字段注入        | `@Autowired User user;`                            |\n| 方法注入        | `@Autowired public void user(User user) { ... }`   |\n| 接口回调注入    | `class MyBean implements BeanFactoryAware { ... }` |\n\n### 构造器注入\n\n- 手动模式\n  - xml 配置元信息\n  - 注解配置元信息\n  - Java 配置元信息\n- 自动模式\n  - constructor\n\n构造器注入是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的，并且本次讨论对构造函数和静态工厂方法的参数进行了类似的处理。\n\n下面是一个构造器注入示例：\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\n构造函数参数解析匹配通过使用参数的类型进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。\n\n```\npackage x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}\n```\n\n假设 ThingTwo 和 ThingThree 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，您无需在 `<constructor-arg/>` 元素中显式指定构造函数参数索引或类型。\n\n```xml\n<beans>\n    <bean id="beanOne" class="x.y.ThingOne">\n        <constructor-arg ref="beanTwo"/>\n        <constructor-arg ref="beanThree"/>\n    </bean>\n\n    <bean id="beanTwo" class="x.y.ThingTwo"/>\n\n    <bean id="beanThree" class="x.y.ThingThree"/>\n</beans>\n```\n\n当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。当使用简单类型时，例如 `<value>true</value>` ，Spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下类：\n\n```java\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private final int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private final String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n```\n\n构造函数参数类型匹配\n\n在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：\n\n```xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.String" value="42"/>\n</bean>\n```\n\n构造函数参数索引匹配\n\n可以使用 `index` 属性显式指定构造函数参数的索引，如以下示例所示\n\n```xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>\n```\n\n构造函数参数名称匹配\n\n```xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateAnswer" value="42"/>\n</bean>\n```\n\n可以使用 `@ConstructorProperties` 显式命名构造函数参数。\n\n```java\npackage examples;\n\npublic class ExampleBean {\n\n    // Fields omitted\n\n    @ConstructorProperties({"years", "ultimateAnswer"})\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n```\n\n### Setter 方法注入\n\n- 手动模式\n  - xml 配置元信息\n  - 注解配置元信息\n  - Java 配置元信息\n- 自动模式\n  - byName\n  - byType\n\nSetter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。\n\n以下示例显示了一个只能通过使用纯 setter 注入进行依赖注入的类。\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\n在 Spring 中，可以混合使用构造器注入和 setter 方法注入。建议将构造器注入用于强制依赖项；并将 setter 方法注入或配置方法用于可选依赖项。需要注意的是，在 setter 方法上使用 `@Required` 注解可用于使属性成为必需的依赖项；然而，更建议使用构造器注入来完成这项工作。\n\n### 字段注入\n\n手动模式（Java 注解配置元信息）\n\n- `@Autowired`\n- `@Resource`\n- `@Inject`（可选）\n\n### 方法注入\n\n手动模式（Java 注解配置元信息）\n\n- `@Autowired`\n- `@Resource`\n- `@Inject`（可选）\n- `@Bean`\n\n### 接口回调注入\n\nAware 系列接口回调\n\n| 內建接口                         | 说明                                                       |\n| -------------------------------- | ---------------------------------------------------------- |\n| `BeanFactoryAware`               | 获取 IoC 容器- `BeanFactory`                               |\n| `ApplicationContextAware`        | 获取 Spring 应用上下文- `ApplicationContext` 对象          |\n| `EnvironmentAware`               | 获取 `Environment` 对象                                    |\n| `ResourceLoaderAware`            | 获取资源加载器对象- `ResourceLoader`                       |\n| `BeanClassLoaderAware`           | 获取加载当前 Bean Class 的 `ClassLoader`                   |\n| `BeanNameAware`                  | 获取当前 Bean 的名称                                       |\n| `MessageSourceAware`             | 获取 `MessageSource` 对象，用于 Spring 国际化              |\n| `ApplicationEventPublisherAware` | 获取 `ApplicationEventPublishAware` 对象，用于 Spring 事件 |\n| `EmbeddedValueResolverAware`     | 获取 `StringValueResolver` 对象，用于占位符处理            |\n\n### 依赖注入选型\n\n- 低依赖：构造器注入\n- 多依赖：Setter 方法注入\n- 便利性：字段注入\n- 声明类：方法注入\n\n## 限定注入和延迟注入\n\n### 限定注入\n\n- 使用 `@Qualifier` 注解限定\n  - 通过 Bean 名称限定\n  - 通过分组限定\n- 通过 `@Qualifier` 注解扩展限定\n  - 自定义注解：如 Spring Cloud 的 `@LoadBalanced`\n\n### 延迟注入\n\n- 使用 `ObjectFactory`\n- 使用 `ObjectProvider`（推荐）\n\n## 依赖注入数据类型\n\n### 基础类型\n\n- 基础数据类型：`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`\n- 标量类型：`Number`、`Character`、`Boolean`、`Enum`、`Locale`、`Charset`、`Currency`、`Properties`、`UUID`\n- 常规类型：`Object`、`String`、`TimeZone`、`Calendar`、`Optional` 等\n- Spring 类型：`Resource`、`InputSource`、`Formatter` 等。\n\n### 集合类型\n\n数组类型：基础数据类型、标量类型、常规类型、String 类型的数组\n\n集合类型：\n\n- `Collection`：`List`、`Set`\n- `Map`：`Properties`\n\n## 依赖处理过程\n\n入口：`DefaultListableBeanFactory#resolveDependency`\n\n依赖描述符：`DependencyDescriptor`\n\n自定义绑定候选对象处理器：`AutowireCandidateResolver`\n\n`@Autowired`、`@Value`、`@javax.inject.Inject` 处理器：`AutowiredAnnotationBeanPostProcessor`\n\n通用注解处理器：`CommonAnnotationBeanPostProcessor`\n\n- 注入注解\n  - `javax.xml.ws.WebServiceRef`\n  - `javax.ejb.EJB`\n  - `javax.annotation.Resources`\n- 生命周期注解\n  - `javax.annotation.PostConstruct`\n  - `javax.annotation.PreDestroy`\n\n自定义依赖注入注解：\n\n- 生命周期处理\n  - `InstantiationAwareBeanPostProcessor`\n  - `MergedBeanDefinitionPostProcessor`\n- 元数据\n  - `InjectionMetadata`\n  - `InjectionMetadata.InjectedElement`\n\n## 依赖查找 VS. 依赖注入\n\n| 类型     | 依赖处理 | 实现复杂度 | 代码侵入性   | API 依赖性     | 可读性 |\n| -------- | -------- | ---------- | ------------ | -------------- | ------ |\n| 依赖查找 | 主动     | 相对繁琐   | 侵入业务逻辑 | 依赖容器 API   | 良好   |\n| 依赖注入 | 被动     | 相对便利   | 低侵入性     | 不依赖容器 API | 一般   |\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring IoC 依赖来源",headers:[{level:2,title:"依赖查找的来源",slug:"依赖查找的来源",link:"#依赖查找的来源",children:[]},{level:2,title:"依赖注入的来源",slug:"依赖注入的来源",link:"#依赖注入的来源",children:[]},{level:2,title:"Spring 容器管理和游离对象",slug:"spring-容器管理和游离对象",link:"#spring-容器管理和游离对象",children:[]},{level:2,title:"Spring BeanDefinition 作为依赖来源",slug:"spring-beandefinition-作为依赖来源",link:"#spring-beandefinition-作为依赖来源",children:[]},{level:2,title:"单例对象作为依赖来源",slug:"单例对象作为依赖来源",link:"#单例对象作为依赖来源",children:[]},{level:2,title:"非 Spring 对象容器管理对象作为依赖来源",slug:"非-spring-对象容器管理对象作为依赖来源",link:"#非-spring-对象容器管理对象作为依赖来源",children:[]},{level:2,title:"外部化配置作为依赖来源",slug:"外部化配置作为依赖来源",link:"#外部化配置作为依赖来源",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a5f257/",pathLocale:"/",extraFields:'---\ntitle: Spring IoC 依赖来源\ndate: 2022-12-20 20:33:51\norder: 05\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - IOC\n  - 依赖注入\npermalink: /pages/a5f257/\n---\n\n# Spring IoC 依赖来源\n\n## 依赖查找的来源\n\n查找来源\n\n| 来源                  | 配置元数据                               |\n| --------------------- | ---------------------------------------- |\n| Spring BeanDefinition | `<bean id ="user" class="xxx.xxx.User">` |\n|                       | `@Bean public User user() {...}`         |\n|                       | `BeanDefinitionBuilder`                  |\n| 单例对象              | API 实现                                 |\n\nSpring 內建 BeanDefintion\n\n| Bean 名称                                                                       | Bean 实例                                 | 使用场景                                            |\n| ------------------------------------------------------------------------------- | ----------------------------------------- | --------------------------------------------------- |\n| org.springframework.context.annotation.internalConfigurationAnnotationProcessor | ConfigurationClassPostProcessor 对象      | 处理 Spring 配置类                                  |\n| org.springframework.context.annotation.internalAutowiredAnnotationProcessor     | AutowiredAnnotationBeanPostProcessor 对象 | 处理 @Autowired 以及 @Value 注解                    |\n| org.springframework.context.annotation.internalCommonAnnotationProcessor        | CommonAnnotationBeanPostProcessor 对象    | （条件激活）处理 JSR-250 注解，如 @PostConstruct 等 |\n| org.springframework.context.event.internalEventListenerProcessor                | EventListenerMethodProcessor 对象         | 处理标注 @EventListener 的 Spring 事件监听方法      |\n\nSpring 內建单例对象\n\n| Bean 名称                   | Bean 实例                        | 使用场景                |\n| --------------------------- | -------------------------------- | ----------------------- |\n| environment                 | Environment 对象                 | 外部化配置以及 Profiles |\n| systemProperties            | java.util.Properties 对象        | Java 系统属性           |\n| systemEnvironment           | java.util.Map 对象               | 操作系统环境变量        |\n| messageSource               | MessageSource 对象               | 国际化文案              |\n| lifecycleProcessor          | LifecycleProcessor 对象          | Lifecycle Bean 处理器   |\n| applicationEventMulticaster | ApplicationEventMulticaster 对象 | Spring 事件广播器       |\n\n## 依赖注入的来源\n\n| 来源                   | 配置元数据                               |\n| ---------------------- | ---------------------------------------- |\n| Spring BeanDefinition  | `<bean id ="user" class="xxx.xxx.User">` |\n|                        | `@Bean public User user() {...}`         |\n|                        | `BeanDefinitionBuilder`                  |\n| 单例对象               | API 实现                                 |\n| 非 Spring 容器管理对象 |                                          |\n\n## Spring 容器管理和游离对象\n\n| 来源                  | Spring Bean 对象 | 生命周期管理 | 配置元信息 | 使用场景           |\n| --------------------- | ---------------- | ------------ | ---------- | ------------------ |\n| Spring BeanDefinition | 是               | 是           | 有         | 依赖查找、依赖注入 |\n| 单体对象              | 是               | 否           | 无         | 依赖查找、依赖注入 |\n| Resolvable Dependency | 否               | 否           | 无         | 依赖注入           |\n\n## Spring BeanDefinition 作为依赖来源\n\n- 元数据：`BeanDefinition`\n- 注册：`BeanDefinitionRegistry#registerBeanDefinition`\n- 类型：延迟和非延迟\n- 顺序：Bean 生命周期顺序按照注册顺序\n\n## 单例对象作为依赖来源\n\n- 要素\n  - 来源：外部普通 Java 对象（不一定是 POJO）\n  - 注册：`SingletonBeanRegistry#registerSingleton`\n- 限制\n  - 无生命周期管理\n  - 无法实现延迟初始化 Bean\n\n## 非 Spring 对象容器管理对象作为依赖来源\n\n- 要素\n  - 注册：`ConfigurableListableBeanFactory#registerResolvableDependency`\n- 限制\n  - 无生命周期管理\n  - 无法实现延迟初始化 Bean\n  - 无法通过依赖查找\n\n## 外部化配置作为依赖来源\n\n- 要素\n  - 类型：非常规 Spring 对象依赖来源\n- 限制\n  - 无生命周期管理\n  - 无法实现延迟初始化 Bean\n  - 无法通过依赖查找\n\n## 问题\n\n注入和查找的依赖来源是否相同？\n\n否，依赖查找的来源仅限于 Spring `BeanDefinition` 以及单例对象，而依赖注入的来源还包括 Resolvable Dependency 以及 `@Value` 所标注的外部化配置\n\n单例对象能在 IoC 容器启动后注册吗？\n\n可以的，单例对象的注册与 `BeanDefinition` 不同，`BeanDefinition` 会被 `ConfigurableListableBeanFactory#freezeConfiguration()` 方法影响，从而冻结注册，单例对象则没有这个限制。\n\nSpring 依赖注入的来源有哪些？\n\n- Spring `BeanDefinition`\n- 单例对象\n- Resolvable Dependency\n- `@Value` 外部化配置\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring Bean 作用域",headers:[{level:2,title:"Spring Bean 作用域",slug:"spring-bean-作用域-1",link:"#spring-bean-作用域-1",children:[]},{level:2,title:'"singleton" Bean 作用域',slug:"singleton-bean-作用域",link:"#singleton-bean-作用域",children:[]},{level:2,title:'"prototype" Bean 作用域',slug:"prototype-bean-作用域",link:"#prototype-bean-作用域",children:[]},{level:2,title:'"request" Bean 作用域',slug:"request-bean-作用域",link:"#request-bean-作用域",children:[]},{level:2,title:'"session" Bean 作用域',slug:"session-bean-作用域",link:"#session-bean-作用域",children:[]},{level:2,title:'"application" Bean 作用域',slug:"application-bean-作用域",link:"#application-bean-作用域",children:[]},{level:2,title:"自定义 Bean 作用域",slug:"自定义-bean-作用域",link:"#自定义-bean-作用域",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/8289f5/",pathLocale:"/",extraFields:'---\ntitle: Spring Bean 作用域\ndate: 2022-12-21 11:42:00\norder: 06\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Bean\npermalink: /pages/8289f5/\n---\n\n# Spring Bean 作用域\n\n## Spring Bean 作用域\n\n| 来源        | 说明                                                       |\n| ----------- | ---------------------------------------------------------- |\n| singleton   | 默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例 |\n| prototype   | 原型作用域，每次依赖查找和依赖注入生成新 Bean 对象         |\n| request     | 将 Spring Bean 存储在 ServletRequest 上下文中              |\n| session     | 将 Spring Bean 存储在 HttpSession 中                       |\n| application | 将 Spring Bean 存储在 ServletContext 中                    |\n\n## "singleton" Bean 作用域\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20221221170833.png)\n\n## "prototype" Bean 作用域\n\nSpring 容器没有办法管理 prototype Bean 的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用 `BeanPostProcessor` 进行清扫工作。\n\n## "request" Bean 作用域\n\n- 配置\n  - XML - `<bean class="..." scope = “request" />`\n  - Java 注解 - `@RequestScope` 或 `@Scope(WebApplicationContext.SCOPE_REQUEST)`\n- 实现\n  - API - RequestScope\n\n## "session" Bean 作用域\n\n- 配置\n  - XML - `<bean class="..." scope = “session" />`\n  - Java 注解 - `@SessionScope` 或 `@Scope(WebApplicationContext.SCOPE_SESSION)`\n- 实现\n  - API - SessionScope\n\n## "application" Bean 作用域\n\n- 配置\n  - XML - `<bean class="..." scope = “application" />`\n  - Java 注解 - `@ApplicationScope` 或 `@Scope(WebApplicationContext.SCOPE_APPLICATION)`\n- 实现\n  - API - ServletContextScope\n\n## 自定义 Bean 作用域\n\n- 实现 Scope\n\n  - `org.springframework.beans.factory.config.Scope`\n\n- 注册 Scope\n\n  - API - `org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope`\n\n- 配置\n\n  ```xml\n  <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">\n    <property name="scopes">\n      <map>\n        <entry key="...">\n        </entry>\n      </map>\n    </property>\n  </bean>\n  ```\n\n## 问题\n\nSpring 內建的 Bean 作用域有几种？\n\nsingleton、prototype、request、session、application 以及 websocket\n\nsingleton Bean 是否在一个应用是唯一的？\n\n否。singleton bean 仅在当前 Spring IoC 容器（BeanFactory）中是单例对象。\n\napplication Bean 是否可以被其他方案替代？\n\n可以的，实际上，“application” Bean 与“singleton” Bean 没有本质区别\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring Bean 生命周期",headers:[{level:2,title:"Spring Bean 元信息配置阶段",slug:"spring-bean-元信息配置阶段",link:"#spring-bean-元信息配置阶段",children:[]},{level:2,title:"Spring Bean 元信息解析阶段",slug:"spring-bean-元信息解析阶段",link:"#spring-bean-元信息解析阶段",children:[]},{level:2,title:"Spring Bean 注册阶段",slug:"spring-bean-注册阶段",link:"#spring-bean-注册阶段",children:[]},{level:2,title:"Spring BeanDefinition 合并阶段",slug:"spring-beandefinition-合并阶段",link:"#spring-beandefinition-合并阶段",children:[]},{level:2,title:"Spring Bean Class 加载阶段",slug:"spring-bean-class-加载阶段",link:"#spring-bean-class-加载阶段",children:[]},{level:2,title:"Spring Bean 实例化前阶段",slug:"spring-bean-实例化前阶段",link:"#spring-bean-实例化前阶段",children:[]},{level:2,title:"Spring Bean 实例化阶段",slug:"spring-bean-实例化阶段",link:"#spring-bean-实例化阶段",children:[]},{level:2,title:"Spring Bean 实例化后阶段",slug:"spring-bean-实例化后阶段",link:"#spring-bean-实例化后阶段",children:[]},{level:2,title:"Spring Bean 属性赋值前阶段",slug:"spring-bean-属性赋值前阶段",link:"#spring-bean-属性赋值前阶段",children:[]},{level:2,title:"Spring Bean Aware 接口回调阶段",slug:"spring-bean-aware-接口回调阶段",link:"#spring-bean-aware-接口回调阶段",children:[]},{level:2,title:"Spring Bean 初始化前阶段",slug:"spring-bean-初始化前阶段",link:"#spring-bean-初始化前阶段",children:[]},{level:2,title:"Spring Bean 初始化阶段",slug:"spring-bean-初始化阶段",link:"#spring-bean-初始化阶段",children:[]},{level:2,title:"Spring Bean 初始化后阶段",slug:"spring-bean-初始化后阶段",link:"#spring-bean-初始化后阶段",children:[]},{level:2,title:"Spring Bean 初始化完成阶段",slug:"spring-bean-初始化完成阶段",link:"#spring-bean-初始化完成阶段",children:[]},{level:2,title:"Spring Bean 销毁前阶段",slug:"spring-bean-销毁前阶段",link:"#spring-bean-销毁前阶段",children:[]},{level:2,title:"Spring Bean 销毁阶段",slug:"spring-bean-销毁阶段",link:"#spring-bean-销毁阶段",children:[]},{level:2,title:"Spring Bean 垃圾收集",slug:"spring-bean-垃圾收集",link:"#spring-bean-垃圾收集",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/4ab176/",pathLocale:"/",extraFields:"---\ntitle: Spring Bean 生命周期\ndate: 2022-12-21 19:26:01\norder: 07\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Bean\npermalink: /pages/4ab176/\n---\n\n# Spring Bean 生命周期\n\n## Spring Bean 元信息配置阶段\n\nBeanDefinition 配置\n\n- 面向资源\n  - XML 配置\n  - Properties 资源配置\n- 面向注解\n- 面向 API\n\n## Spring Bean 元信息解析阶段\n\n- 面向资源 BeanDefinition 解析\n  - BeanDefinitionReader\n  - XML 解析器 - BeanDefinitionParser\n- 面向注解 BeanDefinition 解析\n  - AnnotatedBeanDefinitionReader\n\n## Spring Bean 注册阶段\n\nBeanDefinition 注册接口：BeanDefinitionRegistry\n\n## Spring BeanDefinition 合并阶段\n\nBeanDefinition 合并\n\n父子 BeanDefinition 合并\n\n- 当前 BeanFactory 查找\n- 层次性 BeanFactory 查找\n\n## Spring Bean Class 加载阶段\n\n- ClassLoader 类加载\n- Java Security 安全控制\n- ConfigurableBeanFactory 临时 ClassLoader\n\n## Spring Bean 实例化前阶段\n\n实例化方式\n\n- 传统实例化方式：实例化策略（InstantiationStrategy）\n- 构造器依赖注入\n\n## Spring Bean 实例化阶段\n\n非主流生命周期 - Bean 实例化前阶段\n\nInstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\n## Spring Bean 实例化后阶段\n\nBean 属性赋值（Populate）判断\n\nInstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\n## Spring Bean 属性赋值前阶段\n\n- Bean 属性值元信息\n  - PropertyValues\n- Bean 属性赋值前回调\n  - Spring 1.2 - 5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues\n  - Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties\n\n## Spring Bean Aware 接口回调阶段\n\nSpring Aware 接口：\n\n- BeanNameAware\n- BeanClassLoaderAware\n- BeanFactoryAware\n- EnvironmentAware\n- EmbeddedValueResolverAware\n- ResourceLoaderAware\n- ApplicationEventPublisherAware\n- MessageSourceAware\n- ApplicationContextAware\n\n## Spring Bean 初始化前阶段\n\n已完成：\n\n- Bean 实例化\n\n- Bean 属性赋值\n\n- Bean Aware 接口回调\n\n方法回调：\n\n- BeanPostProcessor#postProcessBeforeInitialization\n\n## Spring Bean 初始化阶段\n\nBean 初始化（Initialization）\n\n- @PostConstruct 标注方法\n- 实现 InitializingBean 接口的 afterPropertiesSet() 方法\n- 自定义初始化方法\n\n## Spring Bean 初始化后阶段\n\n方法回调：BeanPostProcessor#postProcessAfterInitialization\n\n## Spring Bean 初始化完成阶段\n\n方法回调：Spring 4.1 +：SmartInitializingSingleton#afterSingletonsInstantiated\n\n## Spring Bean 销毁前阶段\n\n方法回调：DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\n\n## Spring Bean 销毁阶段\n\nBean 销毁（Destroy）\n\n- @PreDestroy 标注方法\n- 实现 DisposableBean 接口的 destroy() 方法\n- 自定义销毁方法\n\n## Spring Bean 垃圾收集\n\nBean 垃圾回收（GC）\n\n- 关闭 Spring 容器（应用上下文）\n- 执行 GC\n- Spring Bean 覆盖的 finalize() 方法被回调\n\n## 问题\n\n**BeanPostProcessor 的使用场景有哪些**？\n\nBeanPostProcessor 提供 Spring Bean 初始化前和初始化后的生命周期回调，分别对应 postProcessBeforeInitialization 以及 postProcessAfterInitialization 方法，允许对关心的 Bean 进行扩展，甚至是替换。\n\n加分项：其中，ApplicationContext 相关的 Aware 回调也是基于 BeanPostProcessor 实现，即 ApplicationContextAwareProcessor。\n\n**BeanFactoryPostProcessor 与 BeanPostProcessor 的区别**？\n\nBeanFactoryPostProcessor 是 Spring BeanFactory（实际为 ConfigurableListableBeanFactory） 的后置处理器，用于扩展 BeanFactory，或通过 BeanFactory 进行依赖查找和依赖注入。\n\nBeanFactoryPostProcessor 必须有 Spring ApplicationContext 执行，BeanFactory 无法与其直接交互。\n\n而 BeanPostProcessor 则直接与 BeanFactory 关联，属于 N 对 1 的关系。\n\n**BeanFactory 是怎样处理 Bean 生命周期**？\n\nBeanFactory 的默认实现为 `DefaultListableBeanFactory`，其中 Bean生命周期与方法映射如下：\n\n- BeanDefinition 注册阶段 - registerBeanDefinition\n- BeanDefinition 合并阶段 - getMergedBeanDefinition\n- Bean 实例化前阶段 - resolveBeforeInstantiation\n- Bean 实例化阶段 - createBeanInstance\n- Bean 初始化后阶段 - populateBean\n- Bean 属性赋值前阶段 - populateBean\n- Bean 属性赋值阶段 - populateBean\n- Bean Aware 接口回调阶段 - initializeBean\n- Bean 初始化前阶段 - initializeBean\n- Bean 初始化阶段 - initializeBean\n- Bean 初始化后阶段 - initializeBean\n- Bean 初始化完成阶段 - preInstantiateSingletons\n- Bean 销毁前阶段 - destroyBean\n- Bean 销毁阶段 - destroyBean\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring 配置元数据",headers:[{level:2,title:"Spring 配置元信息",slug:"spring-配置元信息",link:"#spring-配置元信息",children:[]},{level:2,title:"Spring Bean 配置元信息",slug:"spring-bean-配置元信息",link:"#spring-bean-配置元信息",children:[]},{level:2,title:"Spring Bean 属性元信息",slug:"spring-bean-属性元信息",link:"#spring-bean-属性元信息",children:[]},{level:2,title:"Spring 容器配置元信息",slug:"spring-容器配置元信息",link:"#spring-容器配置元信息",children:[]},{level:2,title:"基于 XML 文件装载 Spring Bean 配置元信息",slug:"基于-xml-文件装载-spring-bean-配置元信息",link:"#基于-xml-文件装载-spring-bean-配置元信息",children:[]},{level:2,title:"基于 Properties 文件装载 Spring Bean 配置元信息",slug:"基于-properties-文件装载-spring-bean-配置元信息",link:"#基于-properties-文件装载-spring-bean-配置元信息",children:[]},{level:2,title:"基于 Java 注解装载 Spring Bean 配置元信息",slug:"基于-java-注解装载-spring-bean-配置元信息",link:"#基于-java-注解装载-spring-bean-配置元信息",children:[]},{level:2,title:"Spring Bean 配置元信息底层实现",slug:"spring-bean-配置元信息底层实现",link:"#spring-bean-配置元信息底层实现",children:[{level:3,title:"Spring XML 资源 BeanDefinition 解析与注册",slug:"spring-xml-资源-beandefinition-解析与注册",link:"#spring-xml-资源-beandefinition-解析与注册",children:[]},{level:3,title:"Spring Properties 资源 BeanDefinition 解析与注册",slug:"spring-properties-资源-beandefinition-解析与注册",link:"#spring-properties-资源-beandefinition-解析与注册",children:[]},{level:3,title:"Spring Java 注册 BeanDefinition 解析与注册",slug:"spring-java-注册-beandefinition-解析与注册",link:"#spring-java-注册-beandefinition-解析与注册",children:[]}]},{level:2,title:"基于 XML 文件装载 Spring IoC 容器配置元信息",slug:"基于-xml-文件装载-spring-ioc-容器配置元信息",link:"#基于-xml-文件装载-spring-ioc-容器配置元信息",children:[]},{level:2,title:"基于 Java 注解装载 Spring IoC 容器配置元信息",slug:"基于-java-注解装载-spring-ioc-容器配置元信息",link:"#基于-java-注解装载-spring-ioc-容器配置元信息",children:[]},{level:2,title:"基于 Extensible XML authoring 扩展 SpringXML 元素",slug:"基于-extensible-xml-authoring-扩展-springxml-元素",link:"#基于-extensible-xml-authoring-扩展-springxml-元素",children:[]},{level:2,title:"Extensible XML authoring 扩展原理",slug:"extensible-xml-authoring-扩展原理",link:"#extensible-xml-authoring-扩展原理",children:[{level:3,title:"触发时机",slug:"触发时机",link:"#触发时机",children:[]},{level:3,title:"核心流程",slug:"核心流程",link:"#核心流程",children:[]}]},{level:2,title:"基于 Properties 文件装载外部化配置",slug:"基于-properties-文件装载外部化配置",link:"#基于-properties-文件装载外部化配置",children:[]},{level:2,title:"基于 YAML 文件装载外部化配置",slug:"基于-yaml-文件装载外部化配置",link:"#基于-yaml-文件装载外部化配置",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/55f315/",pathLocale:"/",extraFields:'---\ntitle: Spring 配置元数据\ndate: 2022-12-21 19:49:48\norder: 08\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Bean\npermalink: /pages/55f315/\n---\n\n# Spring 配置元数据\n\n## Spring 配置元信息\n\n- Spring Bean 配置元信息 - BeanDefinition\n- Spring Bean 属性元信息 - PropertyValues\n- Spring 容器配置元信息\n- Spring 外部化配置元信息 - PropertySource\n- Spring Profile 元信息 - @Profile\n\n## Spring Bean 配置元信息\n\nBean 配置元信息 - BeanDefinition\n\n- GenericBeanDefinition：通用型 BeanDefinition\n- RootBeanDefinition：无 Parent 的 BeanDefinition 或者合并后 BeanDefinition\n- AnnotatedBeanDefinition：注解标注的 BeanDefinition\n\n## Spring Bean 属性元信息\n\n- Bean 属性元信息 - PropertyValues\n  - 可修改实现 - MutablePropertyValues\n  - 元素成员 - PropertyValue\n- Bean 属性上下文存储 - AttributeAccessor\n- Bean 元信息元素 - BeanMetadataElement\n\n## Spring 容器配置元信息\n\nSpring XML 配置元信息 - beans 元素相关\n\n| beans 元素属性              | 默认值       | 使用场景                                                                |\n| --------------------------- | ------------ | ----------------------------------------------------------------------- |\n| profile                     | null（留空） | Spring Profiles 配置值                                                  |\n| default-lazy-init           | default      | 当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为“false” |\n| default-merge               | default      | 当 outter beans “default-merge” 属性存在时，继承该值，否则为“false”     |\n| default-autowire            | default      | 当 outter beans “default-autowire” 属性存在时，继承该值，否则为“no”     |\n| default-autowire-candidates | null（留空） | 默认 Spring Beans 名称 pattern                                          |\n| default-init-method         | null（留空） | 默认 Spring Beans 自定义初始化方法                                      |\n| default-destroy-method      | null（留空） | 默认 Spring Beans 自定义销毁方法                                        |\n\nSpring XML 配置元信息 - 应用上下文相关\n\n| XML 元素                           | 使用场景                             |\n| ---------------------------------- | ------------------------------------ |\n| `<context:annotation-config />`    | 激活 Spring 注解驱动                 |\n| `<context:component-scan />`       | Spring @Component 以及自定义注解扫描 |\n| `<context:load-time-weaver />`     | 激活 Spring LoadTimeWeaver           |\n| `<context:mbean-export />`         | 暴露 Spring Beans 作为 JMX Beans     |\n| `<context:mbean-server />`         | 将当前平台作为 MBeanServer           |\n| `<context:property-placeholder />` | 加载外部化配置资源作为 Spring 属性配 |\n| `<context:property-override />`    | 利用外部化配置资源覆盖 Spring 属     |\n\n## 基于 XML 文件装载 Spring Bean 配置元信息\n\n底层实现 - XmlBeanDefinitionReader\n\n| XML 元素           | 使用场景                                      |\n| ------------------ | --------------------------------------------- |\n| `<beans:beans />`  | 单 XML 资源下的多个 Spring Beans 配置         |\n| `<beans:bean />`   | 单个 Spring Bean 定义（BeanDefinition）配置   |\n| `<beans:alias />`  | 为 Spring Bean 定义（BeanDefinition）映射别名 |\n| `<beans:import />` | 加载外部 Spring XML 配置资源                  |\n\n## 基于 Properties 文件装载 Spring Bean 配置元信息\n\n底层实现 - PropertiesBeanDefinitionReader\n\n| Properties 属性名 | 使用场景                        |\n| ----------------- | ------------------------------- |\n| `class`           | Bean 类全称限定名               |\n| `abstract`        | 是否为抽象的 BeanDefinition     |\n| `parent`          | 指定 parent BeanDefinition 名称 |\n| `lazy-init`       | 是否为延迟初始化                |\n| `ref`             | 引用其他 Bean 的名称            |\n| `scope`           | 设置 Bean 的 scope 属性         |\n| ${n}              | n 表示第 n+1 个构造器参数       |\n\n## 基于 Java 注解装载 Spring Bean 配置元信息\n\nSpring 模式注解\n\n| Spring 注解      | 场景说明           | 起始版本 |\n| ---------------- | ------------------ | -------- |\n| `@Repository`    | 数据仓储模式注解   | 2.0      |\n| `@Component`     | 通用组件模式注解   | 2.5      |\n| `@Service`       | 服务模式注解       | 2.5      |\n| `@Controller`    | Web 控制器模式注解 | 2.5      |\n| `@Configuration` | 配置类模式注解     | 3.0      |\n\nSpring Bean 定义注解\n\n| Spring 注解  | 场景说明                                   | 起始版本    |\n| ------------ | ------------------------------------------ | ----------- | --- |\n| `@Bean`      | 替换 XML 元素 `<bean>`                     | 3.0         |\n| `@DependsOn` | 替代 XML 属性 `<bean depends-on="..."/>`   | 3.0         |\n| `@Lazy`      | 替代 XML 属性 `<bean lazy-init="true       | falses" />` | 3.0 |\n| `@Primary`   | 替换 XML 元素 `<bean primary="true         | false" />`  | 3.0 |\n| `@Role`      | 替换 XML 元素 `<bean role="..." />`        | 3.1         |\n| `@Lookup`    | 替代 XML 属性 `<bean lookup-method="...">` | 4.1         |\n\nSpring Bean 依赖注入注解\n\n| Spring 注解  | 场景说明                            | 起始版本 |\n| ------------ | ----------------------------------- | -------- |\n| `@Autowired` | Bean 依赖注入，支持多种依赖查找方式 | 2.5      |\n| `@Qualifier` | 细粒度的 @Autowired 依赖查找        | 2.5      |\n\n| Java 注解 | 场景说明          | 起始版本 |\n| --------- | ----------------- | -------- |\n| @Resource | 类似于 @Autowired | 2.5      |\n| @Inject   | 类似于 @Autowired | 2.5      |\n\nSpring Bean 条件装配注解\n\n| Spring 注解  | 场景说明       | 起始版本 |\n| ------------ | -------------- | -------- |\n| @Profile     | 配置化条件装配 | 3.1      |\n| @Conditional | 编程条件装配   | 4.0      |\n\nSpring Bean 生命周期回调注解\n\n| Spring 注解    | 场景说明                                                      | 起始版本 |\n| -------------- | ------------------------------------------------------------- | -------- |\n| @PostConstruct | 替换 XML 元素 <bean init-method="..." /> 或 InitializingBean  | 2.5      |\n| @PreDestroy    | 替换 XML 元素 <bean destroy-method="..." /> 或 DisposableBean | 2.5      |\n\nSpring BeanDefinition 解析与注册\n\n| Spring 注解     | 场景说明                       | 起始版本 |\n| --------------- | ------------------------------ | -------- |\n| XML 资源        | XmlBeanDefinitionReader        | 1.0      |\n| Properties 资源 | PropertiesBeanDefinitionReader | 1.0      |\n| Java 注解       | AnnotatedBeanDefinitionReader  | 3.0      |\n\n## Spring Bean 配置元信息底层实现\n\n### Spring XML 资源 BeanDefinition 解析与注册\n\n核心 API - XmlBeanDefinitionReader\n\n- 资源 - Resource\n- 底层 - BeanDefinitionDocumentReader\n  - XML 解析 - Java DOM Level 3 API\n  - BeanDefinition 解析 - BeanDefinitionParserDelegate\n  - BeanDefinition 注册 - BeanDefinitionRegistry\n\n### Spring Properties 资源 BeanDefinition 解析与注册\n\n核心 API - PropertiesBeanDefinitionReader\n\n- 资源\n  - 字节流 - Resource\n  - 字符流 - EncodedResouce\n- 底层\n  - 存储 - java.util.Properties\n  - BeanDefinition 解析 - API 内部实现\n  - BeanDefinition 注册 - BeanDefinitionRegistry\n\n### Spring Java 注册 BeanDefinition 解析与注册\n\n核心 API - AnnotatedBeanDefinitionReader\n\n- 资源\n  - 类对象 - java.lang.Class\n- 底层\n  - 条件评估 - ConditionEvaluator\n  - Bean 范围解析 - ScopeMetadataResolver\n  - BeanDefinition 解析 - 内部 API 实现\n  - BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations\n  - BeanDefinition 注册 - BeanDefinitionRegistry\n\n## 基于 XML 文件装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器相关 XML 配置\n\n| 命名空间 | 所属模块       | Schema 资源 URL                                                   |\n| -------- | -------------- | ----------------------------------------------------------------- |\n| beans    | spring-beans   | https://www.springframework.org/schema/beans/spring-beans.xsd     |\n| context  | spring-context | https://www.springframework.org/schema/context/spring-context.xsd |\n| aop      | spring-aop     | https://www.springframework.org/schema/aop/spring-aop.xsd         |\n| tx       | spring-tx      | https://www.springframework.org/schema/tx/spring-tx.xsd           |\n| util     | spring-beans   | beans https://www.springframework.org/schema/util/spring-util.xsd |\n| tool     | spring-beans   | https://www.springframework.org/schema/tool/spring-tool.xsd       |\n\n## 基于 Java 注解装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器装配注解\n\n| Spring 注解     | 场景说明                                    | 起始版本 |\n| --------------- | ------------------------------------------- | -------- |\n| @ImportResource | 替换 XML 元素 `<import>`                    | 3.0      |\n| @Import         | 导入 Configuration Class                    | 3.0      |\n| @ComponentScan  | 扫描指定 package 下标注 Spring 模式注解的类 | 3.1      |\n\nSpring IoC 配属属性注解\n\n| Spring 注解      | 场景说明                         | 起始版本 |\n| ---------------- | -------------------------------- | -------- |\n| @PropertySource  | 配置属性抽象 PropertySource 注解 | 3.1      |\n| @PropertySources | @PropertySource 集合注解         | 4.0      |\n\n## 基于 Extensible XML authoring 扩展 SpringXML 元素\n\nSpring XML 扩展\n\n- 编写 XML Schema 文件：定义 XML 结构\n- 自定义 NamespaceHandler 实现：命名空间绑定\n- 自定义 BeanDefinitionParser 实现：XML 元素与 BeanDefinition 解析\n- 注册 XML 扩展：命名空间与 XML Schema 映射\n\n## Extensible XML authoring 扩展原理\n\n### 触发时机\n\n- AbstractApplicationContext#obtainFreshBeanFactory\n  - AbstractRefreshableApplicationContext#refreshBeanFactory\n    - AbstractXmlApplicationContext#loadBeanDefinitions\n      - ...\n        - XmlBeanDefinitionReader#doLoadBeanDefinitions\n          - ...\n            - BeanDefinitionParserDelegate#parseCustomElement\n\n### 核心流程\n\nBeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element, BeanDefinition)\n\n- 获取 namespace\n- 通过 namespace 解析 NamespaceHandler\n- 构造 ParserContext\n- 解析元素，获取 BeanDefinintion\n\n## 基于 Properties 文件装载外部化配置\n\n注解驱动\n\n- @org.springframework.context.annotation.PropertySource\n- @org.springframework.context.annotation.PropertySources\n\nAPI 编程\n\n- org.springframework.core.env.PropertySource\n- org.springframework.core.env.PropertySources\n\n## 基于 YAML 文件装载外部化配置\n\nAPI 编程\n\n- org.springframework.beans.factory.config.YamlProcessor\n  - org.springframework.beans.factory.config.YamlMapFactoryBean\n  - org.springframework.beans.factory.config.YamlPropertiesFactoryBean\n\n## 问题\n\n**Spring 內建 XML Schema 常见有哪些**？\n\n| 命名空间 | 所属模块       | Schema 资源 URL                                                   |\n| -------- | -------------- | ----------------------------------------------------------------- |\n| beans    | spring-beans   | https://www.springframework.org/schema/beans/spring-beans.xsd     |\n| context  | spring-context | https://www.springframework.org/schema/context/spring-context.xsd |\n| aop      | spring-aop     | https://www.springframework.org/schema/aop/spring-aop.xsd         |\n| tx       | spring-tx      | https://www.springframework.org/schema/tx/spring-tx.xsd           |\n| util     | spring-beans   | beans https://www.springframework.org/schema/util/spring-util.xsd |\n| tool     | spring-beans   | https://www.springframework.org/schema/tool/spring-tool.xsd       |\n\n**Spring 配置元信息具体有哪些**？\n\n- Bean 配置元信息：通过媒介（如 XML、Proeprties 等），解析 BeanDefinition\n- IoC 容器配置元信息：通过媒介（如 XML、Proeprties 等），控制 IoC 容器行为，比如注解驱动、AOP 等\n- 外部化配置：通过资源抽象（如 Proeprties、YAML 等），控制 PropertySource\n- Spring Profile：通过外部化配置，提供条件分支流程\n\n**Extensible XML authoring 的缺点**？\n\n- 高复杂度：开发人员需要熟悉 XML Schema，spring.handlers，spring.schemas 以及 Spring API\n- 嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素\n- XML 处理性能较差：Spring XML 基于 DOM Level 3 API 实现，该 API 便于理解，然而性能较差\n- XML 框架移植性差：很难适配高性能和便利性的 XML 框架，如 JAXB\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring 应用上下文生命周期",headers:[{level:2,title:"Spring 应用上下文启动准备阶段",slug:"spring-应用上下文启动准备阶段",link:"#spring-应用上下文启动准备阶段",children:[]},{level:2,title:"BeanFactory 创建阶段",slug:"beanfactory-创建阶段",link:"#beanfactory-创建阶段",children:[]},{level:2,title:"BeanFactory 准备阶段",slug:"beanfactory-准备阶段",link:"#beanfactory-准备阶段",children:[]},{level:2,title:"BeanFactory 后置处理阶段",slug:"beanfactory-后置处理阶段",link:"#beanfactory-后置处理阶段",children:[]},{level:2,title:"BeanFactory 注册 BeanPostProcessor 阶段",slug:"beanfactory-注册-beanpostprocessor-阶段",link:"#beanfactory-注册-beanpostprocessor-阶段",children:[]},{level:2,title:"初始化內建 Bean：MessageSource",slug:"初始化內建-bean-messagesource",link:"#初始化內建-bean-messagesource",children:[]},{level:2,title:"初始化內建 Bean：Spring 事件广播器",slug:"初始化內建-bean-spring-事件广播器",link:"#初始化內建-bean-spring-事件广播器",children:[]},{level:2,title:"Spring 应用上下文刷新阶段",slug:"spring-应用上下文刷新阶段",link:"#spring-应用上下文刷新阶段",children:[]},{level:2,title:"Spring 事件监听器注册阶段",slug:"spring-事件监听器注册阶段",link:"#spring-事件监听器注册阶段",children:[]},{level:2,title:"BeanFactory 初始化完成阶段",slug:"beanfactory-初始化完成阶段",link:"#beanfactory-初始化完成阶段",children:[]},{level:2,title:"Spring 应用上下刷新完成阶段",slug:"spring-应用上下刷新完成阶段",link:"#spring-应用上下刷新完成阶段",children:[]},{level:2,title:"Spring 应用上下文启动阶段",slug:"spring-应用上下文启动阶段",link:"#spring-应用上下文启动阶段",children:[]},{level:2,title:"Spring 应用上下文停止阶段",slug:"spring-应用上下文停止阶段",link:"#spring-应用上下文停止阶段",children:[]},{level:2,title:"Spring 应用上下文关闭阶段",slug:"spring-应用上下文关闭阶段",link:"#spring-应用上下文关闭阶段",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/ad472e/",pathLocale:"/",extraFields:"---\ntitle: Spring 应用上下文生命周期\ndate: 2022-12-23 09:58:09\norder: 09\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/ad472e/\n---\n\n# Spring 应用上下文生命周期\n\n## Spring 应用上下文启动准备阶段\n\nAbstractApplicationContext#prepareRefresh() 方法\n\n- 启动时间 - startupDate\n- 状态标识 - closed(false)、active(true)\n- 初始化 PropertySources - initPropertySources()\n- 检验 Environment 中必须属性\n- 初始化事件监听器集合\n- 初始化早期 Spring 事件集合\n\n## BeanFactory 创建阶段\n\nAbstractApplicationContext#obtainFreshBeanFactory() 方法\n\n- 刷新 Spring 应用上下文底层 BeanFactory - refreshBeanFactory()\n  - 销毁或关闭 BeanFactory，如果已存在的话\n  - 创建 BeanFactory - createBeanFactory()\n  - 设置 BeanFactory Id\n  - 设置“是否允许 BeanDefinition 重复定义” - customizeBeanFactory(DefaultListableBeanFactory)\n  - 设置“是否允许循环引用（依赖）” - customizeBeanFactory(DefaultListableBeanFactory)\n  - 加载 BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory) 方法\n  - 关联新建 BeanFactory 到 Spring 应用上下文\n- 返回 Spring 应用上下文底层 BeanFactory - getBeanFactory()\n\n## BeanFactory 准备阶段\n\nAbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法\n\n- 关联 ClassLoader\n- 设置 Bean 表达式处理器\n- 添加 PropertyEditorRegistrar 实现 - ResourceEditorRegistrar\n- 添加 Aware 回调接口 BeanPostProcessor 实现 - ApplicationContextAwareProcessor\n- 忽略 Aware 回调接口作为依赖注入接口\n- 注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext\n- 注册 ApplicationListenerDetector 对象\n- 注册 LoadTimeWeaverAwareProcessor 对象\n- 注册单例对象 - Environment、Java System Properties 以及 OS 环境变量\n\n## BeanFactory 后置处理阶段\n\n- AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法\n  - 由子类覆盖该方法\n- AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory 方法\n  - 调用 BeanFactoryPostProcessor 或 BeanDefinitionRegistry 后置处理方法\n  - 注册 LoadTimeWeaverAwareProcessor 对象\n\n## BeanFactory 注册 BeanPostProcessor 阶段\n\nAbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法\n\n- 注册 PriorityOrdered 类型的 BeanPostProcessor Beans\n- 注册 Ordered 类型的 BeanPostProcessor Beans\n- 注册普通 BeanPostProcessor Beans\n- 注册 MergedBeanDefinitionPostProcessor Beans\n- 注册 ApplicationListenerDetector 对象\n\n## 初始化內建 Bean：MessageSource\n\nAbstractApplicationContext#initMessageSource() 方法\n\n## 初始化內建 Bean：Spring 事件广播器\n\nAbstractApplicationContext#initApplicationEventMulticaster() 方法\n\n## Spring 应用上下文刷新阶段\n\nAbstractApplicationContext#onRefresh() 方法\n\n子类覆盖该方法\n\n- org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()\n- org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()\n- org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh()\n- org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh()\n- org.springframework.web.context.support.StaticWebApplicationContext#onRefresh()\n\n## Spring 事件监听器注册阶段\n\nAbstractApplicationContext#registerListeners() 方法\n\n- 添加当前应用上下文所关联的 ApplicationListener 对象（集合）\n- 添加 BeanFactory 所注册 ApplicationListener Beans\n- 广播早期 Spring 事件\n\n## BeanFactory 初始化完成阶段\n\nAbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法\n\n- BeanFactory 关联 ConversionService Bean，如果存在\n- 添加 StringValueResolver 对象\n- 依赖查找 LoadTimeWeaverAware Bean\n- BeanFactory 临时 ClassLoader 置为 null\n- BeanFactory 冻结配置\n- BeanFactory 初始化非延迟单例 Beans\n\n## Spring 应用上下刷新完成阶段\n\nAbstractApplicationContext#finishRefresh() 方法\n\n- 清除 ResourceLoader 缓存 - clearResourceCaches() @since 5.0\n- 初始化 LifecycleProcessor 对象 - initLifecycleProcessor()\n- 调用 LifecycleProcessor#onRefresh() 方法\n- 发布 Spring 应用上下文已刷新事件 - ContextRefreshedEvent\n- 向 MBeanServer 托管 Live Beans\n\n## Spring 应用上下文启动阶段\n\nAbstractApplicationContext#start() 方法\n\n- 启动 LifecycleProcessor\n  - 依赖查找 Lifecycle Beans\n  - 启动 Lifecycle Beans\n- 发布 Spring 应用上下文已启动事件 - ContextStartedEvent\n\n## Spring 应用上下文停止阶段\n\nAbstractApplicationContext#stop() 方法\n\n- 停止 LifecycleProcessor\n  - 依赖查找 Lifecycle Beans\n  - 停止 Lifecycle Beans\n- 发布 Spring 应用上下文已停止事件 - ContextStoppedEvent\n\n## Spring 应用上下文关闭阶段\n\nAbstractApplicationContext#close() 方法\n\n- 状态标识：active(false)、closed(true)\n- Live Beans JMX 撤销托管\n  - LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)\n- 发布 Spring 应用上下文已关闭事件 - ContextClosedEvent\n- 关闭 LifecycleProcessor\n  - 依赖查找 Lifecycle Beans\n  - 停止 Lifecycle Beans\n- 销毁 Spring Beans\n- 关闭 BeanFactory\n- 回调 onClose()\n- 注册 Shutdown Hook 线程（如果曾注册）\n\n## 问题\n\n**Spring 应用上下文生命周期有哪些阶段**？\n\n- 刷新阶段 - ConfigurableApplicationContext#refresh()\n- 启动阶段 - ConfigurableApplicationContext#start()\n- 停止阶段 - ConfigurableApplicationContext#stop()\n- 关闭阶段 - ConfigurableApplicationContext#close()\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring AOP",headers:[{level:2,title:"AOP 概念",slug:"aop-概念",link:"#aop-概念",children:[{level:3,title:"什么是 AOP",slug:"什么是-aop",link:"#什么是-aop",children:[]},{level:3,title:"术语",slug:"术语",link:"#术语",children:[]},{level:3,title:"advice 的类型",slug:"advice-的类型",link:"#advice-的类型",children:[]},{level:3,title:"关于 AOP Proxy",slug:"关于-aop-proxy",link:"#关于-aop-proxy",children:[]},{level:3,title:"彻底理解 aspect, join point, point cut, advice",slug:"彻底理解-aspect-join-point-point-cut-advice",link:"#彻底理解-aspect-join-point-point-cut-advice",children:[]}]},{level:2,title:"@AspectJ 支持",slug:"aspectj-支持",link:"#aspectj-支持",children:[{level:3,title:"使能 @AspectJ 支持",slug:"使能-aspectj-支持",link:"#使能-aspectj-支持",children:[]},{level:3,title:"定义 aspect(切面)",slug:"定义-aspect-切面",link:"#定义-aspect-切面",children:[]},{level:3,title:"声明 pointcut",slug:"声明-pointcut",link:"#声明-pointcut",children:[]},{level:3,title:"声明 advice",slug:"声明-advice",link:"#声明-advice",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/53aedb/",pathLocale:"/",extraFields:'---\ntitle: Spring AOP\ndate: 2020-02-26 23:47:47\norder: 10\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - AOP\npermalink: /pages/53aedb/\n---\n\n# Spring AOP\n\n## AOP 概念\n\n### 什么是 AOP\n\nAOP(Aspect-Oriented Programming，即 **面向切面编程**)与 OOP( Object-Oriented Programming，面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角。\n\n在 OOP 中，我们以类(class)作为我们的基本单元，而 AOP 中的基本单元是 **Aspect(切面)**\n\n### 术语\n\n#### Aspect(切面)\n\n`aspect` 由 `pointcount` 和 `advice` 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.\nAOP 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:\n\n1.  如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n2.  如何在 advice 中编写切面代码.\n\n**可以简单地认为, 使用 @Aspect 注解的类就是切面.**\n\n#### advice(增强)\n\n由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码.\n许多 AOP 框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截.\n例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.\n\n#### 连接点(join point)\n\n> a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.\n\n程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.\n`在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.`\n\n#### 切点(point cut)\n\n匹配 join point 的谓词(a predicate that matches join points).\nAdvice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行.\n`在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.`\n\n#### 关于 join point 和 point cut 的区别\n\n在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.\n`advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice`\n\n#### introduction\n\n为一个类型添加额外的方法或字段. Spring AOP 允许我们为 `目标对象` 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.\n\n#### 目标对象(Target)\n\n织入 advice 的目标对象. 目标对象也被称为 `advised object`.\n`因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)`\n`注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.`\n\n#### AOP proxy\n\n一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类.\n在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.\n\n#### 织入(Weaving)\n\n将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.\n根据不同的实现技术, AOP 织入有三种方式:\n\n- 编译器织入, 这要求有特殊的 Java 编译器.\n- 类装载期织入, 这需要有特殊的类装载器.\n- 动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.\n  Spring 采用动态代理织入, 而 AspectJ 采用编译器织入和类装载期织入.\n\n### advice 的类型\n\n- before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)\n- after return advice, 在一个 join point 正常返回后执行的 advice\n- after throwing advice, 当一个 join point 抛出异常后执行的 advice\n- after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.\n- around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.\n\n### 关于 AOP Proxy\n\nSpring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.\n`如果需要为一个类实现代理, 那么可以使用 CGLIB 代理.` 当一个业务逻辑对象没有实现接口时, 那么 Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.\n\n### 彻底理解 aspect, join point, point cut, advice\n\n看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的.\n下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.\n\n让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.\n首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 **爪哇的小县城里的百姓**, point cut 就相当于 **老王所做的指控, 即凶手是个男性, 身高约七尺五寸**, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: **抓过来审问**.\n为什么可以这样类比呢?\n\n- join point --\x3e 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP 中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.\n- point cut --\x3e 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据`凶手是个男性, 身高约七尺五寸`, 把符合条件的人抓起来. 在这里`凶手是个男性, 身高约七尺五寸` 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.\n- advice --\x3e 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, `抓过来审问` 这个动作就是对作用于那些满足 `男性, 身高约七尺五寸` 的`爪哇的小县城里的百姓`.\n- aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: **"根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问"** 这一整个动作可以被认为是一个 aspect.\n\n或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 `定语`, `被动句` 之类的概念, 那么可以做一个不严谨的类比, 即 `joinpoint` 可以认为是一个 `宾语`, 而 `pointcut` 则可以类比为修饰 `joinpoint` 的定语, 那么整个 `aspect` 就可以描述为: `满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.`\n\n## @AspectJ 支持\n\n**`@AspectJ`** 是一种使用 Java 注解来实现 AOP 的编码风格。\n\n@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持 @AspectJ 的 AOP 风格.\n\n### 使能 @AspectJ 支持\n\n@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中.\n\n#### 使用 Java Configuration 方式使能@AspectJ\n\n```java\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig {\n}\n```\n\n#### 使用 XML 方式使能@AspectJ\n\n```\n<aop:aspectj-autoproxy/>\n```\n\n### 定义 aspect(切面)\n\n当使用注解 **@Aspect** 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如:\n\n```java\n@Component\n@Aspect\npublic class MyTest {\n}\n```\n\n`注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解.`\n`注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.`\n\n### 声明 pointcut\n\n一个 pointcut 的声明由两部分组成:\n\n- 一个方法签名, 包括方法名和相关参数\n- 一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).\n\n在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即:\n\n```java\n@Pointcut("execution(* com.xys.service.UserService.*(..))") // 切点表达式\nprivate void dataAccessOperation() {} // 切点前面\n```\n\n`这个方法必须无返回值.`\n`这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定.`\n上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 **com.xys.service.UserService** 下的所有方法的执行.\n\n#### 切点标志符(designator)\n\nAspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 "execution(\\* greetTo(..))" 的切点表达式, \\*\\*execution** 就是 标志符, 而圆括号里的 \\*\\*\\***greetTo(..) 就是操作参数\n\n##### execution\n\n匹配 join point 的执行, 例如 "execution(\\* hello(..))" 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.\n\n##### within\n\n匹配特定包下的所有 join point, 例如 `within(com.xys.*)` 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而`within(com.xys.service.*Service)` 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.\n\n##### this 与 target\n\nthis 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).\n\n##### bean\n\n匹配 bean 名字为指定值的 bean 下的所有方法, 例如:\n\n```\nbean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法\nbean(myService) // 匹配名字为 myService 的 bean 下的所有方法\n```\n\n##### args\n\n匹配参数满足要求的的方法.\n例如:\n\n```java\n@Pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@Before(value = "pointcut2()  &&  args(name)")\npublic void doSomething(String name) {\n    logger.info("---page: {}---", name);\n}\n```\n\n```java\n@Service\npublic class NormalService {\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    public void someMethod() {\n        logger.info("---NormalService: someMethod invoked---");\n    }\n\n    public String test(String name) {\n        logger.info("---NormalService: test invoked---");\n        return "服务一切正常";\n    }\n}\n```\n\n当 NormalService.test 执行时, 则 advice `doSomething` 就会执行, test 方法的参数 name 就会传递到 `doSomething` 中.\n\n常用例子:\n\n```java\n// 匹配只有一个参数 name 的方法\n@Before(value = "aspectMethod()  &&  args(name)")\npublic void doSomething(String name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@Before(value = "aspectMethod()  &&  args(name, ..)")\npublic void doSomething(String name) {\n}\n\n// 匹配第二个参数为 name 的方法\nBefore(value = "aspectMethod()  &&  args(*, name, ..)")\npublic void doSomething(String name) {\n}\n```\n\n##### @annotation\n\n匹配由指定注解所标注的方法, 例如:\n\n```java\n@Pointcut("@annotation(com.xys.demo1.AuthChecker)")\npublic void pointcut() {\n}\n```\n\n则匹配由注解 `AuthChecker` 所标注的方法.\n\n#### 常见的切点表达式\n\n##### 匹配方法签名\n\n```\n// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* UserService.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(String name, ..))\n```\n\n##### 匹配类型签名\n\n```\n// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(UserService)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(UserDao+)\n```\n\n##### 匹配 Bean 名字\n\n```\n// 匹配以指定名字结尾的 Bean 中的所有方法\nbean(*Service)\n```\n\n##### 切点表达式组合\n\n```\n// 匹配以 Service 或 ServiceImpl 结尾的 bean\nbean(*Service || *ServiceImpl)\n\n// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*Service) && within(com.xys.service.*)\n```\n\n### 声明 advice\n\nadvice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. `pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式`.\n下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.\n\n#### Before advice\n\n```java\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@Component\n@Aspect\npublic class BeforeAspectTest {\n    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.\n    @Pointcut("execution(* com.xys.service.UserService.*(..))")\n    public void dataAccessOperation() {\n    }\n}\n```\n\n```java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Before("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public void doBeforeAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n```\n\n这里, **@Before** 引用了一个 pointcut, 即 "com.xys.aspect.PointcutDefine.dataAccessOperation()" 是一个 pointcut 的名字.\n如果我们在 advice 在内置 pointcut, 则可以:\n\n```java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 将 pointcut 和 advice 同时定义\n    @Before("within(com.xys.service..*)")\n    public void doAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****doAccessCheck, Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n```\n\n#### around advice\n\naround advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.\n\n```java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Around("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 开始\n        Object retVal = pjp.proceed();\n        stopWatch.stop();\n        // 结束\n        System.out.println("invoke method: " + pjp.getSignature().getName() + ", elapsed time: " + stopWatch.getTotalTimeMillis());\n        return retVal;\n    }\n}\n```\n\naround advice 和前面的 before advice 差不多, 只是我们把注解 **@Before** 改为了 **@Around** 了.\n\n## 参考资料\n\n- [《 Spring 实战（第 4 版）》](https://item.jd.com/11899370.html)'},{title:"Spring 资源管理",headers:[{level:2,title:"Resource 接口",slug:"resource-接口",link:"#resource-接口",children:[]},{level:2,title:"内置的 Resource 实现",slug:"内置的-resource-实现",link:"#内置的-resource-实现",children:[]},{level:2,title:"ResourceLoader 接口",slug:"resourceloader-接口",link:"#resourceloader-接口",children:[]},{level:2,title:"ResourcePatternResolver 接口",slug:"resourcepatternresolver-接口",link:"#resourcepatternresolver-接口",children:[]},{level:2,title:"ResourceLoaderAware 接口",slug:"resourceloaderaware-接口",link:"#resourceloaderaware-接口",children:[]},{level:2,title:"资源依赖",slug:"资源依赖",link:"#资源依赖",children:[]},{level:2,title:"应用上下文和资源路径",slug:"应用上下文和资源路径",link:"#应用上下文和资源路径",children:[{level:3,title:"构造应用上下文",slug:"构造应用上下文",link:"#构造应用上下文",children:[]},{level:3,title:"使用通配符构造应用上下文",slug:"使用通配符构造应用上下文",link:"#使用通配符构造应用上下文",children:[]}]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a1549f/",pathLocale:"/",extraFields:'---\ntitle: Spring 资源管理\ndate: 2019-09-04 19:46:41\norder: 20\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Resource\npermalink: /pages/a1549f/\n---\n\n# Spring 资源管理\n\n> Version 6.0.3\n\n## Resource 接口\n\n相对标准 URL 访问机制，Spring 的 `org.springframework.core.io.Resource` 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。\n\n```java\npublic interface Resource extends InputStreamSource {\n\n    boolean exists();\n\n    boolean isReadable();\n\n    boolean isOpen();\n\n    boolean isFile();\n\n    URL getURL() throws IOException;\n\n    URI getURI() throws IOException;\n\n    File getFile() throws IOException;\n\n    ReadableByteChannel readableChannel() throws IOException;\n\n    long contentLength() throws IOException;\n\n    long lastModified() throws IOException;\n\n    Resource createRelative(String relativePath) throws IOException;\n\n    String getFilename();\n\n    String getDescription();\n}\n```\n\n正如 `Resource` 接口的定义所示，它扩展了 `InputStreamSource` 接口。`Resource` 最核心的方法如下：\n\n- `getInputStream()` - 定位并且打开当前资源，返回当前资源的 `InputStream`。每次调用都会返回一个新的 `InputStream`。调用者需要负责关闭流。\n- `exists()` - 判断当前资源是否真的存在。\n- `isOpen()` - 判断当前资源是否是一个已打开的 `InputStream`。如果为 true，则 `InputStream` 不能被多次读取，必须只读取一次然后关闭以避免资源泄漏。对所有常用资源实现返回 false，`InputStreamResource` 除外。\n- `getDescription()` - 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 URL。\n\n常见 Spring 资源接口：\n\n| 类型       | 接口                                                  |\n| ---------- | ----------------------------------------------------- |\n| 输入流     | `org.springframework.core.io.InputStreamSource`       |\n| 只读资源   | `org.springframework.core.io.Resource`                |\n| 可写资源   | `org.springframework.core.io.WritableResource`        |\n| 编码资源   | `org.springframework.core.io.support.EncodedResource` |\n| 上下文资源 | `org.springframework.core.io.ContextResource`         |\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20221223155859.png)\n\n## 内置的 Resource 实现\n\nSpring 包括几个内置的 Resource 实现：\n\n| 资源来源                                                                                                                                                   | 前缀                         | 说明                                                                                                                                                                                                                                                                                                                                                      |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [`UrlResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-urlresource)                       | `file:`、`https:`、`ftp:` 等 | `UrlResource` 封装了一个 `java.net.URL` 对象，**用于访问可通过 URL 访问的任何对象**，例如文件、HTTPS 目标、FTP 目标等。所有 URL 都可以通过标准化的字符串形式表示，因此可以使用适当的标准化前缀来指示一种 URL 类型与另一种 URL 类型的区别。 这包括：`file`：用于访问文件系统路径；`https`：用于通过 HTTPS 协议访问资源；`ftp`：用于通过 FTP 访问资源等等。 |\n| [`ClassPathResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-classpathresource)           | `classpath:`                 | `ClassPathResource` **从类路径上加载资源**。它使用线程上下文加载器、给定的类加载器或指定的 class 类型中的任意一个来加载资源。                                                                                                                                                                                                                             |\n| [`FileSystemResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-filesystemresource)         | `file:`                      | `FileSystemResource` **是 `java.io.File` 的资源实现**。它还支持 `java.nio.file.Path` ，应用 Spring 的标准对字符串路径进行转换。`FileSystemResource` 支持解析为文件和 URL。                                                                                                                                                                                |\n| [`PathResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-pathresource)                     | 无                           | `PathResource` 是 `java.nio.file.Path` 的资源实现。                                                                                                                                                                                                                                                                                                       |\n| [`ServletContextResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-servletcontextresource) | 无                           | `ServletContextResource` **是 `ServletContext` 的资源实现**。它表示相应 Web 应用程序根目录中的相对路径。                                                                                                                                                                                                                                                  |\n| [`InputStreamResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-inputstreamresource)       | 无                           | `InputStreamResource` **是指定 `InputStream` 的资源实现**。注意：如果该 `InputStream` 已被打开，则不可以多次读取该流。                                                                                                                                                                                                                                    |\n| [`ByteArrayResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-bytearrayresource)           | 无                           | `ByteArrayResource` 是指定的二进制数组的资源实现。它会为给定的字节数组创建一个 `ByteArrayInputStream`。                                                                                                                                                                                                                                                   |\n\n## ResourceLoader 接口\n\n`ResourceLoader` 接口用于加载 `Resource` 对象。其定义如下：\n\n```java\npublic interface ResourceLoader {\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n```\n\nSpring 中主要的 ResourceLoader 实现：\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20221223164745.png)\n\nSpring 中，所有的 `ApplicationContext` 都实现了 `ResourceLoader` 接口。因此，所有 `ApplicationContext` 都可以通过 `getResource()` 方法获取 `Resource` 实例。\n\n【示例】\n\n```java\n// 如果没有指定资源前缀，Spring 会尝试返回合适的资源\nResource template = ctx.getResource("some/resource/path/myTemplate.txt");\n// 如果指定 classpath: 前缀，Spring 会强制使用 ClassPathResource\nResource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");\n// 如果指定 file:、http 等 URL 前缀，Spring 会强制使用 UrlResource\nResource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");\nResource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");\n```\n\n下表列举了 Spring 根据各种位置路径加载资源的策略：\n\n| 前缀         | 样例                             | 说明                                 |\n| ------------ | -------------------------------- | :----------------------------------- |\n| `classpath:` | `classpath:com/myapp/config.xml` | 从类路径加载                         |\n| `file:`      | `file:///data/config.xml`        | 以 URL 形式从文件系统加载            |\n| `http:`      | `http://myserver/logo.png`       | 以 URL 形式加载                      |\n| 无           | `/data/config.xml`               | 由底层的 ApplicationContext 实现决定 |\n\n## ResourcePatternResolver 接口\n\n`ResourcePatternResolver` 接口是 `ResourceLoader` 接口的扩展，它的作用是定义策略，根据位置模式解析 `Resource` 对象。\n\n```java\npublic interface ResourcePatternResolver extends ResourceLoader {\n\n    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n```\n\n`PathMatchingResourcePatternResolver` 是一个独立的实现，可以在 `ApplicationContext` 之外使用，也可以被 `ResourceArrayPropertyEditor` 用于填充 `Resource[]` bean 属性。`PathMatchingResourcePatternResolver` 能够将指定的资源位置路径解析为一个或多个匹配的 `Resource` 对象。\n\n> 注意：任何标准 `ApplicationContext` 中的默认 `ResourceLoader` 实际上是 `PathMatchingResourcePatternResolver` 的一个实例，它实现了 `ResourcePatternResolver` 接口。\n\n## ResourceLoaderAware 接口\n\n`ResourceLoaderAware` 接口是一个特殊的回调接口，用来标记提供 `ResourceLoader` 引用的对象。`ResourceLoaderAware` 接口定义如下：\n\n```java\npublic interface ResourceLoaderAware {\n    void setResourceLoader(ResourceLoader resourceLoader);\n}\n```\n\n当一个类实现 `ResourceLoaderAware` 并部署到应用程序上下文中（作为 Spring 管理的 bean）时，它会被应用程序上下文识别为 `ResourceLoaderAware`，然后，应用程序上下文会调用 `setResourceLoader(ResourceLoader)`，将自身作为参数提供（请记住，Spring 中的所有应用程序上下文都实现 `ResourceLoader` 接口）。\n\n由于 `ApplicationContext` 是一个 `ResourceLoader`，该 bean 还可以实现 `ApplicationContextAware` 接口并直接使用提供的应用程序上下文来加载资源。 但是，一般来说，如果您只需要这些，最好使用专门的 `ResourceLoader` 接口。 该代码将仅耦合到资源加载接口（可以被视为实用程序接口），而不耦合到整个 Spring `ApplicationContext` 接口。\n\n在应用程序中，还可以使用 `ResourceLoader` 的自动装配作为实现 `ResourceLoaderAware` 接口的替代方法。传统的构造函数和 `byType` 自动装配模式能够分别为构造函数参数或 setter 方法参数提供 `ResourceLoader`。 为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注解的自动装配功能。 在这种情况下，`ResourceLoader` 会自动连接到需要 `ResourceLoader` 类型的字段、构造函数参数或方法参数中，只要相关字段、构造函数或方法带有 `@Autowired` 注解即可。\n\n## 资源依赖\n\n如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 可以使用 `ResourceLoader` 或 `ResourcePatternResolver` 接口来加载资源。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，完全消除 `ResourceLoader` 接口（或 `ResourcePatternResolver` 接口）的使用，让 bean 公开它需要的 `Resource` 属性，并期望将它们注入其中是有意义的。\n\n使注入这些属性变得简单的原因是所有应用程序上下文都注册并使用一个特殊的 JavaBeans `PropertyEditor`，它可以将 `String` 路径转换为 `Resource` 对象。 例如，下面的 MyBean 类有一个 `Resource` 类型的模板属性。\n\n【示例】\n\n```xml\n<bean id="myBean" class="example.MyBean">\n    <property name="template" value="some/resource/path/myTemplate.txt"/>\n</bean>\n```\n\n请注意，配置中引用的模板资源路径没有前缀，因为应用程序上下文本身将用作 `ResourceLoader`，资源本身将根据需要通过 `ClassPathResource`，`FileSystemResource` 或 ServletContextResource 加载，具体取决于上下文的确切类型。\n\n如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制使用 `ClassPathResource` 和 `UrlResource`（后者用于访问文件系统文件）。\n\n```xml\n<property name="template" value="classpath:some/resource/path/myTemplate.txt">\n<property name="template" value="file:///some/resource/path/myTemplate.txt"/>\n```\n\n可以通过 `@Value` 注解加载资源文件 `myTemplate.txt`，示例如下：\n\n```java\n@Component\npublic class MyBean {\n\n    private final Resource template;\n\n    public MyBean(@Value("${template.path}") Resource template) {\n        this.template = template;\n    }\n\n    // ...\n}\n```\n\nSpring 的 `PropertyEditor` 会根据资源文件的路径字符串，加载 `Resource` 对象，并将其注入到 MyBean 的构造方法。\n\n如果想要加载多个资源文件，可以使用 `classpath*:` 前缀，例如：`classpath*:/config/templates/*.txt`。\n\n```java\n@Component\npublic class MyBean {\n\n    private final Resource[] templates;\n\n    public MyBean(@Value("${templates.path}") Resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}\n```\n\n## 应用上下文和资源路径\n\n### 构造应用上下文\n\n应用上下文构造函数（针对特定的应用上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 XML 文件。\n\n【示例】\n\n```java\nApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");\nApplicationContext ctx = new ClassPathXmlApplicationContext(\n                new String[] {"services.xml", "daos.xml"}, MessengerService.class);\n```\n\n### 使用通配符构造应用上下文\n\nApplicationContext 构造器的中的资源路径可以是单一的路径（即一对一地映射到目标资源）；也可以是通配符形式——可包含 classpath\\*：也可以是前缀或 ant 风格的正则表达式（使用 spring 的 PathMatcher 来匹配）。\n\n示例：\n\n```java\nApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");\n```\n\n使用 `classpath*` 表示类路径下所有匹配文件名称的资源都会被获取(本质上就是调用了 ClassLoader.getResources(…) 方法），接着将获取到的资源组装成最终的应用上下文。\n\n在位置路径的其余部分，`classpath*:` 前缀可以与 PathMatcher 结合使用，如：`classpath*:META-INF/*-beans.xml`。\n\n## 问题\n\nSpring 配置资源中有哪些常见类型？\n\n- XML 资源\n- Properties 资源\n- YAML 资源\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring 校验",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"校验示例",slug:"校验示例",link:"#校验示例",children:[]},{level:3,title:"统一异常处理",slug:"统一异常处理",link:"#统一异常处理",children:[]}]},{level:2,title:"进阶使用",slug:"进阶使用",link:"#进阶使用",children:[{level:3,title:"分组校验",slug:"分组校验",link:"#分组校验",children:[]},{level:3,title:"嵌套校验",slug:"嵌套校验",link:"#嵌套校验",children:[]},{level:3,title:"自定义校验注解",slug:"自定义校验注解",link:"#自定义校验注解",children:[]},{level:3,title:"自定义校验",slug:"自定义校验",link:"#自定义校验",children:[]},{level:3,title:"快速失败(Fail Fast)",slug:"快速失败-fail-fast",link:"#快速失败-fail-fast",children:[]}]},{level:2,title:"Spring 校验原理",slug:"spring-校验原理",link:"#spring-校验原理",children:[{level:3,title:"Spring 校验使用场景",slug:"spring-校验使用场景",link:"#spring-校验使用场景",children:[]},{level:3,title:"Validator 接口设计",slug:"validator-接口设计",link:"#validator-接口设计",children:[]},{level:3,title:"Errors 接口设计",slug:"errors-接口设计",link:"#errors-接口设计",children:[]},{level:3,title:"Errors 文案来源",slug:"errors-文案来源",link:"#errors-文案来源",children:[]},{level:3,title:"spring web 校验原理",slug:"spring-web-校验原理",link:"#spring-web-校验原理",children:[]}]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/fe6aad/",pathLocale:"/",extraFields:'---\ntitle: Spring 校验\ndate: 2022-12-22 17:42:28\norder: 21\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/fe6aad/\n---\n\n# Spring 校验\n\nJava API 规范(`JSR303`)定义了`Bean`校验的标准`validation-api`，但没有提供实现。`hibernate validation`是对这个规范的实现，并增加了校验注解如`@Email`、`@Length`等。`Spring Validation`是对`hibernate validation`的二次封装，用于支持`spring mvc`参数自动校验。\n\n## 快速入门\n\n### 引入依赖\n\n如果 spring-boot 版本小于 2.3.x，spring-boot-starter-web 会自动传入 hibernate-validator 依赖。如果 spring-boot 版本大于 2.3.x，则需要手动引入依赖：\n\n```xml\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator-parent</artifactId>\n  <version>6.2.5.Final</version>\n</dependency>\n```\n\n对于 web 服务来说，为防止非法参数对业务造成影响，在 Controller 层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：\n\n- POST、PUT 请求，使用 requestBody 传递参数；\n- GET 请求，使用 requestParam/PathVariable 传递参数。\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n### 校验示例\n\n（1）在实体上标记校验注解\n\n```kotlin\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    @NotNull\n    private Long id;\n\n    @NotBlank\n    @Size(min = 2, max = 10)\n    private String name;\n\n    @Min(value = 1)\n    @Max(value = 100)\n    private Integer age;\n\n}\n```\n\n（2）在方法参数上声明校验注解\n\n```less\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate1")\npublic class ValidatorController {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "save")\n    public DataResult<Boolean> save(@Valid @RequestBody User entity) {\n        log.info("保存一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestParam} 参数校验\n     */\n    @GetMapping(value = "queryByName")\n    public DataResult<User> queryByName(\n        @RequestParam("username")\n        @NotBlank\n        @Size(min = 2, max = 10)\n        String name\n    ) {\n        User user = new User(1L, name, 18);\n        return DataResult.ok(user);\n    }\n\n    /**\n     * {@link PathVariable} 参数校验\n     */\n    @GetMapping(value = "detail/{id}")\n    public DataResult<User> detail(@PathVariable("id") @Min(1L) Long id) {\n        User user = new User(id, "李四", 18);\n        return DataResult.ok(user);\n    }\n\n}\n```\n\n（3）如果请求参数不满足校验规则，则会抛出 `ConstraintViolationException` 或 `MethodArgumentNotValidException` 异常。\n\n### 统一异常处理\n\n在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。\n\n```java\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.OK)\n    @ExceptionHandler(Throwable.class)\n    public Result handleException(Throwable e) {\n        log.error("未知异常", e);\n        return new Result(ResultStatus.HTTP_SERVER_ERROR.getCode(), e.getMessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e ConstraintViolationException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ ConstraintViolationException.class })\n    public Result handleConstraintViolationException(final ConstraintViolationException e) {\n        log.error("ConstraintViolationException", e);\n        List<String> errors = new ArrayList<>();\n        for (ConstraintViolation<?> violation : e.getConstraintViolations()) {\n            Path path = violation.getPropertyPath();\n            List<String> pathArr = StrUtil.split(path.toString(), \',\');\n            errors.add(pathArr.get(0) + " " + violation.getMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e MethodArgumentNotValidException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ MethodArgumentNotValidException.class })\n    private Result handleMethodArgumentNotValidException(final MethodArgumentNotValidException e) {\n        log.error("MethodArgumentNotValidException", e);\n        List<String> errors = new ArrayList<>();\n        for (ObjectError error : e.getBindingResult().getAllErrors()) {\n            errors.add(((FieldError) error).getField() + " " + error.getDefaultMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n}\n```\n\n## 进阶使用\n\n### 分组校验\n\n在实际项目中，可能多个方法需要使用同一个 DTO 类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在 DTO 类的字段上加约束注解无法解决这个问题。因此，spring-validation 支持了分组校验的功能，专门用来解决这类问题。\n\n（1）定义分组\n\n```java\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AddCheck { }\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface EditCheck { }\n```\n\n（2）在实体上标记校验注解\n\n```less\n@Data\npublic class User2 {\n\n    @NotNull(groups = EditCheck.class)\n    private Long id;\n\n    @NotNull(groups = { AddCheck.class, EditCheck.class })\n    @Size(min = 2, max = 10, groups = { AddCheck.class, EditCheck.class })\n    private String name;\n\n    @IsMobile(message = "不是有效手机号", groups = { AddCheck.class, EditCheck.class })\n    private String mobile;\n\n}\n```\n\n（3）在方法上根据不同场景进行校验分组\n\n```less\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate2")\npublic class ValidatorController2 {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "add")\n    public DataResult<Boolean> add(@Validated(AddCheck.class) @RequestBody User2 entity) {\n        log.info("添加一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "edit")\n    public DataResult<Boolean> edit(@Validated(EditCheck.class) @RequestBody User2 entity) {\n        log.info("编辑一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n}\n```\n\n### 嵌套校验\n\n前面的示例中，DTO 类里面的字段都是基本数据类型和 String 类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。\npost\n比如，上面保存 User 信息的时候同时还带有 Job 信息。需要注意的是，此时 DTO 类的对应字段必须标记@Valid 注解。\n\n```less\n@Data\npublic class UserDTO {\n\n    @Min(value = 10000000000000000L, groups = Update.class)\n    private Long userId;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n    private String userName;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String account;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String password;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Valid\n    private Job job;\n\n    @Data\n    public static class Job {\n\n        @Min(value = 1, groups = Update.class)\n        private Long jobId;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String jobName;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface Save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface Update {\n    }\n}\n复制代码\n```\n\n嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如`List<Job>`字段会对这个 list 里面的每一个 Job 对象都进行校验\n\n### 自定义校验注解\n\n（1）自定义校验注解 `@IsMobile`\n\n```less\n@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })\n@Retention(RUNTIME)\n@Constraint(validatedBy = MobileValidator.class)\npublic @interface IsMobile {\n\n    String message();\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n```\n\n（2）实现 `ConstraintValidator` 接口，编写 `@IsMobile` 校验注解的解析器\n\n```java\nimport cn.hutool.core.util.StrUtil;\nimport io.github.dunwu.spring.core.validation.annotation.IsMobile;\nimport io.github.dunwu.tool.util.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\npublic class MobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    @Override\n    public void initialize(IsMobile isMobile) { }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if (StrUtil.isBlank(s)) {\n            return false;\n        } else {\n            return ValidatorUtil.isMobile(s);\n        }\n    }\n\n}\n```\n\n### 自定义校验\n\n可以通过实现 `org.springframework.validation.Validator` 接口来自定义校验。\n\n有以下要点\n\n- 实现 `supports` 方法\n- 实现 `validate` 方法\n  - 通过 `Errors` 对象收集错误\n    - `ObjectError`：对象（Bean）错误：\n    - `FieldError`：对象（Bean）属性（Property）错误\n  - 通过 `ObjectError` 和 `FieldError` 关联 `MessageSource` 实现获取最终的错误文案\n\n```less\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.Valid;\nimport io.github.dunwu.spring.core.validation.config.CustomValidatorConfig;\nimport io.github.dunwu.spring.core.validation.entity.Person;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Component\npublic class CustomValidator implements Validator {\n\n    private final CustomValidatorConfig validatorConfig;\n\n    public CustomValidator(CustomValidatorConfig validatorConfig) {\n        this.validatorConfig = validatorConfig;\n    }\n\n    /**\n     * 本校验器只针对 Person 对象进行校验\n     */\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Person.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, "name", "name.empty");\n\n        List<Field> fields = getFields(target.getClass());\n        for (Field field : fields) {\n            Annotation[] annotations = field.getAnnotations();\n            for (Annotation annotation : annotations) {\n                if (annotation.annotationType().getAnnotation(Valid.class) != null) {\n                    try {\n                        ValidatorRule validatorRule = validatorConfig.findRule(annotation);\n                        if (validatorRule != null) {\n                            validatorRule.valid(annotation, target, field, errors);\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private List<Field> getFields(Class<?> clazz) {\n        // 声明Field数组\n        List<Field> fields = new ArrayList<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            Collections.addAll(fields, clazz.getDeclaredFields());\n            clazz = clazz.getSuperclass();\n        }\n        return fields;\n    }\n\n}\n```\n\n### 快速失败(Fail Fast)\n\nSpring Validation 默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启 Fali Fast 模式，一旦校验失败就立即返回。\n\n```scss\n@Bean\npublic Validator validator() {\n    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)\n            .configure()\n            // 快速失败模式\n            .failFast(true)\n            .buildValidatorFactory();\n    return validatorFactory.getValidator();\n}\n```\n\n## Spring 校验原理\n\n### Spring 校验使用场景\n\n- Spring 常规校验（Validator）\n- Spring 数据绑定（DataBinder）\n- Spring Web 参数绑定（WebDataBinder）\n- Spring WebMVC/WebFlux 处理方法参数校验\n\n### Validator 接口设计\n\n- 接口职责\n  - Spring 内部校验器接口，通过编程的方式校验目标对象\n- 核心方法\n  - `supports(Class)`：校验目标类能否校验\n  - `validate(Object,Errors)`：校验目标对象，并将校验失败的内容输出至 Errors 对象\n- 配套组件\n  - 错误收集器：`org.springframework.validation.Errors`\n  - Validator 工具类：`org.springframework.validation.ValidationUtils`\n\n### Errors 接口设计\n\n- 接口职责\n  - 数据绑定和校验错误收集接口，与 Java Bean 和其属性有强关联性\n- 核心方法\n  - `reject` 方法（重载）：收集错误文案\n  - `rejectValue` 方法（重载）：收集对象字段中的错误文案\n- 配套组件\n  - Java Bean 错误描述：`org.springframework.validation.ObjectError`\n  - Java Bean 属性错误描述：`org.springframework.validation.FieldError`\n\n### Errors 文案来源\n\nErrors 文案生成步骤\n\n- 选择 Errors 实现（如：`org.springframework.validation.BeanPropertyBindingResult`）\n- 调用 reject 或 rejectValue 方法\n- 获取 Errors 对象中 ObjectError 或 FieldError\n- 将 ObjectError 或 FieldError 中的 code 和 args，关联 MessageSource 实现（如：`ResourceBundleMessageSource`）\n\n### spring web 校验原理\n\n#### RequestBody 参数校验实现原理\n\n在 spring-mvc 中，`RequestResponseBodyMethodProcessor` 是用于解析 `@RequestBody` 标注的参数以及处理`@ResponseBody` 标注方法的返回值的。其中，执行参数校验的逻辑肯定就在解析参数的方法 `resolveArgument()` 中：\n\n```java\n@Override\npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n    parameter = parameter.nestedIfOptional();\n    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n    String name = Conventions.getVariableNameForParameter(parameter);\n\n    if (binderFactory != null) {\n        WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateIfApplicable(binder, parameter);\n            if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 MethodArgumentNotValidException\n                throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n            }\n        }\n        if (mavContainer != null) {\n            mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n        }\n    }\n\n    return adaptArgumentIfNecessary(arg, parameter);\n}\n```\n\n可以看到，resolveArgument()调用了 validateIfApplicable()进行参数校验。\n\n```java\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n    // 获取参数注解，如 @RequestBody、@Valid、@Validated\n    Annotation[] annotations = parameter.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        // 先尝试获取 @Validated 注解\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        // 如果标注了 @Validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 Valid 开头的注解。\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            // 执行校验\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}\n```\n\n以上代码，就解释了 Spring 为什么能同时支持 `@Validated`、`@Valid` 两个注解。\n\n接下来，看一下 WebDataBinder.validate() 的实现：\n\n```typescript\n@Override\npublic void validate(Object target, Errors errors, Object... validationHints) {\n    if (this.targetValidator != null) {\n        processConstraintViolations(\n            // 此处调用 Hibernate Validator 执行真正的校验\n            this.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n    }\n}\n```\n\n通过上面代码，可以看出 Spring 校验实际上是基于 Hibernate Validator 的封装。\n\n#### 方法级别的参数校验实现原理\n\nSpring 支持根据方法去进行拦截、校验，原理就在于应用了 AOP 技术。具体来说，是通过 `MethodValidationPostProcessor` 动态注册 AOP 切面，然后使用 `MethodValidationInterceptor` 对切点方法织入增强。\n\n```java\npublic class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean {\n    @Override\n    public void afterPropertiesSet() {\n        // 为所有 @Validated 标注的 Bean 创建切面\n        Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true);\n        // 创建 Advisor 进行增强\n        this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator));\n    }\n\n    // 创建 Advice，本质就是一个方法拦截器\n    protected Advice createMethodValidationAdvice(@Nullable Validator validator) {\n        return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor());\n    }\n}\n```\n\n接着看一下 `MethodValidationInterceptor`：\n\n```scss\npublic class MethodValidationInterceptor implements MethodInterceptor {\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        // 无需增强的方法，直接跳过\n        if (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        Class<?>[] groups = determineValidationGroups(invocation);\n        ExecutableValidator execVal = this.validator.forExecutables();\n        Method methodToValidate = invocation.getMethod();\n        Set<ConstraintViolation<Object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 Hibernate Validator 来校验\n            result = execVal.validateParameters(\n                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n        }\n        catch (IllegalArgumentException ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        // 真正的方法调用\n        Object returnValue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给Hibernate Validator来校验\n        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        return returnValue;\n    }\n}\n```\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n## 问题\n\n**Spring 有哪些校验核心组件**？\n\n- 检验器：`org.springframework.validation.Validator`\n- 错误收集器：`org.springframework.validation.Errors`\n- Java Bean 错误描述：`org.springframework.validation.ObjectError`\n- Java Bean 属性错误描述：`org.springframework.validation.FieldError`\n- Bean Validation 适配：`org.springframework.validation.beanvalidation.LocalValidatorFactoryBean`\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n- https://juejin.cn/post/6856541106626363399'},{title:"Spring 数据绑定",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"Spring 数据绑定使用场景",slug:"spring-数据绑定使用场景",link:"#spring-数据绑定使用场景",children:[]},{level:2,title:"DataBinder",slug:"databinder",link:"#databinder",children:[]},{level:2,title:"Spring 数据绑定元数据",slug:"spring-数据绑定元数据",link:"#spring-数据绑定元数据",children:[]},{level:2,title:"Spring 数据绑定控制参数",slug:"spring-数据绑定控制参数",link:"#spring-数据绑定控制参数",children:[{level:3,title:"DataBinder 绑定控制参数",slug:"databinder-绑定控制参数",link:"#databinder-绑定控制参数",children:[]}]},{level:2,title:"BeanWrapper 的使用场景",slug:"beanwrapper-的使用场景",link:"#beanwrapper-的使用场景",children:[]},{level:2,title:"Spring 底层 Java Beans 替换实现",slug:"spring-底层-java-beans-替换实现",link:"#spring-底层-java-beans-替换实现",children:[]},{level:2,title:"DataBinder 数据校验",slug:"databinder-数据校验",link:"#databinder-数据校验",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/267b4c/",pathLocale:"/",extraFields:'---\ntitle: Spring 数据绑定\ndate: 2022-12-22 19:26:57\norder: 22\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - 数据绑定\npermalink: /pages/267b4c/\n---\n\n# Spring 数据绑定\n\n**Spring 数据绑定(Data Binding)的作用是将用户的输入动态绑定到 JavaBean**。换句话说，Spring 数据绑定机制是将属性值设置到目标对象中。\n\n在 Spring 中，数据绑定功能主要由 `DataBinder` 类实现。此外，`BeanWrapper` 也具有类似的功能，但 `DataBinder` 额外支持字段验证、字段格式化和绑定结果分析。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20230111150930.png)\n\n## 快速入门\n\n定义一个用于测试的 JavaBean\n\n```java\npublic class TestBean {\n\n    private int num;\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return "TestBean{" + "num=" + num + \'}\';\n    }\n\n}\n```\n\n数据绑定示例\n\n```java\npublic class DataBindingDemo {\n\n    public static void main(String[] args) {\n\n        MutablePropertyValues mpv = new MutablePropertyValues();\n        mpv.add("num", "10");\n\n        TestBean testBean = new TestBean();\n        DataBinder db = new DataBinder(testBean);\n\n        db.bind(mpv);\n        System.out.println(testBean);\n    }\n\n}\n```\n\n## Spring 数据绑定使用场景\n\n- Spring `BeanDefinition` 到 Bean 实例创建\n- Spring 数据绑定（`DataBinder`）\n- Spring Web 参数绑定（`WebDataBinder`）\n\n## DataBinder\n\n在 Spring 中，`DataBinder` 类是数据绑定功能的基类。`WebDataBinder` 是 `DataBinder` 的子类，主要用于 Spring Web 数据绑定，此外，还有一些 `WebDataBinder` 的扩展子类，其类族如下图所示：\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20230111152225.png)\n\nDataBinder 核心属性：\n\n| 属性                   | 说明                           |\n| ---------------------- | ------------------------------ |\n| `target`               | 关联目标 Bean                  |\n| `objectName`           | 目标 Bean 名称                 |\n| `bindingResult`        | 属性绑定结果                   |\n| `typeConverter`        | 类型转换器                     |\n| `conversionService`    | 类型转换服务                   |\n| `messageCodesResolver` | 校验错误文案 Code 处理器       |\n| `validators`           | 关联的 Bean Validator 实例集合 |\n\n`DataBinder` 类的核心方法是 `bind(PropertyValues)`：将 PropertyValues Key-Value 内容映射到关联 Bean（target）中的属性上\n\n- 假设 PropertyValues 中包含 name=dunwu 的键值对时, 同时 Bean 对象 User 中存在 name 属性, 当 bind 方法执行时, User 对象中的 name 属性值将被绑定为 dunwu\n\n## Spring 数据绑定元数据\n\nDataBinder 元数据 - PropertyValues\n\n| 特征         | 说明                                                                 |\n| ------------ | -------------------------------------------------------------------- |\n| 数据来源     | BeanDefinition，主要来源 XML 资源配置 BeanDefinition                 |\n| 数据结构     | 由一个或多个 PropertyValue 组成                                      |\n| 成员结构     | PropertyValue 包含属性名称，以及属性值（包括原始值、类型转换后的值） |\n| 常见实现     | MutablePropertyValues                                                |\n| Web 扩展实现 | ServletConfigPropertyValues、ServletRequestParameterPropertyValues   |\n| 相关生命周期 | InstantiationAwareBeanPostProcessor#postProcessProperties            |\n\n## Spring 数据绑定控制参数\n\nDataBinder 绑定特殊场景分析\n\n- 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 不存在 x 属性，当 bind 方法执\n  行时，会发生什么？\n- 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 中存在 x 属性，当 bind 方法执\n  行时，如何避免 B 属性 x 不被绑定？\n- 当 PropertyValues 中包含名称 x.y 的 PropertyValue，目标对象 B 中存在 x 属性（嵌套 y 属性）\n  ，当 bind 方法执行时，会发生什么？\n\n### DataBinder 绑定控制参数\n\n| 参数名称            | 说明                               |\n| ------------------- | ---------------------------------- |\n| ignoreUnknownFields | 是否忽略未知字段，默认值：true     |\n| ignoreInvalidFields | 是否忽略非法字段，默认值：false    |\n| autoGrowNestedPaths | 是否自动增加嵌套路径，默认值：true |\n| allowedFields       | 绑定字段白名单                     |\n| disallowedFields    | 绑定字段黑名单                     |\n| requiredFields      | 必须绑定字段                       |\n\n## BeanWrapper 的使用场景\n\n- Spring 底层 JavaBeans 基础设施的中心化接口\n- 通常不会直接使用，间接用于 BeanFactory 和 DataBinder\n- 提供标准 JavaBeans 分析和操作，能够单独或批量存储 Java Bean 的属性（properties）\n- 支持嵌套属性路径（nested path）\n- 实现类 org.springframework.beans.BeanWrapperImpl\n\n## Spring 底层 Java Beans 替换实现\n\nJavaBeans 核心实现 - `java.beans.BeanInfo`\n\n- 属性（Property）\n  - `java.beans.PropertyEditor`\n- 方法（Method）\n- 事件（Event）\n- 表达式（Expression）\n\nSpring 替代实现 - `org.springframework.beans.BeanWrapper`\n\n- 属性（Property）\n  - `java.beans.PropertyEditor`\n- 嵌套属性路径（nested path）\n\n## DataBinder 数据校验\n\nDataBinder 与 BeanWrapper\n\n- bind 方法生成 BeanPropertyBindingResult\n- BeanPropertyBindingResult 关联 BeanWrapper\n\n## 问题\n\n标准 JavaBeans 是如何操作属性的？\n\n| API                           | 说明                     |\n| ----------------------------- | ------------------------ |\n| java.beans.Introspector       | Java Beans 内省 API      |\n| java.beans.BeanInfo           | Java Bean 元信息 API     |\n| java.beans.BeanDescriptor     | Java Bean 信息描述符     |\n| java.beans.PropertyDescriptor | Java Bean 属性描述符     |\n| java.beans.MethodDescriptor   | Java Bean 方法描述符     |\n| java.beans.EventSetDescriptor | Java Bean 事件集合描述符 |\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring 类型转换",headers:[{level:2,title:"Spring 类型转换的实现",slug:"spring-类型转换的实现",link:"#spring-类型转换的实现",children:[]},{level:2,title:"使用场景",slug:"使用场景",link:"#使用场景",children:[]},{level:2,title:"基于 JavaBeans 接口的类型转换",slug:"基于-javabeans-接口的类型转换",link:"#基于-javabeans-接口的类型转换",children:[]},{level:2,title:"Spring 內建 PropertyEditor 扩展",slug:"spring-內建-propertyeditor-扩展",link:"#spring-內建-propertyeditor-扩展",children:[]},{level:2,title:"自定义 PropertyEditor 扩展",slug:"自定义-propertyeditor-扩展",link:"#自定义-propertyeditor-扩展",children:[]},{level:2,title:"Spring PropertyEditor 的设计缺陷",slug:"spring-propertyeditor-的设计缺陷",link:"#spring-propertyeditor-的设计缺陷",children:[]},{level:2,title:"Spring 3 通用类型转换接口",slug:"spring-3-通用类型转换接口",link:"#spring-3-通用类型转换接口",children:[]},{level:2,title:"Spring 內建类型转换器",slug:"spring-內建类型转换器",link:"#spring-內建类型转换器",children:[]},{level:2,title:"Converter 接口的局限性",slug:"converter-接口的局限性",link:"#converter-接口的局限性",children:[]},{level:2,title:"GenericConverter 接口",slug:"genericconverter-接口",link:"#genericconverter-接口",children:[]},{level:2,title:"优化 GenericConverter 接口",slug:"优化-genericconverter-接口",link:"#优化-genericconverter-接口",children:[]},{level:2,title:"扩展 Spring 类型转换器",slug:"扩展-spring-类型转换器",link:"#扩展-spring-类型转换器",children:[]},{level:2,title:"统一类型转换服务",slug:"统一类型转换服务",link:"#统一类型转换服务",children:[]},{level:2,title:"ConversionService 作为依赖",slug:"conversionservice-作为依赖",link:"#conversionservice-作为依赖",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/6662dc/",pathLocale:"/",extraFields:"---\ntitle: Spring 类型转换\ndate: 2022-12-22 19:43:59\norder: 23\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/6662dc/\n---\n\n# Spring 类型转换\n\n## Spring 类型转换的实现\n\n- 基于 JavaBeans 接口的类型转换实现\n  - 基于 java.beans.PropertyEditor 接口扩展\n- Spring 3.0+ 通用类型转换实现\n\n## 使用场景\n\n| 场景               | 基于 JavaBeans 接口的类型转换实现 | Spring 3.0+ 通用类型转换实现 |\n| ------------------ | --------------------------------- | ---------------------------- |\n| 数据绑定           | YES                               | YES                          |\n| BeanWrapper        | YES                               | YES                          |\n| Bean 属性类型转换  | YES                               | YES                          |\n| 外部化属性类型转换 | NO                                | YES                          |\n\n## 基于 JavaBeans 接口的类型转换\n\n核心职责\n\n- 将 String 类型的内容转化为目标类型的对象\n\n扩展原理\n\n- Spring 框架将文本内容传递到 PropertyEditor 实现的 setAsText(String) 方法\n- PropertyEditor#setAsText(String) 方法实现将 String 类型转化为目标类型的对象\n- 将目标类型的对象传入 PropertyEditor#setValue(Object) 方法\n- PropertyEditor#setValue(Object) 方法实现需要临时存储传入对象\n- Spring 框架将通过 PropertyEditor#getValue() 获取类型转换后的对象\n\n## Spring 內建 PropertyEditor 扩展\n\n內建扩展（org.springframework.beans.propertyeditors 包下）\n\n| 转换场景            | 实现类                                                            |\n| ------------------- | ----------------------------------------------------------------- |\n| String -> Byte 数组 | org.springframework.beans.propertyeditors.ByteArrayPropertyEditor |\n| String -> Char      | org.springframework.beans.propertyeditors.CharacterEditor         |\n| String -> Char 数组 | org.springframework.beans.propertyeditors.CharArrayPropertyEditor |\n| String -> Charset   | org.springframework.beans.propertyeditors.CharsetEditor           |\n| String -> Class     | org.springframework.beans.propertyeditors.ClassEditor             |\n| String -> Currency  | org.springframework.beans.propertyeditors.CurrencyEditor          |\n|                     |                                                                   |\n\n## 自定义 PropertyEditor 扩展\n\n扩展模式\n\n- 扩展 `java.beans.PropertyEditorSupport` 类\n\n实现 `org.springframework.beans.PropertyEditorRegistrar`\n\n- 实现 `registerCustomEditors(org.springframework.beans.PropertyEditorRegistry)` 方法\n- 将 `PropertyEditorRegistrar` 实现注册为 Spring Bean\n\n向 `org.springframework.beans.PropertyEditorRegistry` 注册自定义 PropertyEditor 实现\n\n- 通用类型实现 `registerCustomEditor(Class<?>, PropertyEditor)`\n- Java Bean 属性类型实现：`registerCustomEditor(Class<?>, String, PropertyEditor)`\n\n## Spring PropertyEditor 的设计缺陷\n\n违反职责单一原则\n\n- `java.beans.PropertyEditor` 接口职责太多，除了类型转换，还包括 Java Beans 事件和 Java GUI 交\n  互\n\n`java.beans.PropertyEditor` 实现类型局限\n\n- 来源类型只能为 `java.lang.String` 类型\n\n`java.beans.PropertyEditor` 实现缺少类型安全\n\n- 除了实现类命名可以表达语义，实现类无法感知目标转换类型\n\n## Spring 3 通用类型转换接口\n\n类型转换接口 - org.springframework.core.convert.converter.Converter<S,T>\n\n- 泛型参数 S：来源类型，参数 T：目标类型\n- 核心方法：T convert(S)\n\n通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\n\n- 核心方法：convert(Object,TypeDescriptor,TypeDescriptor)\n- 配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\n- 类型描述：org.springframework.core.convert.TypeDescriptor\n\n## Spring 內建类型转换器\n\n內建扩展\n\n| 转换场景             | 实现类所在包名（package）                    |\n| -------------------- | -------------------------------------------- |\n| 日期/时间相关        | org.springframework.format.datetime          |\n| Java 8 日期/时间相关 | org.springframework.format.datetime.standard |\n| 通用实现             | org.springframework.core.convert.support     |\n\n## Converter 接口的局限性\n\n局限一：缺少 Source Type 和 Target Type 前置判断\n\n- 应对：增加 org.springframework.core.convert.converter.ConditionalConverter 实现\n\n局限二：仅能转换单一的 Source Type 和 Target Type\n\n- 应对：使用 org.springframework.core.convert.converter.GenericConverter 代替\n\n## GenericConverter 接口\n\n`org.springframework.core.convert.converter.GenericConverter`\n\n| 核心要素 | 说明                                                                          |\n| -------- | ----------------------------------------------------------------------------- |\n| 使用场景 | 用于“复合”类型转换场景，比如 Collection、Map、数组等                          |\n| 转换范围 | `Set<ConvertiblePair> getConvertibleTypes()`                                  |\n| 配对类型 | `org.springframework.core.convert.converter.GenericConverter.ConvertiblePair` |\n| 转换方法 | `convert(Object,TypeDescriptor,TypeDescriptor)`                               |\n| 类型描述 | `org.springframework.core.convert.TypeDescriptor`                             |\n\n## 优化 GenericConverter 接口\n\nGenericConverter 局限性\n\n- 缺少 Source Type 和 Target Type 前置判断\n- 单一类型转换实现复杂\n\nGenericConverter 优化接口 - `ConditionalGenericConverter`\n\n- 复合类型转换：`org.springframework.core.convert.converter.GenericConverter`\n- 类型条件判断：`org.springframework.core.convert.converter.ConditionalConverter`\n\n## 扩展 Spring 类型转换器\n\n实现转换器接口\n\n- `org.springframework.core.convert.converter.Converter`\n- `org.springframework.core.convert.converter.ConverterFactory`\n- `org.springframework.core.convert.converter.GenericConverter`\n\n注册转换器实现\n\n- 通过 `ConversionServiceFactoryBean` Spring Bean\n- 通过 `org.springframework.core.convert.ConversionService API`\n\n## 统一类型转换服务\n\n`org.springframework.core.convert.ConversionService`\n\n| 实现类型                             | 说明                                                                                      |\n| ------------------------------------ | ----------------------------------------------------------------------------------------- |\n| `GenericConversionService`           | 通用 ConversionService 模板实现，不内置转化器实现                                         |\n| `DefaultConversionService`           | 基础 ConversionService 实现，内置常用转化器实现                                           |\n| `FormattingConversionService`        | 通用 Formatter + GenericConversionService 实现，不内置转化器和 Formatter 实现             |\n| `DefaultFormattingConversionService` | DefaultConversionService + 格式化 实现（如：JSR-354 Money & Currency, JSR-310 Date-Time） |\n\n## ConversionService 作为依赖\n\n类型转换器底层接口 - `org.springframework.beans.TypeConverter`\n\n- 起始版本：Spring 2.0\n- 核心方法 - convertIfNecessary 重载方法\n- 抽象实现 - `org.springframework.beans.TypeConverterSupport`\n- 简单实现 - `org.springframework.beans.SimpleTypeConverter`\n\n类型转换器底层抽象实现 - `org.springframework.beans.TypeConverterSupport`\n\n- 实现接口 - `org.springframework.beans.TypeConverter`\n- 扩展实现 - `org.springframework.beans.PropertyEditorRegistrySupport`\n- 委派实现 - `org.springframework.beans.TypeConverterDelegate`\n\n类型转换器底层委派实现 - `org.springframework.beans.TypeConverterDelegate`\n\n- 构造来源 - `org.springframework.beans.AbstractNestablePropertyAccessor` 实现\n  - `org.springframework.beans.BeanWrapperImpl`\n- 依赖 - `java.beans.PropertyEditor` 实现\n  - 默认內建实现 - `PropertyEditorRegistrySupport#registerDefaultEditors`\n- 可选依赖 - `org.springframework.core.convert.ConversionService` 实现\n\n## 问题\n\n**Spring 类型转换实现有哪些**？\n\n- 基于 JavaBeans PropertyEditor 接口实现\n- Spring 3.0+ 通用类型转换实现\n\n**Spring 类型转换器接口有哪些**？\n\n- 类型转换接口 - `org.springframework.core.convert.converter.Converter`\n- 通用类型转换接口 - `org.springframework.core.convert.converter.GenericConverter`\n- 类型条件接口 - `org.springframework.core.convert.converter.ConditionalConverter`\n- 综合类型转换接口 - `org.springframework.core.convert.converter.ConditionalGenericConverter`\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring EL 表达式",headers:[{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1f743f/",pathLocale:"/",extraFields:"---\ntitle: Spring EL 表达式\ndate: 2023-01-12 20:26:46\norder: 24\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/1f743f/\n---\n\n# Spring EL 表达式\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring 事件",headers:[{level:2,title:"Java 事件/监听器编程模型",slug:"java-事件-监听器编程模型",link:"#java-事件-监听器编程模型",children:[]},{level:2,title:"面向接口的事件/监听器设计模式",slug:"面向接口的事件-监听器设计模式",link:"#面向接口的事件-监听器设计模式",children:[]},{level:2,title:"面向注解的事件/监听器设计模式",slug:"面向注解的事件-监听器设计模式",link:"#面向注解的事件-监听器设计模式",children:[]},{level:2,title:"Spring 标准事件 - ApplicationEvent",slug:"spring-标准事件-applicationevent",link:"#spring-标准事件-applicationevent",children:[]},{level:2,title:"基于接口的 Spring 事件监听器",slug:"基于接口的-spring-事件监听器",link:"#基于接口的-spring-事件监听器",children:[]},{level:2,title:"基于注解的 Spring 事件监听器",slug:"基于注解的-spring-事件监听器",link:"#基于注解的-spring-事件监听器",children:[]},{level:2,title:"注册 Spring ApplicationListener",slug:"注册-spring-applicationlistener",link:"#注册-spring-applicationlistener",children:[]},{level:2,title:"Spring 事件发布器",slug:"spring-事件发布器",link:"#spring-事件发布器",children:[]},{level:2,title:"Spring 层次性上下文事件传播",slug:"spring-层次性上下文事件传播",link:"#spring-层次性上下文事件传播",children:[]},{level:2,title:"Spring 内建事件",slug:"spring-内建事件",link:"#spring-内建事件",children:[]},{level:2,title:"Spring 4.2 Payload 事件",slug:"spring-4-2-payload-事件",link:"#spring-4-2-payload-事件",children:[]},{level:2,title:"自定义 Spring 事件",slug:"自定义-spring-事件",link:"#自定义-spring-事件",children:[]},{level:2,title:"依赖注入 ApplicationEventPublisher",slug:"依赖注入-applicationeventpublisher",link:"#依赖注入-applicationeventpublisher",children:[]},{level:2,title:"依赖查找 ApplicationEventMulticaster",slug:"依赖查找-applicationeventmulticaster",link:"#依赖查找-applicationeventmulticaster",children:[]},{level:2,title:"ApplicationEventPublisher 底层实现",slug:"applicationeventpublisher-底层实现",link:"#applicationeventpublisher-底层实现",children:[]},{level:2,title:"同步和异步 Spring 事件广播",slug:"同步和异步-spring-事件广播",link:"#同步和异步-spring-事件广播",children:[]},{level:2,title:"Spring 4.1 事件异常处理",slug:"spring-4-1-事件异常处理",link:"#spring-4-1-事件异常处理",children:[]},{level:2,title:"Spring 事件/监听器实现原理",slug:"spring-事件-监听器实现原理",link:"#spring-事件-监听器实现原理",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cca414/",pathLocale:"/",extraFields:'---\ntitle: Spring 事件\ndate: 2022-12-22 20:31:02\norder: 25\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/cca414/\n---\n\n# Spring 事件\n\n## Java 事件/监听器编程模型\n\n设计模式 - 观察者模式扩展\n\n- 可观者对象（消息发送者） - java.util.Observable\n- 观察者 - java.util.Observer\n\n标准化接口\n\n- 事件对象 - java.util.EventObject\n- 事件监听器 - java.util.EventListener\n\n## 面向接口的事件/监听器设计模式\n\n事件/监听器场景举例\n\n| Java 技术规范   | 事件接口                              | 监听器接口                               |\n| --------------- | ------------------------------------- | ---------------------------------------- |\n| JavaBeans       | java.beans.PropertyChangeEvent        | java.beans.PropertyChangeListener        |\n| Java AWT        | java.awt.event.MouseEvent             | java.awt.event.MouseListener             |\n| Java Swing      | javax.swing.event.MenuEvent           | javax.swing.event.MenuListener           |\n| Java Preference | java.util.prefs.PreferenceChangeEvent | java.util.prefs.PreferenceChangeListener |\n\n## 面向注解的事件/监听器设计模式\n\n事件/监听器注解场景举例\n\n| Java 技术规范 | 事件注解                       | 监听器注解                            |\n| ------------- | ------------------------------ | ------------------------------------- |\n| Servlet 3.0+  |                                | @javax.servlet.annotation.WebListener |\n| JPA 1.0+      | @javax.persistence.PostPersist |                                       |\n| Java Common   | @PostConstruct                 |                                       |\n| EJB 3.0+      | @javax.ejb.PrePassivate        |                                       |\n| JSF 2.0+      | @javax.faces.event.ListenerFor |                                       |\n\n## Spring 标准事件 - ApplicationEvent\n\nJava 标准事件 `java.util.EventObject` 扩展\n\n- 扩展特性：事件发生事件戳\n- Spring 应用上下文 ApplicationEvent 扩展 - `ApplicationContextEvent`\n- Spring 应用上下文（ApplicationContext）作为事件源\n\n具体实现：\n\n- `org.springframework.context.event.ContextClosedEvent`\n- `org.springframework.context.event.ContextRefreshedEvent`\n- `org.springframework.context.event.ContextStartedEvent`\n- `org.springframework.context.event.ContextStoppedEvent`\n\n## 基于接口的 Spring 事件监听器\n\nJava 标准事件监听器 `java.util.EventListener` 扩展\n\n- 扩展接口 - `org.springframework.context.ApplicationListener`\n- 设计特点：单一类型事件处理\n- 处理方法：`onApplicationEvent(ApplicationEvent)`\n- 事件类型：`org.springframework.context.ApplicationEvent`\n\n## 基于注解的 Spring 事件监听器\n\nSpring 注解 - `@org.springframework.context.event.EventListener`\n\n| 特性                 | 说明                                         |\n| -------------------- | -------------------------------------------- |\n| 设计特点             | 支持多 `ApplicationEvent` 类型，无需接口约束 |\n| 注解目标             | 方法                                         |\n| 是否支持异步执行     | 支持                                         |\n| 是否支持泛型类型事件 | 支持                                         |\n| 是指支持顺序控制     | 支持，配合 `@Order` 注解控制                 |\n\n## 注册 Spring ApplicationListener\n\n- 方法一：ApplicationListener 作为 Spring Bean 注册\n- 方法二：通过 ConfigurableApplicationContext API 注册\n\n## Spring 事件发布器\n\n- 方法一：通过 ApplicationEventPublisher 发布 Spring 事件\n  - 获取 ApplicationEventPublisher\n    - 依赖注入\n- 方法二：通过 ApplicationEventMulticaster 发布 Spring 事件\n  - 获取 ApplicationEventMulticaster\n    - 依赖注入\n    - 依赖查找\n\n## Spring 层次性上下文事件传播\n\n- 发生说明\n- 当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 ApplicationContext 发起 Spring 事件可能会传递到其 Parent ApplicationContext（直到 Root）的过程\n- 如何避免\n- 定位 Spring 事件源（ApplicationContext）进行过滤处理\n\n## Spring 内建事件\n\nApplicationContextEvent 派生事件\n\n- ContextRefreshedEvent ：Spring 应用上下文就绪事件\n- ContextStartedEvent ：Spring 应用上下文启动事件\n- ContextStoppedEvent ：Spring 应用上下文停止事件\n- ContextClosedEvent ：Spring 应用上下文关闭事件\n\n## Spring 4.2 Payload 事件\n\nSpring Payload 事件 - org.springframework.context.PayloadApplicationEvent\n\n- 使用场景：简化 Spring 事件发送，关注事件源主体\n- 发送方法：ApplicationEventPublisher#publishEvent(java.lang.Object)\n\n## 自定义 Spring 事件\n\n- 扩展 org.springframework.context.ApplicationEvent\n- 实现 org.springframework.context.ApplicationListener\n- 注册 org.springframework.context.ApplicationListener\n\n## 依赖注入 ApplicationEventPublisher\n\n- 通过 ApplicationEventPublisherAware 回调接口\n- 通过 @Autowired ApplicationEventPublisher\n\n## 依赖查找 ApplicationEventMulticaster\n\n查找条件\n\n- Bean 名称："applicationEventMulticaster"\n- Bean 类型：org.springframework.context.event.ApplicationEventMulticaster\n\n## ApplicationEventPublisher 底层实现\n\n- 接口：org.springframework.context.event.ApplicationEventMulticaster\n- 抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster\n- 实现类：org.springframework.context.event.SimpleApplicationEventMulticaster\n\n## 同步和异步 Spring 事件广播\n\n基于实现类 - `org.springframework.context.event.SimpleApplicationEventMulticaster`\n\n- 模式切换：`setTaskExecutor(java.util.concurrent.Executor)` 方法\n  - 默认模式：同步\n  - 异步模式：如 `java.util.concurrent.ThreadPoolExecutor`\n- 设计缺陷：非基于接口契约编程\n\n基于注解 - `@org.springframework.context.event.EventListener`\n\n- 模式切换\n  - 默认模式：同步\n  - 异步模式：标注 `@org.springframework.scheduling.annotation.Async`\n- 实现限制：无法直接实现同步/异步动态切换\n\n## Spring 4.1 事件异常处理\n\nSpring 3.0 错误处理接口 - org.springframework.util.ErrorHandler\n\n使用场景\n\n- Spring 事件（Events）\n  - SimpleApplicationEventMulticaster Spring 4.1 开始支持\n- Spring 本地调度（Scheduling）\n  - org.springframework.scheduling.concurrent.ConcurrentTaskScheduler\n  - org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\n\n## Spring 事件/监听器实现原理\n\n核心类 - `org.springframework.context.event.SimpleApplicationEventMulticaster`\n\n- 设计模式：观察者模式扩展\n  - 被观察者 - org.springframework.context.ApplicationListener\n    - API 添加\n    - 依赖查找\n  - 通知对象 - org.springframework.context.ApplicationEvent\n- 执行模式：同步/异步\n- 异常处理：org.springframework.util.ErrorHandler\n- 泛型处理：org.springframework.core.ResolvableType\n\n## 问题\n\n**Spring Boot 事件**\n\n| 事件类型                            | 发生时机                                |\n| ----------------------------------- | --------------------------------------- |\n| ApplicationStartingEvent            | 当 Spring Boot 应用已启动时             |\n| ApplicationStartedEvent             | 当 Spring Boot 应用已启动时             |\n| ApplicationEnvironmentPreparedEvent | 当 Spring Boot Environment 实例已准备时 |\n| ApplicationPreparedEvent            | 当 Spring Boot 应用预备时               |\n| ApplicationReadyEvent               | 当 Spring Boot 应用完全可用时           |\n| ApplicationFailedEvent              | 当 Spring Boot 应用启动失败时           |\n\n**Spring Cloud 事件**\n\n| 事件类型                   | 发生时机                              |\n| -------------------------- | ------------------------------------- |\n| EnvironmentChangeEvent     | 当 Environment 示例配置属性发生变化时 |\n| HeartbeatEvent             | 当 DiscoveryClient 客户端发送心跳时   |\n| InstancePreRegisteredEvent | 当服务实例注册前                      |\n| InstanceRegisteredEvent    | 当服务实例注册后                      |\n| RefreshEvent               | 当 RefreshEndpoint 被调用时           |\n| RefreshScopeRefreshedEvent | 当 Refresh Scope Bean 刷新后          |\n\n**Spring 事件核心接口/组件**？\n\n- Spring 事件 - org.springframework.context.ApplicationEvent\n- Spring 事件监听器 - org.springframework.context.ApplicationListener\n- Spring 事件发布器 - org.springframework.context.ApplicationEventPublisher\n- Spring 事件广播器 - org.springframework.context.event.ApplicationEventMulticaster\n\n**Spring 同步和异步事件处理的使用场景**？\n\n- Spring 同步事件 - 绝大多数 Spring 使用场景，如 ContextRefreshedEvent\n- Spring 异步事件 - 主要 @EventListener 与 @Async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 SimpleApplicationEventMulticaster 中关联的 taskExecutor 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)'},{title:"Spring 国际化",headers:[{level:2,title:"Spring 国际化使用场景",slug:"spring-国际化使用场景",link:"#spring-国际化使用场景",children:[]},{level:2,title:"Spring 国际化接口",slug:"spring-国际化接口",link:"#spring-国际化接口",children:[]},{level:2,title:"层次性 MessageSource",slug:"层次性-messagesource",link:"#层次性-messagesource",children:[]},{level:2,title:"Java 国际化标准实现",slug:"java-国际化标准实现",link:"#java-国际化标准实现",children:[]},{level:2,title:"Java 文本格式化",slug:"java-文本格式化",link:"#java-文本格式化",children:[]},{level:2,title:"MessageSource 开箱即用实现",slug:"messagesource-开箱即用实现",link:"#messagesource-开箱即用实现",children:[]},{level:2,title:"MessageSource 內建依赖",slug:"messagesource-內建依赖",link:"#messagesource-內建依赖",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/b5b8ad/",pathLocale:"/",extraFields:"---\ntitle: Spring 国际化\ndate: 2022-12-22 11:44:54\norder: 26\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/b5b8ad/\n---\n\n# Spring 国际化\n\n## Spring 国际化使用场景\n\n- 普通国际化文案\n- Bean Validation 校验国际化文案\n- Web 站点页面渲染\n- Web MVC 错误消息提示\n\n## Spring 国际化接口\n\n- 核心接口：`org.springframework.context.MessageSource`\n- 主要概念\n  - 文案模板编码（code）\n  - 文案模板参数（args）\n  - 区域（Locale）\n\n## 层次性 MessageSource\n\n- Spring 层次性接口回顾\n  - `org.springframework.beans.factory.HierarchicalBeanFactory`\n  - `org.springframework.context.ApplicationContext`\n  - `org.springframework.beans.factory.config.BeanDefinition`\n- Spring 层次性国际化接口\n  - `org.springframework.context.HierarchicalMessageSource`\n\n## Java 国际化标准实现\n\n核心接口：\n\n- 抽象实现 - `java.util.ResourceBundle`\n- Properties 资源实现 - `java.util.PropertyResourceBundle`\n- 例举实现 - `java.util.ListResourceBundle`\n\n`ResourceBundle` 核心特性\n\n- Key-Value 设计\n- 层次性设计\n- 缓存设计\n- 字符编码控制 - `java.util.ResourceBundle.Control`（@since 1.6）\n- Control SPI 扩展 - `java.util.spi.ResourceBundleControlProvider`（@since 1.8）\n\n## Java 文本格式化\n\n- 核心接口\n  - java.text.MessageFormat\n- 基本用法\n  - 设置消息格式模式- new MessageFormat(...)\n  - 格式化 - format(new Object[]{...})\n- 消息格式模式\n  - 格式元素：{ArgumentIndex (,FormatType,(FormatStyle))}\n  - FormatType：消息格式类型，可选项，每种类型在 number、date、time 和 choice 类型选其一\n  - FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、\n    percent\n- 高级特性\n  - 重置消息格式模式\n  - 重置 java.util.Locale\n  - 重置 java.text.Format\n\n## MessageSource 开箱即用实现\n\n- 基于 ResourceBundle + MessageFormat 组合 MessageSource 实现\n- org.springframework.context.support.ResourceBundleMessageSource\n- 可重载 Properties + MessageFormat 组合 MessageSource 实现\n- org.springframework.context.support.ReloadableResourceBundleMessageSource\n\n## MessageSource 內建依赖\n\n- MessageSource 內建 Bean 可能来源\n- 预注册 Bean 名称为：“messageSource”，类型为：MessageSource Bean\n- 默认內建实现 - DelegatingMessageSource\n- 层次性查找 MessageSource 对象\n\n## 问题\n\n**Spring Boot 为什么要新建 MessageSource Bean**？\n\n- AbstractApplicationContext 的实现决定了 MessageSource 內建实现\n- Spring Boot 通过外部化配置简化 MessageSource Bean 构建\n- Spring Boot 基于 Bean Validation 校验非常普遍\n\n**Spring 国际化接口有哪些**？\n\n- 核心接口 - MessageSource\n- 层次性接口 - `org.springframework.context.HierarchicalMessageSource`\n\n**Spring 有哪些 MessageSource 內建实现**？\n\n- `org.springframework.context.support.ResourceBundleMessageSource`\n- `org.springframework.context.support.ReloadableResourceBundleMessageSource`\n- `org.springframework.context.support.StaticMessageSource`\n- `org.springframework.context.support.DelegatingMessageSource`\n\n**如何实现配置自动更新 MessageSource**？\n\n主要技术\n\n- Java NIO 2：`java.nio.file.WatchService`\n- Java Concurrency : `java.util.concurrent.ExecutorService`\n- Spring：`org.springframework.context.support.AbstractMessageSource`\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring 泛型处理",headers:[{level:2,title:"Java 泛型基础",slug:"java-泛型基础",link:"#java-泛型基础",children:[]},{level:2,title:"Java 5 类型接口",slug:"java-5-类型接口",link:"#java-5-类型接口",children:[]},{level:2,title:"Spring 泛型类型辅助类",slug:"spring-泛型类型辅助类",link:"#spring-泛型类型辅助类",children:[]},{level:2,title:"Spring 泛型集合类型辅助类",slug:"spring-泛型集合类型辅助类",link:"#spring-泛型集合类型辅助类",children:[]},{level:2,title:"Spring 方法参数封装 - MethodParameter",slug:"spring-方法参数封装-methodparameter",link:"#spring-方法参数封装-methodparameter",children:[]},{level:2,title:"Spring 4.0 泛型优化实现 - ResolvableType",slug:"spring-4-0-泛型优化实现-resolvabletype",link:"#spring-4-0-泛型优化实现-resolvabletype",children:[]},{level:2,title:"ResolvableType 的局限性",slug:"resolvabletype-的局限性",link:"#resolvabletype-的局限性",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/175cbd/",pathLocale:"/",extraFields:"---\ntitle: Spring 泛型处理\ndate: 2022-12-22 20:11:52\norder: 27\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/175cbd/\n---\n\n# Spring 泛型处理\n\n## Java 泛型基础\n\n泛型类型\n\n- 泛型类型是在类型上参数化的泛型类或接口\n\n泛型使用场景\n\n- 编译时强类型检查\n- 避免类型强转\n- 实现通用算法\n\n泛型类型擦写\n\n- 泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会\n  为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n  - 将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为\n    “Object”。因此，生成的字节码只包含普通类、接口和方法\n  - 必要时插入类型转换以保持类型安全\n  - 生成桥方法以保留扩展泛型类型中的多态性\n\n## Java 5 类型接口\n\nJava 5 类型接口 - `java.lang.reflect.Type`\n\n| 派生类或接口                          | 说明                                    |\n| ------------------------------------- | --------------------------------------- |\n| `java.lang.Class`                     | Java 类 API，如 `java.lang.String`      |\n| `java.lang.reflect.GenericArrayType`  | 泛型数组类型                            |\n| `java.lang.reflect.ParameterizedType` | 泛型参数类型                            |\n| `java.lang.reflect.TypeVariable`      | 泛型类型变量，如 `Collection<E>` 中的 E |\n| `java.lang.reflect.WildcardType`      | 泛型通配类型                            |\n\nJava 泛型反射 API\n\n| 类型                             | API                                      |\n| -------------------------------- | ---------------------------------------- |\n| 泛型信息（Generics Info）        | `java.lang.Class#getGenericInfo()`       |\n| 泛型参数（Parameters）           | `java.lang.reflect.ParameterizedType`    |\n| 泛型父类（Super Classes）        | `java.lang.Class#getGenericSuperclass()` |\n| 泛型接口（Interfaces）           | `java.lang.Class#getGenericInterfaces()` |\n| 泛型声明（Generics Declaration） | `java.lang.reflect.GenericDeclaration`   |\n\n## Spring 泛型类型辅助类\n\n核心 API - `org.springframework.core.GenericTypeResolver`\n\n- 版本支持：[2.5.2 , )\n- 处理类型相关（Type）相关方法\n  - `resolveReturnType`\n  - `resolveType`\n- 处理泛型参数类型（`ParameterizedType`）相关方法\n  - `resolveReturnTypeArgument`\n  - `resolveTypeArgument`\n  - `resolveTypeArguments`\n- 处理泛型类型变量（`TypeVariable`）相关方法\n  - `getTypeVariableMap`\n\n## Spring 泛型集合类型辅助类\n\n核心 API - `org.springframework.core.GenericCollectionTypeResolver`\n\n- 版本支持：[2.0 , 4.3]\n- 替换实现：`org.springframework.core.ResolvableType`\n- 处理 Collection 相关\n  - `getCollection*Type`\n- 处理 Map 相关\n  - `getMapKey*Type`\n  - `getMapValue*Type`\n\n## Spring 方法参数封装 - MethodParameter\n\n核心 API - `org.springframework.core.MethodParameter`\n\n- 起始版本：[2.0 , )\n- 元信息\n  - 关联的方法 - Method\n  - 关联的构造器 - Constructor\n  - 构造器或方法参数索引 - parameterIndex\n  - 构造器或方法参数类型 - parameterType\n  - 构造器或方法参数泛型类型 - genericParameterType\n  - 构造器或方法参数参数名称 - parameterName\n  - 所在的类 - containingClass\n\n## Spring 4.0 泛型优化实现 - ResolvableType\n\n核心 API - `org.springframework.core.ResolvableType`\n\n- 起始版本：[4.0 , )\n- 扮演角色：`GenericTypeResolver` 和 `GenericCollectionTypeResolver` 替代者\n- 工厂方法：`for*` 方法\n- 转换方法：`as*` 方法\n- 处理方法：`resolve*` 方法\n\n## ResolvableType 的局限性\n\n- 局限一：ResolvableType 无法处理泛型擦写\n- 局限二：ResolvableType 无法处理非具体化的 ParameterizedType\n\n## 问题\n\n**Java 泛型擦写发生在编译时还是运行时**？\n\n运行时\n\n**请介绍 Java 5 Type 类型的派生类或接口**\n\n- `java.lang.Class`\n- `java.lang.reflect.GenericArrayType`\n- `java.lang.reflect.ParameterizedType`\n- `java.lang.reflect.TypeVariable`\n- `java.lang.reflect.WildcardType`\n\n**请说明 ResolvableType 的设计优势**？\n\n- 简化 Java 5 Type API 开发，屏蔽复杂 API 的运用，如 ParameterizedType\n- 不变性设计（Immutability）\n- Fluent API 设计（Builder 模式），链式（流式）编程\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring 注解",headers:[{level:2,title:"Spring 注解驱动编程发展历程",slug:"spring-注解驱动编程发展历程",link:"#spring-注解驱动编程发展历程",children:[]},{level:2,title:"Spring 核心注解场景分类",slug:"spring-核心注解场景分类",link:"#spring-核心注解场景分类",children:[]},{level:2,title:"Spring 注解编程模型",slug:"spring-注解编程模型",link:"#spring-注解编程模型",children:[]},{level:2,title:"Spring 元注解（Meta-Annotations）",slug:"spring-元注解-meta-annotations",link:"#spring-元注解-meta-annotations",children:[]},{level:2,title:"Spring 模式注解（Stereotype Annotations）",slug:"spring-模式注解-stereotype-annotations",link:"#spring-模式注解-stereotype-annotations",children:[]},{level:2,title:"Spring 组合注解（Composed Annotations）",slug:"spring-组合注解-composed-annotations",link:"#spring-组合注解-composed-annotations",children:[]},{level:2,title:"Spring 注解属性别名（Attribute Aliases）",slug:"spring-注解属性别名-attribute-aliases",link:"#spring-注解属性别名-attribute-aliases",children:[]},{level:2,title:"Spring 注解属性覆盖（Attribute Overrides）",slug:"spring-注解属性覆盖-attribute-overrides",link:"#spring-注解属性覆盖-attribute-overrides",children:[]},{level:2,title:"Spring @Enable 模块驱动",slug:"spring-enable-模块驱动",link:"#spring-enable-模块驱动",children:[]},{level:2,title:"Spring 条件注解",slug:"spring-条件注解",link:"#spring-条件注解",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/b6556f/",pathLocale:"/",extraFields:"---\ntitle: Spring 注解\ndate: 2022-12-23 09:08:15\norder: 28\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/b6556f/\n---\n\n# Spring 注解\n\n## Spring 注解驱动编程发展历程\n\n- 注解驱动启蒙时代：Spring Framework 1.x\n- 注解驱动过渡时代：Spring Framework 2.x\n- 注解驱动黄金时代：Spring Framework 3.x\n- 注解驱动完善时代：Spring Framework 4.x\n- 注解驱动当下时代：Spring Framework 5.x\n\n## Spring 核心注解场景分类\n\nSpring 模式注解\n\n| Spring 注解    | 场景说明           | 起始版本 |\n| -------------- | ------------------ | -------- |\n| @Repository    | 数据仓储模式注解   | 2.0      |\n| @Component     | 通用组件模式注解   | 2.5      |\n| @Service       | 服务模式注解       | 2.5      |\n| @Controller    | Web 控制器模式注解 | 2.5      |\n| @Configuration | 配置类模式注解     | 3.0      |\n\n装配注解\n\n| Spring 注解     | 场景说明                                    | 起始版本 |\n| --------------- | ------------------------------------------- | -------- |\n| @ImportResource | 替换 XML 元素 `<import>`                    | 2.5      |\n| @Import         | 导入 Configuration 类                       | 2.5      |\n| @ComponentScan  | 扫描指定 package 下标注 Spring 模式注解的类 | 3.1      |\n\n依赖注入注解\n\n| Spring 注解 | 场景说明                            | 起始版本 |\n| ----------- | ----------------------------------- | -------- |\n| @Autowired  | Bean 依赖注入，支持多种依赖查找方式 | 2.5      |\n| @Qualifier  | 细粒度的 @Autowired 依赖查找        | 2.5      |\n\n## Spring 注解编程模型\n\n- 元注解（Meta-Annotations）\n- Spring 模式注解（Stereotype Annotations）\n- Spring 组合注解（Composed Annotations）\n- Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）\n\n## Spring 元注解（Meta-Annotations）\n\n- java.lang.annotation.Documented\n- java.lang.annotation.Inherited\n- java.lang.annotation.Repeatable\n\n## Spring 模式注解（Stereotype Annotations）\n\n理解 @Component “派⽣性”：元标注 @Component 的注解在 XML 元素 <context:component-scan> 或注解 @ComponentScan 扫描中“派生”了 @Component 的特性，并且从 Spring Framework 4.0 开始支持多层次“派⽣性”。\n\n举例说明：\n\n- @Repository\n- @Service\n- @Controller\n- @Configuration\n- @SpringBootConfiguration（Spring Boot）\n\n@Component “派⽣性”原理\n\n- 核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner\n- org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider\n- 资源处理 - org.springframework.core.io.support.ResourcePatternResolver\n- 资源-类元信息\n- org.springframework.core.type.classreading.MetadataReaderFactory\n- 类元信息 - org.springframework.core.type.ClassMetadata\n- ASM 实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor\n- 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n- 注解元信息 - org.springframework.core.type.AnnotationMetadata\n- ASM 实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\n- 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n\n## Spring 组合注解（Composed Annotations）\n\nSpring 组合注解（Composed Annotations）中的元注允许是 Spring 模式注解（Stereotype Annotation）与其他 Spring 功能性注解的任意组合。\n\n## Spring 注解属性别名（Attribute Aliases）\n\n## Spring 注解属性覆盖（Attribute Overrides）\n\n## Spring @Enable 模块驱动\n\n@Enable 模块驱动\n\n@Enable 模块驱动是以 @Enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 Web MVC 模块、AspectJ 代理模块、Caching（缓存）模块、JMX（Java 管理扩展）模块、Async（异步处理）模块等。\n\n举例说明\n\n- @EnableWebMvc\n- @EnableTransactionManagement\n- @EnableCaching\n- @EnableMBeanExport\n- @EnableAsync\n\n@Enable 模块驱动编程模式\n\n- 驱动注解：@EnableXXX\n- 导入注解：@Import 具体实现\n- 具体实现\n- 基于 Configuration Class\n- 基于 ImportSelector 接口实现\n- 基于 ImportBeanDefinitionRegistrar 接口实现\n\n## Spring 条件注解\n\n基于配置条件注解 - @org.springframework.context.annotation.Profile\n\n- 关联对象 - org.springframework.core.env.Environment 中的 Profiles\n- 实现变化：从 Spring 4.0 开始，@Profile 基于 @Conditional 实现\n\n基于编程条件注解 - @org.springframework.context.annotation.Conditional\n\n- 关联对象 - org.springframework.context.annotation.Condition 具体实现\n\n@Conditional 实现原理\n\n- 上下文对象 - org.springframework.context.annotation.ConditionContext\n- 条件判断 - org.springframework.context.annotation.ConditionEvaluator\n- 配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase\n- 判断入口\n  - org.springframework.context.annotation.ConfigurationClassPostProcessor\n  - org.springframework.context.annotation.ConfigurationClassParser\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"Spring Environment 抽象",headers:[{level:2,title:"理解 Spring Environment 抽象",slug:"理解-spring-environment-抽象",link:"#理解-spring-environment-抽象",children:[]},{level:2,title:"Spring Environment 接口使用场景",slug:"spring-environment-接口使用场景",link:"#spring-environment-接口使用场景",children:[]},{level:2,title:"Environment 占位符处理",slug:"environment-占位符处理",link:"#environment-占位符处理",children:[]},{level:2,title:"理解条件配置 Spring Profiles",slug:"理解条件配置-spring-profiles",link:"#理解条件配置-spring-profiles",children:[]},{level:2,title:"Spring 4 重构 @Profile",slug:"spring-4-重构-profile",link:"#spring-4-重构-profile",children:[]},{level:2,title:"依赖注入 Environment",slug:"依赖注入-environment",link:"#依赖注入-environment",children:[]},{level:2,title:"依赖查找 Environment",slug:"依赖查找-environment",link:"#依赖查找-environment",children:[]},{level:2,title:"依赖注入 @Value",slug:"依赖注入-value",link:"#依赖注入-value",children:[]},{level:2,title:"Spring 类型转换在 Environment 中的运用",slug:"spring-类型转换在-environment-中的运用",link:"#spring-类型转换在-environment-中的运用",children:[]},{level:2,title:"Spring 类型转换在 @Value 中的运用",slug:"spring-类型转换在-value-中的运用",link:"#spring-类型转换在-value-中的运用",children:[]},{level:2,title:"Spring 配置属性源 PropertySource",slug:"spring-配置属性源-propertysource",link:"#spring-配置属性源-propertysource",children:[]},{level:2,title:"Spring 內建的配置属性源",slug:"spring-內建的配置属性源",link:"#spring-內建的配置属性源",children:[]},{level:2,title:"基于注解扩展 Spring 配置属性源",slug:"基于注解扩展-spring-配置属性源",link:"#基于注解扩展-spring-配置属性源",children:[]},{level:2,title:"基于 API 扩展 Spring 配置属性源",slug:"基于-api-扩展-spring-配置属性源",link:"#基于-api-扩展-spring-配置属性源",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/03d838/",pathLocale:"/",extraFields:"---\ntitle: Spring Environment 抽象\ndate: 2022-12-23 09:27:44\norder: 29\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/03d838/\n---\n\n# Spring Environment 抽象\n\n## 理解 Spring Environment 抽象\n\n统一的 Spring 配置属性管理\n\nSpring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）\n\n条件化 Spring Bean 装配管理\n\n通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean\n\n## Spring Environment 接口使用场景\n\n- ⽤于属性占位符处理\n- 用于转换 Spring 配置属性类型\n- 用于存储 Spring 配置属性源（PropertySource）\n- 用于 Profiles 状态的维护\n\n## Environment 占位符处理\n\nSpring 3.1 前占位符处理\n\n- 组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\n- 接口：org.springframework.util.StringValueResolver\n\nSpring 3.1 + 占位符处理\n\n- 组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer\n- 接口：org.springframework.beans.factory.config.EmbeddedValueResolver\n\n## 理解条件配置 Spring Profiles\n\nSpring 3.1 条件配置\n\n- API：org.springframework.core.env.ConfigurableEnvironment\n- 修改：addActiveProfile(String)、setActiveProfiles(String...) 和 setDefaultProfiles(String...)\n- 获取：getActiveProfiles() 和 getDefaultProfiles()\n- 匹配：#acceptsProfiles(String...) 和 acceptsProfiles(Profiles)\n- 注解：@org.springframework.context.annotation.Profile\n\n## Spring 4 重构 @Profile\n\n基于 Spring 4 org.springframework.context.annotation.Condition 接口实现\n\norg.springframework.context.annotation.ProfileCondition\n\n## 依赖注入 Environment\n\n直接依赖注入\n\n- 通过 EnvironmentAware 接口回调\n- 通过 @Autowired 注入 Environment\n\n间接依赖注入\n\n- 通过 ApplicationContextAware 接口回调\n- 通过 @Autowired 注入 ApplicationContext\n\n## 依赖查找 Environment\n\n直接依赖查找\n\n- 通过 org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME\n\n间接依赖查找\n\n- 通过 org.springframework.context.ConfigurableApplicationContext#getEnvironment\n\n## 依赖注入 @Value\n\n通过注入 @Value\n\n实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n\n## Spring 类型转换在 Environment 中的运用\n\nEnvironment 底层实现\n\n- 底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver\n- 核心方法 - convertValueIfNecessary(Object,Class)\n- 底层服务 - org.springframework.core.convert.ConversionService\n- 默认实现 - org.springframework.core.convert.support.DefaultConversionService\n\n## Spring 类型转换在 @Value 中的运用\n\n@Value 底层实现\n\n- 底层实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n  - org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency\n- 底层服务 - org.springframework.beans.TypeConverter\n  - 默认实现 - org.springframework.beans.TypeConverterDelegate\n    - java.beans.PropertyEditor\n    - org.springframework.core.convert.ConversionService\n\n## Spring 配置属性源 PropertySource\n\n- API\n  - 单配置属性源 - org.springframework.core.env.PropertySource\n  - 多配置属性源 - org.springframework.core.env.PropertySources\n- 注解\n  - 单配置属性源 - @org.springframework.context.annotation.PropertySource\n  - 多配置属性源 - @org.springframework.context.annotation.PropertySources\n- 关联\n  - 存储对象 - org.springframework.core.env.MutablePropertySources\n  - 关联方法 - org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\n## Spring 內建的配置属性源\n\n內建 PropertySource\n\n| PropertySource 类型                                                  | 说明                      |\n| -------------------------------------------------------------------- | ------------------------- |\n| org.springframework.core.env.CommandLinePropertySource               | 命令行配置属性源          |\n| org.springframework.jndi.JndiPropertySource                          | JDNI 配置属性源           |\n| org.springframework.core.env.PropertiesPropertySource                | Properties 配置属性源     |\n| org.springframework.web.context.support.ServletConfigPropertySource  | Servlet 配置属性源        |\n| org.springframework.web.context.support.ServletContextPropertySource | ServletContext 配置属性源 |\n| org.springframework.core.env.SystemEnvironmentPropertySource         | 环境变量配置属性源        |\n\n## 基于注解扩展 Spring 配置属性源\n\n@org.springframework.context.annotation.PropertySource 实现原理\n\n- 入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass\n  - org.springframework.context.annotation.ConfigurationClassParser#processPropertySource\n- 4.3 新增语义\n  - 配置属性字符编码 - encoding\n  - org.springframework.core.io.support.PropertySourceFactory\n- 适配对象 - org.springframework.core.env.CompositePropertySource\n\n## 基于 API 扩展 Spring 配置属性源\n\n- Spring 应用上下文启动前装配 PropertySource\n- Spring 应用上下文启动后装配 PropertySource\n\n## 问题\n\n简单介绍 Spring Environment 接口？\n\n- 核心接口 - org.springframework.core.env.Environment\n- 父接口 - org.springframework.core.env.PropertyResolver\n- 可配置接口 - org.springframework.core.env.ConfigurableEnvironment\n- 职责：\n  - 管理 Spring 配置属性源\n  - 管理 Profiles\n\n## 参考资料\n\n- [Spring 官方文档之 Core Technologies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans)\n- [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)"},{title:"SpringBoot 之快速入门",headers:[{level:2,title:"Spring Boot 简介",slug:"spring-boot-简介",link:"#spring-boot-简介",children:[]},{level:2,title:"Spring Boot 系统要求",slug:"spring-boot-系统要求",link:"#spring-boot-系统要求",children:[]},{level:2,title:"部署第一个 Spring Boot 项目",slug:"部署第一个-spring-boot-项目",link:"#部署第一个-spring-boot-项目",children:[{level:3,title:"环境检查",slug:"环境检查",link:"#环境检查",children:[]},{level:3,title:"创建 pom",slug:"创建-pom",link:"#创建-pom",children:[]},{level:3,title:"添加依赖",slug:"添加依赖",link:"#添加依赖",children:[]},{level:3,title:"编写代码",slug:"编写代码",link:"#编写代码",children:[]},{level:3,title:"运行示例",slug:"运行示例",link:"#运行示例",children:[]},{level:3,title:"创建可执行 jar",slug:"创建可执行-jar",link:"#创建可执行-jar",children:[]}]},{level:2,title:"通过 SPRING INITIALIZR 创建 Spring Boot 项目",slug:"通过-spring-initializr-创建-spring-boot-项目",link:"#通过-spring-initializr-创建-spring-boot-项目",children:[{level:3,title:"创建项目",slug:"创建项目",link:"#创建项目",children:[]},{level:3,title:"项目说明",slug:"项目说明",link:"#项目说明",children:[]},{level:3,title:"编写 REST 服务",slug:"编写-rest-服务",link:"#编写-rest-服务",children:[]},{level:3,title:"编写单元测试用例",slug:"编写单元测试用例",link:"#编写单元测试用例",children:[]},{level:3,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/950e4d/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之快速入门\ndate: 2021-12-10 18:22:26\norder: 31\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/950e4d/\n---\n\n# SpringBoot 之快速入门\n\n## Spring Boot 简介\n\nSpring Boot 可以让使用者非常方便的创建 Spring 应用。\n\nSpring Boot 的目标是：\n\n- 为所有 Spring 开发者提供更快且可广泛访问的入门体验。\n- 开箱即用\n- 提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）\n- 完全不需要代码生成，也不需要 XML 配置。\n\n## Spring Boot 系统要求\n\nSpring Boot 的构建工具要求：\n\n| Build Tool | Version               |\n| :--------- | :-------------------- |\n| Maven      | 3.5+                  |\n| Gradle     | 6.8.x, 6.9.x, and 7.x |\n\nSpring Boot 支持的 Servlet 容器：\n\n| Name         | Servlet Version |\n| :----------- | :-------------- |\n| Tomcat 9.0   | 4.0             |\n| Jetty 9.4    | 3.1             |\n| Jetty 10.0   | 4.0             |\n| Undertow 2.0 | 4.0             |\n\n## 部署第一个 Spring Boot 项目\n\n> 本节介绍如何开发一个小的“Hello World!” web 应用示例，来展示 Spring Boot 的一些关键功能。我们使用 Maven 来构建这个项目，因为大多数 IDE 都支持它。\n\n### 环境检查\n\nSpring Boot 项目依赖于 Java 环境和 Mave，开始项目之前需要先检查一下环境。\n\n本地是否已安装 Java：\n\n```shell\n$ java -version\njava version "1.8.0_102"\nJava(TM) SE Runtime Environment (build 1.8.0_102-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)\n```\n\n本地是否已安装 Maven：\n\n```java\n$ mvn -v\nApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)\nMaven home: /usr/local/Cellar/maven/3.3.9/libexec\nJava version: 1.8.0_102, vendor: Oracle Corporation\n```\n\n### 创建 pom\n\n我们需要从创建 Maven pom.xml 文件开始。 pom.xml 是 Maven 用于构建项目的配置文件。\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>myproject</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- Additional lines to be added here... --\x3e\n\n</project>\n```\n\n使用者可以通过运行 mvn package 来测试它\n\n### 添加依赖\n\nSpring Boot 提供了许多启动器（Starters）以应对不同的使用场景。使用者可将 jars 添加到类路径中。我们的示例程序在 POM 的 parent 使用 spring-boot-starter-parent。 spring-boot-starter-parent 是一个特殊的启动器，提供有用的 Maven 默认值。它还提供了一个依赖项的版本管理，可以让使用者使用时不必显示指定版本。\n\n其他启动器（Starters）提供了各种针对不同使用场景的功能。比如，我们需要开发一个 Web 应用程序，就可以添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令来查看我们当前拥有的 maven 依赖：\n\n```shell\n$ mvn dependency:tree\n\n[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT\n```\n\nmvn dependency:tree 命令打印项目依赖项的层级结构。可以看到 spring-boot-starter-parent 本身没有提供任何依赖。要添加必要的依赖，需要编辑 pom.xml 并在 `<dependencies>` 部分添加 spring-boot-starter-web 依赖项：\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### 编写代码\n\n要运行应用程序，我们需要创建一个启动类。默认情况下，Maven 从 `src/main/java` 编译源代码，因此您需要创建该目录结构，然后添加一个名为 `src/main/java/MyApplication.java` 的文件以包含以下代码：\n\n```java\n@RestController\n@EnableAutoConfiguration\npublic class MyApplication {\n\n    @RequestMapping("/")\n    String home() {\n        return "Hello World!";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n\n}\n```\n\n说明：\n\n@RestController 注解告诉 Spring，这个类是用来处理 Rest 请求的。\n\n`@RequestMapping` 注解提供了“路由”信息。它告诉 Spring 任何带有 `/` 路径的 HTTP 请求都应该映射到 `home` 方法。 `@RestController` 注解告诉 Spring 将结果字符串直接呈现给调用者。\n\n`@EnableAutoConfiguration` 注解告诉 Spring Boot 根据你添加的 jar 依赖去自动装配 Spring。\n\n> 自动配置旨在与“Starters”配合使用，但这两个概念并没有直接联系。您可以自由选择 starters 之外的 jar 依赖项。 Spring Boot 仍然尽力自动配置您的应用程序。\n\nSpring Boot 的 main 方法通过调用 run 委托给 Spring Boot 的 `SpringApplication` 类。 `SpringApplication` 引导我们的应用程序，启动 Spring，进而启动自动配置的 Tomcat Web 服务器。我们需要将 `MyApplication.class` 作为参数传递给 run 方法，以告诉 `SpringApplication` 哪个是入口类。还传递 args 数组以公开任何命令行参数。\n\n### 运行示例\n\n此时，您的应用程序应该可以工作了。由于您使用了 spring-boot-starter-parent POM，因此您有一个有用的运行目标，可用于启动应用程序。从项目根目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似于以下内容的输出：\n\n```shell\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.222 seconds (JVM running for 6.514)\n```\n\n如果您打开 Web 浏览器访问 localhost:8080，您应该会看到以下输出：\n\n```\nHello World!\n```\n\n要正常退出应用程序，请按 `ctrl-c`。\n\n### 创建可执行 jar\n\n要创建一个可执行的 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。为此，请在依赖项部分下方插入以下行：\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n保存 pom.xml 并从命令行运行 mvn package，如下所示：\n\n```shell\n$ mvn package\n\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building myproject 0.0.1-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] .... ..\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar\n[INFO]\n[INFO] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n```\n\n如果您查看 target 目录，应该会看到 `myproject-0.0.1-SNAPSHOT.jar`。该文件的大小应约为 10 MB。如果想看里面，可以使用 jar tvf，如下：\n\n```shell\n$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar\n```\n\n您还应该在目标目录中看到一个更小的名为 `myproject-0.0.1-SNAPSHOT.jar.original` 的文件。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用 java -jar 命令，如下所示：\n\n```\n$ java -jar target/myproject-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.536 seconds (JVM running for 2.864)\n```\n\n和以前一样，要退出应用程序，请按 `ctrl-c`。\n\n## 通过 SPRING INITIALIZR 创建 Spring Boot 项目\n\n### 创建项目\n\n通过 `SPRING INITIALIZR` 工具产生基础项目\n\n1. 访问：`http://start.spring.io/`\n2. 选择构建工具`Maven Project`、Spring Boot 版本 `1.5.10` 以及一些工程基本信息，可参考下图所示：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/start.spring.io.png)\n\n3. 点击`Generate Project`下载项目压缩包\n4. 解压压缩包，包中已是一个完整的项目。\n\n如果你使用 Intellij 作为 IDE，那么你可以直接使用 SPRING INITIALIZR，参考下图操作：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/intellij-spring-initializr.gif)\n\n### 项目说明\n\n**重要文件**\n\n- `src/main/java` 路径下的 `Chapter1Application` 类 ：程序入口\n- `src/main/resources` 路径下的 `application.properties` ：项目配置文件\n- `src/test/java` 路径下的 `Chapter01ApplicationTests` ：程序测试入口\n\n**pom.xml**\n\npom 中指定 parent 为以下内容，表示此项目继承了 `spring-boot-starter-parent` 的 maven 配置（主要是指定了常用依赖、插件的版本）。\n\n```xml\n<parent>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-parent</artifactId>\n <version>1.5.10.RELEASE</version>\n <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n```\n\n此外，pom 中默认引入两个依赖包，和一个插件。\n\n```xml\n<dependencies>\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n </dependency>\n\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-maven-plugin</artifactId>\n  </plugin>\n </plugins>\n</build>\n```\n\n- `spring-boot-starter-web`：核心模块，包括自动配置支持、日志和 YAML。\n- `spring-boot-starter-test`：测试模块，包括 JUnit、Hamcrest、Mockito。\n- `spring-boot-maven-plugin`：spring boot 插件， 提供了一系列 spring boot 相关的 maven 操作。\n  - `spring-boot:build-info`，生成 Actuator 使用的构建信息文件 build-info.properties\n  - `spring-boot:repackage`，默认 goal。在 mvn package 之后，再次打包可执行的 jar/war，同时保留 mvn package 生成的 jar/war 为.origin\n  - `spring-boot:run`，运行 Spring Boot 应用\n  - `spring-boot:start`，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n  - `spring-boot:stop`，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n\n### 编写 REST 服务\n\n- 创建 `package` ，名为 `io.github.zp.springboot.chapter1.web`（根据项目情况修改）\n- 创建 `HelloController` 类，内容如下：\n\n```java\n@RestController\npublic class HelloController {\n\n    @RequestMapping("/hello")\n    public String index() {\n        return "Hello World";\n    }\n\n}\n```\n\n- 启动主程序 `XXXApplication`，打开浏览器访问`http://localhost:8080/hello` ，可以看到页面输出`Hello World`\n\n### 编写单元测试用例\n\n在 `XXXApplicationTests` 类中编写一个简单的单元测试来模拟 HTTP 请求，具体如下：\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = MockServletContext.class)\n@WebAppConfiguration\npublic class SpringBootHelloWorldApplicationTest {\n\n\tprivate MockMvc mvc;\n\n\t@Before\n\tpublic void setUp() {\n\t\tmvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n\t}\n\n\t@Test\n\tpublic void getHello() throws Exception {\n\t\tmvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(equalTo("Hello World")));\n\t}\n\n}\n```\n\n使用`MockServletContext`来构建一个空的`WebApplicationContext`，这样我们创建的`HelloController`就可以在`@Before`函数中创建并传递到`MockMvcBuilders.standaloneSetup（）`函数中。\n\n- 注意引入下面内容，让`status`、`content`、`equalTo`函数可用\n\n```java\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n```\n\n至此已完成目标，通过 Maven 构建了一个空白 Spring Boot 项目，再通过引入 web 模块实现了一个简单的请求处理。\n\n### 示例源码\n\n> 示例源码：[spring-boot-web-helloworld](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/web/spring-boot-web-helloworld)\n\n## 参考资料\n\n- [Spring Boot 官方文档之 Getting Started](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started)'},{title:"SpringBoot 之属性加载详解",headers:[{level:2,title:"加载 property 顺序",slug:"加载-property-顺序",link:"#加载-property-顺序",children:[]},{level:2,title:"随机属性",slug:"随机属性",link:"#随机属性",children:[]},{level:2,title:"命令行属性",slug:"命令行属性",link:"#命令行属性",children:[]},{level:2,title:"Application 属性文件",slug:"application-属性文件",link:"#application-属性文件",children:[]},{level:2,title:"Profile 特定属性",slug:"profile-特定属性",link:"#profile-特定属性",children:[]},{level:2,title:"属性中的占位符",slug:"属性中的占位符",link:"#属性中的占位符",children:[]},{level:2,title:"YAML 属性",slug:"yaml-属性",link:"#yaml-属性",children:[{level:3,title:"访问属性",slug:"访问属性",link:"#访问属性",children:[]},{level:3,title:"多 profile 配置",slug:"多-profile-配置",link:"#多-profile-配置",children:[]},{level:3,title:"YAML 的缺点",slug:"yaml-的缺点",link:"#yaml-的缺点",children:[]}]},{level:2,title:"属性前缀",slug:"属性前缀",link:"#属性前缀",children:[]},{level:2,title:"属性松散绑定规则",slug:"属性松散绑定规则",link:"#属性松散绑定规则",children:[]},{level:2,title:"属性转换",slug:"属性转换",link:"#属性转换",children:[{level:3,title:"时间单位转换",slug:"时间单位转换",link:"#时间单位转换",children:[]},{level:3,title:"数据大小转换",slug:"数据大小转换",link:"#数据大小转换",children:[]}]},{level:2,title:"校验属性",slug:"校验属性",link:"#校验属性",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/0fb992/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之属性加载详解\ndate: 2019-01-10 11:55:54\norder: 32\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/0fb992/\n---\n\n# SpringBoot 之属性加载详解\n\n## 加载 property 顺序\n\nSpring Boot 加载 property 顺序如下：\n\n1. [Devtools 全局配置](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-globalsettings) (当 devtools 被激活 `~/.spring-boot-devtools.properties`).\n2. [测试环境中的 `@TestPropertySource` 注解配置](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/TestPropertySource.html)\n3. 测试环境中的属性 `properties`：[`@SpringBootTest`](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html) 和 [测试注解](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests).\n4. 命令行参数\n5. `SPRING_APPLICATION_JSON` 属性\n6. `ServletConfig` 初始化参数\n7. `ServletContext` 初始化参数\n8. JNDI attributes from 通过 `java:comp/env` 配置的 JNDI 属性\n9. Java 系统属性 (`System.getProperties()`)\n10. 操作系统环境比那里\n11. `RandomValuePropertySource` 加载 `random.*` 形式的属性\n12. jar 包外的 `application-{profile}.properties` 或 `application-{profile}.yml` 配置\n13. jar 包内的 `application-{profile}.properties` 或 `application-{profile}.yml` 配置\n14. jar 包外的 `application.properties` 或 `application.yml` 配置\n15. jar 包内的 `application.properties` 或 `application.yml` 配置\n16. `@PropertySource` 绑定的配置\n17. 默认属性 (通过 `SpringApplication.setDefaultProperties` 指定)\n\n## 随机属性\n\n`RandomValuePropertySource` 类用于配置随机值。\n\n示例：\n\n```properties\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n```\n\n## 命令行属性\n\n默认情况下， `SpringApplication` 会获取 `--` 参数（例如 `--server.port=9000` ），并将这个 `property` 添加到 Spring 的 `Environment` 中。\n\n如果不想加载命令行属性，可以通过 `SpringApplication.setAddCommandLineProperties(false)` 禁用。\n\n## Application 属性文件\n\n`SpringApplication` 会自动加载以下路径下的 `application.properties` 配置文件，将其中的属性读到 Spring 的 `Environment` 中。\n\n1. 当前目录的 `/config` 子目录\n2. 当前目录\n3. classpath 路径下的 `/config` package\n4. classpath 根路径\n\n> 注：\n>\n> 以上列表的配置文件会根据顺序，后序的配置会覆盖前序的配置。\n>\n> 你可以选择 [YAML(yml)](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-yaml) 配置文件替换 properties 配置文件。\n\n如果不喜欢 `application.properties` 作为配置文件名，可以使用 `spring.config.name` 环境变量替换：\n\n```\n$ java -jar myproject.jar --spring.config.name=myproject\n```\n\n可以使用 `spring.config.location` 环境变量指定配置文件路径：\n\n```properties\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties\n```\n\n## Profile 特定属性\n\n如果定义 `application-{profile}.properties` 形式的配置文件，将被视为 `profile` 环境下的特定配置。\n\n可以通过 `spring.profiles.active` 参数来激活 profile，如果没有激活的 profile,默认会加载 `application-default.properties` 中的配置。\n\n## 属性中的占位符\n\n`application.properties` 中的值会被 `Environment` 过滤，所以，可以引用之前定义的属性。\n\n```\napp.name=MyApp\napp.description=${app.name} is a Spring Boot application\n```\n\n> 注：你可以使用此技术来创建 Spring Boot 属性变量。请参考： [Section 77.4, “Use ‘Short’ Command Line Arguments](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-use-short-command-line-arguments)\n\n## YAML 属性\n\nSpring 框架有两个类支持加载 YAML 文件。\n\n- `YamlPropertiesFactoryBean` 将 YAML 文件的配置加载为 `Properties` 。\n- `YamlMapFactoryBean` 将 YAML 文件的配置加载为 `Map` 。\n\n示例 1\n\n```yaml\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: Developer Setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: My Cool App\n```\n\n等价于：\n\n```properties\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=My Cool App\n```\n\nYAML 支持列表形式，等价于 property 中的 `[index]` ：\n\n```yaml\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com\n```\n\n等价于\n\n```properties\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com\n```\n\n### 访问属性\n\n`YamlPropertySourceLoader` 类会将 YAML 配置转化为 Spring `Environment` 类中的 `PropertySource` 。然后，你可以如同 properties 文件中的属性一样，使用 `@Value` 注解来访问 YAML 中配置的属性。\n\n### 多 profile 配置\n\n```yaml\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120\n```\n\n### YAML 的缺点\n\n注：YAML 注解中的属性不能通过 `@PropertySource` 注解来访问。所以，如果你的项目中使用了一些自定义属性文件，建议不要用 YAML。\n\n## 属性前缀\n\n```java\npackage com.example;\n\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix="acme")\npublic class AcmeProperties {\n\n\tprivate boolean enabled;\n\n\tprivate InetAddress remoteAddress;\n\n\tprivate final Security security = new Security();\n\n\tpublic boolean isEnabled() { ... }\n\n\tpublic void setEnabled(boolean enabled) { ... }\n\n\tpublic InetAddress getRemoteAddress() { ... }\n\n\tpublic void setRemoteAddress(InetAddress remoteAddress) { ... }\n\n\tpublic Security getSecurity() { ... }\n\n\tpublic static class Security {\n\n\t\tprivate String username;\n\n\t\tprivate String password;\n\n\t\tprivate List<String> roles = new ArrayList<>(Collections.singleton("USER"));\n\n\t\tpublic String getUsername() { ... }\n\n\t\tpublic void setUsername(String username) { ... }\n\n\t\tpublic String getPassword() { ... }\n\n\t\tpublic void setPassword(String password) { ... }\n\n\t\tpublic List<String> getRoles() { ... }\n\n\t\tpublic void setRoles(List<String> roles) { ... }\n\n\t}\n}\n```\n\n相当于支持配置以下属性：\n\n- `acme.enabled`\n- `acme.remote-address`\n- `acme.security.username`\n- `acme.security.password`\n- `acme.security.roles`\n\n然后，你需要使用 `@EnableConfigurationProperties` 注解将属性类注入配置类中。\n\n```java\n@Configuration\n@EnableConfigurationProperties(AcmeProperties.class)\npublic class MyConfiguration {\n}\n```\n\n## 属性松散绑定规则\n\nSpring Boot 属性名绑定比较松散。\n\n以下属性 key 都是等价的：\n\n| Property                            | Note     |\n| ----------------------------------- | -------- |\n| `acme.my-project.person.first-name` | `-` 分隔 |\n| `acme.myProject.person.firstName`   | 驼峰命名 |\n| `acme.my_project.person.first_name` | `_` 分隔 |\n| `ACME_MYPROJECT_PERSON_FIRSTNAME`   | 大写字母 |\n\n## 属性转换\n\n如果需要类型转换，你可以提供一个 `ConversionService` bean (一个名叫 `conversionService` 的 bean) 或自定义属性配置 (一个 `CustomEditorConfigurer` bean) 或自定义的 `Converters` (被 `@ConfigurationPropertiesBinding` 注解修饰的 bena)。\n\n### 时间单位转换\n\nSpring 使用 `java.time.Duration` 类代表时间大小，以下场景适用：\n\n- 除非指定 `@DurationUnit` ，否则一个 long 代表的时间为毫秒。\n- ISO-8601 标准格式（ [`java.time.Duration`](https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-) 的实现就是参照此标准）\n- 你也可以使用以下支持的单位：\n  - `ns` - 纳秒\n  - `us` - 微秒\n  - `ms` - 毫秒\n  - `s` - 秒\n  - `m` - 分\n  - `h` - 时\n  - `d` - 天\n\n示例：\n\n```java\n@ConfigurationProperties("app.system")\npublic class AppSystemProperties {\n\n\t@DurationUnit(ChronoUnit.SECONDS)\n\tprivate Duration sessionTimeout = Duration.ofSeconds(30);\n\n\tprivate Duration readTimeout = Duration.ofMillis(1000);\n\n\tpublic Duration getSessionTimeout() {\n\t\treturn this.sessionTimeout;\n\t}\n\n\tpublic void setSessionTimeout(Duration sessionTimeout) {\n\t\tthis.sessionTimeout = sessionTimeout;\n\t}\n\n\tpublic Duration getReadTimeout() {\n\t\treturn this.readTimeout;\n\t}\n\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n}\n```\n\n### 数据大小转换\n\nSpring 使用 `DataSize` 类代表数据大小，以下场景适用：\n\n- long 值（默认视为 byte）\n- 你也可以使用以下支持的单位：\n  - `B`\n  - `KB`\n  - `MB`\n  - `GB`\n  - `TB`\n\n示例：\n\n```java\n@ConfigurationProperties("app.io")\npublic class AppIoProperties {\n\n\t@DataSizeUnit(DataUnit.MEGABYTES)\n\tprivate DataSize bufferSize = DataSize.ofMegabytes(2);\n\n\tprivate DataSize sizeThreshold = DataSize.ofBytes(512);\n\n\tpublic DataSize getBufferSize() {\n\t\treturn this.bufferSize;\n\t}\n\n\tpublic void setBufferSize(DataSize bufferSize) {\n\t\tthis.bufferSize = bufferSize;\n\t}\n\n\tpublic DataSize getSizeThreshold() {\n\t\treturn this.sizeThreshold;\n\t}\n\n\tpublic void setSizeThreshold(DataSize sizeThreshold) {\n\t\tthis.sizeThreshold = sizeThreshold;\n\t}\n\n}\n```\n\n## 校验属性\n\n```java\n@ConfigurationProperties(prefix="acme")\n@Validated\npublic class AcmeProperties {\n\n\t@NotNull\n\tprivate InetAddress remoteAddress;\n\n\t@Valid\n\tprivate final Security security = new Security();\n\n\t// ... getters and setters\n\n\tpublic static class Security {\n\n\t\t@NotEmpty\n\t\tpublic String username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}\n```\n\n你也可以自定义一个名为 `configurationPropertiesValidator` 的校验器 Bean。获取这个 `@Bean` 的方法必须声明为 `static`。\n\n## 示例源码\n\n> 示例源码：[spring-boot-property](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-property)\n\n## 参考资料\n\n- [Spring Boot 官方文档之 boot-features-external-config](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config)'},{title:"SpringBoot 之 Profile",headers:[{level:2,title:"区分环境的配置",slug:"区分环境的配置",link:"#区分环境的配置",children:[{level:3,title:"properties 配置",slug:"properties-配置",link:"#properties-配置",children:[]},{level:3,title:"yml 配置",slug:"yml-配置",link:"#yml-配置",children:[]}]},{level:2,title:"区分环境的代码",slug:"区分环境的代码",link:"#区分环境的代码",children:[{level:3,title:"修饰类",slug:"修饰类",link:"#修饰类",children:[]},{level:3,title:"修饰注解",slug:"修饰注解",link:"#修饰注解",children:[]},{level:3,title:"修饰方法",slug:"修饰方法",link:"#修饰方法",children:[]}]},{level:2,title:"激活 profile",slug:"激活-profile",link:"#激活-profile",children:[{level:3,title:"插件激活 profile",slug:"插件激活-profile",link:"#插件激活-profile",children:[]},{level:3,title:"main 方法激活 profile",slug:"main-方法激活-profile",link:"#main-方法激活-profile",children:[]},{level:3,title:"jar 激活 profile",slug:"jar-激活-profile",link:"#jar-激活-profile",children:[]},{level:3,title:"在 Java 代码中激活 profile",slug:"在-java-代码中激活-profile",link:"#在-java-代码中激活-profile",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cb598e/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之 Profile\ndate: 2019-11-18 14:55:01\norder: 33\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/cb598e/\n---\n\n# SpringBoot 之 Profile\n\n> 一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。\n>\n> 关键词： `@Profile`、`spring.profiles.active`\n\n## 区分环境的配置\n\n### properties 配置\n\n假设，一个应用的工作环境有：dev、test、prod\n\n那么，我们可以添加 4 个配置文件：\n\n- `applcation.properties` - 公共配置\n- `application-dev.properties` - 开发环境配置\n- `application-test.properties` - 测试环境配置\n- `application-prod.properties` - 生产环境配置\n\n在 `applcation.properties` 文件中可以通过以下配置来激活 profile：\n\n```properties\nspring.profiles.active = test\n```\n\n### yml 配置\n\n与 properties 文件类似，我们也可以添加 4 个配置文件：\n\n- `applcation.yml` - 公共配置\n- `application-dev.yml` - 开发环境配置\n- `application-test.yml` - 测试环境配置\n- `application-prod.yml` - 生产环境配置\n\n在 `applcation.yml` 文件中可以通过以下配置来激活 profile：\n\n```yml\nspring:\n  profiles:\n    active: prod\n```\n\n此外，yml 文件也可以在一个文件中完成所有 profile 的配置：\n\n```yml\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置\n```\n\n注意：不同 profile 之间通过 `---` 分割\n\n## 区分环境的代码\n\n使用 `@Profile` 注解可以指定类或方法在特定的 Profile 环境生效。\n\n### 修饰类\n\n```java\n@Configuration\n@Profile("production")\npublic class JndiDataConfig {\n\n    @Bean(destroyMethod="")\n    public DataSource dataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n```\n\n### 修饰注解\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Profile("production")\npublic @interface Production {\n}\n```\n\n### 修饰方法\n\n```java\n@Configuration\npublic class AppConfig {\n\n    @Bean("dataSource")\n    @Profile("development")\n    public DataSource standaloneDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript("classpath:com/bank/config/sql/schema.sql")\n            .addScript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @Bean("dataSource")\n    @Profile("production")\n    public DataSource jndiDataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n```\n\n## 激活 profile\n\n### 插件激活 profile\n\n```\nspring-boot:run -Drun.profiles=prod\n```\n\n### main 方法激活 profile\n\n```\n--spring.profiles.active=prod\n```\n\n### jar 激活 profile\n\n```\njava -jar -Dspring.profiles.active=prod *.jar\n```\n\n### 在 Java 代码中激活 profile\n\n直接指定环境变量来激活 profile：\n\n```java\nSystem.setProperty("spring.profiles.active", "test");\n```\n\n在 Spring 容器中激活 profile：\n\n```java\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles("development");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh();\n```\n\n## 示例源码\n\n> 示例源码：[spring-boot-profile](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-profile)\n\n## 参考资料\n\n- [Spring 官方文档之 Bean Definition Profiles](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles)\n- [Spring Boot 官方文档之 boot-features-profiles](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-profiles)'},{title:"Spring 核心",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/5e7c20/",pathLocale:"/",extraFields:"---\ntitle: Spring 核心\ndate: 2020-02-26 23:47:47\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring核心\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/5e7c20/\nhidden: true\nindex: false\n---\n\n# Spring 核心\n\n> 章节主要针对：Spring & Spring Boot 框架的核心技术。如；Spring Bean、IoC、依赖查找、依赖注入、AOP、数据绑定、资源管理等。\n\n## 📖 内容\n\n- [Spring Bean](01.SpringBean.md)\n- [Spring IoC](02.SpringIoC.md)\n- [Spring 依赖查找](03.Spring依赖查找.md)\n- [Spring 依赖注入](04.Spring依赖注入.md)\n- [Spring IoC 依赖来源](05.SpringIoC依赖来源.md)\n- [Spring Bean 作用域](06.SpringBean作用域.md)\n- [Spring Bean 生命周期](07.SpringBean生命周期.md)\n- [Spring 配置元数据](08.Spring配置元数据.md)\n- [Spring AOP](10.SpringAop.md)\n- [Spring 资源管理](20.Spring资源管理.md)\n- [Spring 校验](21.Spring校验.md)\n- [Spring 数据绑定](22.Spring数据绑定.md)\n- [Spring 类型转换](23.Spring类型转换.md)\n- [Spring EL 表达式](24.SpringEL.md)\n- [Spring 事件](25.Spring事件.md)\n- [Spring 国际化](26.Spring国际化.md)\n- [Spring 泛型处理](27.Spring泛型处理.md)\n- [Spring 注解](28.Spring注解.md)\n- [SpringBoot 教程之快速入门](31.SpringBoot之快速入门.md)\n- [SpringBoot 之属性加载](32.SpringBoot之属性加载.md)\n- [SpringBoot 之 Profile](33.SpringBoot之Profile.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"Spring 之数据源",headers:[{level:2,title:"Spring Boot 数据源基本配置",slug:"spring-boot-数据源基本配置",link:"#spring-boot-数据源基本配置",children:[]},{level:2,title:"Spring Boot 连接嵌入式数据源",slug:"spring-boot-连接嵌入式数据源",link:"#spring-boot-连接嵌入式数据源",children:[]},{level:2,title:"Spring Boot 连接池化数据源",slug:"spring-boot-连接池化数据源",link:"#spring-boot-连接池化数据源",children:[{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",link:"#引入-spring-boot-依赖",children:[]},{level:3,title:"测试单数据源连接",slug:"测试单数据源连接",link:"#测试单数据源连接",children:[]}]},{level:2,title:"Spring Boot 连接多数据源",slug:"spring-boot-连接多数据源",link:"#spring-boot-连接多数据源",children:[{level:3,title:"多数据源配置",slug:"多数据源配置",link:"#多数据源配置",children:[]},{level:3,title:"测试多数据源连接",slug:"测试多数据源连接",link:"#测试多数据源连接",children:[]}]},{level:2,title:"Spring 之数据源",slug:"spring-之数据源-1",link:"#spring-之数据源-1",children:[{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",link:"#引入-spring-依赖",children:[]},{level:3,title:"Spring 配置数据源",slug:"spring-配置数据源",link:"#spring-配置数据源",children:[]}]},{level:2,title:"SpringBoot 数据源配置",slug:"springboot-数据源配置",link:"#springboot-数据源配置",children:[]},{level:2,title:"DataSourceAutoConfiguration 类",slug:"datasourceautoconfiguration-类",link:"#datasourceautoconfiguration-类",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1b774c/",pathLocale:"/",extraFields:'---\ntitle: Spring 之数据源\ndate: 2017-10-20 09:27:55\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 数据库\n  - DataSource\npermalink: /pages/1b774c/\n---\n\n# Spring 之数据源\n\n> 本文基于 Spring Boot 2.7.3 版本。\n\n## Spring Boot 数据源基本配置\n\nSpring Boot 提供了一系列 `spring.datasource.*` 配置来控制 `DataSource` 的配置。用户可以在 `application.properties` 或 `application.yml` 文件中指定数据源配置。这些配置项维护在 [`DataSourceProperties`](https://github.com/spring-projects/spring-boot/tree/v2.7.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java) 。\n\n下面是一个最基本的 mysql 数据源配置示例（都是必填项）：\n\n```properties\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root\n```\n\n需要根据实际情况，替换 `url`、`username`、`password`。\n\n## Spring Boot 连接嵌入式数据源\n\n使用内存嵌入式数据库开发应用程序通常很方便。显然，内存数据库不提供持久存储。使用者需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。\n\nSpring Boot 可以自动配置嵌入式数据库 [H2](https://www.h2database.com/)、[HSQL](https://hsqldb.org/) 和 [Derby](https://db.apache.org/derby/)。使用者无需提供任何连接 URL，只需要包含对要使用的嵌入式数据库的构建依赖项。如果类路径上有多个嵌入式数据库，需要设置 `spring.datasource.embedded-database-connection` 配置属性来控制使用哪一个。将该属性设置为 none 会禁用嵌入式数据库的自动配置。\n\n> 注意：如果在测试中使用此功能，无论使用多少应用程序上下文，整个测试套件都会重用同一个数据库。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 `spring.datasource.generate-unique-name` 设置为 true。\n\n下面，通过一个实例展示如何连接 H2 嵌入式数据库。\n\n（1）在 pom.xml 中引入所需要的依赖：\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>com.h2database</groupId>\n  <artifactId>h2</artifactId>\n</dependency>\n```\n\n（2）数据源配置\n\n```properties\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.Driver\nspring.datasource.username = sa\nspring.datasource.password =\n```\n\n## Spring Boot 连接池化数据源\n\n> 完整示例：[spring-boot-data-jdbc](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/spring-boot-data-jdbc)\n\n在生产环境中，出于性能考虑，一般会通过数据库连接池连接数据源。\n\n除了 [`DataSourceProperties`](https://github.com/spring-projects/spring-boot/tree/v2.7.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java) 中的数据源通用配置以外，Spring Boot 还支持通过使用类似`spring.datasource.hikari.*`、`spring.datasource.tomcat.*`、`spring.datasource.dbcp2.*` 和 `spring.datasource.oracleucp.*` 的前缀来配置指定的数据库连接池属性。\n\n下面，就是一份 hikari 的连接池配置示例：\n\n```properties\n# 连接池名称\nspring.datasource.hikari.pool-name = SpringTutorialHikariPool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000\n```\n\nSpring Boot 会按以下顺序检测连接池是否可用，如果可用就选择对应的池化 `DataSource`：\n\nHikariCP -> Tomcat pooling DataSource -> DBCP2 -> Oracle UCP\n\n用户也可以通过 `spring.datasource.type` 来指定数据源类型。\n\n此外，也可以使用 `DataSourceBuilder` 手动配置其他连接池。如果自定义 DataSource bean，则不会发生自动配置。 `DataSourceBuilder` 支持以下连接池：\n\n- HikariCP\n- Tomcat pooling `Datasource`\n- Commons DBCP2\n- Oracle UCP & `OracleDataSource`\n- Spring Framework’s `SimpleDriverDataSource`\n- H2 `JdbcDataSource`\n- PostgreSQL `PGSimpleDataSource`\n- C3P0\n\n### 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（[Spring Initializr](https://start.spring.io/)）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n### 测试单数据源连接\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n```\n\n运行 `main` 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n```\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n```\n\n## Spring Boot 连接多数据源\n\n> 完整示例：[spring-boot-data-jdbc-multi-datasource](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/spring-boot-data-jdbc-multi-datasource)\n\nSpring Boot 连接多数据源所需要的依赖并无不同，主要差异在于数据源的配置。Spring Boot 默认的数据源配置类为 `org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`。使用者只要指定一些必要的 spring.datasource 配置，`DataSourceAutoConfiguration` 类就会自动完成剩下的数据源实例化工作。\n\n### 多数据源配置\n\n下面的示例中，自定义了一个数据源配置类，通过读取不同的 spring.datasource.xxx 来完成对于不同数据源的实例化工作。对于 JDBC 来说，最重要的，就是实例化 `DataSource` 和 `JdbcTemplate`。\n\n```java\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\n@Configuration\npublic class DataSourceConfig {\n\n    @Primary\n    @Bean("mysqlDataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.mysql")\n    public DataSource mysqlDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Primary\n    @Bean("mysqlJdbcTemplate")\n    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n    @Bean("h2DataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.h2")\n    public DataSource h2DataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = "h2JdbcTemplate")\n    public JdbcTemplate h2JdbcTemplate(@Qualifier("h2DataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n}\n```\n\n`application.properties` 或 `application.yml` 配置文件中也必须以 `@ConfigurationProperties` 所指定的配置前缀进行配置：\n\n```properties\n# 数据源一：Mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：H2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.Driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =\n```\n\n### 测试多数据源连接\n\n```java\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.sql.DataSource;\n\n@SpringBootApplication\npublic class SpringBootDataJdbcMultiDataSourceApplication implements CommandLineRunner {\n\n    private static final Logger log = LoggerFactory.getLogger(SpringBootDataJdbcMultiDataSourceApplication.class);\n\n    private final UserDao mysqlUserDao;\n\n    private final UserDao h2UserDao;\n\n    public SpringBootDataJdbcMultiDataSourceApplication(@Qualifier("mysqlUserDao") UserDao mysqlUserDao,\n        @Qualifier("h2UserDao") UserDao h2UserDao) {\n        this.mysqlUserDao = mysqlUserDao;\n        this.h2UserDao = h2UserDao;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcMultiDataSourceApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n\n        if (mysqlUserDao != null && mysqlUserDao.getJdbcTemplate() != null) {\n            printDataSourceInfo(mysqlUserDao.getJdbcTemplate());\n            log.info("Connect to mysql datasource success.");\n        } else {\n            log.error("Connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2UserDao != null) {\n            printDataSourceInfo(h2UserDao.getJdbcTemplate());\n            log.info("Connect to h2 datasource success.");\n        } else {\n            log.error("Connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 JDBC SQL\n        mysqlUserDao.recreateTable();\n\n        // 次数据源执行 JDBC SQL\n        h2UserDao.recreateTable();\n    }\n\n    private void printDataSourceInfo(JdbcTemplate jdbcTemplate) throws SQLException {\n\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("Get dataSource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("DataSource Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("Connect to datasource failed!");\n        }\n    }\n\n}\n```\n\n运行 `main` 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n```\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to mysql datasource success.\n\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:h2:mem:test\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to h2 datasource success.\n```\n\n## Spring 之数据源\n\n如果你的项目是传统的 Spring 项目，当然也可以轻松建立数据源连接，只是需要自行设置的配置更多一些。\n\n### 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n### Spring 配置数据源\n\nSpring 配置数据源有多种方式，下面一一列举：\n\n#### 使用 JNDI 数据源\n\n如果 Spring 应用部署在支持 JNDI 的 WEB 服务器上（如 WebSphere、JBoss、Tomcat 等），就可以使用 JNDI 获取数据源。\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">\n    <property name="jndiName" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>\n```\n\n#### 使用数据库连接池\n\nSpring 本身并没有提供数据库连接池的实现，需要自行选择合适的数据库连接池。下面是一个使用 [Druid](https://github.com/alibaba/druid) 作为数据库连接池的示例：\n\n```xml\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"\n        init-method="init" destroy-method="close">\n    <property name="driverClassName" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialSize" value="1"/>\n    <property name="minIdle" value="1"/>\n    <property name="maxActive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxWait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timeBetweenEvictionRunsMillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minEvictableIdleTimeMillis" value="300000"/>\n\n    <property name="testWhileIdle" value="true"/>\n\n    \x3c!-- 这里建议配置为TRUE，防止取到的连接不可用 --\x3e\n    <property name="testOnBorrow" value="true"/>\n    <property name="testOnReturn" value="false"/>\n\n    \x3c!-- 打开PSCache，并且指定每个连接上PSCache的大小 --\x3e\n    <property name="poolPreparedStatements" value="true"/>\n    <property name="maxPoolPreparedStatementPerConnectionSize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --\x3e\n\n    <property name="defaultAutoCommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的SQL，不同的数据配置不同 --\x3e\n    <property name="validationQuery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>\n```\n\n#### 基于 JDBC 驱动的数据源\n\n```xml\n<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n  <property name="driverClassName" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>\n```\n\n## SpringBoot 数据源配置\n\n> Spring Boot 数据库配置官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql\n\n通过前面的实战，我们已经知道了 Spring、Spring Boot 是如何连接数据源，并通过 JDBC 方式访问数据库。\n\nSpringBoot 数据源的配置方式是在 `application.properties` 或 `application.yml` 文件中指定 `spring.datasource.*` 的配置。\n\n（1）数据源基本配置方式是指定 url、用户名、密码\n\n```properties\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\n```\n\n（2）配置 JNDI\n\n如果想要通过 JNDI 方式连接数据源，可以采用如下方式：\n\n```properties\nspring.datasource.jndi-name=java:jboss/datasources/customers\n```\n\n## DataSourceAutoConfiguration 类\n\n显而易见，Spring Boot 的配置更加简化，那么， Spring Boot 做了哪些工作，使得接入更加便捷呢？奥秘就在于 `spring-boot-autoconfigure` jar 包，其中定义了大量的 Spring Boot 自动配置类。其中，与数据库访问相关的比较核心的配置类有：\n\n- `DataSourceAutoConfiguration`：数据源自动配置类\n- `JdbcTemplateAutoConfiguration`：`JdbcTemplate` 自动配置类\n- `DataSourceTransactionManagerAutoConfiguration`：数据源事务管理自动配置类\n- `JndiDataSourceAutoConfiguration`：JNDI 数据源自动配置类\n- `EmbeddedDataSourceConfiguration`：嵌入式数据库数据源自动配置类\n- 等等\n\n这些自动配置类会根据各种条件控制核心类的实例化。\n\n`DataSourceAutoConfiguration` 是数据源自动配置类，它负责实例化 `DataSource`。\n\n`DataSourceAutoConfiguration` 的源码如下（省略部分代码）：\n\n```java\n@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import(DataSourcePoolMetadataProvidersConfiguration.class)\npublic class DataSourceAutoConfiguration {\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedDatabaseConfiguration {\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(PooledDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })\n\tprotected static class PooledDataSourceConfiguration {\n  }\n\n\tstatic class PooledDataSourceCondition extends AnyNestedCondition {\n    // 略\n\t}\n\n\tstatic class PooledDataSourceAvailableCondition extends SpringBootCondition {\n    // 略\n\t}\n\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n    // 略\n\t}\n}\n```\n\n`DataSourceAutoConfiguration` 类的源码解读：\n\n- `DataSourceProperties` 是 `DataSourceAutoConfiguration` 的配置选项类，允许使用者通过设置选项控制 `DataSource` 初始化行为。\n- `DataSourceAutoConfiguration` 通过 `@Import` 注解引入 `DataSourcePoolMetadataProvidersConfiguration` 类。\n- `DataSourceAutoConfiguration` 中定义了两个内部类：嵌入式数据源配置类 `EmbeddedDatabaseConfiguration` 和 池化数据源配置类 `PooledDataSourceConfiguration`，分别标记了不同的实例化条件。\n  - 当满足 `EmbeddedDatabaseConfiguration` 的示例化条件时，将引入 `EmbeddedDataSourceConfiguration` 类初始化数据源，这个类实际上是加载嵌入式数据源驱动的 ClassLoader 去进行初始化。\n  - 当满足 `PooledDataSourceConfiguration` 的示例化条件时，将引入 `DataSourceConfiguration.Hikari.class`、`DataSourceConfiguration.Tomcat.class`、`DataSourceConfiguration.Dbcp2.class`、`DataSourceConfiguration.OracleUcp.class`、`DataSourceConfiguration.Generic.class`、`DataSourceJmxConfiguration.class` 这些配置类，分别对应不同的数据库连接池方式。具体选用哪种数据库连接池，可以通过 `spring.datasource.type` 配置指定。其中，Hikari 是 Spring Boot 默认的数据库连接池，spring-boot-starter-data-jdbc 中内置了 Hikari 连接池驱动包。如果想要替换其他数据库连接池，前提是必须先手动引入对应的连接池驱动包。\n\n## 参考资料\n\n- [Spring 官网](https://spring.io/)\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)'},{title:"Spring 之 JDBC",headers:[{level:2,title:"JDBC 入门示例",slug:"jdbc-入门示例",link:"#jdbc-入门示例",children:[{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"定义 DAO 接口",slug:"定义-dao-接口",link:"#定义-dao-接口",children:[]},{level:3,title:"定义 DAO 实现类",slug:"定义-dao-实现类",link:"#定义-dao-实现类",children:[]},{level:3,title:"测试类",slug:"测试类",link:"#测试类",children:[]}]},{level:2,title:"Spring Boot JDBC",slug:"spring-boot-jdbc",link:"#spring-boot-jdbc",children:[{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",link:"#引入-spring-boot-依赖",children:[]},{level:3,title:"配置数据源",slug:"配置数据源",link:"#配置数据源",children:[]},{level:3,title:"测试",slug:"测试",link:"#测试",children:[]}]},{level:2,title:"Spring JDBC",slug:"spring-jdbc",link:"#spring-jdbc",children:[{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",link:"#引入-spring-依赖",children:[]},{level:3,title:"基于 JDBC 驱动的数据源配置",slug:"基于-jdbc-驱动的数据源配置",link:"#基于-jdbc-驱动的数据源配置",children:[]},{level:3,title:"测试",slug:"测试-1",link:"#测试-1",children:[]}]},{level:2,title:"JdbcTemplate API",slug:"jdbctemplate-api",link:"#jdbctemplate-api",children:[{level:3,title:"execute 方法",slug:"execute-方法",link:"#execute-方法",children:[]},{level:3,title:"update 方法",slug:"update-方法",link:"#update-方法",children:[]},{level:3,title:"query 方法",slug:"query-方法",link:"#query-方法",children:[]}]},{level:2,title:"SpringBoot JDBC 配置",slug:"springboot-jdbc-配置",link:"#springboot-jdbc-配置",children:[{level:3,title:"JdbcTemplateAutoConfiguration 类",slug:"jdbctemplateautoconfiguration-类",link:"#jdbctemplateautoconfiguration-类",children:[]},{level:3,title:"JdbcTemplateConfiguration 类",slug:"jdbctemplateconfiguration-类",link:"#jdbctemplateconfiguration-类",children:[]},{level:3,title:"NamedParameterJdbcTemplateConfiguration 类",slug:"namedparameterjdbctemplateconfiguration-类",link:"#namedparameterjdbctemplateconfiguration-类",children:[]}]},{level:2,title:"spring-data-jdbc",slug:"spring-data-jdbc",link:"#spring-data-jdbc",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cf19fd/",pathLocale:"/",extraFields:'---\ntitle: Spring 之 JDBC\ndate: 2019-02-18 14:33:55\norder: 02\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - JDBC\n  - JdbcTemplate\npermalink: /pages/cf19fd/\n---\n\n# Spring 之 JDBC\n\nJDBC 是 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。\n\n## JDBC 入门示例\n\nJDBC 的工作步骤大致如下：\n\n1. 创建实体类。\n2. 声明数据库读写接口的 DAO 接口。定义 DAO 的好处在于对于数据层上层的业务，调用 DAO 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。\n3. 创建一个 DAO 接口的实现类，使用 Spring 的 JDBC 模板去实现接口。\n4. 最后，定义一个 DAO 接口的实现类的 JavaBean，并将数据源注入进去。\n\n假设，我们要通过 Spring + JDBC 访问一张 Mysql 数据表 `user`，`user` 表的数据结构如下：\n\n```sql\n-- 创建用户表\nCREATE TABLE `user` (\n    `id`      BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'ID\',\n    `name`    VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'用户名\',\n    `age`     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\n    `address` VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'地址\',\n    `email`   VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'邮件\',\n    PRIMARY KEY (`id`),\n    UNIQUE (`name`)\n) COMMENT = \'用户表\';\n\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'张三\', 18, \'北京\', \'xxx@163.com\');\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'李四\', 19, \'上海\', \'xxx@163.com\');\n```\n\n### 定义实体\n\n```java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n}\n```\n\n### 定义 DAO 接口\n\n```java\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * user 表 Dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\npublic interface UserDao {\n\n    // DML\n    // -------------------------------------------------------------------\n    void insert(User user);\n\n    void batchInsert(List<User> users);\n\n    void deleteByName(String name);\n\n    void deleteAll();\n\n    void update(User user);\n\n    Integer count();\n\n    List<User> list();\n\n    User queryByName(String name);\n\n    JdbcTemplate getJdbcTemplate();\n\n    // DDL\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreateTable();\n\n}\n```\n\n### 定义 DAO 实现类\n\n通过 `JdbcTemplate` 执行对应数据源符合语法的 SQL，即可完成各种数据库访问。\n\n```java\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * user 表 Dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\n@Repository\npublic class UserDaoImpl implements UserDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public UserDaoImpl(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public void insert(User user) {\n        jdbcTemplate.update("INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail());\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void batchInsert(List<User> users) {\n        String sql = "INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)";\n\n        List<Object[]> params = new ArrayList<>();\n\n        users.forEach(user -> {\n            params.add(new Object[] { user.getName(), user.getAge(), user.getAddress(), user.getEmail() });\n        });\n        jdbcTemplate.batchUpdate(sql, params);\n    }\n\n    @Override\n    public void deleteByName(String name) {\n        jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void deleteAll() {\n        jdbcTemplate.execute("DELETE FROM user");\n    }\n\n    @Override\n    public void update(User user) {\n        jdbcTemplate.update("UPDATE user SET name=?, age=?, address=?, email=? WHERE id=?",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail(), user.getId());\n    }\n\n    @Override\n    public Integer count() {\n        try {\n            return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public List<User> list() {\n        return jdbcTemplate.query("SELECT * FROM user", new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @Override\n    public User queryByName(String name) {\n        try {\n            return jdbcTemplate.queryForObject("SELECT * FROM user WHERE name = ?",\n                new BeanPropertyRowMapper<>(User.class), name);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    @Override\n    public void truncate() {\n        jdbcTemplate.execute("TRUNCATE TABLE user");\n    }\n\n    @Override\n    public void recreateTable() {\n        jdbcTemplate.execute("DROP TABLE IF EXISTS user");\n\n        String sqlStatement =\n            "CREATE TABLE IF NOT EXISTS user (\\n"\n                + "    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\\n"\n                + "    name    VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\\n"\n                + "    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\\n"\n                + "    address VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\\n"\n                + "    email   VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\\n"\n                + "    PRIMARY KEY (id)\\n"\n                + ") COMMENT = \'用户表\';";\n        jdbcTemplate.execute(sqlStatement);\n    }\n\n}\n```\n\n### 测试类\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.Rollback;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Slf4j\n@Rollback\n@SpringBootTest(classes = { SpringBootDataJdbcApplication.class })\npublic class DataJdbcMysqlDataSourceTest {\n\n    @Autowired\n    private UserDao userDAO;\n\n    @BeforeEach\n    public void before() {\n        userDAO.truncate();\n    }\n\n    @Test\n    public void insert() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User linda = userDAO.queryByName("张三");\n        assertThat(linda).isNotNull();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n\n        userDAO.batchInsert(users);\n        int count = userDAO.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = userDAO.list();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(user -> {\n            log.info(user.toString());\n        });\n    }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        userDAO.batchInsert(users);\n\n        userDAO.deleteByName("张三");\n        User user = userDAO.queryByName("张三");\n        assertThat(user).isNull();\n\n        userDAO.deleteAll();\n        List<User> list = userDAO.list();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void update() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User oldUser = userDAO.queryByName("张三");\n        oldUser.setName("张三丰");\n        userDAO.update(oldUser);\n        User newUser = userDAO.queryByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n```\n\n## Spring Boot JDBC\n\n> 完整示例：[spring-boot-data-jdbc](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/spring-boot-data-jdbc)\n\n### 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（[Spring Initializr](https://start.spring.io/)）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n```xml\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n  </dependencies>\n```\n\n### 配置数据源\n\n引入依赖后，需要在 `application.properties` 或 `application.yml` 文件中指定数据源配置。\n\n下面是一个最基本的数据源配置示例：\n\n```properties\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n```\n\n需要根据实际情况，替换 `url`、`username`、`password`。\n\n### 测试\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n```\n\n运行 `main` 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n```\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n```\n\n## Spring JDBC\n\n> 完整示例：[spring-data-jdbc](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/spring-data-jdbc)\n\n`spring-boot-starter-data-jdbc` 引入了 `spring-jdbc` ，其 JDBC 特性就是基于 `spring-jdbc`。\n\n### 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n### 基于 JDBC 驱动的数据源配置\n\n下面是一个 mysql 的 JDBC 数据源配置实例：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用JDBC驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="dataSource2" class="org.springframework.jdbc.datasource.SingleConnectionDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- JDBC模板 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <constructor-arg ref="dataSource1" />\n    </bean>\n    <bean id="userDao" class="io.github.dunwu.springboot.data.jdbc.UserDaoImpl">\n        <constructor-arg ref="jdbcTemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="dataSource1" ignore-failures="ALL">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>\n```\n\n### 测试\n\n```java\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n@SuppressWarnings("all")\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class MysqlJdbcTest {\n\n    @Autowired\n    private ApplicationContext ctx;\n\n    @Before\n    public void before() {\n        ctx = JdbcDemo.getMysqlApplicationContext();\n    }\n\n    @Test\n    public void testExecJdbcOper() throws SQLException, IOException {\n        UserDao userDao = (UserDaoImpl) ctx.getBean("userDao");\n        JdbcDemo.execJdbcOper(userDao);\n    }\n\n    @After\n    public void after() {\n        ((ClassPathXmlApplicationContext) ctx).close();\n    }\n\n}\n```\n\n## JdbcTemplate API\n\nSpring 将数据访问的样板式代码提取到模板类中。Spring 提供了 3 个 JDBC 模板类：\n\n- `JdbcTemplate`：最基本的 Spring JDBC 模板，这个模板支持最简单的 JDBC 数据库访问功能以及简单的索引参数查询。\n- `SimpleJdbcTemplate`：改模板类利用 Java 5 的一些特性，如自动装箱、泛型以及可变参数列表来简化 JDBC 模板的使用。\n- `NamedParameterJdbcTemplate`：使用该模板类执行查询时，可以将查询值以命名参数的形式绑定到 SQL 中，而不是使用简单的索引参数。\n\n`spring-jdbc` 最核心的 API 无疑就是 `JdbcTemplate`，可以说所有的 JDBC 数据访问，几乎都是围绕着这个类去工作的。Spring 对数据库的操作在 Jdbc 层面做了深层次的封装，利用依赖注入，把数据源配置装配到 `JdbcTemplate` 中，再由 `JdbcTemplate` 负责具体的数据访问。\n\n`JdbcTemplate` 主要提供以下几类方法：\n\n- `execute` 方法：可以用于执行任何 SQL 语句，一般用于执行 DDL 语句；\n- `update` 方法及 `batchUpdate` 方法：`update` 方法用于执行新增、修改、删除等语句；`batchUpdate` 方法用于执行批处理相关语句；\n- `query` 方法及 `queryForXXX` 方法：用于执行查询相关语句；\n- `call` 方法：用于执行存储过程、函数相关语句。\n\n为了方便演示，以下增删改查操作都围绕一个名为 user 的表（该表的主键 id 是自增序列）进行，该表的数据实体如下：\n\n```java\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    // 省略 getter/setter\n}\n```\n\n数据实体只要是一个纯粹的 Java Bean 即可，无需任何注解修饰。\n\n### execute 方法\n\n使用 execute 执行 DDL 语句，创建一个名为 test 的数据库，并在此数据库下新建一个名为 user 的表。\n\n```java\npublic void recreateTable() {\n    jdbcTemplate.execute("DROP DATABASE IF EXISTS test");\n    jdbcTemplate.execute("CREATE DATABASE test");\n    jdbcTemplate.execute("USE test");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    // @formatter:off\n    StringBuilder sb = new StringBuilder();\n    sb.append("CREATE TABLE user (id int (10) unsigned NOT NULL AUTO_INCREMENT,\\n")\n        .append("name varchar (64) NOT NULL DEFAULT \'\',\\n")\n        .append("age tinyint (3) NOT NULL DEFAULT 0,\\n")\n        .append("PRIMARY KEY (ID));\\n");\n    // @formatter:on\n    jdbcTemplate.execute(sb.toString());\n}\n```\n\n### update 方法\n\n新增数据\n\n```java\npublic void insert(String name, Integer age) {\n    jdbcTemplate.update("INSERT INTO user(name, age) VALUES(?, ?)", name, age);\n}\n```\n\n删除数据\n\n```java\npublic void delete(String name) {\n    jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n}\n```\n\n修改数据\n\n```java\npublic void update(User user) {\n    jdbcTemplate.update("UPDATE USER SET name=?, age=? WHERE id=?", user.getName(), user.getAge(), user.getId());\n}\n```\n\n批处理\n\n```java\npublic void batchInsert(List<User> users) {\n    String sql = "INSERT INTO user(name, age) VALUES(?, ?)";\n\n    List<Object[]> params = new ArrayList<>();\n\n    users.forEach(item -> {\n        params.add(new Object[] {item.getName(), item.getAge()});\n    });\n    jdbcTemplate.batchUpdate(sql, params);\n}\n```\n\n### query 方法\n\n查单个对象\n\n```java\npublic User queryByName(String name) {\n    try {\n        return jdbcTemplate\n            .queryForObject("SELECT * FROM user WHERE name = ?", new BeanPropertyRowMapper<>(User.class), name);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n```\n\n查多个对象\n\n```java\npublic List<User> list() {\n    return jdbcTemplate.query("select * from USER", new BeanPropertyRowMapper(User.class));\n}\n```\n\n获取某个记录某列或者 count、avg、sum 等函数返回唯一值\n\n```java\npublic Integer count() {\n    try {\n        return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n```\n\n## SpringBoot JDBC 配置\n\n### JdbcTemplateAutoConfiguration 类\n\n`JdbcTemplateAutoConfiguration` 是 `JdbcTemplate` 自动配置类，它负责实例化 `JdbcTemplate`。\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {\n\n}\n```\n\n`JdbcTemplateAutoConfiguration` 类的源码解读：\n\n- `@AutoConfigureAfter(DataSourceAutoConfiguration.class)` 表明 `JdbcTemplateAutoConfiguration` 必须在 `DataSourceAutoConfiguration` 执行完之后才开始工作，这意味着：`JdbcTemplate` 的初始化必须在 `DataSource` 初始化之后。\n- `JdbcProperties` 是 `JdbcTemplateAutoConfiguration` 的配置选项类，允许使用者通过设置选项控制 `JdbcTemplate` 初始化行为。\n- `@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })` 表明引入 `JdbcTemplateConfiguration`、`NamedParameterJdbcTemplateConfiguration` 两个配置类，具体的实例化 `JdbcTemplate` 的工作也是放在这两个配置中完成。\n\n### JdbcTemplateConfiguration 类\n\n`JdbcTemplateConfiguration` 源码如下：\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n\n}\n```\n\n`JdbcTemplateConfiguration` 源码解读：`JdbcTemplateConfiguration` 中根据 `DataSource` 和 `JdbcProperties` 实例化了一个 `JdbcTemplate`。\n\n### NamedParameterJdbcTemplateConfiguration 类\n\n`NamedParameterJdbcTemplateConfiguration` 源码如下：\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnSingleCandidate(JdbcTemplate.class)\n@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\nclass NamedParameterJdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tNamedParameterJdbcTemplate namedParameterJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\treturn new NamedParameterJdbcTemplate(jdbcTemplate);\n\t}\n\n}\n```\n\n`NamedParameterJdbcTemplateConfiguration` 源码解读：`NamedParameterJdbcTemplateConfiguration` 中根据 `JdbcTemplate` 实例化了一个 `NamedParameterJdbcTemplate`。\n\n## spring-data-jdbc\n\nSpring Data 项目包含了对 JDBC 的存储库支持，并将自动为 `CrudRepository` 上的方法生成 SQL。对于更高级的查询，提供了 `@Query` 注解。\n\n当 classpath 上存在必要的依赖项时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。它们可以通过 `spring-boot-starter-data-jdbc` 的单一依赖项添加到项目中。如有必要，可以通过将 `@EnableJdbcRepositories` 批注或 `JdbcConfiguration` 子类添加到应用程序来控制 Spring Data JDBC 的配置。\n\n> 更多 Spring Data JDBC 细节，可以参考 [Spring Data JDBC 官方文档](http://spring.io/projects/spring-data-jdbc)。\n\n## 参考资料\n\n- [Spring 官网](https://spring.io/)\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)'},{title:"Spring 之事务",headers:[{level:2,title:"理解事务",slug:"理解事务",link:"#理解事务",children:[{level:3,title:"事务的特性",slug:"事务的特性",link:"#事务的特性",children:[]},{level:3,title:"全局事务",slug:"全局事务",link:"#全局事务",children:[]},{level:3,title:"本地事务",slug:"本地事务",link:"#本地事务",children:[]},{level:3,title:"Spring 对事务的支持",slug:"spring-对事务的支持",link:"#spring-对事务的支持",children:[]},{level:3,title:"Spring 事务的优点",slug:"spring-事务的优点",link:"#spring-事务的优点",children:[]}]},{level:2,title:"核心 API",slug:"核心-api",link:"#核心-api",children:[{level:3,title:"TransactionManager",slug:"transactionmanager",link:"#transactionmanager",children:[]},{level:3,title:"TransactionDefinition",slug:"transactiondefinition",link:"#transactiondefinition",children:[]},{level:3,title:"TransactionStatus",slug:"transactionstatus",link:"#transactionstatus",children:[]},{level:3,title:"TransactionTemplate",slug:"transactiontemplate",link:"#transactiontemplate",children:[]}]},{level:2,title:"声明式事务管理",slug:"声明式事务管理",link:"#声明式事务管理",children:[{level:3,title:"Spring 声明式事务管理的实现",slug:"spring-声明式事务管理的实现",link:"#spring-声明式事务管理的实现",children:[]},{level:3,title:"声明式事务示例",slug:"声明式事务示例",link:"#声明式事务示例",children:[]},{level:3,title:"回滚一个声明性事务",slug:"回滚一个声明性事务",link:"#回滚一个声明性事务",children:[]},{level:3,title:"为不同的 Bean 配置不同的事务语义",slug:"为不同的-bean-配置不同的事务语义",link:"#为不同的-bean-配置不同的事务语义",children:[]},{level:3,title:"<tx:advice/> 配置",slug:"tx-advice-配置",link:"#tx-advice-配置",children:[]},{level:3,title:"使用 @Transactional 注解",slug:"使用-transactional-注解",link:"#使用-transactional-注解",children:[]}]},{level:2,title:"JDBC 异常抽象",slug:"jdbc-异常抽象",link:"#jdbc-异常抽象",children:[]},{level:2,title:"Spring 事务最佳实践",slug:"spring-事务最佳实践",link:"#spring-事务最佳实践",children:[{level:3,title:"Spring 事务未生效",slug:"spring-事务未生效",link:"#spring-事务未生效",children:[]},{level:3,title:"事务虽然生效但未回滚",slug:"事务虽然生效但未回滚",link:"#事务虽然生效但未回滚",children:[]},{level:3,title:"细化事务传播方式",slug:"细化事务传播方式",link:"#细化事务传播方式",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/128c54/",pathLocale:"/",extraFields:'---\ntitle: Spring 之事务\ndate: 2022-09-22 07:46:49\norder: 03\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 事务\npermalink: /pages/128c54/\n---\n\n# Spring 之事务\n\nSpring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 `@Transactional` 注解，即可一键开启方法的事务性配置。\n\n## 理解事务\n\n在软件开发领域，全有或全无的操作被称为**事务（transaction）**。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：**全局事务**或**本地事务**，两者都有很大的局限性。\n\n### 事务的特性\n\n事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 **ACID**。\n\n- **原子性（Atomic）**：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n- **一致性（Consistent）**：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n- **隔离性（Isolated）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n- **持久性（Durable）**：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n### 全局事务\n\n全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因在于其异常模型）。此外，JTA UserTransaction 通常需要来自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用程序服务器环境中可用。\n\n以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是一种声明式事务管理（不同于程序化事务管理）。 EJB CMT 消除了对与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身就需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。其明显的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，它仅在选择在 EJB 中实现业务逻辑（或至少在事务性 EJB 外观之后）时才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。\n\n### 本地事务\n\n本地事务是指定资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。\n\n### Spring 对事务的支持\n\nSpring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。Spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。Spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。\n\n- 编码式事务允许用户在代码中精确定义事务的边界\n- 声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦\n\n通过程序化事务管理，开发人员可以使用 Spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 Spring 事务 API 或任何其他事务 API。\n\n### Spring 事务的优点\n\nSpring 框架为事务管理提供了一致的抽象，具有以下好处：\n\n- 跨不同事务 API 的一致编程模型，例如 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA)。\n- 支持声明式事务管理。\n- 用于编程事务管理的 API 比复杂事务 API（如 JTA）更简单。\n- 与 Spring 的数据访问抽象完美集成。\n\n## 核心 API\n\n### TransactionManager\n\nSpring 事务抽象的关键是事务策略的概念。事务策略由 `TransactionManager` 定义，特别是用于命令式事务管理的 `org.springframework.transaction.PlatformTransactionManager` 接口和用于响应式事务管理的 `org.springframework.transaction.ReactiveTransactionManager` 接口。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20220922073737.png)\n\n#### PlatformTransactionManager\n\n以下清单显示了 `PlatformTransactionManager` API 的定义：\n\n```java\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}\n```\n\n`PlatformTransactionManager` 是一个 SPI 接口，所以使用者可以以编程方式使用它。因为 `PlatformTransactionManager` 是一个接口，所以可以根据需要轻松地 MOCK 或存根。它不依赖于查找策略，例如 JNDI。 `PlatformTransactionManager` 实现的定义与 Spring IoC 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 Spring 事务成为有价值的抽象，即使您使用 JTA 也是如此。与直接使用 JTA 相比，您可以更轻松地测试事务代码。\n\n同样，为了与 Spring 的理念保持一致，任何 `PlatformTransactionManager` 接口的方法可以抛出的 `TransactionException` 都是未经检查的（也就是说，它扩展了 `java.lang.RuntimeException` 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 `TransactionException`。重点是开发人员并非被迫这样做。\n\n`getTransaction(..)` 方法根据 `TransactionDefinition` 参数返回一个 `TransactionStatus` 对象。如果当前调用堆栈中存在匹配的事务，则返回的 `TransactionStatus` 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 Java EE 事务上下文一样，`TransactionStatus` 与执行线程相关联。\n\n从以上可以看出，具体的事务管理机制对 Spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 Spring 事务管理的一个优点就是为不同的事务 API 提供一致的编程模型，如 JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。\n\n#### JDBC 事务\n\n如果应用程序中直接使用 JDBC 来进行持久化，`DataSourceTransactionManager` 会为你处理事务边界。为了使用 `DataSourceTransactionManager`，你需要使用如下的 XML 将其装配到应用程序的上下文定义中：\n\n```xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource" ref="dataSource" />\n</bean>\n```\n\n实际上，`DataSourceTransactionManager` 是通过调用 `java.sql.Connection` 来管理事务，而后者是通过 `DataSource` 获取到的。通过调用连接的 `commit()` 方法来提交事务，同样，事务失败则通过调用 `rollback()` 方法进行回滚。\n\n#### Hibernate 事务\n\n如果应用程序的持久化是通过 Hibernate 实现的，那么你需要使用 `HibernateTransactionManager`。对于 Hibernate3，需要在 Spring 上下文定义中添加如下的 `bean` 声明：\n\n```xml\n<bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n```\n\n`sessionFactory` 属性需要装配一个 Hibernate 的 session 工厂，`HibernateTransactionManager` 的实现细节是它将事务管理的职责委托给 `org.hibernate.Transaction` 对象，而后者是从 Hibernate Session 中获取到的。当事务成功完成时，`HibernateTransactionManager` 将会调用 `Transaction` 对象的 `commit()` 方法，反之，将会调用 `rollback()` 方法。\n\n#### Java 持久化 API 事务（JPA）\n\nHibernate 多年来一直是事实上的 Java 持久化标准，但是现在 Java 持久化 API 作为真正的 Java 持久化标准进入大家的视野。如果你计划使用 JPA 的话，那你需要使用 Spring 的 `JpaTransactionManager` 来处理事务。你需要在 Spring 中这样配置 `JpaTransactionManager`：\n\n```xml\n<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n```\n\n`JpaTransactionManager` 只需要装配一个 JPA 实体管理工厂（`javax.persistence.EntityManagerFactory` 接口的任意实现）。`JpaTransactionManager` 将与由工厂所产生的 JPA EntityManager 合作来构建事务。\n\n#### Java 原生 API 事务（JTA）\n\n如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用`JtaTransactionManager`：\n\n```xml\n<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">\n  <property name="transactionManagerName" value="java:/TransactionManager" />\n</bean>\n```\n\n`JtaTransactionManager` 将事务管理的责任委托给 `javax.transaction.UserTransaction` 和 `javax.transaction.TransactionManager` 对象，其中事务成功完成通过 `UserTransaction.commit()` 方法提交，事务失败通过 `UserTransaction.rollback()` 方法回滚。\n\n#### ReactiveTransactionManager\n\nSpring 还为使用响应式类型或 Kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 `org.springframework.transaction.ReactiveTransactionManager` 定义的事务策略：\n\n```java\npublic interface ReactiveTransactionManager extends TransactionManager {\n\n    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n\n    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n\n    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\n}\n```\n\n响应式事务管理器主要是一个 SPI，所以使用者可以以编程方式使用它。因为 `ReactiveTransactionManager` 是一个接口，所以可以根据需要轻松地 MOCK 或存根。\n\n### TransactionDefinition\n\n`PlatformTransactionManager` 通过 `getTransaction(TransactionDefinition definition)` 方法来得到事务，这个方法里面的参数是 `TransactionDefinition` 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\n`TransactionDefinition` 接口内容如下：\n\n```java\npublic interface TransactionDefinition {\n    int getPropagationBehavior(); // 返回事务的传播行为\n    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int getTimeout();  // 返回事务必须在多少秒内完成\n    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}\n```\n\n我们可以发现 `TransactionDefinition` 正好用来定义事务属性，下面详细介绍一下各个事务属性。\n\n#### 传播行为\n\n事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring 定义了七种传播行为：\n\n| 传播行为                    | 含义                                                                                                                                                                                                                                                                       |\n| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `PROPAGATION_REQUIRED`      | 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务                                                                                                                                                                           |\n| `PROPAGATION_SUPPORTS`      | 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行                                                                                                                                                                                       |\n| `PROPAGATION_MANDATORY`     | 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常                                                                                                                                                                                                           |\n| `PROPAGATION_REQUIRED_NEW`  | 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager                                                                                       |\n| `PROPAGATION_NOT_SUPPORTED` | 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager                                                                                                                     |\n| `PROPAGATION_NEVER`         | 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常                                                                                                                                                                                             |\n| `PROPAGATION_NESTED`        | 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与 PROPAGATION_REQUIRED 一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务 |\n\n_注：以下具体讲解传播行为的内容参考自 Spring 事务机制详解_\n\n1. PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n```java\n// 事务属性 PROPAGATION_REQUIRED\nmethodA {\n    ……\n    methodB();\n    ……\n}\n```\n\n```java\n// 事务属性 PROPAGATION_REQUIRED\nmethodB {\n   ……\n}\n```\n\n使用 spring 声明式事务，spring 使用 AOP 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。\n\n单独调用 methodB 方法：\n\n```java\nmain {\n    metodB();\n}\n```\n\n相当于\n\n```java\nMain {\n    Connection con=null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n\n        //方法调用\n        methodB();\n\n        //提交事务\n        con.commit();\n    } Catch(RuntimeException ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closeCon();\n    }\n}\n```\n\nSpring 保证在 methodB 方法中所有的调用都获得到一个相同的连接。在调用 methodB 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。\n单独调用 MethodA 时，在 MethodA 内又会调用 MethodB.\n\n执行效果相当于：\n\n```java\nmain{\n    Connection con = null;\n    try{\n        con = getConnection();\n        methodA();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        closeCon();\n    }\n}\n```\n\n调用 MethodA 时，环境中没有事务，所以开启一个新的事务.当在 MethodA 中调用 MethodB 时，环境中已经有了一个事务，所以 methodB 就加入当前事务。\n\n2. `PROPAGATION_SUPPORTS` 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，`PROPAGATION_SUPPORTS` 与不使用事务有少许不同。\n\n```java\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n  methodB();\n}\n\n//事务属性 PROPAGATION_SUPPORTS\nmethodB(){\n  ……\n}\n```\n\n单纯的调用 methodB 时，methodB 方法是非事务的执行的。当调用 methdA 时,methodB 则加入了 methodA 的事务中,事务地执行。\n\n3. `PROPAGATION_MANDATORY` 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n```\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    methodB();\n}\n\n//事务属性 PROPAGATION_MANDATORY\n    methodB(){\n    ……\n}\n```\n\n当单独调用 methodB 时，因为当前没有一个活动的事务，则会抛出异常 throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methodA 时，methodB 则加入到 methodA 的事务中，事务地执行。\n\n4. `PROPAGATION_REQUIRES_NEW` 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n```\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_REQUIRES_NEW\nmethodB(){\n    ……\n}\n```\n\n调用 A 方法：\n\n```\nmain(){\n    methodA();\n}\n```\n\n相当于\n\n```\nmain(){\n    TransactionManager tm = null;\n    try{\n        //获得一个JTA事务管理器\n        tm = getTransactionManager();\n        tm.begin();//开启一个新的事务\n        Transaction ts1 = tm.getTransaction();\n        doSomeThing();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            Transaction ts2 = tm.getTransaction();\n            methodB();\n            ts2.commit();//提交第二个事务\n        } Catch(RunTimeException ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodB执行完后，恢复第一个事务\n        tm.resume(ts1);\n        doSomeThingB();\n        ts1.commit();//提交第一个事务\n    } catch(RunTimeException ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}\n```\n\n在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。Ts2 是否成功并不依赖于 ts1。如果 methodA 方法在调用 methodB 方法后的 doSomeThingB 方法失败了，而 methodB 方法所做的结果依然被提交。而除了 methodB 之外的其它代码导致的结果却被回滚了。使用 PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager 作为事务管理器。\n\n5. `PROPAGATION_NOT_SUPPORTED` 总是非事务地执行，并挂起任何存在的事务。使用 PROPAGATION_NOT_SUPPORTED,也需要使用 JtaTransactionManager 作为事务管理器。（代码示例同上，可同理推出）\n6. PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。\n7. PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用 JDBC 3.0 驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器。需要 JDBC 驱动的 java.sql.Savepoint 类。有一些 JTA 的事务管理器实现可能也提供了同样的功能。使用 PROPAGATION_NESTED，还需要把 PlatformTransactionManager 的 nestedTransactionAllowed 属性设为 true;而 nestedTransactionAllowed 属性值默认为 false。\n\n```\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_NESTED\nmethodB(){\n    ……\n}\n```\n\n如果单独调用 methodB 方法，则按 REQUIRED 属性执行。如果调用 methodA 方法，相当于下面的效果：\n\n```\nmain(){\n    Connection con = null;\n    Savepoint savepoint = null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n        doSomeThingA();\n        savepoint = con2.setSavepoint();\n        try{\n            methodB();\n        } catch(RuntimeException ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        doSomeThingB();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}\n```\n\n当 methodB 方法调用之前，调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括 methodB 方法的所有操作。\n\n嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。\n\nPROPAGATION_NESTED 与 PROPAGATION_REQUIRES_NEW 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 JTA 事务管理器的支持。\n\n使用 PROPAGATION_NESTED 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager 使用 savepoint 支持 PROPAGATION_NESTED 时，需要 JDBC 3.0 以上驱动及 1.4 以上的 JDK 版本支持。其它的 JTA TrasactionManager 实现可能有不同的支持方式。\n\nPROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.\n\nPROPAGATION_REQUIRED 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。\n\n#### 隔离级别\n\n事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n\n1. 并发事务引起的问题\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。\n\n- 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\n- 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\n- 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。\n\n**不可重复读与幻读的区别**\n\n不可重复读的重点是修改:\n同样的条件, 你读取过的数据, 再次读取出来发现值不一样了\n例如：在事务 1 中，Mary 读取了自己的工资为 1000,操作并没有完成\n\n```\n    con1 = getConnection();\n    select salary from employee empId ="Mary";\n```\n\n在事务 2 中，这时财务人员修改了 Mary 的工资为 2000,并提交了事务.\n\n```\n    con2 = getConnection();\n    update employee set salary = 2000;\n    con2.commit();\n```\n\n在事务 1 中，Mary 再次读取自己的工资时，工资变为了 2000\n\n```\n    //con1\n    select salary from employee empId ="Mary";\n```\n\n在一个事务中前后两次读取的结果并不一致，导致了不可重复读。\n\n幻读的重点在于新增或者删除：\n同样的条件, 第 1 次和第 2 次读出来的记录数不一样\n例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。\n\n```\n    con1 = getConnection();\n    Select * from employee where salary =1000;\n```\n\n共读取 10 条记录\n\n这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000\n\n```\n    con2 = getConnection();\n    Insert into employee(empId,salary) values("Lili",1000);\n    con2.commit();\n```\n\n事务 1 再次读取所有工资为 1000 的员工\n\n```\n    //con1\n    select * from employee where salary =1000;\n```\n\n共读取到了 11 条记录，这就产生了幻像读。\n\n从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。\n对于前者, 只需要锁住满足条件的记录。\n对于后者, 要锁住满足条件及其相近的记录。\n\n2. 隔离级别\n\n| 隔离级别                   | 含义                                                                                                                                                   |\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ISOLATION_DEFAULT          | 使用后端数据库默认的隔离级别                                                                                                                           |\n| ISOLATION_READ_UNCOMMITTED | 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读                                                                           |\n| ISOLATION_READ_COMMITTED   | 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生                                                                         |\n| ISOLATION_REPEATABLE_READ  | 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生                                       |\n| ISOLATION_SERIALIZABLE     | 最高的隔离级别，完全服从 ACID 的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 |\n\n#### 只读\n\n事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\n\n#### 事务超时\n\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\n\n#### 回滚规则\n\n事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 EJB 的回滚行为是一致的）\n但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\n\n### TransactionStatus\n\n`TransactionStatus` 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 API 都是通用的。以下清单显示了 `TransactionStatus` 接口：\n\n```java\npublic interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n\n    @Override\n    boolean isNewTransaction();\n\n    boolean hasSavepoint();\n\n    @Override\n    void setRollbackOnly();\n\n    @Override\n    boolean isRollbackOnly();\n\n    void flush();\n\n    @Override\n    boolean isCompleted();\n}\n```\n\n可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\n\n### TransactionTemplate\n\nSpring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦。TransactionTemplate 就是用于支持编程式事务的核心 API。\n\n采用 TransactionTemplate 和采用其他 Spring 模板，如 JdbcTempalte 和 HibernateTemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate 是线程安全的。代码片段：\n\n```java\n    TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate\n    Object result = tt.execute(\n        new TransactionCallback(){\n            public Object doTransaction(TransactionStatus status){\n                updateOperation();\n                return resultOfUpdateOperation();\n            }\n    }); // 执行execute方法进行事务管理\n```\n\n使用 TransactionCallback()可以返回一个值。如果使用 TransactionCallbackWithoutResult 则没有返回值。\n\n## 声明式事务管理\n\n> 大多数 Spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n\nSpring 框架的声明式事务管理是通过 Spring AOP 实现的。然而，由于事务方面代码随 Spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 AOP 概念即可有效地使用此代码。\n\nSpring 框架的声明式事务管理类似于 EJB CMT，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 `setRollbackOnly()` 调用。两种类型的事务管理之间的区别是：\n\n- 与绑定到 JTA 的 EJB CMT 不同，Spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 JDBC、JPA 或 Hibernate 处理 JTA 事务或本地事务。\n- 您可以将 Spring 声明式事务管理应用于任何类，而不仅仅是诸如 EJB 之类的特殊类。\n- Spring 提供声明性回滚规则，这是一个没有 EJB 等效功能的特性。提供了对回滚规则的编程和声明性支持。\n- Spring 允许您使用 AOP 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 EJB CMT，您无法影响容器的事务管理，除非使用 `setRollbackOnly()`。\n- Spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 EJB。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。\n\n回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 Java 代码中。因此，尽管您仍然可以在 TransactionStatus 对象上调用 setRollbackOnly() 来回滚当前事务，但通常您可以指定 MyApplicationException 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 Spring 事务 API 或其他 Spring API。\n\n尽管 EJB 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 EJB CMT 不会在应用程序异常（即除 java.rmi.RemoteException 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 Spring 默认行为遵循 EJB 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。\n\n### Spring 声明式事务管理的实现\n\n关于 Spring 框架的声明式事务支持，最重要的概念是这种支持是通过 AOP 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 XML 或基于注释的）。 AOP 与事务元数据的结合产生了一个 AOP 代理，它使用 `TransactionInterceptor` 和适当的 `TransactionManager` 实现来驱动围绕方法调用的事务。\n\nSpring 的 `TransactionInterceptor` 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 Publisher 或 Kotlin Flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。\n\n事务管理风格会影响需要哪个事务管理器。命令式事务需要 `PlatformTransactionManager`，而响应式事务使用 `ReactiveTransactionManager` 实现。\n\n> `@Transactional` 通常与 `PlatformTransactionManager` 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。\n>\n> 由 `ReactiveTransactionManager` 管理的反应式事务使用 Reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 Reactor 上下文中执行。\n\n下图显示了在事务代理上调用方法的概念视图：\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20220927093737.png)\n\n### 声明式事务示例\n\n考虑以下接口及其伴随的实现。此示例使用 Foo 和 Bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，DefaultFooService 类在每个已实现方法的主体中抛出 `UnsupportedOperationException` 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 `UnsupportedOperationException` 实例。\n\n以下清单显示了 FooService 接口：\n\n```java\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface FooService {\n\n    Foo getFoo(String fooName);\n\n    Foo getFoo(String fooName, String barName);\n\n    void insertFoo(Foo foo);\n\n    void updateFoo(Foo foo);\n\n}\n```\n\n以下示例显示了上述接口的实现：\n\n```java\npackage x.y.service;\n\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n```\n\n假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String, String) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertFoo(Foo) 和 updateFoo(Foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：\n\n```xml\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txAdvice" transaction-manager="txManager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>\n        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the DataSource --\x3e\n    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">\n        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the TransactionManager --\x3e\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n```\n\n检查前面的配置。它假定您要使服务对象 fooService bean 具有事务性。要应用的事务语义封装在 `<tx:advice/>` 定义中。`<tx:advice/>` 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。`<tx:advice/>` 标签的 `transaction-manager` 属性设置为将驱动事务的 TransactionManager bean 的名称（在本例中为 txManager bean）。\n\n> 如果要连接的 TransactionManager 的 bean 名称具有名称 transactionManager，则可以省略事务 advice (tx:advice/) 中的 transaction-manager 属性。如果要连接的 TransactionManager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。\n\n`<aop:config/>` 定义确保由 `txAdvice` bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 `FooService` 接口 (fooServiceOperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 `txAdvice` 相关联。结果表明，在执行 fooServiceOperation 时，会运行 `txAdvice` 定义的建议。\n\n一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：\n\n```xml\n<aop:config>\n    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>\n</aop:config>\n```\n\n前面显示的配置用于围绕从 fooService bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：\n\n```java\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");\n        FooService fooService = ctx.getBean(FooService.class);\n        fooService.insertFoo(new Foo());\n    }\n}\n```\n\n### 回滚一个声明性事务\n\nSpring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。Spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。\n\n在其默认配置中，Spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 `RuntimeException` 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。\n\n您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。\n\n> 回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 `Throwable` 的子类），目前不支持通配符。例如，`javax.servlet.ServletException` 或 `ServletException` 的值将匹配 `javax.servlet.ServletException` 及其子类。\n>\n> 回滚规则可以通过 `rollback-for` 和 `no-rollback-for` 属性在 XML 中配置，这允许将模式指定为字符串。使用 `@Transactional` 时，可以通过 `rollbackFor` / `noRollbackFor` 和`rollbackForClassName` / `noRollbackForClassName` 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，`@Transactional(rollbackFor = example.CustomException.class)` 等价于 `@Transactional(rollbackForClassName = \'example.CustomException\')`。\n\n以下 XML 片段演示了如何通过 `rollback-for` 属性提供异常模式来为已检查的、特定的 `Exception` 类型配置回滚：\n\n```xml\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 Spring 事务框架，即使在面对未处理的 InstrumentNotFoundException 时也要提交伴随事务。\n\n```xml\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n当 Spring Framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 `InstrumentNotFoundException` 之外的任何异常都会导致伴随事务的回滚。\n\n```xml\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 Spring Framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。\n\n```java\npublic void resolvePosition() {\n    try {\n        // some business logic...\n    } catch (NoProductInStockException ex) {\n        // trigger rollback programmatically\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}\n```\n\n如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。\n\n### 为不同的 Bean 配置不同的事务语义\n\n考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 `<aop:advisor/>` 元素和不同 `advice-ref` 属性值的切点来实现这一点。\n\n作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 Service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceOperation"\n                expression="execution(* x.y.service..*Service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherService" class="org.xyz.SomeService"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barManager" class="x.y.service.SimpleBarManager"/> \x3c!-- (doesn\'t end in \'Service\') --\x3e\n\n    <tx:advice id="txAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n```\n\n以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultServiceOperation"\n                expression="execution(* x.y.service.*Service.*(..))"/>\n\n        <aop:pointcut id="noTxServiceOperation"\n                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>\n\n        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultServiceOperation\' pointcut) --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>\n\n    <tx:advice id="defaultTxAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="noTxAdvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="NEVER"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n```\n\n### `<tx:advice/>` 配置\n\n`<tx:advice/>` 的默认配置为：\n\n- 传播设置是 `REQUIRED`\n\n- 隔离级别为 `DEFAULT`\n\n- 事务是 read-write\n\n- 事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。\n\n- 任何 `RuntimeException` 都会触发回滚，而任何已检查的 `Exception` 都不会\n\n`<tx:advice/>` 配置属性\n\n| 属性              | 是否必要 | 默认值     | 描述                                                                         |\n| :---------------- | :------- | :--------- | :--------------------------------------------------------------------------- |\n| `name`            | Yes      |            | 与事务属性关联的方法名称。支持通配符，如：`get*`、`handle*`、`on*Event`      |\n| `propagation`     | No       | `REQUIRED` | 事务传播行为                                                                 |\n| `isolation`       | No       | `DEFAULT`  | 事务隔离级别。仅适用于 `REQUIRED` 或 `REQUIRES_NEW` 的传播设置。             |\n| `timeout`         | No       | -1         | 事务超时时间（单位：秒）。仅适用于 `REQUIRED` 或 `REQUIRES_NEW` 的传播设置。 |\n| `read-only`       | No       | false      | read-write 或 read-only 事务。                                               |\n| `rollback-for`    | No       |            | 触发回滚的 `Exception` 实例列表（通过逗号分隔）。                            |\n| `no-rollback-for` | No       |            | 不触发回滚的 `Exception` 实例列表（通过逗号分隔）。                          |\n\n### 使用 `@Transactional` 注解\n\n除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。\n\n下面是一个使用 `@Transactional` 注解的示例：\n\n```java\n@Transactional\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n```\n\n如上所述在类级别使用，`@Transactional` 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。\n\n当上面的 POJO 类在 Spring 上下文中定义为 bean 时，您可以通过 `@Configuration` 类中的 `@EnableTransactionManagement` 注解使 bean 实例具有事务性。\n\n在 XML 配置中， `<tx:annotation-driven/>` 标签提供了类似的便利：\n\n```xml\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a TransactionManager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txManager"/>\n\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n```\n\n#### `@Transactional` 配置\n\n| Property                                                                                                                               | Type                                                                          | Description                                                                                                                |\n| :------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------- |\n| [value](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-multiple-tx-mgrs-with-attransactional) | `String`                                                                      | Optional qualifier that specifies the transaction manager to be used.                                                      |\n| `transactionManager`                                                                                                                   | `String`                                                                      | Alias for `value`.                                                                                                         |\n| `label`                                                                                                                                | Array of `String` labels to add an expressive description to the transaction. | Labels may be evaluated by transaction managers to associate implementation-specific behavior with the actual transaction. |\n| [propagation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation)                     | `enum`: `Propagation`                                                         | Optional propagation setting.                                                                                              |\n| `isolation`                                                                                                                            | `enum`: `Isolation`                                                           | Optional isolation level. Applies only to propagation values of `REQUIRED` or `REQUIRES_NEW`.                              |\n| `timeout`                                                                                                                              | `int` (in seconds of granularity)                                             | Optional transaction timeout. Applies only to propagation values of `REQUIRED` or `REQUIRES_NEW`.                          |\n| `timeoutString`                                                                                                                        | `String` (in seconds of granularity)                                          | Alternative for specifying the `timeout` in seconds as a `String` value — for example, as a placeholder.                   |\n| `readOnly`                                                                                                                             | `boolean`                                                                     | Read-write versus read-only transaction. Only applicable to values of `REQUIRED` or `REQUIRES_NEW`.                        |\n| `rollbackFor`                                                                                                                          | Array of `Class` objects, which must be derived from `Throwable.`             | Optional array of exception types that must cause rollback.                                                                |\n| `rollbackForClassName`                                                                                                                 | Array of exception name patterns.                                             | Optional array of exception name patterns that must cause rollback.                                                        |\n| `noRollbackFor`                                                                                                                        | Array of `Class` objects, which must be derived from `Throwable.`             | Optional array of exception types that must not cause rollback.                                                            |\n| `noRollbackForClassName`                                                                                                               | Array of exception name patterns.                                             | Optional array of exception name patterns that must not cause rollback.                                                    |\n\n#### 多事务管理器场景下使用 `@Transactional`\n\n某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 `@Transactional` 注释的 value 或 `transactionManager` 属性来选择性地指定要使用的 `TransactionManager` 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。\n\n```java\npublic class TransactionalService {\n\n    @Transactional("order")\n    public void setSomething(String name) { ... }\n\n    @Transactional("account")\n    public void doSomething() { ... }\n\n    @Transactional("reactive-account")\n    public Mono<Void> doSomethingReactive() { ... }\n}\n```\n\n下面展示如何定义 `TransactionManager`：\n\n```xml\n<tx:annotation-driven/>\n\n    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>\n```\n\n在这种情况下，`TransactionalService` 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 `TransactionManager` bean，则仍使用默认的 `<tx:annotation-driven>` 目标 bean 名称。\n\n#### 自定义组合注解\n\n如果您发现在许多不同的方法上重复使用 `@Transactional` 相同的属性，可以使用 Spring 的元注解自定义组合注解。\n\n```java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "order", label = "causal-consistency")\npublic @interface OrderTx {\n}\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "account", label = "retryable")\npublic @interface AccountTx {\n}\n```\n\n使用示例：\n\n```java\npublic class TransactionalService {\n\n    @OrderTx\n    public void setSomething(String name) {\n        // ...\n    }\n\n    @AccountTx\n    public void doSomething() {\n        // ...\n    }\n}\n```\n\n在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。\n\n#### 事务传播\n\n在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20220928114544.png)\n\n`PROPAGATION_REQUIRED` 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。\n\n当传播设置为 PROPAGATION_REQUIRED 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 PROPAGATION_REQUIRED 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。\n\n但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 `UnexpectedRollbackException`。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 `UnexpectedRollbackException` 以清楚地指示执行了回滚。\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20220928115243.png)\n\nPROPAGATION_REQUIRES_NEW 与 PROPAGATION_REQUIRED 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。\n\n## JDBC 异常抽象\n\nSpring 会将数据操作的异常转换为 `DataAccessException`。\n\nSpring 是怎么认识那些错误码的\n\n通过 SQLErrorCodeSQLExceptionTranslator 解析错误码\n\nErrorCode 定义（sql-error-codes.xml 文件）\n\n## Spring 事务最佳实践\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200805171418.png)\n\n### Spring 事务未生效\n\n使用 `@Transactional` 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。\n\n`@Transactional` 生效原则：\n\n#### @Transactional 方法必须是 public\n\n原则一：除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则**只有定义在 `public` 方法上的 `@Transactional` 才能生效**。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。\n\n【示例】错误使用 `@Transactional` 案例一\n\n```java\n\t@Transactional\n\tvoid createUserPrivate(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createUserWrong1(String name) {\n\t\ttry {\n\t\t\tthis.createUserPrivate(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n```\n\n当传入名为 test 的用户实体，会抛出异常，但 `@Transactional` 未生效，不会触发回滚。\n\n#### 必须通过 Spring 注入的 Bean 进行调用\n\n原则二：**必须通过代理过的类从外部调用目标方法才能生效**。\n\n【示例】错误使用 `@Transactional` 案例二\n\n```java\n\t//自调用\n\tpublic int createUserWrong2(String name) {\n\t\ttry {\n\t\t\tthis.createUserPublic(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\t//可以传播出异常\n\t@Transactional\n\tpublic void createUserPublic(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n```\n\n当传入名为 test 的用户实体，会抛出异常，但 `@Transactional` 未生效，不会触发回滚。\n\n说明：Spring 通过 AOP 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。\n\n### 事务虽然生效但未回滚\n\n通过 AOP 实现事务处理可以理解为，使用 `try…catch…` 来包裹标记了 `@Transactional` 注解的方法，当方法出现了异常并且满足**一定条件**的时候，在 `catch` 里面我们可以设置事务回滚，没有异常则直接提交事务。\n\n“一定条件”，主要包括两点：\n\n第一，只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚。在 Spring 的 TransactionAspectSupport 里有个 invokeWithinTransaction 方法，里面就是处理事务的逻辑。\n\n第二，默认情况下，**出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务**。\n\n```java\n@Service\n@Slf4j\npublic class UserService {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@Transactional\n\tpublic void createUserWrong1(String name) {\n\t\ttry {\n\t\t\tuserRepository.save(new UserEntity(name));\n\t\t\tthrow new RuntimeException("error");\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@Transactional\n\tpublic void createUserWrong2(String name) throws IOException {\n\t\tuserRepository.save(new UserEntity(name));\n\t\totherTask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个IOException\n\tprivate void otherTask() throws IOException {\n\t\tFiles.readAllLines(Paths.get("file-that-not-exist"));\n\t}\n\n}\n```\n\n在 createUserWrong1 方法中会抛出一个 RuntimeException，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。\n\n在 createUserWrong2 方法中，注册用户的同时会有一次 otherTask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 otherTask 方法抛出的是受检异常，createUserWrong2 传播出去的也是受检异常，事务同样不会回滚。\n\n【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，**可以手动设置 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();` 让当前事务处于回滚状态**：\n\n```java\n@Transactional\npublic void createUserRight1(String name) {\n   try {\n      userRepository.save(new UserEntity(name));\n      throw new RuntimeException("error");\n   } catch (Exception ex) {\n      log.error("create user failed", ex);\n      TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n   }\n}\n```\n\n【解决方案二】在注解中声明 `@Transactional(rollbackFor = Exception.class)`，期望遇到所有的 Exception 都回滚事务（来突破默认不回滚受检异常的限制）：\n\n```java\n@Transactional(rollbackFor = Exception.class)\npublic void createUserRight2(String name) throws IOException {\n   userRepository.save(new UserEntity(name));\n   otherTask();\n}\n```\n\n### 细化事务传播方式\n\n如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么\n我们需要考虑进一步细化配置事务传播方式，也就是 `@Transactional` 注解的 `Propagation` 属性。\n\n```java\n/**\n * {@link Propagation#REQUIRES_NEW} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void createSubUserWithExceptionRight(UserEntity entity) {\n   log.info("createSubUserWithExceptionRight start");\n   userRepository.save(entity);\n   throw new RuntimeException("invalid status");\n}\n```\n\n## 参考资料\n\n- [Spring 官网](https://spring.io/)\n- [Spring 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)\n- [《Java 业务开发常见错误 100 例》](https://time.geekbang.org/column/intro/100047701)'},{title:"Spring 之 JPA",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"常用 JPA 注解",slug:"常用-jpa-注解",link:"#常用-jpa-注解",children:[{level:3,title:"实体",slug:"实体",link:"#实体",children:[]},{level:3,title:"主键",slug:"主键",link:"#主键",children:[]},{level:3,title:"映射",slug:"映射",link:"#映射",children:[]},{level:3,title:"关系",slug:"关系",link:"#关系",children:[]}]},{level:2,title:"查询",slug:"查询",link:"#查询",children:[{level:3,title:"方法名字方式查询方式",slug:"方法名字方式查询方式",link:"#方法名字方式查询方式",children:[]},{level:3,title:"@Query 注解方式查询",slug:"query-注解方式查询",link:"#query-注解方式查询",children:[]},{level:3,title:"动态 SQL 方式查询",slug:"动态-sql-方式查询",link:"#动态-sql-方式查询",children:[]},{level:3,title:"Example 方式查询",slug:"example-方式查询",link:"#example-方式查询",children:[]},{level:3,title:"排序 Sort",slug:"排序-sort",link:"#排序-sort",children:[]},{level:3,title:"分页 Page 和 Pageable",slug:"分页-page-和-pageable",link:"#分页-page-和-pageable",children:[]}]},{level:2,title:"核心 API",slug:"核心-api",link:"#核心-api",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a03d7b/",pathLocale:"/",extraFields:'---\ntitle: Spring 之 JPA\ndate: 2019-02-18 14:33:55\norder: 04\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - JPA\npermalink: /pages/a03d7b/\n---\n\n# Spring 之 JPA\n\nJPA 为对象关系映射提供了一种基于 POJO 的持久化模型。\n\n- 简化数据持久化代码的开发\n- 为 Java 社区屏蔽不同持久化 API 的差异\n\n## 快速入门\n\n（1）在 pom.xml 中引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n（2）设置启动注解\n\n```java\n// 【可选】指定扫描的 Entity 目录，如果不指定，会扫描全部目录\n@EntityScan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 Repository 目录，如果不指定，会扫描全部目录\n@EnableJpaRepositories(basePackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 JPA auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n（3）配置\n\n```properties\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 JPA SQL 日志\nspring.jpa.show-sql = true\n# Hibernate的DDL策略\nspring.jpa.hibernate.ddl-auto = create-drop\n```\n\n（4）定义实体\n\n```java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\nimport javax.persistence.*;\n\n@Entity\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(unique = true)\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n    public User(String name, Integer age, String address, String email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof User)) {\n            return false;\n        }\n\n        User user = (User) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}\n```\n\n（5）定义 Repository\n\n```java\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.bind.annotation.PathVariable;\n\nimport java.util.List;\n\n@RepositoryRestResource(collectionResourceRel = "user", path = "user")\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findUserById(@PathVariable("id") Long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByName?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link User}\n     */\n    User findUserByName(@Param("name") String name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByEmail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link User}\n     */\n    @Query("from User u where u.email=:email")\n    List<User> findByEmail(@Param("email") String email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @Transactional(rollbackFor = Exception.class)\n    void deleteByName(@Param("name") String name);\n\n}\n```\n\n（6）测试\n\n```java\n@Slf4j\n@SpringBootTest(classes = { DataJpaApplication.class })\npublic class DataJpaTests {\n\n    @Autowired\n    private UserRepository repository;\n\n    @BeforeEach\n    public void before() {\n        repository.deleteAll();\n    }\n\n    @Test\n    public void insert() {\n        User user = new User("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        Optional<User> optional = repository.findById(user.getId());\n        assertThat(optional).isNotNull();\n        assertThat(optional.isPresent()).isTrue();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        long count = repository.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = repository.findAll();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(this::accept);\n    }\n\n    private void accept(User user) { log.info(user.toString()); }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        repository.deleteByName("张三");\n        assertThat(repository.findUserByName("张三")).isNull();\n\n        repository.deleteAll();\n        List<User> list = repository.findAll();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void findAllInPage() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        PageRequest pageRequest = PageRequest.of(1, 2);\n        Page<User> page = repository.findAll(pageRequest);\n        assertThat(page).isNotNull();\n        assertThat(page.isEmpty()).isFalse();\n        assertThat(page.getTotalElements()).isEqualTo(4);\n        assertThat(page.getTotalPages()).isEqualTo(2);\n\n        List<User> list = page.get().collect(Collectors.toList());\n        System.out.println("user list: ");\n        list.forEach(System.out::println);\n    }\n\n    @Test\n    public void update() {\n        User oldUser = new User("张三", 18, "北京", "user1@163.com");\n        oldUser.setName("张三丰");\n        repository.save(oldUser);\n\n        User newUser = repository.findUserByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n```\n\n## 常用 JPA 注解\n\n### 实体\n\n#### `@Entity`\n\n#### `@MappedSuperclass`\n\n当多个实体有共同的属性字段，比如说 id，则可以把它提炼出一个父类，并且加上 `@MappedSuperclass`，则实体基类就可以继承了。\n\n#### `@Table`\n\n当实体名和表名不一致时，可以通过 `@Table(name="CUSTOMERS")` 的形式来明确指定一个表名。\n\n### 主键\n\n#### `@Id`\n\n@Id 注解用于声明一个实体类的属性映射为数据库的主键。\n\n#### `@GeneratedValue`\n\n`@GeneratedValue` 用于标注主键的生成策略，通过 `strategy` 属性指定。\n\n默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。\n\n在 `javax.persistence.GenerationType` 中定义了以下几种可供选择的策略：\n\n```java\npublic enum GenerationType {\n    TABLE,\n    SEQUENCE,\n    IDENTITY,\n    AUTO\n}\n```\n\n- `IDENTITY`：采用数据库 ID 自增长的方式来自增主键字段，Oracle 不支持这种方式；\n- `AUTO`： JPA 自动选择合适的策略，是默认选项；\n- `SEQUENCE`：通过序列产生主键，通过 `@SequenceGenerator` 注解指定序列名，MySql 不支持这种方式\n- `TABLE`：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n也就是如果你没有指定 strategy 属性，默认策略是 AUTO，JPA 会根据你使用的数据库来自动选择策略，比如说我使用的是 mysql 则，自动的主键策略就是 IDENTITY （auto increment）。\n\n### 映射\n\n#### `@Column`\n\n当你的 entity 属性名和数据库中的字段名不一致，可以使用 `@Column` 明确指定，它也可以设置一些属性\n\n```java\n@Column(length = 10, nullable = false, unique = true)\n```\n\n```java\n@Column(columnDefinition = "INT(3)")\nprivate int age;\n```\n\n`@Column` 支持的参数：\n\n- `unique` 属性表示该字段是否为唯一标识，默认为 false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用 `@Table` 标记中的 `@UniqueConstraint`。\n- `nullable` 属性表示该字段是否可以为 `null` 值，默认为 true。\n- `insertable` 属性表示在使用 `INSERT` 插入数据时，是否需要插入该字段的值。\n- `updatable` 属性表示在使用 `UPDATE` 更新数据时，是否需要更新该字段的值。`insertable` 和 `updatable` 属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n- `columnDefinition` 属性表示创建表时，该字段创建的 SQL 语句，一般用于通过 Entity 生成表定义时使用。\n- `table` 属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。\n- `length` 属性表示字段的长度，当字段的类型为 `varchar` 时，该属性才有效，默认为 255 个字符。\n- `precision` 属性和 scale 属性表示精度，当字段类型为 `double` 时，`precision` 表示数值的总长度，`scale` 表示小数点所占的位数。\n\n`@JoinTable`\n\n`@JoinColumn`\n\n### 关系\n\n表关系映射（双向映射）\n\n- `@OneToOne`：一对一关系\n- `@OneToMany`：一对多\n- `@ManyToMany`（不推荐使用，而是采用用中间对象，把多对多拆成两个对多一关系）\n\n字段映射（单向映射）：\n\n- `@Embedded`、`@Embeddable` 嵌入式关系（单向映射）\n- `@ElementCollection` 集合一对多关系（单向映射）\n\n#### `@OneToOne`\n\n`@OneToOne` 表示一对一关系\n\n#### `@OneToMany`\n\n`@OneToMany` 表示一对多关系\n\n`@ManyToOne`\n\n`@ManyToMany`\n\n`OrderBy`\n\n## 查询\n\n查询方式有：\n\n- 方法名字方式查询\n\n- `@Query` 注解方式查询\n- 动态 SQL 方式查询\n\n- Example 方式查询\n\n`JpaRepository` 提供了如下表所述的内置查询\n\n- `List<T> findAll();` - 返回所有实体\n- `List<T> findAllById(Iterable<ID> var1);` - 返回指定 id 的所有实体\n- `T getOne(ID var1);` - 根据 id 返回对应的实体，如果未找到，则返回空。\n- `List<T> findAll(Sort var1);` - 返回所有实体，按照指定顺序返回。\n- `Page<T> findAll(Pageable var1);` - 返回实体列表，实体的 offset 和 limit 通过 pageable 来指定\n\n### 方法名字方式查询方式\n\nSpring Data 通过查询的方法名和参数名来自动构造一个 JPA QQL 查询。\n\n```java\npublic interface UserRepository extends JpaRepository<User, Integer> {\n    public User findByName(String name);\n}\n```\n\n方法名和参数名要遵守一定的规则，Spring Data JPA 才能自动转换为 JPQL：\n\n- 方法名通常包含多个实体属性用于查询，属性之间可以使用 `AND` 和 `OR` 连接，也支持 `Between`、`LessThan`、`GreaterThan`、`Like`；\n\n- 方法名可以以 `findBy`、`getBy`、`queryBy` 开头；\n\n- 查询结果可以排序，方法名包含 OrderBy+属性+ASC（DESC）；\n\n- 可以通过 `Top`、`First` 来限定查询的结果集；\n\n- 一些特殊的参数可以出现在参数列表里，比如 `Pageeable`、`Sort`\n\n示例：\n\n```java\n// 根据名字查询，且按照名字升序\nList<Person> findByLastnameOrderByFirstnameAsc(String name);\n\n// 根据名字查询，且使用翻页查询\nPage<User> findByLastname(String lastname, Pageable pageable);\n\n// 查询满足条件的前10个用户\nList<User> findFirst10ByLastname(String lastname, Sort sort);\n\n// 使用And联合查询\nList<Person> findByFirstnameAndLastname(String firstname, String lastname);\n\n// 使用Or查询\nList<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic User findByNameLike(String name);\n```\n\n| Keyword             | Sample                                                    | JPQL snippet                                                       |\n| ------------------- | --------------------------------------------------------- | ------------------------------------------------------------------ |\n| `And`               | `findByLastnameAndFirstname`                              | `… where x.lastname = ?1 and x.firstname = ?2`                     |\n| `Or`                | `findByLastnameOrFirstname`                               | `… where x.lastname = ?1 or x.firstname = ?2`                      |\n| `Is,Equals`         | `findByFirstname,findByFirstnameIs,findByFirstnameEquals` | `… where x.firstname = 1?`                                         |\n| `Between`           | `findByStartDateBetween`                                  | `… where x.startDate between 1? and ?2`                            |\n| `LessThan`          | `findByAgeLessThan`                                       | `… where x.age < ?1`                                               |\n| `LessThanEqual`     | `findByAgeLessThanEqual`                                  | `… where x.age <= ?1`                                              |\n| `GreaterThan`       | `findByAgeGreaterThan`                                    | `… where x.age > ?1`                                               |\n| `GreaterThanEqual`  | `findByAgeGreaterThanEqual`                               | `… where x.age >= ?1`                                              |\n| `After`             | `findByStartDateAfter`                                    | `… where x.startDate > ?1`                                         |\n| `Before`            | `findByStartDateBefore`                                   | `… where x.startDate < ?1`                                         |\n| `IsNull`            | `findByAgeIsNull`                                         | `… where x.age is null`                                            |\n| `IsNotNull,NotNull` | `findByAge(Is)NotNull`                                    | `… where x.age not null`                                           |\n| `Like`              | `findByFirstnameLike`                                     | `… where x.firstname like ?1`                                      |\n| `NotLike`           | `findByFirstnameNotLike`                                  | `… where x.firstname not like ?1`                                  |\n| `StartingWith`      | `findByFirstnameStartingWith`                             | `… where x.firstname like ?1` (parameter bound with appended `%`)  |\n| `EndingWith`        | `findByFirstnameEndingWith`                               | `… where x.firstname like ?1` (parameter bound with prepended `%`) |\n| `Containing`        | `findByFirstnameContaining`                               | `… where x.firstname like ?1` (parameter bound wrapped in `%`)     |\n| `OrderBy`           | `findByAgeOrderByLastnameDesc`                            | `… where x.age = ?1 order by x.lastname desc`                      |\n| `Not`               | `findByLastnameNot`                                       | `… where x.lastname <> ?1`                                         |\n| `In`                | `findByAgeIn(Collection<Age> ages)`                       | `… where x.age in ?1`                                              |\n| `NotIn`             | `findByAgeNotIn(Collection<Age> age)`                     | `… where x.age not in ?1`                                          |\n| `True`              | `findByActiveTrue()`                                      | `… where x.active = true`                                          |\n| `False`             | `findByActiveFalse()`                                     | `… where x.active = false`                                         |\n| `IgnoreCase`        | `findByFirstnameIgnoreCase`                               | `… where UPPER(x.firstame) = UPPER(?1)`                            |\n\n### @Query 注解方式查询\n\n注解 `@Query` 允许在方法上使用 JPQL。\n\n其中操作针对的是对象名和对象属性名，而非数据库中的表名和字段名。\n\n```java\n@Query("select u form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n```\n\n```java\n@Query("form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n```\n\n如果使用 SQL 而不是 JPSQL，可以使用 `nativeQuery` 属性，设置为 true。\n\n```java\n@Query(value="select * from user where name=?1 and department_id=?2", nativeQuery=true)\npublic User nativeQuery(String name, Integer departmentId);\n```\n\n无论 JPQL，还是 SQL，都支持"命名参数"：\n\n```java\n@Query(value="select * from user where name=:name and department_id=:departmentId", nativeQuery=true)\npublic User nativeQuery2(String name, Integer departmentId);\n```\n\n如果 SQL 活着 JPQL 查询结果集并非 Entity，可以用 `Object[]` 数组代替，比如分组统计每个部分的用户数\n\n```java\n@Query(value="select department_id,count(*) from user group by department_id", nativeQuery=true)\npublic List<Object[]> queryUserCount()\n```\n\n这条查询将返回数组，对象类型依赖于查询结果，被示例中，返回的是 `String` 和 `BigInteger` 类型\n\n查询时可以使用 `Pageable` 和 `Sort` 来完成翻页和排序。\n\n```java\n@Query("select u from User u where department.id=?1")\npublic Page<User> QueryUsers(Integer departmentId, Pageable page);\n```\n\n`@Query` 还允许 SQL 更新、删除语句，此时必须搭配 `@Modifying` 使用，比如：\n\n```java\n@Modifying\n@Query("update User u set u.name= ?1 where u.id= ?2")\nint updateName(String name, Integer id);\n```\n\n### 动态 SQL 方式查询\n\n可参考：[SpringDataJpa 中的复杂查询和动态查询，多表查询](https://juejin.cn/post/6844904160807092237)\n\n### Example 方式查询\n\n允许根据实体创建一个 Example 对象，Spring Data 通过 Example 对象来构造 JPQL。但是使用不灵活条件是 AND,不能使用 or，时间的大于小于，between 等。\n\n继承 `JpaRepository`\n\n```java\n<S extends T> List<S> findAll(Example<S> var1);\n<S extends T> List<S> findAll(Example<S> var1, Sort var2);\n```\n\n```java\npublic List<User> getByExample(String name) {\n    Department dept = new Department();\n    dept.setId(1);\n\n    User user = new User();\n    user.setName(name);\n    user.setDepartment(dept);\n    Example<User> example = Example.of(user);\n    List<User> list = userDao.findAll(example);\n    return list\n}\n```\n\n以上代码首先创建了 User 对象，设置 查询条件，名称为参数 name，部门 id 为 1，通过 `Example.of` 构造了此查询。\n\n大部分查询并非完全匹配查询，ExampleMatcher 提供了更多的条件指定.比如以 xxx 开头的所有用户，则可以使用以下代码构造\n\n```java\nExampleMatcher matcher = ExampleMatcher.matching().withMatcher("xxx",\n    GenericPropertyMatchers.startsWith().ignoreCase());\nExample<User> example = Example.of(user, matcher);\n```\n\n### 排序 Sort\n\nSort 对象用来指定排序，最简单的 Sort 对象构造可以传入一个属性名列表（不是数据库列名，是属性名）。默认采用升序排序。\n\n```java\nSort sort = new Sort("id");\n//Sort sort = new Sort(Direction.DESC, "id");\nreturn userDao.findAll(sort);\n```\n\nHibernate 根据 Sort 构造了排序条件，Sort("id") 表示按照 id 采用默认 升序进行排序\n\n其他 Sort 的构造方法还包括以下主要的一些：\n\n- `public Sort(String... properties)`，按照指定的属性列表升序排序。\n- `public Sort(Sort.Direction direction, String... properties)`，按照指定属性列表排序，排序由 direction 指定，direction 是一个枚举类型，有 `Direction.ASC` 和 `Direction.DESC`。\n- `public Sort(Sort.Order... orders)`，可以通过 Order 静态方法来创建\n  - `public static Sort.Order asc(String property)`\n  - `public static Sort.Order desc(String property)`\n\n### 分页 Page 和 Pageable\n\nPageable 接口用于构造翻页查询，PageRequest 是其实现类，可以通过提供的工厂方法创建 PageRequest：\n\n注意我这边使用的是 sring boot 2.0.2 ，jpa 版本是 2.0.8，新版本与之前版本的操作方法有所不同。\n\n- `public static PageRequest of(int page, int size)`\n\n- `public static PageRequest of(int page, int size, Sort sort)` - 也可以在 PageRequest 中加入排序\n\n- `public static PageRequest of(int page, int size, Direction direction, String... properties)`，或者自定义排序规则\n\npage 是从 0 开始，表示查询页，size 指每页的期望行数。\n\nSpring Data 翻页查询总是返回 Page 对象，Page 对象提供了以下常用的方法\n\n- `int getTotalPages();`，总的页数\n- `long getTotalElements();` - 返回总数\n- `List<T> getContent();` - 返回此次查询的结果集\n\n## 核心 API\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20230123160810.png)\n\n## 参考资料\n\n- [Spring 官网](https://spring.io/)\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)'},{title:"Spring 集成 Mybatis",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[{level:3,title:"从 XML 中构建 SqlSessionFactory",slug:"从-xml-中构建-sqlsessionfactory",link:"#从-xml-中构建-sqlsessionfactory",children:[]},{level:3,title:"不使用 XML 构建 SqlSessionFactory",slug:"不使用-xml-构建-sqlsessionfactory",link:"#不使用-xml-构建-sqlsessionfactory",children:[]},{level:3,title:"从 SqlSessionFactory 中获取 SqlSession",slug:"从-sqlsessionfactory-中获取-sqlsession",link:"#从-sqlsessionfactory-中获取-sqlsession",children:[]},{level:3,title:"探究已映射的 SQL 语句",slug:"探究已映射的-sql-语句",link:"#探究已映射的-sql-语句",children:[]},{level:3,title:"作用域（Scope）和生命周期",slug:"作用域-scope-和生命周期",link:"#作用域-scope-和生命周期",children:[]}]},{level:2,title:"Mybatis 扩展工具",slug:"mybatis-扩展工具",link:"#mybatis-扩展工具",children:[{level:3,title:"Mybatis Plus",slug:"mybatis-plus",link:"#mybatis-plus",children:[]},{level:3,title:"Mapper",slug:"mapper",link:"#mapper",children:[]},{level:3,title:"PageHelper",slug:"pagehelper",link:"#pagehelper",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/88219e/",pathLocale:"/",extraFields:'---\ntitle: Spring 集成 Mybatis\ndate: 2019-05-09 17:09:25\norder: 10\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - MyBatis\n  - PageHelper\n  - Mapper\npermalink: /pages/88219e/\n---\n\n# Spring 集成 Mybatis\n\n[Mybatis 官网](http://www.mybatis.org/mybatis-3/) 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n## 快速入门\n\n要使用 MyBatis， 只需将 [mybatis-x.x.x.jar](https://github.com/mybatis/mybatis-3/releases) 文件置于类路径（classpath）中即可。\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n```xml\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n```\n\n### 从 XML 中构建 SqlSessionFactory\n\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。\n\n从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\n```java\nString resource = "org/mybatis/example/mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\nXML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC"/>\n      <dataSource type="POOLED">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/BlogMapper.xml"/>\n  </mappers>\n</configuration>\n```\n\n当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。\n\n### 不使用 XML 构建 SqlSessionFactory\n\n如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。\n\n```java\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment("development", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n```\n\n注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。\n\n### 从 SqlSessionFactory 中获取 SqlSession\n\n既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n}\n```\n\n诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。\n\n例如：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n}\n```\n\n现在我们来探究一下这段代码究竟做了些什么。\n\n### 探究已映射的 SQL 语句\n\n现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作，但 SQL 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。\n\n在上面提到的例子中，一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你用过旧版本的 MyBatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 XML 的配置，后面我们会提到这些改进。这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。\n\n```xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.BlogMapper">\n  <select id="selectBlog" resultType="Blog">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n```\n\n为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：\n\n```java\nBlog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n```\n\n你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：\n\n```java\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n```\n\n第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。\n\n**提示** **对命名空间的一点补充**\n\n在之前版本的 MyBatis 中，**命名空间（Namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。\n\n命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。\n\n**命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n\n- 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。\n- 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。\n\n对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：\n\n```java\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select("SELECT * FROM blog WHERE id = #{id}")\n  Blog selectBlog(int id);\n}\n```\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n\n选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 XML 的语句映射方式间自由移植和切换。\n\n### 作用域（Scope）和生命周期\n\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n**提示** **对象生命周期和依赖注入框架**\n\n依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。\n\n#### SqlSessionFactoryBuilder\n\n这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\n#### SqlSessionFactory\n\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n#### SqlSession\n\n每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}\n```\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n#### 映射器实例\n\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}\n```\n\n## Mybatis 扩展工具\n\n### Mybatis Plus\n\n[MyBatis-Plus](https://github.com/baomidou/mybatis-plus)（简称 MP）是一个 [MyBatis](https://www.mybatis.org/mybatis-3/) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n【集成示例】[spring-boot-data-mybatis-plus](https://github.com/dunwu/spring-tutorial/tree/develop/codes/data/orm/spring-boot-data-mybatis-plus)\n\n### Mapper\n\n[Mapper](https://github.com/abel533/Mapper) 是一个 Mybatis CRUD 扩展插件。\n\nMapper 的基本原理是将实体类映射为数据库中的表和字段信息，因此实体类需要通过注解配置基本的元数据，配置好实体后， 只需要创建一个继承基础接口的 Mapper 接口就可以开始使用了。\n\n【集成示例】[spring-boot-data-mybatis-mapper](https://github.com/dunwu/spring-tutorial/tree/develop/codes/data/orm/spring-boot-data-mybatis-mapper)\n\n### PageHelper\n\n[PageHelper](https://github.com/pagehelper/Mybatis-PageHelper) 是一个 Mybatis 通用分页插件。\n\n【集成示例】[spring-boot-data-mybatis-mapper](https://github.com/dunwu/spring-tutorial/tree/develop/codes/data/orm/spring-boot-data-mybatis-mapper)\n\n## 参考资料\n\n- **官方**\n  - [Mybatis Github](https://github.com/mybatis/mybatis-3)\n  - [Mybatis 官网](http://www.mybatis.org/mybatis-3/)\n  - [MyBatis 官方代码生成（mybatis-generator）](https://github.com/mybatis/generator)\n  - [MyBatis 官方集成 Spring（mybatis-spring）](https://github.com/mybatis/spring)\n  - [Mybatis 官方集成 Spring Boot（mybatis-spring-boot）](https://github.com/mybatis/spring-boot-starter)\n- **扩展插件**\n  - [MyBatis-Plus](https://github.com/baomidou/mybatis-plus) - CRUD 扩展插件、代码生成器、分页器等多功能\n  - [Mapper](https://github.com/abel533/Mapper) - Mybatis CRUD 扩展插件\n  - [PageHelper](https://github.com/pagehelper/Mybatis-PageHelper) - Mybatis 通用分页插件\n- **文章**\n  - [深入理解 mybatis 原理](https://blog.csdn.net/luanlouis/article/details/40422941)\n  - [mybatis 源码中文注释](https://github.com/tuguangquan/mybatis)\n  - [MyBatis Generator 详解](https://blog.csdn.net/isea533/article/details/42102297)\n  - [Mybatis 常见面试题](https://juejin.im/post/5aa646cdf265da237e095da1)\n  - [Mybatis 中强大的 resultMap](https://juejin.im/post/5cee8b61e51d455d88219ea4)'},{title:"Spring Data 综合",headers:[{level:2,title:"核心概念",slug:"核心概念",link:"#核心概念",children:[]},{level:2,title:"查询方法",slug:"查询方法",link:"#查询方法",children:[]},{level:2,title:"定义 Repository",slug:"定义-repository",link:"#定义-repository",children:[{level:3,title:"微调 Repository 定义",slug:"微调-repository-定义",link:"#微调-repository-定义",children:[]},{level:3,title:"使用多个 Spring 数据模块",slug:"使用多个-spring-数据模块",link:"#使用多个-spring-数据模块",children:[]}]},{level:2,title:"定义查询方法",slug:"定义查询方法",link:"#定义查询方法",children:[{level:3,title:"查询策略",slug:"查询策略",link:"#查询策略",children:[]},{level:3,title:"查询创建",slug:"查询创建",link:"#查询创建",children:[]}]},{level:2,title:"创建 Repository 实例",slug:"创建-repository-实例",link:"#创建-repository-实例",children:[]},{level:2,title:"自定义 Repository 实现",slug:"自定义-repository-实现",link:"#自定义-repository-实现",children:[]},{level:2,title:"Spring Data 扩展",slug:"spring-data-扩展",link:"#spring-data-扩展",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/191cdb/",pathLocale:"/",extraFields:'---\ntitle: Spring Data 综合\ndate: 2023-02-08 09:10:35\norder: 20\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/191cdb/\n---\n\n# Spring Data 综合\n\nSpring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。\n\n## 核心概念\n\nRepository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。`CrudRepository` 和 `ListCrudRepository` 接口为被管理的实体类提供复杂的 CRUD 功能。`ListCrudRepository` 提供等效方法，但它们返回 `List`，而 `CrudRepository` 方法返回 `Iterable`。\n\n`CrudRepository` 接口定义：\n\n```java\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n\n  <S extends T> S save(S entity);\n\n  Optional<T> findById(ID primaryKey);\n\n  Iterable<T> findAll();\n\n  long count();\n\n  void delete(T entity);\n\n  boolean existsById(ID primaryKey);\n\n  // … more functionality omitted.\n}\n```\n\n> Spring Data 项目也提供了一些特定持久化技术的抽象接口，如：JpaRepository 或 MongoRepository。这些接口扩展了 CrudRepository 并暴露了一些持久化技术的底层功能。\n\n除了 `CrudRepository` 之外，还有一个 `PagingAndSortingRepository` 接口，它添加了额外的方法来简化对实体的分页访问：\n\n```java\npublic interface PagingAndSortingRepository<T, ID>  {\n\n  Iterable<T> findAll(Sort sort);\n\n  Page<T> findAll(Pageable pageable);\n}\n```\n\n【示例】要按页面大小 20 访问 User 的第二页，可以执行如下操作\n\n```java\nPagingAndSortingRepository<User, Long> repository = // … get access to a bean\nPage<User> users = repository.findAll(PageRequest.of(1, 20));\n```\n\n除了查询方法之外，计数和删除时的查询也是可用的。\n\n【示例】根据姓氏计数\n\n```java\ninterface UserRepository extends CrudRepository<User, Long> {\n  long countByLastname(String lastname);\n}\n```\n\n【示例】根据姓氏删除\n\n```java\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long deleteByLastname(String lastname);\n\n  List<User> removeByLastname(String lastname);\n}\n```\n\n## 查询方法\n\n使用 Spring Data 对数据库进行查询有以下四步：\n\n1. 声明一个扩展 `Repository` 或其子接口的接口，并指定泛型类型（实体类和 ID 类型），如以下示例所示：\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> { … }\n   ```\n\n2. 在接口中声明查询方法\n\n   ```java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }\n   ```\n\n3. 使用 [JavaConfig](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances.java-config) 或 [XML 配置](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances)为这些接口创建代理实例\n\n   ```java\n   @EnableJpaRepositories\n   class Config { … }\n   ```\n\n4. 注入 `Repository` 实例并使用\n\n   ```java\n   class SomeClient {\n\n     private final PersonRepository repository;\n\n     SomeClient(PersonRepository repository) {\n       this.repository = repository;\n     }\n\n     void doSomething() {\n       List<Person> persons = repository.findByLastname("Matthews");\n     }\n   }\n   ```\n\n## 定义 Repository\n\n首先需要定义一个 Repository 接口，该接口必须扩展 Repository 并且指定泛型类型（实体类和 ID 类型）。如果想为该实体暴露 CRUD 方法，可以扩展 CrudRepository 接口。\n\n### 微调 Repository 定义\n\nSpring Data 提供了很多种 Repository 以应对不同的需求场景。\n\n`CrudRepository` 提供了 CRUD 功能。\n\n`ListCrudRepository` 和 `CrudRepository` 类似，但对于那些返回多个实体的方法，它返回一个 `List` 而不是 `Iterable`，这样使用可能更方便。\n\n如果使用响应式框架，可以使用 `ReactiveCrudRepository` 或 `RxJava3CrudRepository`。\n\n`CoroutineCrudRepository` 支持 Kotlin 的协程特性。\n\n`PagingAndSortingRepository` 提供了分页、排序功能。\n\n如果不想扩展 Spring Data 接口，还可以使用 `@RepositoryDefinition` 注释您的 `Repository` 接口。 扩展一个 CRUD Repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 CRUD Repository 复制到自定义的 Repository 中。 这样做时，可以更改方法的返回类型。 如果可能，Spring Data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 `Iterable<T>`、`List<T>`、`Collection<T>` 或 `VAVR` 列表。\n\n自定义基础 `Repository` 接口，必须用 `@NoRepositoryBean` 标记。 这可以防止 Spring Data 尝试直接创建它的实例并失败，因为它无法确定该 Repository 的实体，因为它仍然包含一个通用类型变量。\n\n以下示例显示了如何有选择地暴露 CRUD 方法（在本例中为 findById 和 save）：\n\n```java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends Repository<T, ID> {\n\n  Optional<T> findById(ID id);\n\n  <S extends T> S save(S entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n```\n\n### 使用多个 Spring 数据模块\n\n有时，程序中需要使用多个 Spring Data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 Repository 工厂时，Spring Data 进入严格的配置模式。\n\n如果定义的 Repository 扩展了特定模块中的 Repository，则它是特定 Spring Data 模块的有效候选者。\n\n如果实体类使用了特定模块的类型注解，则它是特定 Spring Data 模块的有效候选者。 Spring Data 模块接受第三方注解（例如 JPA 的 `@Entity`）或提供自己的注解（例如用于 Spring Data MongoDB 和 Spring Data Elasticsearch 的 `@Document`）。\n\n以下示例显示了一个使用模块特定接口（在本例中为 JPA）的 Repository：\n\n```java\ninterface MyRepository extends JpaRepository<User, Long> { }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends JpaRepository<T, ID> { … }\n\ninterface UserRepository extends MyBaseRepository<User, Long> { … }\n```\n\nMyRepository 和 UserRepository 扩展了 JpaRepository。它们是 Spring Data JPA 模块的有效候选者。\n\n以下示例显示了一个使用通用接口的 Repository\n\n```java\ninterface AmbiguousRepository extends Repository<User, Long> { … }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends CrudRepository<T, ID> { … }\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> { … }\n```\n\nAmbiguousRepository 和 AmbiguousUserRepository 仅扩展了 Repository 和 CrudRepository。 虽然这在使用唯一的 Spring Data 模块时很好，但是存在多个模块时，无法区分这些 Repository 应该绑定到哪个特定的 Spring Data。\n\n以下示例显示了一个使用带注解的实体类的 Repository\n\n```java\ninterface PersonRepository extends Repository<Person, Long> { … }\n\n@Entity\nclass Person { … }\n\ninterface UserRepository extends Repository<User, Long> { … }\n\n@Document\nclass User { … }\n```\n\nPersonRepository 引用 Person，它使用 JPA @Entity 注解进行标记，因此这个 Repository 显然属于 Spring Data JPA。 UserRepository 引用 User，它使用 Spring Data MongoDB 的 @Document 注解进行标记。\n\n以下错误示例显示了一个使用带有混合注解的实体类的 Repository\n\n```java\ninterface JpaPersonRepository extends Repository<Person, Long> { … }\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> { … }\n\n@Entity\n@Document\nclass Person { … }\n```\n\n此示例中的实体类同时使用了 JPA 和 Spring Data MongoDB 的注解。示例中定义了两个 Repository：JpaPersonRepository 和 MongoDBPersonRepository。 一个用于 JPA，另一个用于 MongoDB。 Spring Data 不再能够区分 Repository，这会导致未定义的行为。\n\n区分 Repository 的最后一种方法是确定 Repository 扫描 package 的范围。\n\n```java\n@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")\n@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")\nclass Configuration { … }\n```\n\n## 定义查询方法\n\nRepository 代理有两种方法可以从方法名称派生特定于存储的查询：\n\n- 通过直接从方法名称派生查询。\n- 通过使用手动定义的查询。\n\n可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。\n\n### 查询策略\n\n以下策略可用于Repository 基础结构来解析查询。 对于 Java 配置，您可以使用 EnableJpaRepositories 注释的 queryLookupStrategy 属性。 特定数据存储可能不支持某些策略。\n\n- `CREATE` 尝试从查询方法名称构造特定存储的查询。\n- `USE_DECLARED_QUERY` 尝试查找已声明的查询，如果找不到则抛出异常。\n- `CREATE_IF_NOT_FOUND` （默认）结合了 `CREATE` 和 `USE_DECLARED_QUERY`。\n\n### 查询创建\n\nSpring Data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\n解析查询方法名称分为主语和谓语。第一部分 (find…By, exists…By) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 `find`（或其他引入关键字）和 `By` 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 `Distinct` 在要创建的查询上设置不同的标志或 `Top`/`First` 限制查询结果。\n\n> 参考：\n>\n> [Spring Data 支持的查询主语关键词](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.subject)\n>\n> [Spring Data 支持的查询谓语关键词](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.predicate)\n\n## 创建 Repository 实例\n\n## 自定义 Repository 实现\n\n## Spring Data 扩展\n\n## 参考资料\n\n- [Redis 官网](https://redis.io/)\n- [Redis Github](https://github.com/redis/redis)\n- [spring-data-redis Github](https://github.com/spring-projects/spring-data-redis)\n- [Spring Data Redis 官方文档](https://docs.spring.io/spring-data/redis/docs/current/reference/html/)\n- [Spring Data 官方示例](https://github.com/spring-projects/spring-data-examples/)'},{title:"Spring 访问 Redis",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",link:"#spring-boot-快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"数据源配置",slug:"数据源配置",link:"#数据源配置",children:[]},{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"定义 CRUD 接口",slug:"定义-crud-接口",link:"#定义-crud-接口",children:[]},{level:3,title:"创建 CRUD 接口实现",slug:"创建-crud-接口实现",link:"#创建-crud-接口实现",children:[]},{level:3,title:"创建 Application",slug:"创建-application",link:"#创建-application",children:[]},{level:3,title:"测试",slug:"测试",link:"#测试",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/65e4a2/",pathLocale:"/",extraFields:'---\ntitle: Spring 访问 Redis\ndate: 2023-01-31 20:54:42\norder: 21\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - Redis\npermalink: /pages/65e4a2/\n---\n\n# Spring 访问 Redis\n\n## 简介\n\n[Redis](https://redis.io/) 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。\n\n在 Spring 中，[spring-data-redis](https://github.com/spring-projects/spring-data-redis) 项目对访问 [Redis](https://redis.io/) 进行了 API 封装，提供了便捷的访问方式。 [spring-data-redis](https://github.com/spring-projects/spring-data-redis)\n\n[spring-boot](https://github.com/spring-projects/spring-boot) 项目中的子模块 [spring-boot-starter-data-redis](https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis) 基于 [spring-data-redis](https://github.com/spring-projects/spring-data-redis) 项目，做了二次封装，大大简化了 Redis 的相关配置。\n\n## Spring Boot 快速入门\n\n### 引入依赖\n\n在 pom.xml 中引入依赖：\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n### 数据源配置\n\n```properties\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n```\n\n### 定义实体\n\n```java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.io.Serializable;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 4142994984277644695L;\n\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n\n}\n```\n\n### 定义 CRUD 接口\n\n```java\nimport java.util.Map;\n\npublic interface UserService {\n\n    void batchSetUsers(Map<String, User> users);\n\n    long count();\n\n    User getUser(Long id);\n\n    void setUser(User user);\n\n}\n```\n\n### 创建 CRUD 接口实现\n\n```java\n\nimport cn.hutool.core.bean.BeanUtil;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Map;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    public static final String DEFAULT_KEY = "spring:tutorial:user";\n\n    private final RedisTemplate<String, Object> redisTemplate;\n\n    public UserServiceImpl(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    public void batchSetUsers(Map<String, User> users) {\n        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);\n    }\n\n    @Override\n    public long count() {\n        return redisTemplate.opsForHash().size(DEFAULT_KEY);\n    }\n\n    @Override\n    public User getUser(Long id) {\n        Object obj = redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());\n        return BeanUtil.toBean(obj, User.class);\n    }\n\n    @Override\n    public void setUser(User user) {\n        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);\n    }\n\n}\n```\n\n### 创建 Application\n\n创建 Application，实例化一个 `RedisTemplate` 对象。\n\n```java\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Slf4j\n@SpringBootApplication\npublic class RedisQuickstartApplication {\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Bean\n    @Primary\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常\n        // objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),\n        //     ObjectMapper.DefaultTyping.NON_FINAL);\n\n        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）\n        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        serializer.setObjectMapper(objectMapper);\n\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 配置连接工厂\n        template.setConnectionFactory(factory);\n        // 值采用json序列化\n        template.setValueSerializer(serializer);\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        // 设置hash key 和value序列化模式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n        template.afterPropertiesSet();\n\n        return template;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(RedisQuickstartApplication.class, args);\n    }\n\n}\n```\n\n### 测试\n\n```java\n@Slf4j\n@SpringBootTest(classes = { RedisQuickstartApplication.class })\npublic class RedisQuickstartTests {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void test() {\n        final long SIZE = 1000L;\n        Map<String, User> map = new HashMap<>();\n        for (long i = 0; i < SIZE; i++) {\n            User user = new User(i, RandomUtil.randomChineseName(),\n                RandomUtil.randomInt(1, 100),\n                RandomUtil.randomEnum(Location.class).name(),\n                RandomUtil.randomEmail());\n            map.put(String.valueOf(i), user);\n        }\n        userService.batchSetUsers(map);\n        long count = userService.count();\n        Assertions.assertThat(count).isEqualTo(SIZE);\n\n        for (int i = 0; i < 100; i++) {\n            long id = RandomUtil.randomLong(0, 1000);\n            User user = userService.getUser(id);\n            log.info("user-{}: {}", id, user.toString());\n        }\n    }\n\n}\n```\n\n## 示例源码\n\n更多 Spring 访问 Redis 示例请参考：[Redis 示例源码](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/redis)\n\n## 参考资料\n\n- [Redis 官网](https://redis.io/)\n- [Redis Github](https://github.com/redis/redis)\n- [spring-data-redis Github](https://github.com/spring-projects/spring-data-redis)\n- [Spring Data Redis 官方文档](https://docs.spring.io/spring-data/redis/docs/current/reference/html/)\n- [Spring Data 官方示例](https://github.com/spring-projects/spring-data-examples/)'},{title:"Spring 访问 MongoDB",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",link:"#spring-boot-快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"数据源配置",slug:"数据源配置",link:"#数据源配置",children:[]},{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"创建 Repository",slug:"创建-repository",link:"#创建-repository",children:[]},{level:3,title:"创建 Application",slug:"创建-application",link:"#创建-application",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/db2a41/",pathLocale:"/",extraFields:'---\ntitle: Spring 访问 MongoDB\ndate: 2018-12-15 17:29:36\norder: 22\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - MongoDB\npermalink: /pages/db2a41/\n---\n\n# Spring 访问 MongoDB\n\n## 简介\n\n[MongoDB](https://www.mongodb.org/) 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\n在 Spring 中，[spring-data-mongodb](https://github.com/spring-projects/spring-data-mongodb) 项目对访问 [MongoDB](https://www.mongodb.org/) 进行了 API 封装，提供了便捷的访问方式。 Spring Data MongoDB 的核心是一个以 POJO 为中心的模型，用于与 MongoDB `DBCollection` 交互并轻松编写 `Repository` 样式的数据访问层。\n\n[spring-boot](https://github.com/spring-projects/spring-boot) 项目中的子模块 [spring-boot-starter-data-mongodb](https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb) 基于 [spring-data-mongodb](https://github.com/spring-projects/spring-data-mongodb) 项目，做了二次封装，大大简化了 MongoDB 的相关配置。\n\n## Spring Boot 快速入门\n\n### 引入依赖\n\n在 pom.xml 中引入依赖：\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n```\n\n### 数据源配置\n\n```properties\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root\n```\n\n### 定义实体\n\n定义一个具有三个属性的 `Customer` 类：`id`、`firstName` 和 `lastName`\n\n```java\nimport org.springframework.data.annotation.Id;\n\npublic class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n\n    public String lastName;\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n            "Customer[id=%s, firstName=\'%s\', lastName=\'%s\']",\n            id, firstName, lastName);\n    }\n\n}\n```\n\n[spring-data-mongodb](https://github.com/spring-projects/spring-data-mongodb) 会将 `Customer` 类映射到一个名为 `customer` 的集合中。如果要更改集合的名称，可以在类上使用 `@Document` 注解。\n\n### 创建 Repository\n\n[spring-data-mongodb](https://github.com/spring-projects/spring-data-mongodb) 继承了 [Spring Data Commons](https://github.com/spring-projects/spring-data-commons) 项目的能力，所以可以使用其通用 API——`Repository`。\n\n先定义一个 `CustomerRepository` 类，继承 `MongoRepository` 接口，并指定其泛型参数：`Customer` 和 `String`。MongoRepository 接口支持多种操作，包括 CRUD 和分页查询。在下面的例子中，定义了两个查询方法：\n\n```java\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\npublic interface CustomerRepository extends MongoRepository<Customer, String> {\n\n    Customer findByFirstName(String firstName);\n    List<Customer> findByLastName(String lastName);\n\n}\n```\n\n### 创建 Application\n\n创建一个 Spring Boot 的启动类 Application，并在启动的 main 方法中使用 `CustomerRepository` 实例访问 MongoDB。\n\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DataMongodbApplication implements CommandLineRunner {\n\n    @Autowired\n    private CustomerRepository repository;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DataMongodbApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) {\n\n        repository.deleteAll();\n\n        // save a couple of customers\n        repository.save(new Customer("Alice", "Smith"));\n        repository.save(new Customer("Bob", "Smith"));\n\n        // fetch all customers\n        System.out.println("Customers found with findAll():");\n        System.out.println("-------------------------------");\n        for (Customer customer : repository.findAll()) {\n            System.out.println(customer);\n        }\n        System.out.println();\n\n        // fetch an individual customer\n        System.out.println("Customer found with findByFirstName(\'Alice\'):");\n        System.out.println("--------------------------------");\n        System.out.println(repository.findByFirstName("Alice"));\n\n        System.out.println("Customers found with findByLastName(\'Smith\'):");\n        System.out.println("--------------------------------");\n        for (Customer customer : repository.findByLastName("Smith")) {\n            System.out.println(customer);\n        }\n    }\n\n}\n```\n\n运行 `DataMongodbApplication` 的 main 方法后，输出类似如下类容：\n\n```\nCustomers found with findAll():\n-------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\nCustomer found with findByFirstName(\'Alice\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomers found with findByLastName(\'Smith\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n```\n\n## 示例源码\n\n更多 Spring 访问 MongoDB 示例请参考：[MongoDB 示例源码](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/mongodb)\n\n## 参考资料\n\n- [MongoDB 官网](https://www.mongodb.com/)\n- [MongoDB Github](https://github.com/mongodb/mongo)\n- [MongoDB 官方免费教程](https://university.mongodb.com/)\n- [spring-data-mongodb Github](https://github.com/spring-projects/spring-data-mongodb)\n- [Spring Data MongoDB 官方文档](https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/)\n- [Spring Data 官方示例](https://github.com/spring-projects/spring-data-examples/)\n- [Accessing Data with MongoDB](https://spring.io/guides/gs/accessing-data-mongodb/)\n- [Accessing MongoDB Data with REST](https://spring.io/guides/gs/accessing-mongodb-data-rest/)'},{title:"Spring 访问 Elasticsearch",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"通过 REST 客户端连接 Elasticsearch",slug:"通过-rest-客户端连接-elasticsearch",link:"#通过-rest-客户端连接-elasticsearch",children:[]},{level:3,title:"通过 Jest 连接 Elasticsearch",slug:"通过-jest-连接-elasticsearch",link:"#通过-jest-连接-elasticsearch",children:[]},{level:3,title:"通过 Spring Data 访问 Elasticsearch",slug:"通过-spring-data-访问-elasticsearch",link:"#通过-spring-data-访问-elasticsearch",children:[]},{level:3,title:"Elasticsearch Repositories",slug:"elasticsearch-repositories",link:"#elasticsearch-repositories",children:[]}]},{level:2,title:"源码",slug:"源码",link:"#源码",children:[]},{level:2,title:"版本",slug:"版本",link:"#版本",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/fac14c/",pathLocale:"/",extraFields:"---\ntitle: Spring 访问 Elasticsearch\ndate: 2018-12-25 14:06:36\norder: 23\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - Elasticsearch\npermalink: /pages/fac14c/\n---\n\n# Spring 访问 Elasticsearch\n\n## 简介\n\n[Elasticsearch](https://www.elastic.co/products/elasticsearch) 是一个开源的、分布式的搜索和分析引擎。\n\n### 通过 REST 客户端连接 Elasticsearch\n\n如果在 classpath 路径下存在 `org.elasticsearch.client:elasticsearch-rest-client` jar 包，Spring Boot 会自动配置并注册一个 `RestClient` Bean，它的默认访问路径为：`localhost:9200`。\n\n你可以使用如下方式进行定制：\n\n```properties\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret\n```\n\n您还可以注册实现任意数量的 `RestClientBuilderCustomizer` bean，以进行更高级的定制。要完全控制注册，请定义 `RestClient` bean。\n\n如果 classpath 路径有 `org.elasticsearch.client：elasticsearch-rest-high-level-client` jar 包，Spring Boot 将自动配置一个 `RestHighLevelClient`，它包装任何现有的 `RestClient` bean，重用其 HTTP 配置。\n\n### 通过 Jest 连接 Elasticsearch\n\n如果 classpath 上有 Jest，你可以注入一个自动配置的 `JestClient`，默认情况下是 `localhost:9200`。您可以进一步调整客户端的配置方式，如以下示例所示：\n\n```properties\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret\n```\n\n您还可以注册实现任意数量的 `HttpClientConfigBuilderCustomizer` bean，以进行更高级的定制。以下示例调整为其他 HTTP 设置：\n\n```java\nstatic class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {\n\n\t@Override\n\tpublic void customize(HttpClientConfig.Builder builder) {\n\t\tbuilder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);\n\t}\n\n}\n```\n\n要完全控制注册，请定义 `JestClient` bean。\n\n### 通过 Spring Data 访问 Elasticsearch\n\n要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将 `spring.data.elasticsearch.cluster-nodes` 属性设置为以逗号分隔的 `host:port` 列表来指定地址。使用此配置，可以像任何其他 Spring bean 一样注入 `ElasticsearchTemplate` 或 `TransportClient`，如以下示例所示：\n\n```java\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@Component\npublic class MyBean {\n\n\tprivate final ElasticsearchTemplate template;\n\n\tpublic MyBean(ElasticsearchTemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}\n```\n\n如果你添加了自定义的 `ElasticsearchTemplate` 或 `TransportClient` `@Bean` ，就会替换默认的配置。\n\n### Elasticsearch Repositories\n\nSpring Data 包含对 Elasticsearch 的 repository 支持。基本原则是根据方法名称自动为您构建查询。\n\n事实上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。\n\n## 源码\n\n完整示例：[源码](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-data-elasticsearch)\n\n使用方法：\n\n```bash\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar\n```\n\n## 版本\n\nSpring 和 Elasticsearch 匹配版本：\n\n|                                        Spring Data Elasticsearch                                         | Elasticsearch | Spring Framework | Spring Boot |\n| :------------------------------------------------------------------------------------------------------: | :-----------: | :--------------: | :---------: |\n|                                                  5.0.x                                                   |     8.5.3     |      6.0.x       |    3.0.x    |\n|                                                  4.4.x                                                   |    7.17.3     |      5.3.x       |    2.7.x    |\n|                                                  4.3.x                                                   |    7.15.2     |      5.3.x       |    2.6.x    |\n| 4.2.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |    7.12.0     |      5.3.x       |    2.5.x    |\n| 4.1.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |     7.9.3     |      5.3.2       |    2.4.x    |\n| 4.0.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |     7.6.2     |      5.2.12      |    2.3.x    |\n| 3.2.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |    6.8.12     |      5.2.12      |    2.2.x    |\n| 3.1.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |     6.2.2     |      5.1.19      |    2.1.x    |\n| 3.0.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |     5.5.0     |      5.0.13      |    2.0.x    |\n| 2.1.x[[1](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1)] |     2.4.0     |      4.3.25      |    1.5.x    |\n\n## 参考资料\n\n- **官方**\n  - [Elasticsearch 官网](https://www.elastic.co/cn/products/elasticsearch)\n  - [Elasticsearch Github](https://github.com/elastic/elasticsearch)\n  - [Elasticsearch 官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n  - [Elasticsearch: The Definitive Guide](https://www.elastic.co/guide/en/elasticsearch/guide/master/index.html) - ElasticSearch 官方学习资料\n- [Spring Boot 官方文档之 boot-features-elasticsearch](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-elasticsearch)\n- [Spring Data Elasticsearch Github](https://github.com/spring-projects/spring-data-elasticsearch)\n- [Spring Data Elasticsearch 官方文档](https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/)"},{title:"Spring 数据篇",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"💻 示例",slug:"💻-示例",link:"#💻-示例",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/b912d1/",pathLocale:"/",extraFields:"---\ntitle: Spring 数据篇\ndate: 2022-09-18 11:05:36\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring数据\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 数据库\npermalink: /pages/b912d1/\nhidden: true\nindex: false\n---\n\n# Spring 数据篇\n\n## 📖 内容\n\n- [Spring 之数据源](01.Spring之数据源.md)\n- [Spring 之 JDBC](02.Spring之JDBC.md)\n- [Spring 之事务](03.Spring之事务.md)\n- [Spring 之 JPA](04.Spring之JPA.md)\n- [Spring 集成 Mybatis](10.Spring集成Mybatis.md)\n- [Spring 访问 Redis](21.Spring访问Redis.md)\n- [Spring 访问 MongoDB](22.Spring访问MongoDB.md)\n- [Spring 访问 Elasticsearch](23.Spring访问Elasticsearch.md)\n\n## 💻 示例\n\n- **JDBC**\n  - [spring-data-jdbc-basics](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/basics) - Spring Boot 以 JDBC 方式访问关系型数据库，通过 `JdbcTemplate` 执行基本的 CRUD 操作。\n  - [spring-data-jdbc-druid](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/druid) - SpringBoot 使用 [Druid](https://github.com/alibaba/druid) 作为数据库连接池。\n  - [spring-data-jdbc-multi-datasource](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/multi-datasource) - SpringBoot 连接多数据源示例。\n  - [spring-data-jdbc-xml](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/jdbc/xml) - Spring 以 JDBC 方式访问关系型数据库，通过 `JdbcTemplate` 执行基本的 CRUD 操作。\n- **ORM**\n  - [spring-data-orm-jpa](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/orm/jpa) - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n  - [spring-data-orm-mybatis](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/orm/mybatis) - Spring 使用 [MyBatis](https://github.com/mybatis/mybatis-3) 作为 ORM 框架访问数据库示例。\n  - [spring-data-orm-mybatis-mapper](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/orm/mybatis-mapper) - SpringBoot 使用 [MyBatis](https://github.com/mybatis/mybatis-3) + [Mapper](https://github.com/abel533/Mapper) + [PageHelper](https://github.com/pagehelper/Mybatis-PageHelper) 作为 ORM 框架访问数据库示例。\n  - [spring-data-orm-mybatis-multi-datasource](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/orm/mybatis-multi-datasource) - SpringBoot 连接多数据源，并使用 [MyBatis Plus](https://github.com/baomidou/mybatis-plus) 作为 ORM 框架访问数据库示例。\n  - [spring-data-orm-mybatis-plus](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/orm/mybatis-plus) - SpringBoot 使用 [MyBatis Plus](https://github.com/baomidou/mybatis-plus) 作为 ORM 框架访问数据库示例。\n- **Nosql**\n  - [spring-data-nosql-basics](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/basics) - Spring 访问各种 NoSQL 的示例。\n  - [spring-data-nosql-mongodb](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/mongodb) - SpringBoot 访问 [MongoDB](https://www.mongodb.com/) 的示例。\n  - [spring-data-nosql-redis](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/redis) - SpringBoot 访问 [Redis](https://redis.io/) 单节点、集群的示例。\n  - [spring-data-nosql-elasticsearch](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/elasticsearch) - SpringBoot 访问 [Elasticsearch](https://www.elastic.co/guide/index.html) 的示例。\n  - [spring-data-nosql-hdfs](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/hdfs) - SpringBoot 访问 HDFS 的示例。\n- **Cache**\n  - [spring-data-cache-basics](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/cache/basics) - SpringBoot 默认缓存框架的示例。\n  - [spring-data-cache-j2cache](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/cache/j2cache) - SpringBoot 使用 [j2cache](https://gitee.com/ld/J2Cache) 作为缓存框架的示例。\n  - [spring-data-cache-jetcache](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/cache/jetcache) - SpringBoot 使用 [jetcache](https://github.com/alibaba/jetcache) 作为缓存框架的示例。\n- **中间件**\n  - [spring-data-middleware-flyway](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/middleware/flyway) - Spring 使用版本管理中间件 Flyway 示例。\n  - [spring-data-middleware-sharding](https://github.com/dunwu/spring-tutorial/tree/master/codes/data/middleware/sharding) - Spring 使用分库分表中间件示例。\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"Spring Web 综述",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"SpringMVC 工作流程",slug:"springmvc-工作流程",link:"#springmvc-工作流程",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/65351b/",pathLocale:"/",extraFields:'---\ntitle: Spring Web 综述\ndate: 2017-11-08 16:53:27\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\npermalink: /pages/65351b/\n---\n\n# Spring Web 综述\n\n## 快速入门\n\n下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。\n\n（1）`pom.xml` 中引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n（2）定义 Controller\n\nSpring 构建 RESTful 服务的方法，HTTP 请求由 `Controller` 处理。 这些组件由 `@RestController` 注解标识。\n\n【示例】下面的示例定义了一个处理 `/greeting` 的 GET 请求\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}\n```\n\n（3）创建启动类\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}\n```\n\n（4）启动服务：执行 `HelloWorldApplication.main` 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\n```json\nHello, World!\n```\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\n```\nHello, dunwu!\n```\n\n## SpringMVC 工作流程\n\nSpring MVC 的工作流程可以用一幅图来说明：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png)\n\n1. 向服务器发送 HTTP 请求，请求被前端控制器 `DispatcherServlet` 捕获。\n2. `DispatcherServlet` 根据 **`<servlet-name>-servlet.xml`** 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 `HandlerMapping` 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以`HandlerExecutionChain` 对象的形式返回。\n3. `DispatcherServlet` 根据获得的`Handler`，选择一个合适的 `HandlerAdapter`。（附注：如果成功获得`HandlerAdapter`后，此时将开始执行拦截器的 preHandler(...)方法）。\n4. 提取`Request`中的模型数据，填充`Handler`入参，开始执行`Handler`（`Controller`)。 在填充`Handler`的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n   - HttpMessageConverter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n   - 数据转换：对请求消息进行数据转换。如`String`转换成`Integer`、`Double`等。\n   - 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n   - 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到`BindingResult`或`Error`中。\n5. Handler(Controller)执行完成后，向 `DispatcherServlet` 返回一个 `ModelAndView` 对象；\n6. 根据返回的`ModelAndView`，选择一个适合的 `ViewResolver`（必须是已经注册到 Spring 容器中的`ViewResolver`)返回给`DispatcherServlet`。\n7. `ViewResolver` 结合`Model`和`View`，来渲染视图。\n8. 视图负责将渲染结果返回给客户端。\n\n## 参考资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n'},{title:"Spring Web 应用",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"Spring Web 组件",slug:"spring-web-组件",link:"#spring-web-组件",children:[{level:3,title:"组件扫描",slug:"组件扫描",link:"#组件扫描",children:[]},{level:3,title:"AOP 代理",slug:"aop-代理",link:"#aop-代理",children:[]},{level:3,title:"@Controller",slug:"controller",link:"#controller",children:[]},{level:3,title:"@RequestMapping",slug:"requestmapping",link:"#requestmapping",children:[]}]},{level:2,title:"处理方法",slug:"处理方法",link:"#处理方法",children:[{level:3,title:"请求数据",slug:"请求数据",link:"#请求数据",children:[]},{level:3,title:"响应数据",slug:"响应数据",link:"#响应数据",children:[]}]},{level:2,title:"@ModelAttribute",slug:"modelattribute",link:"#modelattribute",children:[]},{level:2,title:"@InitBinder",slug:"initbinder",link:"#initbinder",children:[]},{level:2,title:"表单处理",slug:"表单处理",link:"#表单处理",children:[{level:3,title:"创建处理表单的 Controller",slug:"创建处理表单的-controller",link:"#创建处理表单的-controller",children:[]},{level:3,title:"定义需要提交的表单实体",slug:"定义需要提交的表单实体",link:"#定义需要提交的表单实体",children:[]},{level:3,title:"提交表单前端代码",slug:"提交表单前端代码",link:"#提交表单前端代码",children:[]}]},{level:2,title:"文件上传",slug:"文件上传",link:"#文件上传",children:[{level:3,title:"创建文件上传处理 Controller",slug:"创建文件上传处理-controller",link:"#创建文件上传处理-controller",children:[]},{level:3,title:"定义存储文件的 Service",slug:"定义存储文件的-service",link:"#定义存储文件的-service",children:[]},{level:3,title:"创建文件上传表单",slug:"创建文件上传表单",link:"#创建文件上传表单",children:[]},{level:3,title:"文件上传限制",slug:"文件上传限制",link:"#文件上传限制",children:[]}]},{level:2,title:"异常处理",slug:"异常处理",link:"#异常处理",children:[{level:3,title:"@ExceptionHandler",slug:"exceptionhandler",link:"#exceptionhandler",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/5d002f/",pathLocale:"/",extraFields:'---\ntitle: Spring Web 应用\ndate: 2023-02-14 19:21:22\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\n  - Controller\npermalink: /pages/5d002f/\n---\n\n# Spring Web 应用\n\nSpring MVC 提供了一种基于注解的编程模型，`@Controller` 和 `@RestController` 组件使用注解来表达请求映射、请求输入、异常处理等。注解控制器具有灵活的方法签名，并且不必扩展基类或实现特定接口。以下示例显示了一个由注解定义的控制器：\n\n```java\n@Controller\npublic class HelloController {\n\n    @GetMapping("/hello")\n    public String handle(Model model) {\n        model.addAttribute("message", "Hello World!");\n        return "index";\n    }\n}\n```\n\n在前面的示例中，该方法接受一个 `Model` 并以 `String` 形式返回一个视图名称，但还存在许多其他选项。\n\n## 快速入门\n\n下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。\n\n（1）`pom.xml` 中引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n（2）定义 Controller\n\nSpring 构建 RESTful 服务的方法，HTTP 请求由 `Controller` 处理。 这些组件由 `@RestController` 注解标识。\n\n【示例】下面的示例定义了一个处理 `/greeting` 的 GET 请求\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}\n```\n\n（3）创建启动类\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}\n```\n\n（4）启动服务：执行 `HelloWorldApplication.main` 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\n```json\nHello, World!\n```\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\n```\nHello, dunwu!\n```\n\n## Spring Web 组件\n\n### 组件扫描\n\n可以使用 Servlet 的 `WebApplicationContext` 中的标准 Spring bean 定义来定义控制器。`@Controller` 构造型允许自动检测，与 Spring 对检测类路径中的 `@Component` 类并为它们自动注册 bean 定义的一般支持保持一致。它还充当带注解类的构造型，表明其作为 Web 组件的角色。\n\n要启用此类 `@Controller` 的自动检测，可以将组件扫描添加到您的 Java 配置中，如以下示例所示：\n\n```java\n@Configuration\n@ComponentScan("org.example.web")\npublic class WebConfig {\n\n    // ...\n}\n```\n\n以下示例显示了与上述示例等效的 XML 配置：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:p="http://www.springframework.org/schema/p"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="org.example.web"/>\n\n    \x3c!-- ... --\x3e\n\n</beans>\n```\n\n### AOP 代理\n\n在某些情况下，可能需要在运行时使用 AOP 代理装饰控制器。一个例子是，如果选择直接在控制器上使用 `@Transactional` 注解。在这种情况下，特别是对于控制器，建议使用基于类的代理。直接在控制器上使用此类注解会自动出现这种情况。\n\n如果控制器实现了一个接口，并且需要 AOP 代理，您可能需要显式配置基于类的代理。例如，对于 `@EnableTransactionManagement` ，可以更改为 `@EnableTransactionManagement(proxyTargetClass = true)`，对于 `<tx:annotation-driven/>` ，您可以更改为 `<tx:annotation-driven proxy-target-class="true"/>`。\n\n### @Controller\n\n`@RestController` 是一个[组合注解](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，它本身使用 `@Controller` 和 `@ResponseBody` 元注解进行标记，以指示控制器的每个方法继承了类型级别的 `@ResponseBody` 注解，因此直接写入响应主体，而不是使用 HTML 模板进行视图解析和渲染。\n\n### @RequestMapping\n\n可以使用 `@RequestMapping` 注解将请求映射到控制器方法。它具有各种属性，可以通过 URL、HTTP 方法、请求参数、标头和媒体类型进行匹配。可以在类级别使用它来表达共享映射，或者在方法级别使用它来缩小到特定端点的映射。\n\n`@RequestMapping` 的主要参数：\n\n- path / method 指定映射路径与方法\n- params / headers 限定映射范围\n- consumes / produces 限定请求与响应格式\n\nSpring 还提供了以下 `@RequestMapping` 的变体：\n\n- `@GetMapping`\n- `@PostMapping`\n- `@PutMapping`\n- `@DeleteMapping`\n- `@PatchMapping`\n\n快捷方式是提供的[自定义注解](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-composed)，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 `@RequestMapping`，默认情况下，它与所有 HTTP 方法匹配。在类级别仍然需要 `@RequestMapping` 来表达共享映射。\n\n以下示例具有类型和方法级别的映射：\n\n```java\n@RestController\n@RequestMapping("/persons")\nclass PersonController {\n\n    @GetMapping("/{id}")\n    public Person getPerson(@PathVariable Long id) {\n        // ...\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public void add(@RequestBody Person person) {\n        // ...\n    }\n}\n```\n\n#### URI 模式\n\n`@RequestMapping` 方法可以使用 URL 模式进行映射。有两种选择：\n\n- `PathPattern` - 与 URL 路径匹配的预解析模式也预解析为 `PathContainer`。该解决方案专为网络使用而设计，可有效处理编码和路径参数，并高效匹配。\n- `AntPathMatcher` - 根据字符串路径匹配字符串模式。这是在 Spring 配置中也使用的原始解决方案，用于在类路径、文件系统和其他位置选择资源。它的效率较低，并且字符串路径输入对于有效处理 URL 的编码和其他问题是一个挑战。\n\n`PathPattern` 是 Web 应用程序的推荐解决方案，它是 Spring WebFlux 中的唯一选择。它从 5.3 版开始在 Spring MVC 中使用，从 6.0 版开始默认启用。请参阅 [MVC 配置](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-path-matching) 以自定义路径匹配选项。\n\n`PathPattern` 支持与 `AntPathMatcher` 相同的模式语法。此外，它还支持捕获模式，例如 `{spring}`，用于匹配路径末尾的 0 个或多个路径段。`PathPattern` 还限制使用 `**` 来匹配多个路径段，这样它只允许出现在模式的末尾。这消除了在为给定请求选择最佳匹配模式时出现的许多歧义。有关完整模式语法，请参阅 [PathPattern](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/util/pattern/PathPattern.html) 和 [AntPathMatcher](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/util/AntPathMatcher.html)。\n\n一些示例模式：\n\n- `"/resources/ima?e.png"` -匹配一个字符\n- `"/resources/*.png"` - 匹配零个或多个字符\n- `"/resources/**"` - 匹配多个字符\n- `"/projects/{project}/versions"` - 匹配路径段并将其捕获为变量\n- `"/projects/{project:[a-z]+}/versions"` - 使用正则表达式匹配并捕获变量\n\n可以使用 `@PathVariable` 访问捕获的 URI 变量。例如：\n\n```java\n@GetMapping("/owners/{ownerId}/pets/{petId}")\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n```\n\n可以在类和方法级别声明 URI 变量，如以下示例所示：\n\n```java\n@Controller\n@RequestMapping("/owners/{ownerId}")\npublic class OwnerController {\n\n    @GetMapping("/pets/{petId}")\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n        // ...\n    }\n}\n```\n\nURI 变量会自动转换为适当的类型，否则会引发 `TypeMismatchException`。默认支持简单类型（`int`、`long`、`Date` 等），可以注册对任何其他数据类型的支持。请参见[类型转换](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-typeconversion)和 [`DataBinder`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder)。\n\n可以显式命名 URI 变量（例如，`@PathVariable("customId")`），但如果名称相同并且代码是使用 `-parameters` 编译器标志编译的，则可以省略该细节。\n\n语法 `{varName:regex}` 使用正则表达式声明一个 URI 变量。例如，给定 URL `"/spring-web-3.0.5.jar"`，以下方法提取名称、版本和文件扩展名：\n\n```java\n@GetMapping("/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}")\npublic void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {\n    // ...\n}\n```\n\nURI 路径模式还可以嵌入 `${…}` 占位符，这些占位符在启动时通过使用 `PropertySourcesPlaceholderConfigurer` 针对本地、系统、环境和其他属性源进行解析。例如，可以使用它来根据某些外部配置参数化基本 URL。\n\n#### 模式比较\n\n当多个模式匹配一个 URL 时，必须选择最佳匹配。这是通过以下方式之一完成的，具体取决于是否启用了已解析的 `PathPattern` 以供使用：\n\n- [`PathPattern.SPECIFICITY_COMPARATOR`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR)\n- [`AntPathMatcher.getPatternComparator(String path)`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/util/AntPathMatcher.html#getPatternComparator-java.lang.String-)\n\n两者都有助于对模式进行排序，更具体的模式位于顶部。如果模式具有较少的 URI 变量（计为 1）、单通配符（计为 1）和双通配符（计为 2），则模式不太具体。如果得分相同，则选择较长的模式。给定相同的分数和长度，选择 URI 变量多于通配符的模式。\n\n默认映射模式 (`/**`) 被排除在评分之外并始终排在最后。此外，前缀模式（例如 `/public/**`）被认为不如其他没有双通配符的模式具体。\n\n#### 后缀匹配\n\n从 5.3 开始，默认情况下 Spring MVC 不再执行 `.*` 后缀模式匹配，其中映射到 `person` 的控制器也隐式映射到 `/person.*`。因此，路径扩展不再用于解释请求的响应内容类型⟩——例如，`/person.pdf`、`/person.xml` 等。\n\n当浏览器过去发送难以一致解释的 `Accept` 请求头时，以这种方式使用文件扩展名是必要的。现在，这不再是必需的，使用 `Accept` 请求头应该是首选。\n\n随着时间的推移，文件扩展名的使用在很多方面都被证明是有问题的。当使用 URI 变量、路径参数和 URI 编码覆盖时，它可能会导致歧义。关于基于 URL 的授权和安全性的推理也变得更加困难。\n\n要在 5.3 之前的版本中完全禁用路径扩展，请设置以下内容：\n\n- `useSuffixPatternMatching(false)` - 参考：[PathMatchConfigurer](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-path-matching)\n- `favorPathExtension(false)` - 参考：[ContentNegotiationConfigurer](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation)\n\n除了通过 `Accept` 请求头之外，还有一种请求内容类型的方法仍然有用，例如在浏览器中键入 URL 时。路径扩展的一种安全替代方法是使用查询参数策略。如果您必须使用文件扩展名，请考虑通过 [ContentNegotiationConfigurer](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation) 的 `mediaTypes` 属性将它们限制为明确注册的扩展名列表。\n\n#### 后缀匹配和 RFD\n\n反射文件下载 (RFD) 攻击与 XSS 类似，因为它依赖于响应中反映的请求输入（例如，查询参数和 URI 变量）。然而，RFD 攻击不是将 JavaScript 插入 HTML，而是依赖于浏览器切换来执行下载，并在稍后双击时将响应视为可执行脚本。\n\n在 Spring MVC 中，`@ResponseBody` 和 `ResponseEntity` 方法存在风险，因为它们可以渲染不同的内容类型，客户端可以通过 URL 路径扩展请求这些内容类型。禁用后缀模式匹配并使用路径扩展进行内容协商可以降低风险，但不足以防止 RFD 攻击。\n\n为了防止 RFD 攻击，在渲染响应主体之前，Spring MVC 添加了一个 `Content-Disposition:inline;filename=f.txt` 头以建议一个固定且安全的下载文件。仅当 URL 路径包含的文件扩展名既不安全也不明确注册用于内容协商时，才会执行此操作。但是，当 URL 直接输入浏览器时，它可能会产生副作用。\n\n默认情况下，允许许多常见的路径扩展是安全的。具有自定义 `HttpMessageConverter` 实现的应用程序可以显式注册文件扩展名以进行内容协商，以避免为这些扩展名添加 `Content-Disposition` 头。请参阅 [内容类型](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation)。\n\n关于 RFD 更多细节推荐参考 [CVE-2015-5211](https://pivotal.io/security/cve-2015-5211)\n\n#### 限定数据类型\n\n您可以根据请求的 `Content-Type` 缩小请求映射，如以下示例所示：\n\n```java\n@PostMapping(path = "/pets", consumes = "application/json")\npublic void addPet(@RequestBody Pet pet) {\n    // ...\n}\n```\n\n`consumes` 属性还支持否定表达式 - 例如，`!textplain` 表示除 `textplain` 之外的任何内容类型。\n\n您可以在类级别声明一个共享的 `consumes` 属性。然而，与大多数其他请求映射属性不同的是，当在类级别使用时，方法级别的 `consumes` 属性会覆盖而不是扩展类级别的声明。\n\n#### Producible Media Types\n\n可以根据 `Accept` 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：\n\n```java\n@GetMapping(path = "/pets/{petId}", produces = "application/json")\n@ResponseBody\npublic Pet getPet(@PathVariable String petId) {\n    // ...\n}\n```\n\n媒体类型可以指定一个字符集。支持否定表达式——例如，`!textplain` 表示除 "text/plain" 之外的任何内容类型。\n\n可以在类级别声明一个共享的 `produces` 属性。然而，与大多数其他请求映射属性不同，当在类级别使用时，方法级别的 `produces` 属性会覆盖而不是扩展类级别的声明。\n\n#### 参数、请求头\n\n可以根据请求参数条件缩小请求映射范围。可以测试是否存在请求参数 (`myParam`)、是否缺少请求参数 (`!myParam`) 或特定值 (`myParam=myValue`)。以下示例显示如何测试特定值：\n\n```java\n@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}\n```\n\n还可以使用相同的请求头条件，如以下示例所示：\n\n```java\n@GetMapping(path = "/pets", headers = "myHeader=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}\n```\n\n#### HTTP HEAD, OPTIONS\n\n`@GetMapping`（和 `@RequestMapping(method=HttpMethod.GET)`）透明地支持 HTTP HEAD 以进行请求映射。控制器方法不需要改变。在 `jakarta.servlet.http.HttpServlet` 中应用的响应包装器确保将 `Content-Length` 头设置为写入的字节数（实际上没有写入响应）。\n\n`@GetMapping`（和`@RequestMapping(method=HttpMethod.GET)`）被隐式映射并支持 HTTP HEAD。HTTP HEAD 请求的处理方式就好像它是 HTTP GET 一样，除了不写入正文，而是计算字节数并设置 `Content-Length` 头。\n\n默认情况下，通过将 `Allow` 响应头设置为所有具有匹配 URL 模式的 `@RequestMapping` 方法中列出的 HTTP 方法列表来处理 HTTP OPTIONS。\n\n对于没有 HTTP 方法声明的 `@RequestMapping` ，`Allow` 头设置为 `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`。控制器方法应始终声明支持的 HTTP 方法（例如，通过使用 HTTP 方法特定变体：`@GetMapping`、`@PostMapping` 等）。\n\nYou can explicitly map the `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.\n\n可以显式地将 `@RequestMapping` 方法映射到 HTTP HEAD 和 HTTP OPTIONS，但在常见情况下这不是必需的。\n\n#### 自定义注解\n\nSpring MVC 支持使用[组合注解](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations) 进行请求映射。这些注解本身是用 `@RequestMapping` 进行元注解的，并且组合起来重新声明 `@RequestMapping` 属性的一个子集（或全部），具有更明确的目的。\n\n`@GetMapping`、`@PostMapping`、`@PutMapping`、`@DeleteMapping` 和 `@PatchMapping` 是组合注解的示例。提供它们是因为，可以说，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 `@RequestMapping`，默认情况下，它与所有 HTTP 方法匹配。如果您需要组合注解的示例，请查看这些注解的声明方式。\n\nSpring MVC 还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承 `RequestMappingHandlerMapping` 并覆盖 `getCustomMethodCondition` 方法，您可以在其中检查自定义属性并返回您自己的 `RequestCondition`。\n\n#### 显示注册\n\n您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同 URL 下的同一处理程序的不同实例。以下示例注册了一个处理程序方法\n\n```java\n@Configuration\npublic class MyConfig {\n\n    @Autowired\n    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)\n            throws NoSuchMethodException {\n\n        RequestMappingInfo info = RequestMappingInfo\n                .paths("/user/{id}").methods(RequestMethod.GET).build();\n\n        Method method = UserHandler.class.getMethod("getUser", Long.class);\n\n        mapping.registerMapping(info, handler, method);\n    }\n}\n```\n\n1. 为控制器注入目标处理程序和处理程序映射。\n\n2. 准备请求映射元数据。\n\n3. 获取处理程序方法。\n\n4. 添加注册。\n\n## 处理方法\n\n### 请求数据\n\n- `@RequestParam`\n\n- `@RequestBody`\n\n- `@PathVariable`\n\n- `@RequestHeader`\n\n> 更多 Spring Web 方法参数可以参考： [Method Arguments](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments)\n\n### 响应数据\n\n- `@ResponseBody`\n- `@ResponseStatus`\n- ResponseEntity\n\n- HttpEntity\n\n> 更多 Spring Web 方法返回值可以参考：[Return Values](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types)\n\n## @ModelAttribute\n\n可以使用 `@ModelAttribute` 注解：\n\n- 在 `@RequestMapping` 方法中的方法参数上，用于模型创建或访问对象，并通过 `WebDataBinder` 将其绑定到请求。\n- 作为 `@Controller` 或 `@ControllerAdvice` 类中的方法级注解，有助于在任何 `@RequestMapping` 方法调用之前初始化模型。\n- 在 `@RequestMapping` 方法上标记它的返回值是一个模型属性。\n\n本节讨论 `@ModelAttribute` 方法——前面列表中的第二项。一个控制器可以有任意数量的 `@ModelAttribute` 方法。所有这些方法都在同一控制器中的 `@RequestMapping` 方法之前被调用。`@ModelAttribute` 方法也可以通过 `@ControllerAdvice` 在控制器之间共享。\n\n`@ModelAttribute` 方法具有灵活的方法签名。它们支持许多与 `@RequestMapping` 方法相同的参数，除了 `@ModelAttribute` 本身或与请求主体相关的任何内容。\n\n以下示例显示了 `@ModelAttribute` 方法：\n\n```java\n@ModelAttribute\npublic void populateModel(@RequestParam String number, Model model) {\n    model.addAttribute(accountRepository.findAccount(number));\n    // add more ...\n}\n```\n\n以下示例仅添加一个属性：\n\n```java\n@ModelAttribute\npublic Account addAccount(@RequestParam String number) {\n    return accountRepository.findAccount(number);\n}\n```\n\n还可以将 `@ModelAttribute` 用作 `@RequestMapping` 方法上的方法级注解，在这种情况下，`@RequestMapping` 方法的返回值被解释为模型属性。这通常不是必需的，因为它是 HTML 控制器中的默认行为，除非返回值是一个 String 否则将被解释为视图名称。 `@ModelAttribute` 还可以自定义模型属性名称，如下例所示：\n\n```java\n@GetMapping("/accounts/{id}")\n@ModelAttribute("myAccount")\npublic Account handle() {\n    // ...\n    return account;\n}\n```\n\n## @InitBinder\n\n`@Controller` 或 `@ControllerAdvice` 类可以用 `@InitBinder` 方法来初始化 `WebDataBinder` 的实例，而这些方法又可以：\n\n- 将请求参数（即表单或查询数据）绑定到模型对象。\n- 将基于字符串的请求值（例如请求参数、路径变量、标头、cookie 等）转换为控制器方法参数的目标类型。\n- 在渲染 HTML 表单时将模型对象值格式化为 `String` 值。\n\n`@InitBinder` 方法可以注册指定控制器 `java.beans.PropertyEditor` 或 Spring `Converter` 和 `Formatter` 组件。此外，您可以使用 [MVC 配置](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion) 在全局共享的 `FormattingConversionService` 中注册 `Converter` 和 `Formatter` 类型。\n\n`@InitBinder` 方法支持许多与 `@RequestMapping` 方法相同的参数，除了 `@ModelAttribute`（命令对象）参数。通常，它们使用 `WebDataBinder` 参数（用于注册）和 `void` 返回值声明。下面展示了一个示例：\n\n```java\n@Controller\npublic class FormController {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");\n        dateFormat.setLenient(false);\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n    }\n\n    // ...\n}\n```\n\n或者，当您通过共享的 `FormattingConversionService` 使用基于 `Formatter` 的设置时，您可以重复使用相同的方法并注册指定控制器的 `Formatter` 实现，如以下示例所示：\n\n```java\n@Controller\npublic class FormController {\n\n    @InitBinder\n    protected void initBinder(WebDataBinder binder) {\n        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));\n    }\n\n    // ...\n}\n```\n\n在 Web 应用程序的上下文中，*数据绑定*涉及将 HTTP 请求参数（即表单数据或查询参数）绑定到模型对象及其嵌套对象中的属性。\n\n仅公开遵循 [JavaBeans 命名约定](https://www.oracle.com/java/technologies/javase/javabeans-spec.html) 的 `public` 属性用于数据绑定——例如，`firstName` 属性的 get/set 方法：`public String getFirstName()` 和 `public void setFirstName(String)`。\n\n默认情况下，Spring 允许绑定到模型对象图中的所有公共属性。这意味着您需要仔细考虑模型具有哪些公共属性，因为客户端可以将任何公共属性路径作为目标，甚至是一些预计不会针对给定用例的公共属性路径。\n\n例如，给定一个 HTTP 表单数据端点，恶意客户端可以为存在于模型对象图中但不属于浏览器中显示的 HTML 表单的属性提供值。这可能导致在模型对象及其任何嵌套对象上设置数据，这些数据预计不会更新。\n\n荐的方法是使用一个*专用模型对象*，它只公开与表单提交相关的属性。例如，在用于更改用户电子邮件地址的表单上，模型对象应声明最少的一组属性，例如以下 `ChangeEmailForm`。\n\n```java\npublic class ChangeEmailForm {\n\n    private String oldEmailAddress;\n    private String newEmailAddress;\n\n    public void setOldEmailAddress(String oldEmailAddress) {\n        this.oldEmailAddress = oldEmailAddress;\n    }\n\n    public String getOldEmailAddress() {\n        return this.oldEmailAddress;\n    }\n\n    public void setNewEmailAddress(String newEmailAddress) {\n        this.newEmailAddress = newEmailAddress;\n    }\n\n    public String getNewEmailAddress() {\n        return this.newEmailAddress;\n    }\n\n}\n```\n\n如果您不能或不想为每个数据绑定用例使用*专用模型对象*，则必须限制允许用于数据绑定的属性。理想情况下，可以通过 `WebDataBinder` 上的 `setAllowedFields()` 方法注册*允许的字段模式* 来实现这一点。\n\n例如，要在您的应用程序中注册允许的字段模式，您可以在 `@Controller` 或 `@ControllerAdvice` 组件中实现 `@InitBinder` 方法，如下所示：\n\n```java\n@Controller\npublic class ChangeEmailController {\n\n    @InitBinder\n    void initBinder(WebDataBinder binder) {\n        binder.setAllowedFields("oldEmailAddress", "newEmailAddress");\n    }\n\n    // @RequestMapping methods, etc.\n\n}\n```\n\n除了注册允许的模式外，还可以通过 `DataBinder`及其子类中的 `setDisallowedFields()` 方法注册 _允许的字段模式_。但是请注意，“允许列表”比“拒绝列表”更安全。因此，`setAllowedFields()` 应该优于 `setDisallowedFields()`。\n\n请注意，匹配允许的字段模式是区分大小写的；然而，与不允许的字段模式匹配是不区分大小写的。此外，匹配不允许的模式的字段将不会被接受，即使它也恰好匹配允许列表中的模式。\n\n## 表单处理\n\n### 创建处理表单的 Controller\n\n`GreetingController` 通过返回视图的名称处理 `/greeting` 的 GET 请求，这意味着返回的内容是名为 `greeting.html` 的视图内容。\n\n`greetingForm()` 方法是通过使用 `@GetMapping` 专门映射到 GET 请求的，而 `greetingSubmit()` 是通过 `@PostMapping` 映射到 POST  请求的。\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PostMapping;\n\n@Controller\npublic class GreetingController {\n\n  @GetMapping("/greeting")\n  public String greetingForm(Model model) {\n    model.addAttribute("greeting", new Greeting());\n    return "greeting";\n  }\n\n  @PostMapping("/greeting")\n  public String greetingSubmit(@ModelAttribute Greeting greeting, Model model) {\n    model.addAttribute("greeting", greeting);\n    return "result";\n  }\n\n}\n```\n\n### 定义需要提交的表单实体\n\n```java\nimport lombok.Data;\n\n@Data\npublic class Greeting {\n\n    private long id;\n\n    private String content;\n\n}\n```\n\n### 提交表单前端代码\n\n提交实体的页面必须依赖某种视图技术，通过将视图名称转换为模板进行渲染，从而对HTML进行服务端渲染。在下面的例子中，使用了 Thymeleaf 模板引擎作为视图，它解析 `greeting.html` 的各种模板表达式以渲染表单。\n\n```html\n<!DOCTYPE html>\n<html xmlns:th="https://www.thymeleaf.org">\n  <head>\n    <title>Getting Started: Handling Form Submission</title>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n  </head>\n  <body>\n    <h1>Form</h1>\n    <form action="#" th:action="@{/greeting}" th:object="${greeting}" method="post">\n      <p>Id: <input type="text" th:field="*{id}" /></p>\n      <p>Message: <input type="text" th:field="*{content}" /></p>\n      <p><input type="submit" value="Submit" /> <input type="reset" value="Reset" /></p>\n    </form>\n  </body>\n</html>\n```\n\n## 文件上传\n\n### 创建文件上传处理 Controller\n\n```java\nimport java.io.IOException;\nimport java.util.stream.Collectors;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport com.example.uploadingfiles.storage.StorageFileNotFoundException;\nimport com.example.uploadingfiles.storage.StorageService;\n\n@Controller\npublic class FileUploadController {\n\n\tprivate final StorageService storageService;\n\n\t@Autowired\n\tpublic FileUploadController(StorageService storageService) {\n\t\tthis.storageService = storageService;\n\t}\n\n\t@GetMapping("/")\n\tpublic String listUploadedFiles(Model model) throws IOException {\n\n\t\tmodel.addAttribute("files", storageService.loadAll().map(\n\t\t\t\tpath -> MvcUriComponentsBuilder.fromMethodName(FileUploadController.class,\n\t\t\t\t\t\t"serveFile", path.getFileName().toString()).build().toUri().toString())\n\t\t\t\t.collect(Collectors.toList()));\n\n\t\treturn "uploadForm";\n\t}\n\n\t@GetMapping("/files/{filename:.+}")\n\t@ResponseBody\n\tpublic ResponseEntity<Resource> serveFile(@PathVariable String filename) {\n\n\t\tResource file = storageService.loadAsResource(filename);\n\t\treturn ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,\n\t\t\t\t"attachment; filename=\\"" + file.getFilename() + "\\"").body(file);\n\t}\n\n\t@PostMapping("/")\n\tpublic String handleFileUpload(@RequestParam("file") MultipartFile file,\n\t\t\tRedirectAttributes redirectAttributes) {\n\n\t\tstorageService.store(file);\n\t\tredirectAttributes.addFlashAttribute("message",\n\t\t\t\t"You successfully uploaded " + file.getOriginalFilename() + "!");\n\n\t\treturn "redirect:/";\n\t}\n\n\t@ExceptionHandler(StorageFileNotFoundException.class)\n\tpublic ResponseEntity<?> handleStorageFileNotFound(StorageFileNotFoundException exc) {\n\t\treturn ResponseEntity.notFound().build();\n\t}\n\n}\n```\n\n`FileUploadController` 类使用 `@Controller` 注解，以便 Spring 可以扫描并注册它。 每个方法都标有 `@GetMapping` 或 `@PostMapping` ，将路径和 HTTP 操作映射到指定的控制器。\n\n在这种情况下：\n\n- GET `/`：从 `StorageService` 中查找当前上传文件的列表，并将其加载到 Thymeleaf 模板中。 它使用 `MvcUriComponentsBuilder` 计算指向实际资源的链接。\n\n- GET `/files/{filename}`：加载资源（如果存在）并使用 Content-Disposition 响应标头将其发送到浏览器进行下载。\n\n- POST `/`：处理一个多部分的消息文件，并将其交给 `StorageService` 进行保存。\n\n### 定义存储文件的 Service\n\n```java\nimport org.springframework.core.io.Resource;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\npublic interface StorageService {\n\n\tvoid init();\n\n\tvoid store(MultipartFile file);\n\n\tStream<Path> loadAll();\n\n\tPath load(String filename);\n\n\tResource loadAsResource(String filename);\n\n\tvoid deleteAll();\n\n}\n```\n\n一个加单的 `StorageService` 实现：\n\n```java\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.FileSystemUtils;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.stream.Stream;\n\n@Service\npublic class FileSystemStorageServiceImpl implements StorageService {\n\n    private final Path rootLocation;\n\n    @Autowired\n    public FileSystemStorageServiceImpl(StorageProperties properties) {\n        this.rootLocation = Paths.get(properties.getLocation());\n    }\n\n    @Override\n    public void deleteAll() {\n        FileSystemUtils.deleteRecursively(rootLocation.toFile());\n    }\n\n    @Override\n    public void init() {\n        try {\n            Files.createDirectories(rootLocation);\n        } catch (IOException e) {\n            throw new StorageException("Could not initialize storage", e);\n        }\n    }\n\n    @Override\n    public Path load(String filename) {\n        return rootLocation.resolve(filename);\n    }\n\n    @Override\n    public Stream<Path> loadAll() {\n        try {\n            return Files.walk(this.rootLocation, 1).filter(path -> !path.equals(this.rootLocation))\n                .map(this.rootLocation::relativize);\n        } catch (IOException e) {\n            throw new StorageException("Failed to read stored files", e);\n        }\n    }\n\n    @Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path file = load(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                throw new StorageFileNotFoundException("Could not read file: " + filename);\n            }\n        } catch (MalformedURLException e) {\n            throw new StorageFileNotFoundException("Could not read file: " + filename, e);\n        }\n    }\n\n    @Override\n    public void store(MultipartFile file) {\n        String filename = StringUtils.cleanPath(file.getOriginalFilename());\n        try {\n            if (file.isEmpty()) {\n                throw new StorageException("Failed to store empty file " + filename);\n            }\n            if (filename.contains("..")) {\n                // This is a security check\n                throw new StorageException(\n                    "Cannot store file with relative path outside current directory " + filename);\n            }\n            try (InputStream inputStream = file.getInputStream()) {\n                Files.copy(inputStream, this.rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n            }\n        } catch (IOException e) {\n            throw new StorageException("Failed to store file " + filename, e);\n        }\n    }\n\n}\n```\n\n### 创建文件上传表单\n\n```html\n<html xmlns:th="https://www.thymeleaf.org">\n<body>\n\n\t<div th:if="${message}">\n\t\t<h2 th:text="${message}"/>\n\t</div>\n\n\t<div>\n\t\t<form method="POST" enctype="multipart/form-data" action="/">\n\t\t\t<table>\n\t\t\t\t<tr><td>File to upload:</td><td><input type="file" name="file" /></td></tr>\n\t\t\t\t<tr><td></td><td><input type="submit" value="Upload" /></td></tr>\n\t\t\t</table>\n\t\t</form>\n\t</div>\n\n\t<div>\n\t\t<ul>\n\t\t\t<li th:each="file : ${files}">\n\t\t\t\t<a th:href="${file}" th:text="${file}" />\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\n</body>\n</html>\n```\n\n### 文件上传限制\n\n如果使用 Spring Boot，可以使用一些属性设置来调整其自动配置的 `MultipartConfigElement`。\n\n将以下属性添加到现有属性设置中（在 `src/main/resources/application.properties` 中）：\n\n```properties\nspring.servlet.multipart.max-file-size=128KB\nspring.servlet.multipart.max-request-size=128KB\n```\n\n- `spring.servlet.multipart.max-file-size` 设置为 128KB，表示总文件大小不能超过 128KB。\n- `spring.servlet.multipart.max-request-size` 设置为 128KB，这意味着 `multipart/form-data` 的总请求大小不能超过 128KB。\n\n## 异常处理\n\n### @ExceptionHandler\n\n`@Controller` 和 [@ControllerAdvice](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice) 类可以用 `@ExceptionHandler` 方法来处理来自控制器方法的异常，如以下示例所示：\n\n```java\n@Controller\npublic class SimpleController {\n\n    // ...\n\n    @ExceptionHandler\n    public ResponseEntity<String> handle(IOException ex) {\n        // ...\n    }\n}\n```\n\n异常可能与正在传播的顶级异常（例如，抛出直接的 `IOException`）或包装器异常中的嵌套原因（例如，包装在 `IllegalStateException` 中的 `IOException`）相匹配。从 5.3 开始，这可以匹配任意原因级别，而以前只考虑直接原因。\n\n对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常优先于原因异常匹配。更具体地说，`ExceptionDepthComparator` 用于根据抛出的异常类型的深度对异常进行排序。\n\n或者，注解声明可以缩小要匹配的异常类型，如以下示例所示：\n\n```java\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(IOException ex) {\n    // ...\n}\n```\n\n您甚至可以使用具有非常通用的参数签名的特定异常类型列表，如以下示例所示：\n\n```java\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(Exception ex) {\n    // ...\n}\n```\n\n通常建议您在参数签名中尽可能具体，以减少根本和原因异常类型之间不匹配的可能性。考虑将一个多重匹配方法分解为单独的 `@ExceptionHandler` 方法，每个方法通过其签名匹配一个特定的异常类型。\n\n在多 `@ControllerAdvice` 安排中，建议在具有相应顺序优先级的 `@ControllerAdvice` 上声明您的主要根异常映射。虽然根异常匹配优于原因，但这是在给定控制器或 `@ControllerAdvice` 类的方法中定义的。这意味着优先级较高的 `@ControllerAdvice` 上的原因匹配优于优先级较低的 `@ControllerAdvice` 上的任何匹配（例如，root）。\n\n最后但同样重要的是， `@ExceptionHandler` 方法实现可以选择通过以原始形式重新抛出给定异常实例来退出处理。这在您只对根级匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下很有用。重新抛出的异常通过剩余的解析链传播，就好像给定的 `@ExceptionHandler` 方法一开始就不会匹配一样。\n\nSpring MVC 中对 `@ExceptionHandler` 方法的支持建立在 `DispatcherServlet` 级别 [HandlerExceptionResolver](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers) 机制上。\n\n> 附录：\n>\n> [`@ExceptionHandler` 支持的参数](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler-args)\n>\n> [`@ExceptionHandler` 支持返回值](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler-return-values)\n\n\n\n## 参考资料\n\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Framework 官方文档之 Web](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)\n'},{title:"Spring MVC 之 DispatcherServlet",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"DispatcherServlet 工作原理",slug:"dispatcherservlet-工作原理",link:"#dispatcherservlet-工作原理",children:[]}]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"路径匹配",slug:"路径匹配",link:"#路径匹配",children:[]},{level:2,title:"拦截器",slug:"拦截器",link:"#拦截器",children:[]},{level:2,title:"解析器",slug:"解析器",link:"#解析器",children:[{level:3,title:"HandlerExceptionResolver",slug:"handlerexceptionresolver",link:"#handlerexceptionresolver",children:[]},{level:3,title:"ViewResolver",slug:"viewresolver",link:"#viewresolver",children:[]},{level:3,title:"LocaleResolver",slug:"localeresolver",link:"#localeresolver",children:[]},{level:3,title:"ThemeResolver",slug:"themeresolver",link:"#themeresolver",children:[]},{level:3,title:"MultipartResolver",slug:"multipartresolver",link:"#multipartresolver",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/20287b/",pathLocale:"/",extraFields:'---\ntitle: Spring MVC 之 DispatcherServlet\ndate: 2023-02-13 09:57:52\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\n  - DispatcherServlet\npermalink: /pages/20287b/\n---\n\n# Spring MVC 之 DispatcherServlet\n\n## 简介\n\n`DispatcherServlet` 是 Spring MVC 框架的核心组件，负责将**客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果**。\n\n### DispatcherServlet 工作原理\n\n#### DispatcherServlet 工作流程\n\n`DispatcherServlet` 的工作流程大致如下图所示：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png)\n\n1. **接收 Http 请求**：当客户端发送 HTTP 请求时，`DispatcherServlet` 接收该请求并将其传递给 Spring MVC 框架。\n2. **选择 `Handler`**：`DispatcherServlet` 会根据请求的 URL 找到对应的处理器映射器 `HandlerMapping`，该映射器会根据配置文件中的 URL 映射规则找到合适的处理器 `Handler`。\n   - **绑定属性**：`DispatcherServlet` 会根据程序的 web 初始化策略关联各种 `Resolver`，如：`LocaleResolver`、`ThemeResolver` 等。\n   - `DispatcherServlet` 根据 `<servlet-name>-servlet.xml` 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 `HandlerMapping` 获得该 `Handler` 配置的所有相关的对象（包括 `Handler` 对象以及 `Handler` 对象对应的拦截器），最后以`HandlerExecutionChain` 对象的形式返回。\n     - 将请求映射到处理程序以及用于预处理和后处理的拦截器列表。映射基于一些标准，其细节因 `HandlerMapping` 实现而异。\n     - 两个主要的 `HandlerMapping` 实现是 `RequestMappingHandlerMapping`（支持 `@RequestMapping` 注释方法）和 `SimpleUrlHandlerMapping`（维护 URI 路径模式到处理程序的显式注册）。\n3. **选择 `HandlerAdapter`**： `DispatcherServlet` 根据获得的 `Handler`，选择一个合适的 `HandlerAdapter`。\n   - `HandlerAdapter` 帮助 `DispatcherServlet` 调用映射到请求的 `Handler`，而不管实际调用 `Handler` 的方式如何。例如，调用带注解的控制器需要解析注解。`HandlerAdapter` 的主要目的是保护 `DispatcherServlet` 免受此类细节的影响。\n4. **`Handler` 处理请求**：`DispatcherServlet` 提取 `Request` 中的模型数据，填充 `Handler` 入参，由 `HandlerAdapter` 负责调用 `Handler`（`Controller`)。 在填充 `Handler` 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n   - `HttpMessageConverter`： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n   - 数据转换：对请求消息进行数据转换。如 `String` 转换成 `Integer`、`Double `等。\n   - 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n   - 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 `BindingResult` 或 `Error` 中。\n5. **返回 `ModelAndView` 对象**：`Handler` 处理完请求后，会返回一个 `ModelAndView` 对象，其中包含了处理结果（`Model`）和视图（`View`）信息。\n6. **选择 `ViewResolver` 渲染 `ModelAndView`**：根据返回的 `ModelAndView`，选择一个适合的 `ViewResolver`，并将 `ModelAndView` 传递给 `ViewResolver` 进行渲染，最后将渲染后的结果返回给客户端。\n\n#### DispatcherServlet 源码解读\n\n前面介绍了 `DispatcherServlet` 的工作流程，下面通过核心源码解读，来加深对 `DispatcherServlet` 工作原理的理解\n\n（1）`onRefresh` 方法\n\n```java\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * 初始化此 servlet 使用的策略对象\n\t * 可以在子类中重写以初始化更多策略对象\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n```\n\n（2）`doService` 方法\n\n`DispatcherServlet` 的核心方法 `doService` 源码如下：\n\n```java\n\t@Override\n\tprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tlogRequest(request);\n\n\t\t// 在包含的情况下保留请求属性的快照，以便能够在包含后恢复原始属性\n\t\tMap<String, Object> attributesSnapshot = null;\n\t\tif (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = new HashMap<>();\n\t\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 设置请求属性（绑定各种 Resolver），使框架对象可用于处理程序和视图对象\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\tif (this.flashMapManager != null) {\n\t\t\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\tif (inputFlashMap != null) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\t\t}\n\n\t\tRequestPath previousRequestPath = null;\n\t\tif (this.parseRequestPath) {\n\t\t\tpreviousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t}\n\n\t\ttry {\n            // 请求分发\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t// 恢复原始属性快照，以防包含\n\t\t\t\tif (attributesSnapshot != null) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parseRequestPath) {\n\t\t\t\tServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n\t\t\t}\n\t\t}\n\t}\n```\n\n（3）`doDispatch` 方法\n\n`doService` 中的核心方法是 `doDispatch`，负责分发请求。\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   HttpServletRequest processedRequest = request;\n   HandlerExecutionChain mappedHandler = null;\n   boolean multipartRequestParsed = false;\n\n   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n   try {\n      ModelAndView mv = null;\n      Exception dispatchException = null;\n\n      try {\n         // 检查是否为multipart请求，如果是，则解析参数\n         processedRequest = checkMultipart(request);\n         multipartRequestParsed = (processedRequest != request);\n\n         // 确定适配当前请求的 Handler\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n         }\n\n         // 确定适配当前请求的 HandlerAdapter\n         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n         // 如果 Handler 支持，则处理 last-modified 头\n         String method = request.getMethod();\n         boolean isGet = HttpMethod.GET.matches(method);\n         if (isGet || HttpMethod.HEAD.matches(method)) {\n            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n            if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n               return;\n            }\n         }\n\n         // 请求的前置处理\n         if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n            return;\n         }\n\n         // 调用实际的 Handler 处理请求并返回 ModelAndView（有可能为 null）\n         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n         if (asyncManager.isConcurrentHandlingStarted()) {\n            return;\n         }\n\n         applyDefaultViewName(processedRequest, mv);\n         // 请求的后置处理\n         mappedHandler.applyPostHandle(processedRequest, response, mv);\n      }\n      catch (Exception ex) {\n         dispatchException = ex;\n      }\n      catch (Throwable err) {\n         // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n         // making them available for @ExceptionHandler methods and other scenarios.\n         dispatchException = new NestedServletException("Handler dispatch failed", err);\n      }\n       // 处理响应结果\n      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n   }\n   catch (Exception ex) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n   }\n   catch (Throwable err) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler,\n            new NestedServletException("Handler processing failed", err));\n   }\n   finally {\n      if (asyncManager.isConcurrentHandlingStarted()) {\n         // 替代 postHandle 和 afterCompletion\n         if (mappedHandler != null) {\n            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n         }\n      }\n      else {\n         // 清理 multipart 请求所使用的资源\n         if (multipartRequestParsed) {\n            cleanupMultipart(processedRequest);\n         }\n      }\n   }\n}\n```\n\n#### 上下文层次结构\n\n`DispatcherServlet` 需要一个 `WebApplicationContext`（`ApplicationContext` 的扩展类）用于它自己的配置。`WebApplicationContext` 有一个指向 `ServletContext` 和与之关联的 `Servlet` 的链接。它还绑定到 `ServletContext`，以便应用程序可以在 `RequestContextUtils` 上使用静态方法来查找 `WebApplicationContext`。\n\n对于多数应用程序来说，拥有一个 `WebApplicationContext` 单例就足够。也可以有一个上下文层次结构，其中有一个根 `WebApplicationContext` 在多个 `DispatcherServlet`（或其他 `Servlet`）实例之间共享，每个实例都有自己的子 `WebApplicationContext` 配置。\n\n根 `WebApplicationContext` 通常包含基础结构 bean，例如需要跨多个 Servlet 实例共享的数据存储和业务服务。这些 bean 是有效继承的，并且可以在特定 `Servlet` 的子 `WebApplicationContext` 中被覆盖（即重新声明），它通常包含指定 `Servlet` 的本地 bean。下图显示了这种关系：\n\n![](https://raw.githubusercontent.com/dunwu/images/master/snap/20230213103223.png)\n\n【示例】配置 `WebApplicationContext` 层次结构：\n\n```java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/app1/*" };\n    }\n}\n```\n\n【示例】`web.xml` 方式配置 `WebApplicationContext` 层次结构：\n\n```xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n## 配置\n\n`DispatcherServlet` 与其他 Servlet 一样，需要使用 Java 配置或在 `web.xml` 中根据 Servlet 规范进行声明和映射。也就是说，`DispatcherServlet` 使用 Spring 配置来发现请求映射、视图解析、异常处理等所需的委托组件。\n\n可以通过将 Servlet 初始化参数（`init-param` 元素）添加到 `web.xml` 文件中的 Servlet 声明来自定义各个 `DispatcherServlet` 实例。下表列出了支持的参数：\n\n| 参数                             | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| :------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `contextClass`                   | 实现 `ConfigurableWebApplicationContext` 的类，将由此 Servlet 实例化和本地配置。默认情况下，使用 `XmlWebApplicationContext`。                                                                                                                                                                                                                                                                                                                                                                                          |\n| `contextConfigLocation`          | 传递给上下文实例（由 `contextClass` 指定）以指示可以在何处找到上下文的字符串。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。在具有两次定义的 bean 的多个上下文位置的情况下，最新的位置优先。                                                                                                                                                                                                                                                                                                       |\n| `namespace`                      | `WebApplicationContext` 的命名空间。默认为 `[servlet-name]-servlet`。                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| `throwExceptionIfNoHandlerFound` | 当找不到请求的处理程序时是否抛出 `NoHandlerFoundException`。然后可以使用 `HandlerExceptionResolver`（例如，通过使用 `@ExceptionHandler` 控制器方法）捕获异常并像其他任何方法一样处理。默认情况下，它设置为 `false`，在这种情况下，`DispatcherServlet` 设置响应状态为 404 (NOT_FOUND) 而不会引发异常。请注意，如果 [默认 servlet 处理](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc -default-servlet-handler) 也被配置，未解决的请求总是转发到默认的 servlet 并且永远不会引发 404。 |\n\n应用程序可以声明处理请求所需的特殊 Bean 类型中列出的基础结构 bean。`DispatcherServlet` 检查每个特殊 bean 的 `WebApplicationContext`。如果没有匹配的 bean 类型，它将回退到 `DispatcherServlet.properties` 中列出的默认类型。\n\n在大多数情况下，MVC 配置是最好的起点。它以 Java 或 XML 声明所需的 bean，并提供更高级别的配置回调 API 来对其进行自定义。\n\n> 注意：Spring Boot 依赖于 MVC Java 配置来配置 Spring MVC，并提供了许多额外的方便选项。\n\n在 Servlet 环境中，您可以选择以编程方式配置 Servlet 容器作为替代方案或与 web.xml 文件结合使用。\n\n```java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n\n        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/");\n    }\n}\n```\n\n`WebApplicationInitializer` 是 Spring MVC 提供的接口，可确保检测到自定义的实现并自动用于初始化任何 Servlet 3 容器。名为 `AbstractDispatcherServletInitializer` 的 `WebApplicationInitializer` 的抽象基类实现通过覆盖方法来指定 servlet 映射和 `DispatcherServlet` 配置的位置，使得注册 `DispatcherServlet` 变得更加容易。\n\n对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：\n\n```java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return null;\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { MyWebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}\n```\n\n如果使用基于 XML 的 Spring 配置，则应直接从 AbstractDispatcherServletInitializer 扩展，如以下示例所示：\n\n```java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        return null;\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n        return cxt;\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}\n```\n\n`AbstractDispatcherServletInitializer` 还提供了一种方便的方法来添加 Filter 实例并将它们自动映射到 `DispatcherServlet`，如以下示例所示：\n\n```java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected Filter[] getServletFilters() {\n        return new Filter[] {\n            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n    }\n}\n```\n\n每个过滤器都根据其具体类型添加一个默认名称，并自动映射到 `DispatcherServlet`。\n\n`AbstractDispatcherServletInitializer` 的 `isAsyncSupported` 保护方法提供了一个单独的位置来启用 `DispatcherServlet` 和映射到它的所有过滤器的异步支持。默认情况下，此标志设置为 true。\n\n最后，如果需要进一步自定义 `DispatcherServlet` 本身，可以重写 `createDispatcherServlet` 方法。\n\n【示例】Java 方式注册并初始化 `DispatcherServlet`，它由 Servlet 容器自动检测（请参阅 Servlet Config）：\n\n```java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext servletContext) {\n\n        // Load Spring web application configuration\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(AppConfig.class);\n\n        // Create and register the DispatcherServlet\n        DispatcherServlet servlet = new DispatcherServlet(context);\n        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/app/*");\n    }\n}\n```\n\n【示例】web.xml 方式注册并初始化 `DispatcherServlet`\n\n```xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/app-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value></param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n## 路径匹配\n\nServlet API 将完整的请求路径公开为 `requestURI`，并将其进一步细分为 `contextPath`、`servletPath` 和 `pathInfo`，它们的值因 Servlet 的映射方式而异。从这些输入中，Spring MVC 需要确定用于映射处理程序的查找路径，如果适用，它应该排除 `contextPath` 和任何 `servletMapping` 前缀。\n\n`servletPath` 和 `pathInfo` 已解码，这使得它们无法直接与完整的 `requestURI` 进行比较以派生 `lookupPath`，因此有必要对 `requestURI` 进行解码。然而，这引入了它自己的问题，因为路径可能包含编码的保留字符，例如 `"/"` 或 `";"` 这反过来又会在解码后改变路径的结构，这也可能导致安全问题。此外，Servlet 容器可能会在不同程度上规范化 `servletPath`，这使得进一步无法对 `requestURI` 执行 `startsWith` 比较。\n\n这就是为什么最好避免依赖基于前缀的 `servletPath` 映射类型附带的 `servletPath`。如果 `DispatcherServlet` 被映射为带有 `"/"` 的默认 Servlet，或者没有带 `"/*"` 的前缀，并且 Servlet 容器是 4.0+，则 Spring MVC 能够检测 Servlet 映射类型，并避免使用 `servletPath` 和 `pathInfo`。在 3.1 Servlet 容器上，假设相同的 Servlet 映射类型，可以通过在 MVC 配置中通过路径匹配提供一个带有 `alwaysUseFullPath=true` 的 `UrlPathHelper` 来实现等效。\n\n幸运的是，默认的 Servlet 映射 `"/"` 是一个不错的选择。但是，仍然存在一个问题，即需要对 `requestURI` 进行解码才能与控制器映射进行比较。这也是不可取的，因为可能会解码改变路径结构的保留字。如果不需要这样的字符，那么您可以拒绝它们（如 Spring Security HTTP 防火墙），或者您可以使用 `urlDecode=false` 配置 `UrlPathHelper`，但控制器映射需要与编码路径匹配，这可能并不总是有效。此外，有时 `DispatcherServlet` 需要与另一个 Servlet 共享 URL 空间，并且可能需要通过前缀进行映射。\n\n在使用 `PathPatternParser` 和解析模式时解决了上述问题，作为使用 `AntPathMatcher` 进行字符串路径匹配的替代方法。`PathPatternParser` 从 5.3 版本开始就可以在 Spring MVC 中使用，并且从 6.0 版本开始默认启用。与需要解码查找路径或编码控制器映射的 `AntPathMatcher` 不同，解析的 `PathPattern` 与称为 `RequestPath` 的路径的解析表示匹配，一次一个路径段。这允许单独解码和清理路径段值，而没有改变路径结构的风险。解析的 `PathPattern` 也支持使用 `servletPath` 前缀映射，只要使用 Servlet 路径映射并且前缀保持简单，即它没有编码字符。\n\n## 拦截器\n\n所有 `HandlerMapping` 实现都支持处理拦截器，当想要将特定功能应用于某些请求时，这些拦截器很有用——例如，检查主体。拦截器必须使用 `org.springframework.web.servlet` 包中的三个方法实现 `HandlerInterceptor`，这三个方法应该提供足够的灵活性来进行各种预处理和后处理：\n\n- `preHandle(..)`：在实际 handler 之前执行\n- `postHandle(..)`：handler 之后执行\n- `afterCompletion(..)`：完成请求后执行\n\n`preHandle(..)` 方法返回一个布尔值。可以使用此方法中断或继续执行链的处理。当此方法返回 true 时，处理程序执行链将继续。当它返回 false 时，`DispatcherServlet` 假定拦截器本身已经处理请求（并且，例如，呈现适当的视图）并且不会继续执行其他拦截器和执行链中的实际处理程序。\n\n有关如何配置拦截器的示例，请参阅 MVC 配置部分中的[拦截器](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-interceptors)。还可以通过在各个 `HandlerMapping` 实现上使用 setter 来直接注册它们。\n\n`postHandle` 方法对于 `@ResponseBody` 和 `ResponseEntity` 的方法不太有用，它们的响应是在 `HandlerAdapter` 中和 `postHandle` 之前编写和提交的。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于此类场景，您可以实现 `ResponseBodyAdvice` 并将其声明为 [Controller Advice](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice) bean 或直接在 `RequestMappingHandlerAdapter` 上进行配置。\n\n## 解析器\n\nDispatcherServlet 会加载多种解析器来处理请求，比较常见的有以下几个：\n\n- [`HandlerExceptionResolver`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers) - 解决异常的策略，可能将它们映射到处理程序、HTML 错误视图或其他目标。\n- [`ViewResolver`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver) - 将从处理程序返回的基于字符串的逻辑视图名称解析为用于呈现响应的实际视图。\n- [`LocaleResolver`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver), [LocaleContextResolver](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone) - 解析用户正在使用的本地化设置，可能还有他们的时区，以便能够提供国际化的视图。\n- [`ThemeResolver`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver) - 解析 Web 应用程序可以使用的主题——例如，提供个性化布局。\n- [`MultipartResolver`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart) - 通过一些 multipart 解析库的帮助解析 multipart 请求（例如，通过浏览器上传文件）。\n\n### HandlerExceptionResolver\n\n在 `WebApplicationContext` 中声明的 `HandlerExceptionResolver` 用于解决请求处理期间抛出的异常。这些异常解析器允许自定义逻辑来解决异常。\n\n对于 HTTP 缓存支持，处理程序可以使用 `WebRequest` 的 `checkNotModified` 方法，以及用于控制器的 HTTP 缓存中所述的带注释控制器的更多选项。\n\n如果在请求映射期间发生异常或从请求处理程序（例如 `@Controller`）抛出异常，则 `DispatcherServlet` 委托 `HandlerExceptionResolver` 链来解决异常并提供替代处理，这通常是错误响应。\n\n下表列出了可用的 `HandlerExceptionResolver` 实现：\n\n| `HandlerExceptionResolver`                                                                                                                                                           | 说明                                                                                      |\n| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------- |\n| `SimpleMappingExceptionResolver`                                                                                                                                                     | 异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。                  |\n| [`DefaultHandlerExceptionResolver`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html) | 解决由 Spring MVC 引发的异常并将它们映射到 HTTP 状态代码。                                |\n| `ResponseStatusExceptionResolver`                                                                                                                                                    | 使用 `@ResponseStatus` 注解解决异常，并根据注解中的值将它们映射到 HTTP 状态代码。         |\n| `ExceptionHandlerExceptionResolver`                                                                                                                                                  | 通过在 `@Controller` 或 `@ControllerAdvice` 类中调用 `@ExceptionHandler` 方法来解决异常。 |\n\n#### 解析器链\n\n您可以通过在 Spring 配置中声明多个 `HandlerExceptionResolver` bean 并根据需要设置它们的顺序属性来构成异常解析器链。order 属性越高，异常解析器的位置就越靠后。\n\n`HandlerExceptionResolver` 的约定使它可以返回以下内容：\n\n- 指向错误视图的 `ModelAndView`。\n\n- 如果异常是在解析器中处理的，则为空的 `ModelAndView`。\n\n- 如果异常仍未解决，则为 null，供后续解析器尝试，如果异常仍然存在，则允许向上冒泡到 Servlet 容器。\n\nMVC Config 自动为默认的 Spring MVC 异常、`@ResponseStatus` 注释的异常和对 `@ExceptionHandler` 方法的支持声明内置解析器。您可以自定义该列表或替换它。\n\n#### 错误页面\n\n如果异常仍未被任何 `HandlerExceptionResolver` 处理并因此继续传播，或者如果响应状态设置为错误状态（即 4xx、5xx），Servlet 容器可以在 HTML 中呈现默认错误页面。要自定义容器的默认错误页面，您可以在 `web.xml` 中声明一个错误页面映射。以下示例显示了如何执行此操作：\n\n```xml\n<error-page>\n    <location>/error</location>\n</error-page>\n```\n\n在前面的示例中，当出现异常或响应具有错误状态时，Servlet 容器会在容器内将 ERROR 分派到配置的 URL（例如，`/error`）。然后由 `DispatcherServlet` 处理，可能将其映射到 `@Controller`，后者可以返回带有模型的错误视图名称或呈现 JSON 响应，如以下示例所示：\n\n```java\n@RestController\npublic class ErrorController {\n\n    @RequestMapping(path = "/error")\n    public Map<String, Object> handle(HttpServletRequest request) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put("status", request.getAttribute("jakarta.servlet.error.status_code"));\n        map.put("reason", request.getAttribute("jakarta.servlet.error.message"));\n        return map;\n    }\n}\n```\n\n> 提示：Servlet API 不提供在 Java 中创建错误页面映射的方法。但是，您可以同时使用 `WebApplicationInitializer` 和最小的 `web.xml`。\n\n### ViewResolver\n\nSpring MVC 定义了 `ViewResolver` 和 `View` 接口，让用户可以在浏览器中渲染模型，而无需限定于特定的视图技术。`ViewResolver` 提供视图名称和实际视图之间的映射。`View` 解决了在移交给特定视图技术之前准备数据的问题。\n\n下表提供了有关 ViewResolver 一些子类：\n\n| ViewResolver                     | Description                                                                                                                                                                                                                                                                        |\n| :------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `AbstractCachingViewResolver`    | `AbstractCachingViewResolver` 的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。您可以通过将 `cache` 属性设置为 `false` 来关闭缓存。此外，如果您必须在运行时刷新某个视图（例如，修改 FreeMarker 模板时），您可以使用 removeFromCache(String viewName, Locale loc) 方法。 |\n| `UrlBasedViewResolver`           | `ViewResolver` 接口的简单实现，无需显式映射定义即可将逻辑视图名称直接解析为 URL。如果您的逻辑名称以直接的方式匹配您的视图资源的名称，而不需要任意映射，那么这是合适的。                                                                                                            |\n| `InternalResourceViewResolver`   | `UrlBasedViewResolver` 的子类，支持 `InternalResourceView`（实际上是 Servlet 和 JSP）以及 `JstlView` 和 `TilesView` 等子类。可以使用 `setViewClass(..)` 为该解析器生成的所有视图指定视图类。                                                                                       |\n| `FreeMarkerViewResolver`         | `UrlBasedViewResolver` 的子类，支持 `FreeMarkerView` 和它们的自定义子类。                                                                                                                                                                                                          |\n| `ContentNegotiatingViewResolver` | `ViewResolver` 接口的实现，该接口根据请求文件名或 `Accept` 标头解析视图。                                                                                                                                                                                                          |\n| `BeanNameViewResolver`           | 将视图名称解释为当前应用程序上下文中的 bean 名称的 ViewResolver 接口的实现。这是一个非常灵活的变体，允许根据不同的视图名称混合和匹配不同的视图类型。每个这样的“视图”都可以定义为一个 bean，例如 在 XML 或配置类中。                                                                |\n\n#### 处理\n\n可以通过声明多个解析器来构成视图解析器链，如果需要，还可以通过设置 order 属性来指定顺序。顺序属性越高，视图解析器在链中的位置就越靠后。\n\n`ViewResolver` 的约定指定它可以返回 null 以指示找不到视图。但是，对于 JSP 和 `InternalResourceViewResolver`，确定 JSP 是否存在的唯一方法是通过 `RequestDispatcher` 执行分派。因此，您必须始终将 `InternalResourceViewResolver` 配置为在视图解析器的整体顺序中排在最后。\n\n配置视图解析就像将 `ViewResolver` 添加到 Spring 配置中一样简单。MVC Config 为视图解析器和添加无逻辑视图控制器提供了专用的配置 API，这对于没有控制器逻辑的 HTML 模板渲染很有用。\n\n#### 重定向\n\n视图名称中的特殊前缀 `redirect:` 可以实现一个重定向。`UrlBasedViewResolver`（及其子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向 URL。\n\n最终效果与控制器返回 `RedirectView` 相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如 `redirect:/myapp/some/resource`）相对于当前 Servlet 上下文重定向，而名称（例如 `redirect:https://myhost.com/some/arbitrary/path`）重定向到绝对 URL。\n\n请注意，如果使用 `@ResponseStatus` 注解标记控制器方法，则注解值优先于 `RedirectView` 设置的响应状态。\n\n#### 转发\n\n视图名称中的特殊前缀 `forward:` 可以实现一个转发。这将创建一个 `InternalResourceView`，它执行 `RequestDispatcher.forward()`。因此，此前缀对 `InternalResourceViewResolver` 和 `InternalResourceView`（对于 JSP）没有用，但如果您使用另一种视图技术但仍想强制转发由 Servlet/JSP 引擎处理的资源，它可能会有所帮助。\n\n#### 内容协商\n\n`ContentNegotiatingViewResolver` 本身不解析视图，而是委托给其他视图解析器并选择类似于客户端请求的表示的视图。可以从 `Accept` 头或查询参数（例如，`"/path?format=pdf"`）确定表示形式。\n\n`ContentNegotiatingViewResolver` 通过将请求媒体类型与其每个 `ViewResolver` 关联的 `View` 支持的媒体类型（也称为 `Content-Type`）进行比较，来选择合适的 `View` 来处理请求。列表中第一个具有兼容 `Content-Type` 的视图将处理结果返回给客户端。如果 `ViewResolver` 链无法提供兼容的视图，则会查阅通过 `DefaultViews` 属性指定的视图列表。后一个选项适用于单例视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。`Accept` 标头可以包含通配符（例如 `text/*`），在这种情况下，`Content-Type` 为 `text/xml` 的 View 是兼容的匹配项。\n\n### LocaleResolver\n\n大部分的 Spring 架构都支持国际化，就像 Spring web MVC 框架所做的那样。`DispatcherServlet` 允许您使用客户端的语言环境自动解析消息。这是通过 `LocaleResolver` 对象完成的。\n\n当收到请求时，`DispatcherServlet` 会寻找语言环境解析器，如果找到，它会尝试使用它来设置 Locale 环境。通过使用 `RequestContext.getLocale()` 方法，您始终可以检索由 Locale 解析器解析的语言环境。\n\n除了自动识别 Locale 环境之外，您还可以为 handle 映射附加拦截器，在特定情况下更改 Locale 环境设置（例如，基于请求中的参数）。\n\nLocale 解析器和拦截器在 `org.springframework.web.servlet.i18n` 包中定义，并以正常方式在您的应用程序上下文中配置。Spring 中有以下 Locale 解析器可供选择。\n\n- [Time Zone](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone)\n- [Header Resolver](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-acceptheader)\n- [Cookie Resolver](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-cookie)\n- [Session Resolver](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-session)\n- [Locale Interceptor](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver-interceptor)\n\n#### LocaleResolver\n\n除了获取客户端的区域设置外，了解其时区通常也很有用。`LocaleContextResolver` 接口提供了 `LocaleResolver` 的扩展，让解析器提供更丰富的 `LocaleContext`，其中可能包括时区信息。\n\n如果可用，可以使用 `RequestContext.getTimeZone()` 方法获取用户的 `TimeZone`。在 Spring 的 `ConversionService` 中注册的任何日期/时间 `Converter` 和 `Formatter` 对象会自动使用时区信息。\n\n#### 标头解析器\n\n此 Locale 解析器检查客户端（例如网络浏览器）发送的请求中的 `accept-language` 头。通常，此头字段包含客户端操作系统的区域信息。请注意，此解析器不支持时区信息。\n\n#### CookieLocaleResolver\n\nThis locale resolver inspects a `Cookie` that might exist on the client to see if a `Locale` or `TimeZone` is specified. If so, it uses the specified details. By using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. The following example defines a `CookieLocaleResolver`:\n\n此 Locale 解析器检查客户端上是否存在 `Cookie`，以查看是否指定了 `Locale` 或 `TimeZone`。如果是，它会使用指定的详细信息。通过使用此 Locale 解析器的属性，可以指定 cookie 的名称以及最长期限。以下示例定义了 `CookieLocaleResolver`：\n\n```xml\n<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">\n\n    <property name="cookieName" value="clientlanguage"/>\n\n    \x3c!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --\x3e\n    <property name="cookieMaxAge" value="100000"/>\n\n</bean>\n```\n\n下表描述了 `CookieLocaleResolver` 的属性：\n\n| 属性           | 默认值                    | Description                                                                                             |\n| :------------- | :------------------------ | :------------------------------------------------------------------------------------------------------ |\n| `cookieName`   | 类名 + LOCALE             | cookie 名                                                                                               |\n| `cookieMaxAge` | Servlet container default | cookie 在客户端上保留的最长时间。如果指定了“-1”，则不会保留 cookie。它仅在客户端关闭浏览器之前可用。    |\n| `cookiePath`   | /                         | 将 cookie 的可见性限制在您网站的特定部分。当指定 `cookiePath` 时，cookie 仅对该路径及其下方的路径可见。 |\n\n#### SessionLocaleResolver\n\n`SessionLocaleResolver` 允许您从可能与用户请求相关联的会话中检索 `Locale` 和 `TimeZone`。与 `CookieLocaleResolver` 相比，此策略将本地选择的 locale 设置存储在 Servlet 容器的 `HttpSession` 中。因此，这些设置对于每个会话都是临时的，因此会在每个会话结束时丢失。\n\n注意，这与外部会话管理机制（例如 Spring Session 项目）没有直接关系。此 `SessionLocaleResolver` 根据当前 `HttpServletRequest` 评估和修改相应的 `HttpSession` 属性。\n\n#### LocaleChangeInterceptor\n\n可以通过将 `LocaleChangeInterceptor` 添加到一个 `HandlerMapping` 定义来启用区域设置更改。它检测请求中的参数并相应地更改 Locale 环境，在调度程序的应用程序上下文中调用 `LocaleResolver` 上的 `setLocale` 方法。下面的示例显示调用所有包含名为 `siteLanguage` 的参数的 `*.view` 资源，以更改语言环境。因此，例如，对 URL `https://www.sf.net/home.view?siteLanguage=nl` 的请求将站点语言更改为荷兰语。以下示例显示了如何拦截语言环境：\n\n```xml\n<bean id="localeChangeInterceptor"\n        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">\n    <property name="paramName" value="siteLanguage"/>\n</bean>\n\n<bean id="localeResolver"\n        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>\n\n<bean id="urlMapping"\n        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">\n    <property name="interceptors">\n        <list>\n            <ref bean="localeChangeInterceptor"/>\n        </list>\n    </property>\n    <property name="mappings">\n        <value>/**/*.view=someController</value>\n    </property>\n</bean>\n```\n\n### ThemeResolver\n\n您可以应用 Spring Web MVC 框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。\n\n要在 Web 应用程序中使用主题，必须设置 `org.springframework.ui.context.ThemeSource` 接口的实现。`WebApplicationContext` 接口扩展了 `ThemeSource` 但将其职责委托给了专门的实现。默认情况下，委托是 `org.springframework.ui.context.support.ResourceBundleThemeSource` ，它从类的根路径加载属性文件。要使用自定义的 `ThemeSource` 实现或配置 `ResourceBundleThemeSource` 的基本名称前缀，您可以在应用程序上下文中使用保留名称 `themeSource` 注册一个 bean。Web 应用程序上下文自动检测具有该名称的 bean 并使用它。\n\n当使用 `ResourceBundleThemeSource` 时，主题是在一个简单的属性文件中定义的。属性文件列出了构成主题的资源，如以下示例所示：\n\n```properties\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n```\n\n属性的键是从视图代码中引用主题元素的名称。对于 JSP，通常使用 `spring:theme` 自定义标签来执行此操作，它与 `spring:message` 标签非常相似。以下 JSP 片段使用前面示例中定义的主题来自定义外观：\n\n```xml\n<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>\n<html>\n    <head>\n        <link rel="stylesheet" href="<spring:theme code=\'styleSheet\'/>" type="text/css"/>\n    </head>\n    <body style="background=<spring:theme code=\'background\'/>">\n        ...\n    </body>\n</html>\n```\n\n默认情况下， `ResourceBundleThemeSource` 使用空的基本名称前缀。因此，属性文件是从类路径的根加载的。因此，可以将 `cool.properties` 主题定义放在类路径根目录中（例如，在 `/WEB-INF/classes` 中）。`ResourceBundleThemeSource` 使用标准的 Java 资源包加载机制，允许主题完全国际化。例如，我们可以有一个 `/WEB-INF/classes/cool_nl.properties`，它引用一个带有荷兰语文本的特殊背景图像。\n\n定义主题后，可以决定使用哪个要使用的主题。`DispatcherServlet` 查找名为 `themeResolver` 的 bean 以找出要使用的 `ThemeResolver` 实现。主题解析器的工作方式与 `LocaleResolver` 大致相同。它检测用于特定请求的主题，也可以更改请求的主题。下表描述了 Spring 提供的主题解析器：\n\n| Class                  | Description                                                                           |\n| :--------------------- | :------------------------------------------------------------------------------------ |\n| `FixedThemeResolver`   | 选择一个固定的主题，使用 `defaultThemeName` 属性设置。                                |\n| `SessionThemeResolver` | 主题在用户的 HTTP 会话中维护。 它只需要为每个会话设置一次，但不会在会话之间持续存在。 |\n| `CookieThemeResolver`  | 所选主题存储在客户端的 cookie 中。                                                    |\n\nSpring 还提供了一个 `ThemeChangeInterceptor`，它允许使用一个简单的请求参数在每个请求上更改主题。\n\n### MultipartResolver\n\n`org.springframework.web.multipart` 包中的 `MultipartResolver` 是一种解析 multipart 请求（包括文件上传）的策略。 有一个基于容器的 `StandardServletMultipartResolver` 实现，用于 Servlet 多部分请求解析。 请注意，从具有新 Servlet 5.0+ 基线的 Spring Framework 6.0 开始，基于 Apache Commons FileUpload 的过时的 `CommonsMultipartResolver` 不再可用。\n\n要启用 multipart 处理，需要在 `DispatcherServlet` Spring 配置中声明一个名为 `multipartResolver` 的 `MultipartResolver`。 `DispatcherServlet` 检测到它并将其应用于传入请求。 当接收到内容类型为 `multipart/form-data` 的 POST 时，解析器解析将当前 `HttpServletRequest` 包装为 `MultipartHttpServletRequest` 的内容，以提供对已解析文件的访问以及将部分作为请求参数公开。\n\nServlet 多部分解析需要通过 Servlet 容器配置启用。 为此：\n\n- 在 Java 中，在 Servlet 注册上设置一个 `MultipartConfigElement`。\n\n- 在 `web.xml` 中，将 `<multipart-config>` 部分添加到 servlet 声明。\n\n以下示例显示如何在 Servlet 注册上设置 `MultipartConfigElement`：\n\n```java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n        registration.setMultipartConfig(new MultipartConfigElement("/tmp"));\n    }\n\n}\n```\n\n一旦 Servlet multipart 配置好，就可以添加一个名为 `multipartResolver` 的 `StandardServletMultipartResolver` 类型的 bean。\n\n## 参考资料\n\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Framework 官方文档之 Web](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)'},{title:"Spring MVC 之过滤器",headers:[{level:2,title:"表单内容过滤器",slug:"表单内容过滤器",link:"#表单内容过滤器",children:[]},{level:2,title:"转发过滤器",slug:"转发过滤器",link:"#转发过滤器",children:[]},{level:2,title:"ETag 过滤器",slug:"etag-过滤器",link:"#etag-过滤器",children:[]},{level:2,title:"跨域过滤器",slug:"跨域过滤器",link:"#跨域过滤器",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/4a164d/",pathLocale:"/",extraFields:'---\ntitle: Spring MVC 之过滤器\ndate: 2023-02-14 17:44:09\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\n  - Filter\npermalink: /pages/4a164d/\n---\n\n# Spring MVC 之过滤器\n\n`spring-web` 模块提供了一些有用的 Filter：\n\n- [Form Data](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-http-put)\n- [Forwarded Headers](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-forwarded-headers)\n- [Shallow ETag](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-shallow-etag)\n- [CORS](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-cors)\n\n## 表单内容过滤器\n\n浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据，但非浏览器客户端也可以使用 HTTP PUT、PATCH 和 DELETE。 Servlet API 需要 `ServletRequest.getParameter*()` 系列方法来支持仅对 HTTP POST 的表单字段访问。\n\n`spring-web` 模块提供了 `FormContentFilter` 来拦截内容类型为 `applicationx-www-form-urlencoded` 的 HTTP PUT、PATCH、DELETE 请求，从请求体中读取表单数据，并包装 `ServletRequest` 通过 `ServletRequest.getParameter()` 系列方法使表单数据可用。\n\n## 转发过滤器\n\n当请求通过代理（如负载均衡器）时，主机、端口和方案可能会发生变化，这使得从客户端角度创建指向正确主机、端口和方案的链接成为一项挑战。\n\n[RFC 7239](https://tools.ietf.org/html/rfc7239) 定义了 `Forwarded` HTTP 头，代理可以使用它来提供有关原始请求的信息。还有其他非标准头，包括 `X-Forwarded-Host`、`X-Forwarded-Port`、`X-Forwarded-Proto`、`X-Forwarded-Ssl` 和 `X-Forwarded-Prefix`。\n\n`ForwardedHeaderFilter` 是一个 Servlet 过滤器，它修改请求以便 a) 根据 `Forwarded` 头更改主机、端口和 scheme；b) 删除这些头以消除进一步的影响。该过滤器依赖于包装请求，因此它必须排在其他过滤器之前，例如 `RequestContextFilter`，它应该与修改后的请求一起使用，而不是原始请求。\n\n`Forwarded` 头有安全考量，因为应用程序无法知道头是由代理按预期添加的，还是由恶意客户端添加的。这就是为什么应将信任边界处的代理配置为删除来自外部的不受信任的 `Forwarded` 头。还可以使用 `removeOnly=true` 配置 `ForwardedHeaderFilter`，在这种情况下它会删除但不使用头。\n\n为了支持[异步请求](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async)和错误分派，此过滤器应使用 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR` 进行映射。如果使用 Spring Framework 的 `AbstractAnnotationConfigDispatcherServletInitializer`（参见 [Servlet Config](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-container-config)），所有过滤器都会自动为所有调度类型注册。但是，如果通过 `web.xml` 或在 Spring Boot 中通过 `FilterRegistrationBean` 注册过滤器，请确保除了 `DispatcherType.REQUEST` 之外还包括 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR`。\n\n## ETag 过滤器\n\n`ShallowEtagHeaderFilter` 过滤器通过缓存写入响应的内容并从中计算 MD5 哈希来创建“浅”ETag。下次客户端发送时，它会做同样的事情，但它还会将计算值与 `If-None-Match` 请求标头进行比较，如果两者相等，则返回 304 (NOT_MODIFIED)。\n\n此策略节省网络带宽但不节省 CPU，因为必须为每个请求计算完整响应。前面描述的控制器级别的其他策略可以避免计算。\n\n此过滤器有一个 `writeWeakETag` 参数，该参数将过滤器配置为写入类似于以下内容的弱 ETag：`W"02a2d595e6ed9a0b24f027f2b63b134d6"`（如 [RFC 7232 Section 2.3](https://tools.ietf.org/html/rfc7232#section-2.3) 中所定义）。\n\n为了支持[异步请求](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async)，这个过滤器必须用 `DispatcherType.ASYNC` 映射，这样过滤器才能延迟并成功生成一个 ETag 到最后最后一次异步调度。如果使用 Spring Framework 的 `AbstractAnnotationConfigDispatcherServletInitializer`，所有过滤器都会自动为所有调度类型注册。但是，如果通过 `web.xml` 或在 Spring Boot 中通过 `FilterRegistrationBean` 注册过滤器，请确保包含 `DispatcherType.ASYNC`。\n\n## 跨域过滤器\n\nSpring MVC 通过控制器上的注解为 CORS 配置提供细粒度支持。但是，当与 Spring Security 一起使用时，建议依赖内置的 `CorsFilter`，它必须在 Spring Security 的过滤器链之前订阅。\n\n## 参考资料\n\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Framework 官方文档之 Web](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)'},{title:"Spring MVC 之跨域",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"处理",slug:"处理",link:"#处理",children:[]},{level:2,title:"@CrossOrigin",slug:"crossorigin",link:"#crossorigin",children:[]},{level:2,title:"全局配置",slug:"全局配置",link:"#全局配置",children:[{level:3,title:"Java 配置",slug:"java-配置",link:"#java-配置",children:[]},{level:3,title:"XML 配置",slug:"xml-配置",link:"#xml-配置",children:[]}]},{level:2,title:"CORS 过滤器",slug:"cors-过滤器",link:"#cors-过滤器",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1d2954/",pathLocale:"/",extraFields:'---\ntitle: Spring MVC 之跨域\ndate: 2023-02-16 20:33:26\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\n  - CORS\npermalink: /pages/1d2954/\n---\n\n# Spring MVC 之跨域\n\nSpring MVC 支持跨域处理（CORS）。\n\n## 简介\n\n出于安全原因，浏览器禁止对当前源之外的资源进行 AJAX 调用。例如，可以在一个选项卡中使用您的银行帐户，而在另一个选项卡中使用 evil.com。来自 evil.com 的脚本不应该能够使用您的凭据向您的银行 API 发出 AJAX 请求——例如从您的账户中取款！\n\n跨域（CORS）是由 [大多数浏览器](https://caniuse.com/#feat=cors) 实施的 [W3C 规范](https://www.w3.org/TR/cors/)，可让您指定哪种跨域请求是授权，而不是使用基于 IFRAME 或 JSONP 的不太安全和不太强大的解决方法。\n\n## 处理\n\nCORS 规范分为预检请求、简单请求和实际请求。要了解 CORS 的工作原理，可以阅读 [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 等，或者查看规范了解更多详细信息。\n\nSpring MVC `HandlerMapping` 实现提供了对 CORS 的内置支持。成功将请求映射到处理程序后，`HandlerMapping` 实现检查给定请求和处理程序的 CORS 配置并采取进一步的操作。预检请求被直接处理，而简单和实际的 CORS 请求被拦截、验证，并设置了所需的 CORS 响应标头。\n\n为了启用跨源请求（即存在 `Origin` 标头并且与请求的主机不同），您需要有一些明确声明的 CORS 配置。如果未找到匹配的 CORS 配置，预检请求将被拒绝。没有 CORS 标头添加到简单和实际 CORS 请求的响应中，因此浏览器会拒绝它们。\n\n每个 `HandlerMapping` 都可以[配置](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations- java.util.Map-) 单独使用基于 URL 模式的 `CorsConfiguration` 映射。 在大多数情况下，应用程序使用 MVC Java 配置或 XML 命名空间来声明此类映射，这会导致将单个全局映射传递给所有 `HandlerMapping` 实例。\n\n可以将 `HandlerMapping` 级别的全局 CORS 配置与更细粒度的处理程序级别的 CORS 配置相结合。 例如，带注释的控制器可以使用类级或方法级的 `@CrossOrigin` 注释（其他处理程序可以实现 `CorsConfigurationSource`）。\n\nThe rules for combining global and local configuration are generally additive — for example, all global and all local origins. For those attributes where only a single value can be accepted, e.g. `allowCredentials` and `maxAge`, the local overrides the global value.\n\n结合全局和局部配置的规则通常是附加的⟩——例如，所有全局和所有局部起源。 对于那些只能接受单个值的属性，例如 `allowCredentials` 和 `maxAge`，局部覆盖全局值。\n\n## `@CrossOrigin`\n\n[`@CrossOrigin`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html) 注解在带注解的 Controller 方法上启用跨源请求，如以下示例所示：\n\n```java\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n\n默认，`@CrossOrigin` 允许访问：\n\n- 所以 origin\n- 所以 header\n- 所以 Controller 方法映射到的 HTTP 方法\n\n`allowCredentials` 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 CSRF 令牌），并且只应在适当的情况下使用。启用时，必须将 `allowOrigins` 设置为一个或多个特定域（但不是特殊值 `"*"`），或者 `allowOriginPatterns` 属性可用于匹配一组动态来源。\n\n`maxAge` 单位为分钟\n\n`@CrossOrigin` 也支持类级别，并且被所有方继承，如下所示：\n\n```java\n@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n\n可以同时在类级别和方法级别上使用 `@CrossOrigin`\n\n```java\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin("https://domain2.com")\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n\n## 全局配置\n\n除了细粒度的控制器方法级别配置之外，您可能还想定义一些全局 CORS 配置。您可以在任何 `HandlerMapping` 上单独设置基于 URL 的 `CorsConfiguration` 映射。但是，大多数应用程序使用 MVC Java 配置或 MVC XML 命名空间来执行此操作。\n\n默认情况下，全局配置启用以下功能：\n\n- 所以 origin\n- 所以 header\n- `GET`、`HEAD` 和 `POST` 方法\n\n`allowCredentials` 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 CSRF 令牌），并且只应在适当的情况下使用。启用时，必须将 `allowOrigins` 设置为一个或多个特定域（但不是特殊值 `"*"`），或者 `allowOriginPatterns` 属性可用于匹配一组动态来源。\n\n`maxAge` 单位为分钟\n\n### Java 配置\n\n要在 MVC Java 配置中启用 CORS，您可以使用 `CorsRegistry` 回调，如以下示例所示：\n\n```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n\n        registry.addMapping("/api/**")\n            .allowedOrigins("https://domain2.com")\n            .allowedMethods("PUT", "DELETE")\n            .allowedHeaders("header1", "header2", "header3")\n            .exposedHeaders("header1", "header2")\n            .allowCredentials(true).maxAge(3600);\n\n        // Add more mappings...\n    }\n}\n```\n\n### XML 配置\n\n要在 XML 命名空间中启用 CORS，可以使用 `<mvc:cors>` 元素，如以下示例所示：\n\n```xml\n<mvc:cors>\n\n    <mvc:mapping path="/api/**"\n        allowed-origins="https://domain1.com, https://domain2.com"\n        allowed-methods="GET, PUT"\n        allowed-headers="header1, header2, header3"\n        exposed-headers="header1, header2" allow-credentials="true"\n        max-age="123" />\n\n    <mvc:mapping path="/resources/**"\n        allowed-origins="https://domain1.com" />\n\n</mvc:cors>\n```\n\n## CORS 过滤器\n\n可以通过 Spring 内置的 [`CorsFilter`](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/filter/CorsFilter.html) 支持 CORS。\n\n要配置过滤器，请将 `CorsConfigurationSource` 传递给它的构造函数，如以下示例所示：\n\n```java\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin("https://domain1.com");\nconfig.addAllowedHeader("*");\nconfig.addAllowedMethod("*");\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration("/**", config);\n\nCorsFilter filter = new CorsFilter(source);\n```\n\n## 参考资料\n\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Framework 官方文档之 Web](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)'},{title:"Spring MVC 之视图技术",headers:[{level:2,title:"Thymeleaf",slug:"thymeleaf",link:"#thymeleaf",children:[]},{level:2,title:"FreeMarker",slug:"freemarker",link:"#freemarker",children:[{level:3,title:"视图配置",slug:"视图配置",link:"#视图配置",children:[]},{level:3,title:"FreeMarker 配置",slug:"freemarker-配置",link:"#freemarker-配置",children:[]},{level:3,title:"表单处理",slug:"表单处理",link:"#表单处理",children:[]}]},{level:2,title:"Groovy",slug:"groovy",link:"#groovy",children:[{level:3,title:"配置",slug:"配置",link:"#配置",children:[]},{level:3,title:"示例",slug:"示例",link:"#示例",children:[]}]},{level:2,title:"脚本视图",slug:"脚本视图",link:"#脚本视图",children:[{level:3,title:"要求",slug:"要求",link:"#要求",children:[]},{level:3,title:"脚本模板",slug:"脚本模板",link:"#脚本模板",children:[]}]},{level:2,title:"JSP 和 JSTL",slug:"jsp-和-jstl",link:"#jsp-和-jstl",children:[]},{level:2,title:"RSS and Atom",slug:"rss-and-atom",link:"#rss-and-atom",children:[]},{level:2,title:"PDF and Excel",slug:"pdf-and-excel",link:"#pdf-and-excel",children:[{level:3,title:"文档视图简介",slug:"文档视图简介",link:"#文档视图简介",children:[]},{level:3,title:"PDF 视图",slug:"pdf-视图",link:"#pdf-视图",children:[]},{level:3,title:"Excel 视图",slug:"excel-视图",link:"#excel-视图",children:[]}]},{level:2,title:"Jackson",slug:"jackson",link:"#jackson",children:[{level:3,title:"基于 Jackson 的 JSON MVC 视图",slug:"基于-jackson-的-json-mvc-视图",link:"#基于-jackson-的-json-mvc-视图",children:[]},{level:3,title:"基于 Jackson 的 XML 视图",slug:"基于-jackson-的-xml-视图",link:"#基于-jackson-的-xml-视图",children:[]}]},{level:2,title:"XML",slug:"xml",link:"#xml",children:[]},{level:2,title:"XSLT",slug:"xslt",link:"#xslt",children:[{level:3,title:"Beans",slug:"beans",link:"#beans",children:[]},{level:3,title:"Controller",slug:"controller",link:"#controller",children:[]},{level:3,title:"Transformation",slug:"transformation",link:"#transformation",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/251e31/",pathLocale:"/",extraFields:'---\ntitle: Spring MVC 之视图技术\ndate: 2023-02-17 11:21:25\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - Web\n  - View\npermalink: /pages/251e31/\n---\n\n# Spring MVC 之视图技术\n\nSpring MVC 中视图技术的使用是可插拔的。无论决定使用 Thymeleaf、Groovy 等模板引擎、JSP 还是其他技术，都可以通过配置来更改。\n\nSpring MVC 的视图位于该应用程序的内部信任边界内。 视图可以访问应用程序上下文的所有 bean。 因此，不建议在模板可由外部源编辑的应用程序中使用 Spring MVC 的模板支持，因为这可能会产生安全隐患。\n\n## Thymeleaf\n\n[Thymeleaf](https://www.thymeleaf.org/) 是一个现代服务器端 Java 模板引擎，它强调自然的 HTML 模板，可以通过双击在浏览器中预览，而无需运行服务器，这对于 UI 模板的独立工作（例如，由设计师）非常有帮助。\n\nThymeleaf 与 Spring MVC 的集成由 Thymeleaf 项目管理。 配置涉及一些 bean 声明，例如 `ServletContextTemplateResolver`、`SpringTemplateEngine` 和 `ThymeleafViewResolver`。 有关详细信息，请参阅 [Thymeleaf+Spring](https://www.thymeleaf.org/documentation.html)。\n\n## FreeMarker\n\n[Apache FreeMarker](https://freemarker.apache.org/) 是一个模板引擎，用于生成从 HTML 到电子邮件等任何类型的文本内容。 Spring 框架内置了 Spring MVC 与 FreeMarker 模板结合使用的集成。\n\n### 视图配置\n\n以下示例显示了如何将 FreeMarker 配置为视图技术：\n\n```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.freeMarker();\n    }\n\n    // Configure FreeMarker...\n\n    @Bean\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPath("/WEB-INF/freemarker");\n        return configurer;\n    }\n}\n```\n\n以下示例显示了如何在 XML 中配置相同的内容：\n\n```xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:freemarker/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure FreeMarker... --\x3e\n<mvc:freemarker-configurer>\n    <mvc:template-loader-path location="/WEB-INF/freemarker"/>\n</mvc:freemarker-configurer>\n```\n\n或者，您也可以声明 `FreeMarkerConfigurer` 以完全控制所有属性，如以下示例所示：\n\n```xml\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n</bean>\n```\n\n您的模板需要存储在前面示例中所示的 `FreeMarkerConfigurer` 指定的目录中。鉴于前面的配置，如果您的控制器返回视图名称 `welcome`，解析器将查找 `/WEB-INF/freemarker/welcome.ftl` 模板。\n\n### FreeMarker 配置\n\n可以通过在 `FreeMarkerConfigurer` 上设置适当的 bean 属性，将 FreeMarker \'Settings\' 和 \'SharedVariables\' 直接传递给 FreeMarker `Configuration` 对象（由 Spring 管理）。 `freemarkerSettings` 属性需要一个 `java.util.Properties` 对象，`freemarkerVariables` 属性需要一个 `java.util.Map`。 以下示例显示了如何使用 `FreeMarkerConfigurer`：\n\n```xml\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n    <property name="freemarkerVariables">\n        <map>\n            <entry key="xml_escape" value-ref="fmXmlEscape"/>\n        </map>\n    </property>\n</bean>\n\n<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>\n```\n\n有关应用于 `Configuration` 对象的设置和变量的详细信息，请参阅 FreeMarker 文档。\n\n### 表单处理\n\nSpring 提供了一个用于 JSP 的标记库，其中包含一个 `<spring:bind/>` 元素。 此元素主要让表单显示来自表单支持对象的值，并显示来自 Web 或业务层中的“验证器”的验证失败的结果。 Spring 还支持 FreeMarker 中的相同功能，以及用于生成表单输入元素的额外便利宏。\n\n#### 绑定宏\n\n在 FreeMarker 的 `spring-webmvc.jar` 文件中维护了一组标准宏，因此它们始终可用于适当配置的应用程序。\n\nSpring 模板库中定义的一些宏被认为是内部的（私有的），但宏定义中不存在这样的范围，这使得所有宏对调用代码和用户模板都是可见的。以下部分仅关注您需要从模板中直接调用的宏。如果您想直接查看宏代码，该文件名为 `spring.ftl` ，位于 `org.springframework.web.servlet.view.freemarker` 包中。\n\n#### 简单绑定\n\n在基于充当 Spring MVC 控制器表单视图的 FreeMarker 模板的 HTML 表单中，您可以使用类似于下一个示例的代码来绑定到字段值，并以类似于 JSP 等价物的方式为每个输入字段显示错误消息。以下示例显示了一个 personForm 视图：\n\n```xml\n\x3c!-- FreeMarker macros have to be imported into a namespace.\n    We strongly recommend sticking to \'spring\'. --\x3e\n<#import "/spring.ftl" as spring/>\n<html>\n    ...\n    <form action="" method="POST">\n        Name:\n        <@spring.bind "personForm.name"/>\n        <input type="text"\n            name="${spring.status.expression}"\n            value="${spring.status.value?html}"/><br />\n        <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>\n        <br />\n        ...\n        <input type="submit" value="submit"/>\n    </form>\n    ...\n</html>\n```\n\n`<@spring.bind>` 需要一个 \'path\' 参数，它由命令对象的名称（它是 \'command\'，除非您在控制器配置中更改它）组成，在您希望绑定的命令对象后跟一个句点和字段名称。 您还可以使用嵌套字段，例如 `command.address.street`。 `bind` 宏采用 `web.xml` 中的 `ServletContext` 参数 `defaultHtmlEscape` 指定的默认 HTML 转义行为。\n\n称为 `<@spring.bindEscaped>` 的宏的另一种形式采用第二个参数，该参数明确指定是否应在状态错误消息或值中使用 HTML 转义。 您可以根据需要将其设置为 `true` 或 `false` 。 附加的表单处理宏简化了 HTML 转义的使用，您应该尽可能使用这些宏。\n\n#### 输入宏\n\nFreeMarker 的附加便利宏简化了绑定和表单生成（包括验证错误显示）。 永远不需要使用这些宏来生成表单输入字段，您可以将它们与简单的 HTML 混合搭配，或者直接调用我们之前强调的 Spring 绑定宏。\n\n下表中的可用宏显示了 FreeMarker 模板 (FTL) 定义和每个采用的参数列表：\n\n| macro                                                                                                                                  | FTL definition                                                  |\n| :------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------- |\n| `message` (output a string from a resource bundle based on the code parameter)                                                         | <@spring.message code/>                                         |\n| `messageText` (output a string from a resource bundle based on the code parameter, falling back to the value of the default parameter) | <@spring.messageText code, text/>                               |\n| `url` (prefix a relative URL with the application’s context root)                                                                      | <@spring.url relativeUrl/>                                      |\n| `formInput` (standard input field for gathering user input)                                                                            | <@spring.formInput path, attributes, fieldType/>                |\n| `formHiddenInput` (hidden input field for submitting non-user input)                                                                   | <@spring.formHiddenInput path, attributes/>                     |\n| `formPasswordInput` (standard input field for gathering passwords. Note that no value is ever populated in fields of this type.)       | <@spring.formPasswordInput path, attributes/>                   |\n| `formTextarea` (large text field for gathering long, freeform text input)                                                              | <@spring.formTextarea path, attributes/>                        |\n| `formSingleSelect` (drop down box of options that let a single required value be selected)                                             | <@spring.formSingleSelect path, options, attributes/>           |\n| `formMultiSelect` (a list box of options that let the user select 0 or more values)                                                    | <@spring.formMultiSelect path, options, attributes/>            |\n| `formRadioButtons` (a set of radio buttons that let a single selection be made from the available choices)                             | <@spring.formRadioButtons path, options separator, attributes/> |\n| `formCheckboxes` (a set of checkboxes that let 0 or more values be selected)                                                           | <@spring.formCheckboxes path, options, separator, attributes/>  |\n| `formCheckbox` (a single checkbox)                                                                                                     | <@spring.formCheckbox path, attributes/>                        |\n| `showErrors` (simplify display of validation errors for the bound field)                                                               | <@spring.showErrors separator, classOrStyle/>                   |\n\n上述任何宏的参数具有一致的含义：\n\n- `path`: 要绑定到的字段的名称（例如，“command.name”）\n- `options`: 可在输入字段中选择的所有可用值的 `Map`。映射的键表示从表单回传并绑定到命令对象的值。针对键存储的 map 对象是在表单上显示给用户的标签，可能与表单回传的相应值不同。通常，这样的地图由控制器提供作为参考数据。您可以使用任何 `Map` 实现，具体取决于所需的行为。对于严格排序的映射，您可以使用带有合适的“比较器”的 `SortedMap`（例如 `TreeMap`），对于应按插入顺序返回值的任意映射，使用“LinkedHashMap”或“LinkedMap” `公共收藏`。\n- `separator`: 在多个选项可用作离散元素（单选按钮或复选框）的情况下，用于分隔列表中每个选项的字符序列（例如 `<br>`）。\n- `attributes`: 要包含在 HTML 标记本身中的任意标记或文本的附加字符串。该字符串按字面意思由宏回显。例如，在 `textarea` 字段中，您可以提供属性（例如“rows="5" cols="60"\'），或者您可以传递样式信息，例如 \'style="border:1px solid silver"\'。\n- `classOrStyle`: 对于 `showErrors` 宏，包装每个错误的 `span` 元素使用的 CSS 类的名称。如果未提供任何信息（或值为空），错误将包含在 `<b></b>` 标签中。\n\n以下部分概述了宏的示例。\n\n输入字段\n\n`formInput` 宏采用 `path` 参数 (`command.name`) 和一个额外的 `attributes` 参数（在接下来的示例中为空）。该宏与所有其他表单生成宏一起对路径参数执行隐式 Spring 绑定。绑定在新绑定发生之前一直有效，因此 `showErrors` 宏不需要再次传递路径参数——它对上次创建绑定的字段进行操作。\n\n`showErrors` 宏接受一个分隔符参数（用于分隔给定字段上的多个错误的字符），还接受第二个参数——这次是类名或样式属性。请注意，FreeMarker 可以为 attributes 参数指定默认值。以下示例显示了如何使用 `formInput` 和 `showErrors` 宏：\n\n```xml\n<@spring.formInput "command.name"/>\n<@spring.showErrors "<br>"/>\n```\n\n下一个示例显示表单片段的输出，生成名称字段并在表单提交后显示验证错误，该字段中没有任何值。验证通过 Spring 的验证框架进行。\n\n生成的 HTML 类似于以下示例：\n\n```html\nName:\n<input type="text" name="name" value="">\n<br>\n    <b>required</b>\n<br>\n<br>\n```\n\n`formTextarea` 宏的工作方式与 `formInput` 宏相同，并且接受相同的参数列表。通常，第二个参数 (`attributes`) 用于传递样式信息或 `textarea` 的 `rows` 和 `cols` 属性。\n\n选中字段\n\n您可以使用四个选择字段宏在 HTML 表单中生成常见的 UI 值选择输入：\n\n- `formSingleSelect`\n- `formMultiSelect`\n- `formRadioButtons`\n- `formCheckboxes`\n\n四个宏中的每一个都接受一个“Map”选项，其中包含表单字段的值和与该值对应的标签。值和标签可以相同。\n\n下一个例子是 FTL 中的单选按钮。表单支持对象为此字段指定默认值“伦敦”，因此无需验证。渲染表单时，整个可供选择的城市列表作为参考数据提供在模型中，名称为 `cityMap`。以下清单显示了示例：\n\n```html\n...\nTown:\n<@spring.formRadioButtons "command.address.town", cityMap, ""/><br><br>\n```\n\n前面的清单呈现一行单选按钮，一个用于 `cityMap` 中的每个值，并使用分隔符 `""`。没有提供额外的属性（缺少宏的最后一个参数）。 `cityMap` 对地图中的每个键值对使用相同的 `String`。地图的键是表单实际作为 POST 请求参数提交的内容。地图值是用户看到的标签。在前面的示例中，给定三个知名城市的列表和表单支持对象中的默认值，HTML 类似于以下内容：\n\n```html\nTown:\n<input type="radio" name="address.town" value="London">London</input>\n<input type="radio" name="address.town" value="Paris" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="New York">New York</input>\n```\n\n如果您的应用程序希望通过内部代码处理城市（例如），您可以使用合适的键创建代码映射，如以下示例所示：\n\n```java\nprotected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {\n    Map<String, String> cityMap = new LinkedHashMap<>();\n    cityMap.put("LDN", "London");\n    cityMap.put("PRS", "Paris");\n    cityMap.put("NYC", "New York");\n\n    Map<String, Object> model = new HashMap<>();\n    model.put("cityMap", cityMap);\n    return model;\n}\n```\n\n代码现在生成输出，其中无线电值是相关代码，但用户仍然看到更用户友好的城市名称，如下所示：\n\n```html\nTown:\n<input type="radio" name="address.town" value="LDN">London</input>\n<input type="radio" name="address.town" value="PRS" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="NYC">New York</input>\n```\n\n#### HTML 转义\n\n前面描述的表单宏的默认使用导致 HTML 元素符合 HTML 4.01，并且使用 `web.xml` 文件中定义的 HTML 转义的默认值，如 Spring 的绑定支持所使用的那样。 要使元素符合 XHTML 或覆盖默认的 HTML 转义值，您可以在模板中指定两个变量（或在模型中，它们对模板可见）。 在模板中指定它们的好处是它们可以在稍后的模板处理中更改为不同的值，以便为表单中的不同字段提供不同的行为。\n\n要为您的标签切换到 XHTML 合规性，请为名为 `xhtmlCompliant` 的模型或上下文变量指定 `true` 值，如以下示例所示：\n\n```html\n<#-- for FreeMarker --\x3e\n<#assign xhtmlCompliant = true>\n```\n\n处理此指令后，Spring 宏生成的任何元素现在都符合 XHTML。\n\n以类似的方式，您可以为每个字段指定 HTML 转义，如以下示例所示：\n\n```html\n<#-- until this point, default HTML escaping is used --\x3e\n\n<#assign htmlEscape = true>\n<#-- next field will use HTML escaping --\x3e\n<@spring.formInput "command.name"/>\n\n<#assign htmlEscape = false in spring>\n<#-- all future fields will be bound with HTML escaping off --\x3e\n```\n\n## Groovy\n\n[Groovy 标记模板引擎](https://groovy-lang.org/templating.html#_the_markuptemplateengine) 主要用于生成类似 XML 的标记（XML、XHTML、HTML5 等），但可以使用它来生成任何基于文本的内容。 Spring Framework 具有将 Spring MVC 与 Groovy 标记结合使用的内置集成。\n\n### 配置\n\n以下示例显示如何配置 Groovy 标记模板引擎：\n\n```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.groovy();\n    }\n\n    // Configure the Groovy Markup Template Engine...\n\n    @Bean\n    public GroovyMarkupConfigurer groovyMarkupConfigurer() {\n        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();\n        configurer.setResourceLoaderPath("/WEB-INF/");\n        return configurer;\n    }\n}\n```\n\n以下示例显示了如何在 XML 中配置相同的内容：\n\n```xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:groovy/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure the Groovy Markup Template Engine... --\x3e\n<mvc:groovy-configurer resource-loader-path="/WEB-INF/"/>\n```\n\n### 示例\n\n与传统的模板引擎不同，Groovy 标记依赖于使用构建器语法的 DSL。以下示例显示了 HTML 页面的示例模板：\n\n```groovy\nyieldUnescaped \'<!DOCTYPE html>\'\nhtml(lang:\'en\') {\n    head {\n        meta(\'http-equiv\':\'"Content-Type" content="text/html; charset=utf-8"\')\n        title(\'My page\')\n    }\n    body {\n        p(\'This is an example of HTML contents\')\n    }\n}\n```\n\n## 脚本视图\n\nSpring 有一个内置的集成，可以将 Spring MVC 与任何可以在 [JSR-223](https://www.jcp.org/en/jsr/detail?id=223) 之上运行的模板库一起使用 Java 脚本引擎。 我们在不同的脚本引擎上测试了以下模板库：\n\n| 脚本库                                                                             | 脚本引擎                                              |\n| :--------------------------------------------------------------------------------- | :---------------------------------------------------- |\n| [Handlebars](https://handlebarsjs.com/)                                            | [Nashorn](https://openjdk.java.net/projects/nashorn/) |\n| [Mustache](https://mustache.github.io/)                                            | [Nashorn](https://openjdk.java.net/projects/nashorn/) |\n| [React](https://facebook.github.io/react/)                                         | [Nashorn](https://openjdk.java.net/projects/nashorn/) |\n| [EJS](https://www.embeddedjs.com/)                                                 | [Nashorn](https://openjdk.java.net/projects/nashorn/) |\n| [ERB](https://www.stuartellis.name/articles/erb/)                                  | [JRuby](https://www.jruby.org/)                       |\n| [String templates](https://docs.python.org/2/library/string.html#template-strings) | [Jython](https://www.jython.org/)                     |\n| [Kotlin Script templating](https://github.com/sdeleuze/kotlin-script-templating)   | [Kotlin](https://kotlinlang.org/)                     |\n\n### 要求\n\n需要在类路径中包含脚本引擎，具体细节因脚本引擎而异：\n\n- The [Nashorn](https://openjdk.java.net/projects/nashorn/) Java 8+ 提供了 JavaScript 引擎。强烈建议使用可用的最新更新版本。\n- [JRuby](https://www.jruby.org/) 应该作为 Ruby 支持的依赖项添加。\n- [Jython](https://www.jython.org/) 应该作为 Python 支持的依赖项添加。\n- `org.jetbrains.kotlin:kotlin-script-util` 依赖项和包含 `org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory` 行的 `META-INF/services/javax.script.ScriptEngineFactory` 文件应该被添加 Kotlin 脚本支持。 有关详细信息，请参阅[此示例](https://github.com/sdeleuze/kotlin-script-templating)。\n\n您需要有脚本模板库。 为 JavaScript 做到这一点的一种方法是通过 [WebJars](https://www.webjars.org/)。\n\n### 脚本模板\n\n可以声明一个 `ScriptTemplateConfigurer` 来指定要使用的脚本引擎、要加载的脚本文件、调用什么函数来渲染模板等等。 以下示例使用 Mustache 模板和 Nashorn JavaScript 引擎：\n\n```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("mustache.js");\n        configurer.setRenderObject("Mustache");\n        configurer.setRenderFunction("render");\n        return configurer;\n    }\n}\n```\n\n以下示例显示了 XML 中的相同配置：\n\n```xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:script-template/>\n</mvc:view-resolvers>\n\n<mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render">\n    <mvc:script location="mustache.js"/>\n</mvc:script-template-configurer>\n```\n\n对于 Java 和 XML 配置，controller 看起来没有什么不同，如以下示例所示：\n\n```java\n@Controller\npublic class SampleController {\n\n    @GetMapping("/sample")\n    public String test(Model model) {\n        model.addAttribute("title", "Sample title");\n        model.addAttribute("body", "Sample body");\n        return "template";\n    }\n}\n```\n\n以下示例显示了 Mustache 模板：\n\n```html\n<html>\n  <head>\n    <title>{{title}}</title>\n  </head>\n  <body>\n    <p>{{body}}</p>\n  </body>\n</html>\n```\n\n使用以下参数调用渲染函数：\n\n- `String template`: 模板内容\n- `地图模型`：视图模型\n- `RenderingContext renderingContext`： [`RenderingContext`](https://docs.spring.io/spring-framework/docs/6.0.5/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html) 允许访问应用上下文、语言环境、模板加载器和 URL（自 5.0 起）\n\n如果您的模板技术需要一些自定义，您可以提供一个实现自定义渲染功能的脚本。 例如，[Handlerbars](https://handlebarsjs.com/) 需要在使用之前编译模板，并且需要一个 [polyfill](https://en.wikipedia.org/wiki/Polyfill) 来模拟一些浏览器工具，但在服务器端脚本引擎中不可用。\n\n以下示例显示了如何执行此操作：\n\n```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");\n        configurer.setRenderFunction("render");\n        configurer.setSharedEngine(false);\n        return configurer;\n    }\n}\n```\n\n`polyfill.js` 只定义了 Handlebars 正常运行所需的 `window` 对象，如下：\n\n```javascript\nvar window = {}\n```\n\n这个基本的 `render.js` 实现在使用之前编译模板。 生产就绪的实现还应该存储任何重复使用的缓存模板或预编译模板。 您可以在脚本端这样做（并处理您需要的任何定制——管理模板引擎配置，例如）。 以下示例显示了如何执行此操作：\n\n```javascript\nfunction render(template, model) {\n  var compiledTemplate = Handlebars.compile(template)\n  return compiledTemplate(model)\n}\n```\n\n查看 Spring Framework 单元测试，[Java](https://github.com/spring-projects/spring-framework/tree/main/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script) 和[资源](https://github.com/spring-projects/spring-framework/tree/main/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script)，以获取更多配置示例。\n\n## JSP 和 JSTL\n\nSpring Framework 具有将 Spring MVC 与 JSP 和 JSTL 结合使用的内置集成。\n\n> 更多内容详见：[Spring 官方文档之 JSP and JSTL](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-view-jsp)\n\n## RSS and Atom\n\n`AbstractAtomFeedView` 和 `AbstractRssFeedView` 都继承自 `AbstractFeedView` 基类，分别用于提供 Atom 和 RSS Feed 视图。 它们基于 [ROME](https://rometools.github.io/rome/) 项目，位于 org.springframework.web.servlet.view.feed 包中。\n\n`AbstractAtomFeedView` 要求您实现 `buildFeedEntries()` 方法并可选择覆盖 `buildFeedMetadata()` 方法（默认实现为空）。 以下示例显示了如何执行此操作：\n\n```java\npublic class SampleContentAtomView extends AbstractAtomFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Feed feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Entry> buildFeedEntries(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}\n```\n\n类似的要求适用于实现 `AbstractRssFeedView`，如以下示例所示：\n\n```java\npublic class SampleContentRssView extends AbstractRssFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Channel feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Item> buildFeedItems(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}\n```\n\n`buildFeedItems()` 和 `buildFeedEntries()` 方法传入 HTTP 请求，以防您需要访问 Locale。 传入 HTTP 响应仅用于设置 cookie 或其他 HTTP 标头。 方法返回后，提要会自动写入响应对象。\n\n有关创建 Atom 视图的示例，请参阅 Alef Arendsen 的 Spring Team 博客 [entry](https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support)。\n\n## PDF and Excel\n\nSpring 提供了返回 HTML 以外的输出的方法，包括 PDF 和 Excel 电子表格。\n\n### 文档视图简介\n\nHTML 页面并不总是用户查看模型输出的最佳方式，Spring 使从模型数据动态生成 PDF 文档或 Excel 电子表格变得简单。 该文档是视图，从服务器流出正确的内容类型，（希望）使客户端 PC 能够运行他们的电子表格或 PDF 查看器应用程序作为响应。\n\n为了使用 Excel 视图，您需要将 Apache POI 库添加到类路径中。 对于 PDF 生成，您需要添加（最好）OpenPDF 库。\n\n### PDF 视图\n\n单词列表的简单 PDF 视图可以扩展 `org.springframework.web.servlet.view.document.AbstractPdfView` 并实现 `buildPdfDocument()` 方法，如以下示例所示：\n\n```java\npublic class PdfWordList extends AbstractPdfView {\n\n    protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        List<String> words = (List<String>) model.get("wordList");\n        for (String word : words) {\n            doc.add(new Paragraph(word));\n        }\n    }\n}\n```\n\n控制器可以从外部视图定义（按名称引用它）或作为处理程序方法的 `View` 实例返回此类视图。\n\n### Excel 视图\n\n从 Spring Framework 4.2 开始，`org.springframework.web.servlet.view.document.AbstractXlsView` 作为 Excel 视图的基类提供。 它基于 Apache POI，具有专门的子类（`AbstractXlsxView` 和 `AbstractXlsxStreamingView`），取代了过时的 `AbstractExcelView` 类。\n\n编程模型类似于 `AbstractPdfView`，以 `buildExcelDocument()` 作为核心模板方法，控制器能够从外部定义（按名称）或作为处理程序方法的 `View` 实例返回此类视图。\n\n## Jackson\n\nSpring 提供对 Jackson JSON 库的支持。\n\n### 基于 Jackson 的 JSON MVC 视图\n\n`MappingJackson2JsonView` 使用 Jackson 库的 `ObjectMapper` 将响应内容渲染为 JSON。 默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为 JSON。 对于需要过滤 map 内容的情况，您可以使用 `modelKeys` 属性指定一组特定的模型属性进行编码。 您还可以使用 `extractValueFromSingleKeyModel` 属性直接提取和序列化单键模型中的值，而不是作为模型属性的映射。\n\n您可以根据需要使用 Jackson 提供的注释自定义 JSON 映射。 当您需要进一步控制时，您可以通过 `ObjectMapper` 属性注入自定义 `ObjectMapper`，适用于需要为特定类型提供自定义 JSON 序列化器和反序列化器的情况。\n\n### 基于 Jackson 的 XML 视图\n\n`MappingJackson2XmlView` 使用 [Jackson XML 扩展](https://github.com/FasterXML/jackson-dataformat-xml) `XmlMapper` 将响应内容渲染为 XML。 如果模型包含多个条目，您应该使用 `modelKey` bean 属性显式设置要序列化的对象。 如果模型包含单个条目，它会自动序列化。\n\n您可以根据需要使用 JAXB 或 Jackson 提供的注释自定义 XML 映射。当您需要进一步控制时，您可以通过 `ObjectMapper` 属性注入自定义 `XmlMapper`，对于需要为特定类型提供序列化器和反序列化器的自定义 XML 的情况\n\n## XML\n\n`MarshallingView` 使用 XML `Marshaller`（在 `org.springframework.oxm` 包中定义）将响应内容渲染为 XML。 您可以使用 `MarshallingView` 实例的 `modelKey` 属性显式设置要编组的对象。 或者，视图遍历所有模型属性并编组 `Marshaller` 支持的第一个类型。 有关 `org.springframework.oxm` 包中功能的更多信息，请参阅 [Marshalling XML using O/X Mappers](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#oxm)。\n\n## XSLT\n\nXSLT 是 XML 的一种转换语言，作为 Web 应用程序中的一种视图技术很受欢迎。 如果您的应用程序自然地处理 XML，或者如果您的模型可以很容易地转换为 XML，那么 XSLT 作为一种视图技术是一个不错的选择。 以下部分展示了如何生成 XML 文档作为模型数据，并在 Spring Web MVC 应用程序中使用 XSLT 对其进行转换。\n\n此示例是一个简单的 Spring 应用程序，它在 `Controller` 中创建关键字列表并将它们添加到模型映射中。 返回映射以及我们的 XSLT 视图的视图名称。 有关 Spring Web MVC 的 `Controller` 接口的详细信息，请参阅 [Annotated Controllers](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller)。 XSLT 控制器将单词列表转换为准备转换的简单 XML 文档。\n\n### Beans\n\n配置是一个简单的 Spring Web 应用程序的标准配置：MVC 配置必须定义一个 `XsltViewResolver` 和常规 MVC 注释配置。以下示例显示了如何执行此操作：\n\n```java\n@EnableWebMvc\n@ComponentScan\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Bean\n    public XsltViewResolver xsltViewResolver() {\n        XsltViewResolver viewResolver = new XsltViewResolver();\n        viewResolver.setPrefix("/WEB-INF/xsl/");\n        viewResolver.setSuffix(".xslt");\n        return viewResolver;\n    }\n}\n```\n\n### Controller\n\n我们还需要一个控制器来封装我们的单词生成逻辑。\n\n控制器逻辑封装在一个 `@Controller` 类中，处理方法定义如下：\n\n```java\n@Controller\npublic class XsltController {\n\n    @RequestMapping("/")\n    public String home(Model model) throws Exception {\n        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        Element root = document.createElement("wordList");\n\n        List<String> words = Arrays.asList("Hello", "Spring", "Framework");\n        for (String word : words) {\n            Element wordNode = document.createElement("word");\n            Text textNode = document.createTextNode(word);\n            wordNode.appendChild(textNode);\n            root.appendChild(wordNode);\n        }\n\n        model.addAttribute("wordList", root);\n        return "home";\n    }\n}\n```\n\n到目前为止，我们只创建了一个 DOM 文档并将其添加到模型映射中。请注意，您还可以将 XML 文件作为 `Resource` 加载并使用它来代替自定义 DOM 文档。\n\n有可用的软件包可以自动 \'domify\' 一个对象图，但是在 Spring 中，您可以完全灵活地以您选择的任何方式从您的模型创建 DOM。这可以防止 XML 的转换在模型数据的结构中发挥太大作用，这在使用工具管理 DOMification 过程时是一种危险。\n\n### Transformation\n\n最后，`XsltViewResolver` 解析 “home” XSLT 模板文件并将 DOM 文档合并到其中以生成我们的视图。如 `XsltViewResolver` 配置所示，XSLT 模板位于 `WEB-INF/xsl` 目录下的 `war` 文件中，并以 `xslt` 文件扩展名结尾。\n\n以下示例显示了 XSLT 转换：\n\n```xml\n<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\n\n    <xsl:output method="html" omit-xml-declaration="yes"/>\n\n    <xsl:template match="/">\n        <html>\n            <head><title>Hello!</title></head>\n            <body>\n                <h1>My First Words</h1>\n                <ul>\n                    <xsl:apply-templates/>\n                </ul>\n            </body>\n        </html>\n    </xsl:template>\n\n    <xsl:template match="word">\n        <li><xsl:value-of select="."/></li>\n    </xsl:template>\n\n</xsl:stylesheet>\n```\n\n前面的转换渲染为以下 HTML：\n\n```html\n<html>\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>My First Words</h1>\n    <ul>\n      <li>Hello</li>\n      <li>Spring</li>\n      <li>Framework</li>\n    </ul>\n  </body>\n</html>\n```\n\n## 参考资料\n\n- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n- [Spring Framework 官方文档之 Web](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)\n'},{title:"SpringBoot 之应用 EasyUI",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"什么是 EasyUI？",slug:"什么是-easyui",link:"#什么是-easyui",children:[]}]},{level:2,title:"Spring Boot 整合 EasyUI",slug:"spring-boot-整合-easyui",link:"#spring-boot-整合-easyui",children:[{level:3,title:"配置",slug:"配置",link:"#配置",children:[]},{level:3,title:"引入 easyui",slug:"引入-easyui",link:"#引入-easyui",children:[]}]},{level:2,title:"实战",slug:"实战",link:"#实战",children:[{level:3,title:"引入 maven 依赖",slug:"引入-maven-依赖",link:"#引入-maven-依赖",children:[]},{level:3,title:"使用 JPA",slug:"使用-jpa",link:"#使用-jpa",children:[]},{level:3,title:"使用 Web",slug:"使用-web",link:"#使用-web",children:[]},{level:3,title:"使用 EasyUI",slug:"使用-easyui",link:"#使用-easyui",children:[]}]},{level:2,title:"完整示例",slug:"完整示例",link:"#完整示例",children:[]},{level:2,title:"引用和引申",slug:"引用和引申",link:"#引用和引申",children:[]}],path:"/pages/ad0516/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之应用 EasyUI\ndate: 2019-01-08 17:19:34\norder: 21\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - Web\npermalink: /pages/ad0516/\n---\n\n# SpringBoot 之应用 EasyUI\n\n> EasyUI 是一个简单的用户界面组件的集合。由于 EasyUI 已经封装好大部分 UI 基本功能，能帮用户减少大量的 js 和 css 代码。所以，EasyUI 非常适合用于开发简单的系统或原型系统。\n>\n> 本文示例使用技术点：\n>\n> - Spring Boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa\n> - EasyUI：按需加载，并没有引入所有的 EasyUI 特性\n> - 数据库：为了测试方便，使用 H2\n\n![img](http://www.jeasyui.cn/images/easyui.png)\n\n## 简介\n\n### 什么是 EasyUI？\n\n- easyui 是基于 jQuery、Angular.、Vue 和 React 的用户界面组件的集合。\n- easyui 提供了构建现代交互式 javascript 应用程序的基本功能。\n- 使用 easyui，您不需要编写许多 javascript 代码，通常通过编写一些 HTML 标记来定义用户界面。\n- 完整的 HTML5 网页框架。\n- 使用 easyui 开发你的产品时可以大量节省你的时间和规模。\n- easyui 使用非常简单但功能非常强大。\n\n## Spring Boot 整合 EasyUI\n\n### 配置\n\napplication.properties 修改：\n\n```properties\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html\n```\n\n### 引入 easyui\n\nEasyUI 下载地址：http://www.jeasyui.cn/download.html\n\n在 `src/main/resources/static` 目录下引入 easyui。\n\n然后在 html 中引用：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>\n```\n\n引入 easyui 后，需要使用哪种组件，可以查看相关文档或 API，十分简单，此处不一一赘述。\n\n## 实战\n\n### 引入 maven 依赖\n\n```xml\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>com.h2database</groupId>\n      <artifactId>h2</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>\n```\n\n### 使用 JPA\n\n为了使用 JPA 技术访问数据，我们需要定义 Entity 和 Repository\n\n定义一个 Entity：\n\n```java\n@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    private String phone;\n    private String email;\n\n    protected User() {}\n\n    public User(String firstName, String lastName, String phone, String email) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}\n```\n\n定义一个 Repository：\n\n```\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n    List<User> findByLastName(String lastName);\n}\n```\n\n### 使用 Web\n\n首页 Controller，将 web 请求定向到指定页面（下面的例子定向到 index.html）\n\n```java\n@Controller\npublic class IndexController {\n\n    @RequestMapping(value = {"", "/", "index"})\n    public String index() {\n        return "index";\n    }\n\n}\n```\n\n此外，需要定义一个 Controller，提供后台的 API 接口\n\n```java\n@Controller\npublic class UserController {\n\n    @Autowired\n    private UserRepository customerRepository;\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String user() {\n        return "user";\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/list")\n    public ResponseDTO<User> list() {\n        Iterable<User> all = customerRepository.findAll();\n        List<User> list = IteratorUtils.toList(all.iterator());\n        return new ResponseDTO<>(true, list.size(), list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/add")\n    public ResponseDTO<User> add(User user) {\n        User result = customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(result);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/save")\n    public ResponseDTO<User> save(@RequestParam("id") Long id, User user) {\n        user.setId(id);\n        customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(user);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/delete")\n    public ResponseDTO delete(@RequestParam("id") Long id) {\n        customerRepository.deleteById(id);\n        return new ResponseDTO<>(true, null, null);\n    }\n\n}\n```\n\n### 使用 EasyUI\n\n接下来，我们要使用前面定义的后台接口，仅需要在 EasyUI API 中指定 `url` 即可。\n\n请留意下面示例中的 url 字段，和实际接口是一一对应的。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Complex Layout - jQuery EasyUI Demo</title>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 CRUD 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="Custom List"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitColumns="true"\n        singleSelect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">ID</th>\n            <th field="firstName" width="50">First Name</th>\n            <th field="lastName" width="50">Last Name</th>\n            <th field="phone" width="50">Phone</th>\n            <th field="email" width="50">Email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-add"\n          plain="true"\n          onclick="newUser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-edit"\n          plain="true"\n          onclick="editUser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-remove"\n          plain="true"\n          onclick="destroyUser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>User Information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstName"\n              class="easyui-textbox"\n              required="true"\n              label="First Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastName"\n              class="easyui-textbox"\n              required="true"\n              label="Last Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="Phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validType="email"\n              label="Email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconCls="icon-ok"\n          onclick="saveUser()"\n          style="width:90px"\n          >Save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >Cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newUser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'setTitle\', \'New User\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function editUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'setTitle\', \'Edit User\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveUser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onSubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errorMsg) {\n              $.messager.show({\n                title: \'Error\',\n                msg: result.errorMsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $.messager.confirm(\n            \'Confirm\',\n            \'Are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'Error\',\n                        msg: result.errorMsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>\n```\n\n## 完整示例\n\n请参考 [源码](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-web-ui/spring-boot-web-ui-easyui)\n\n运行方式：\n\n```\nmvn clean package -DskipTests=true\njava -jar target/\n```\n\n在浏览器中访问：http://localhost:8080/\n\n## 引用和引申\n\n- [EasyUI 官网](http://www.jeasyui.com/)\n- [EasyUI 中文网](http://www.jeasyui.cn/)'},{title:"Spring Web",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/e2586a/",pathLocale:"/",extraFields:"---\ntitle: Spring Web\ndate: 2020-02-26 23:48:06\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringWeb\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - Web\npermalink: /pages/e2586a/\nhidden: true\nindex: false\n---\n\n# Spring Web\n\n> 章节主要针对：Spring 在 web 领域的应用。如：Spring MVC、WebSocket 等。\n\n## 📖 内容\n\n- [SpringWeb 综述](01.SpringWeb综述.md)\n- [SpringWeb 应用](02.SpringWeb应用.md)\n- [DispatcherServlet](03.DispatcherServlet.md)\n- [Spring 过滤器](04.Spring过滤器.md)\n- [Spring 跨域](05.Spring跨域.md)\n- [Spring 视图](06.Spring视图.md)\n- [SpringBoot 之应用 EasyUI](21.SpringBoot之应用EasyUI.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"spring-boot-async",headers:[{level:2,title:"@EnableAsync 注解",slug:"enableasync-注解",link:"#enableasync-注解",children:[]},{level:2,title:"@Async 注解",slug:"async-注解",link:"#async-注解",children:[{level:3,title:"支持的用法",slug:"支持的用法",link:"#支持的用法",children:[]},{level:3,title:"不支持的用法",slug:"不支持的用法",link:"#不支持的用法",children:[]}]},{level:2,title:"明确指定执行器",slug:"明确指定执行器",link:"#明确指定执行器",children:[]},{level:2,title:"管理 @Async 的异常",slug:"管理-async-的异常",link:"#管理-async-的异常",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/92add2/",pathLocale:"/",extraFields:'---\ntitle: spring-boot-async\ndate: 2019-11-18 14:55:01\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringIO\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 异步\npermalink: /pages/92add2/\n---\n\n# SpringBoot 教程之处理异步请求\n\n## `@EnableAsync` 注解\n\n要使用 `@Async`，首先需要使用 `@EnableAsync` 注解开启 Spring Boot 中的异步特性。\n\n```java\n@Configuration\n@EnableAsync\npublic class AppConfig {\n}\n```\n\n更详细的配置说明，可以参考：[`AsyncConfigurer`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html)\n\n## `@Async` 注解\n\n### 支持的用法\n\n（1）**无入参无返回值方法**\n\n您可以用 `@Async` 注解修饰方法，这表明这个方法是异步方式调用。换句话说，程序在调用此方法时会立即返回，而方法的实际执行发生在已提交给 Spring `TaskExecutor` 的任务中。在最简单的情况下，您可以将注解应用于返回 void 的方法，如以下示例所示：\n\n```java\n@Async\nvoid doSomething() {\n    // this will be executed asynchronously\n}\n```\n\n（2）**有入参无返回值方法**\n\n与使用 `@Scheduled` 注释注释的方法不同，这些方法可以指定参数，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下代码是 `@Async` 注解的合法应用：\n\n```java\n@Async\nvoid doSomething(String s) {\n    // this will be executed asynchronously\n}\n```\n\n（3）**有入参有返回值方法**\n\n甚至可以异步调用返回值的方法。但是，这些方法需要具有 `Future` 类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用 `Future` 上的 `get()` 之前执行其他任务。以下示例显示如何在返回值的方法上使用`@Async`：\n\n```java\n@Async\nFuture<String> returnSomething(int i) {\n    // this will be executed asynchronously\n}\n```\n\n### 不支持的用法\n\n`@Async` 不能与生命周期回调一起使用，例如 `@PostConstruct`。\n\n要异步初始化 Spring bean，必须使用单独的初始化 Spring bean，然后在目标上调用 `@Async` 带注释的方法，如以下示例所示：\n\n```java\npublic class SampleBeanImpl implements SampleBean {\n\n    @Async\n    void doSomething() {\n        // ...\n    }\n\n}\n\npublic class SampleBeanInitializer {\n\n    private final SampleBean bean;\n\n    public SampleBeanInitializer(SampleBean bean) {\n        this.bean = bean;\n    }\n\n    @PostConstruct\n    public void initialize() {\n        bean.doSomething();\n    }\n\n}\n```\n\n## 明确指定执行器\n\n默认情况下，在方法上指定 `@Async` 时，使用的执行器是在启用异步支持时配置的执行器，即如果使用 XML 或 `AsyncConfigurer` 实现（如果有），则为 `annotation-driven` 元素。但是，如果需要指示在执行给定方法时应使用默认值以外的执行器，则可以使用 `@Async` 注解的 value 属性。以下示例显示了如何执行此操作：\n\n```java\n@Async("otherExecutor")\nvoid doSomething(String s) {\n    // this will be executed asynchronously by "otherExecutor"\n}\n```\n\n在这种情况下，“otherExecutor”可以是 Spring 容器中任何 Executor bean 的名称，也可以是与任何 Executor 关联的限定符的名称（例如，使用 `<qualifier>` 元素或 Spring 的 `@Qualifier` 注释指定） ）。\n\n## 管理 `@Async` 的异常\n\n当 `@Async` 方法的返回值类型为 `Future` 型时，很容易管理在方法执行期间抛出的异常，因为在调用 `get` 结果时会抛出此异常。但是，对于返回值类型为 void 型的方法，异常不会被捕获且无法传输。您可以提供 `AsyncUncaughtExceptionHandler` 来处理此类异常。以下示例显示了如何执行此操作：\n\n```java\npublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\n\n    @Override\n    public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n        // handle exception\n    }\n}\n```\n\n默认情况下，仅记录异常。您可以使用 `AsyncConfigurer` 或 `<task：annotation-driven />` XML 元素定义自定义 `AsyncUncaughtExceptionHandler`。\n\n## 示例源码\n\n> 示例源码：[spring-boot-async](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-async)\n\n## 参考资料\n\n- [Spring Boot 官方文档之 boot-features-external-config](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config)\n- [Spring Boot 官方文档之 scheduling-annotation-support](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-annotation-support)'},{title:"SpringBoot 之集成 Json",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"Spring Boot 支持的 Json 库",slug:"spring-boot-支持的-json-库",link:"#spring-boot-支持的-json-库",children:[]},{level:3,title:"Spring Web 中的序列化、反序列化",slug:"spring-web-中的序列化、反序列化",link:"#spring-web-中的序列化、反序列化",children:[]}]},{level:2,title:"指定类的 Json 序列化、反序列化",slug:"指定类的-json-序列化、反序列化",link:"#指定类的-json-序列化、反序列化",children:[]},{level:2,title:"@JsonTest",slug:"jsontest",link:"#jsontest",children:[]},{level:2,title:"Spring Boot 中的 json 配置",slug:"spring-boot-中的-json-配置",link:"#spring-boot-中的-json-配置",children:[{level:3,title:"Jackson 配置",slug:"jackson-配置",link:"#jackson-配置",children:[]},{level:3,title:"GSON 配置",slug:"gson-配置",link:"#gson-配置",children:[]}]},{level:2,title:"Spring Boot 中使用 Fastjson",slug:"spring-boot-中使用-fastjson",link:"#spring-boot-中使用-fastjson",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"引申和引用",slug:"引申和引用",link:"#引申和引用",children:[]}],path:"/pages/676725/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之集成 Json\ndate: 2018-12-30 22:24:16\norder: 02\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringIO\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - JSON\npermalink: /pages/676725/\n---\n\n# SpringBoot 之集成 Json\n\n## 简介\n\n### Spring Boot 支持的 Json 库\n\nSpring Boot 支持三种 Json 库：\n\n- Gson\n- Jackson\n- JSON-B\n\n**Jackson 是 Spring Boot 官方推荐的默认库。**\n\nSpring Boot 提供了 Jackson 的自动配置，Jackson 是 `spring-boot-starter-json` 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。\n\nSpring Boot 提供了 Gson 的自动配置。当 Gson 在 classpath 上时，会自动配置 Gson bean。提供了几个 `spring.gson.*` 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 `GsonBuilderCustomizer` bean。\n\nSpring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 在 classpath 上时，将自动配置 Jsonb bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖关系管理。\n\n### Spring Web 中的序列化、反序列化\n\n以下注解都是 `spring-web` 中提供的支持。\n\n#### `@ResponseBody`\n\n`@Responsebody` 注解用于将 Controller 的方法返回的对象，通过适当的 `HttpMessageConverter` 转换为指定格式后，写入到 HTTP Response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 `@RequestMapping` 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP 响应正文中。\n\n示例：\n\n```java\n@ResponseBody\n@RequestMapping(name = "/getInfo", method = RequestMethod.GET)\npublic InfoDTO getInfo() {\n\treturn new InfoDTO();\n}\n```\n\n#### `@RequestBody`\n\n@RequestBody 注解用于读取 HTTP Request 请求的 body 部分数据，使用系统默认配置的 `HttpMessageConverter` 进行解析，然后把相应的数据绑定到要返回的对象上；再把 `HttpMessageConverter` 返回的对象数据绑定到 controller 中方法的参数上。\n\nrequest 的 body 部分的数据编码格式由 header 部分的 `Content-Type` 指定。\n\n示例：\n\n```java\n@RequestMapping(name = "/postInfo", method = RequestMethod.POST)\npublic void postInfo(@RequestBody InfoDTO infoDTO) {\n    // ...\n}\n```\n\n#### `@RestController`\n\nSpring 4 以前：\n\n如果需要返回到指定页面，则需要用 `@Controller` 配合视图解析器 `InternalResourceViewResolver` 。\n\n如果需要返回 JSON，XML 或自定义 mediaType 内容到页面，则需要在对应的方法上加上 `@ResponseBody` 注解。\n\nSpring 4 以后，新增了 `@RestController` 注解：\n\n它相当于 `@Controller` + `@RequestBody` 。\n\n如果使用 `@RestController` 注解 Controller，则 Controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 `InternalResourceViewResolver` 将不起作用，直接返回内容。\n\n## 指定类的 Json 序列化、反序列化\n\n如果使用 Jackson 序列化和反序列化 JSON 数据，您可能需要编写自己的 `JsonSerializer` 和 `JsonDeserializer` 类。自定义序列化程序通常通过模块向 Jackson 注册，但 Spring Boot 提供了另一种 `@JsonComponent` 注释，可以更容易地直接注册 Spring Beans。\n\n您可以直接在 `JsonSerializer` 或 `JsonDeserializer` 实现上使用 `@JsonComponent` 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：\n\n```java\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@JsonComponent\npublic class Example {\n\n\tpublic static class Serializer extends JsonSerializer<SomeObject> {\n\t\t// ...\n\t}\n\n\tpublic static class Deserializer extends JsonDeserializer<SomeObject> {\n\t\t// ...\n\t}\n\n}\n```\n\n`ApplicationContext` 中的所有 `@JsonComponent` bean 都会自动注册到 Jackson。因为 `@JsonComponent` 是使用 `@Component` 进行元注释的，所以通常的组件扫描规则适用。\n\nSpring Boot 还提供了 [`JsonObjectSerializer`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java) 和 [`JsonObjectDeserializer`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java) 基类，它们在序列化对象时提供了标准 Jackson 版本的有用替代方法。有关详细信息，请参阅 Javadoc 中的 [`JsonObjectSerializer`](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/jackson/JsonObjectSerializer.html) 和 [`JsonObjectDeserializer`](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/jackson/JsonObjectDeserializer.html)。\n\n## @JsonTest\n\n使用 `@JsonTest` 可以很方便的在 Spring Boot 中测试序列化、反序列化。\n\n使用 `@JsonTest` 相当于使用以下自动配置：\n\n```\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration\n```\n\n`@JsonTest` 使用示例：\n\n想试试完整示例，可以参考：[源码](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-web-fastjson)\n\n```java\n@JsonTest\n@RunWith(SpringRunner.class)\npublic class SimpleJsonTest {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private JacksonTester<InfoDTO> json;\n\n    @Test\n    public void testSerialize() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n        InfoDTO infoDTO = new InfoDTO("JSON测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        JsonContent<InfoDTO> jsonContent = json.write(infoDTO);\n        log.info("json content: {}", jsonContent.getJson());\n        // 或者使用基于JSON path的校验\n        assertThat(jsonContent).hasJsonPathStringValue("@.appName");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.appName").isEqualTo("JSON测试应用");\n        assertThat(jsonContent).hasJsonPathStringValue("@.version");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.version").isEqualTo("1.0.0");\n        assertThat(jsonContent).hasJsonPathStringValue("@.date");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.date").isEqualTo("2019-01-01 12:00:00");\n    }\n\n    @Test\n    public void testDeserialize() throws Exception {\n        String content = "{\\"appName\\":\\"JSON测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        InfoDTO actual = json.parseObject(content);\n        assertThat(actual.getAppName()).isEqualTo("JSON测试应用");\n        assertThat(actual.getVersion()).isEqualTo("1.0.0");\n    }\n}\n```\n\n## Spring Boot 中的 json 配置\n\n### Jackson 配置\n\n当 Spring Boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 [`JacksonProperties`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonProperties.java) 类）：\n\n```properties\nspring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.\nspring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson\'s JsonInclude.Include enumeration.\nspring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.\nspring.jackson.generator.*= # Jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # Locale used for formatting.\nspring.jackson.mapper.*= # Jackson general purpose on/off features.\nspring.jackson.parser.*= # Jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # One of the constants on Jackson\'s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.\nspring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.\nspring.jackson.time-zone= #  Time zone used when formatting dates. For instance, "America/Los_Angeles" or "GMT+10".\nspring.jackson.visibility.*= # Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.\n```\n\n### GSON 配置\n\n当 Spring Boot 的 json 库为 gson 时，可以使用以下配置属性（对应 [`GsonProperties`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/gson/GsonProperties.java) 类）：\n\n```properties\nspring.gson.date-format= # Format to use when serializing Date objects.\nspring.gson.disable-html-escaping= # Whether to disable the escaping of HTML characters such as \'<\', \'>\', etc.\nspring.gson.disable-inner-class-serialization= # Whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # Whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # Whether to exclude all fields from consideration for serialization or deserialization that do not have the "Expose" annotation.\nspring.gson.field-naming-policy= # Naming policy that should be applied to an object\'s field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # Whether to generate non executable JSON by prefixing the output with some special text.\nspring.gson.lenient= # Whether to be lenient about parsing JSON that doesn\'t conform to RFC 4627.\nspring.gson.long-serialization-policy= # Serialization policy for Long and long types.\nspring.gson.pretty-printing= # Whether to output serialized JSON that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # Whether to serialize null fields.\n```\n\n## Spring Boot 中使用 Fastjson\n\n国内很多的 Java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 Spring Boot 中将其替换默认的 jackson 库呢？\n\n你需要做如下处理：\n\n（1）引入 fastjson jar 包：\n\n```xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.54</version>\n</dependency>\n```\n\n（2）实现 WebMvcConfigurer 接口，自定义 `configureMessageConverters` 接口。如下所示：\n\n```java\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        // 清除默认 Json 转换器\n        converters.removeIf(converter -> converter instanceof MappingJackson2HttpMessageConverter);\n\n        // 配置 FastJson\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.QuoteFieldNames, SerializerFeature.WriteEnumUsingToString,\n            SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat,\n            SerializerFeature.DisableCircularReferenceDetect);\n\n        // 添加 FastJsonHttpMessageConverter\n        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();\n        fastJsonHttpMessageConverter.setFastJsonConfig(config);\n        List<MediaType> fastMediaTypes = new ArrayList<>();\n        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);\n        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);\n        converters.add(fastJsonHttpMessageConverter);\n\n        // 添加 StringHttpMessageConverter，解决中文乱码问题\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));\n        converters.add(stringHttpMessageConverter);\n    }\n\n    // ...\n}\n```\n\n## 示例源码\n\n完整示例：[源码](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-web-fastjson)\n\n## 引申和引用\n\n**引申**\n\n- [Spring Boot 教程](https://github.com/dunwu/spring-boot-tutorial)\n\n**引用**\n\n- [Spring Boot 官方文档之 boot-features-json](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-json)'},{title:"SpringBoot 之发送邮件",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"API",slug:"api",link:"#api",children:[]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"实战",slug:"实战",link:"#实战",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"配置邮件属性",slug:"配置邮件属性",link:"#配置邮件属性",children:[]},{level:3,title:"Java 代码",slug:"java-代码",link:"#java-代码",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/2586f1/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot 之发送邮件\ndate: 2019-11-20 15:20:44\norder: 03\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringIO\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 邮件\npermalink: /pages/2586f1/\n---\n\n# SpringBoot 之发送邮件\n\n## 简介\n\nSpring Boot 收发邮件最简便方式是通过 `spring-boot-starter-mail`。\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\nspring-boot-starter-mail 本质上是使用 JavaMail(javax.mail)。如果想对 JavaMail 有进一步了解，可以参考： [JavaMail 使用指南](https://dunwu.github.io/java-tutorial/#/javalib/javamail)\n\n## API\n\nSpring Framework 提供了一个使用 `JavaMailSender` 接口发送电子邮件的简单抽象，这是发送邮件的核心 API。\n\n`JavaMailSender` 接口提供的 API 如下：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20190110111102.png)\n\n## 配置\n\nSpring Boot 为 `JavaMailSender` 提供了自动配置以及启动器模块。\n\n如果 `spring.mail.host` 和相关库（由 spring-boot-starter-mail 定义）可用，则 Spring Boot 会创建默认 `JavaMailSender`（如果不存在）。可以通过 `spring.mail` 命名空间中的配置项进一步自定义发件人。\n特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：\n\n```properties\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000\n```\n\n也可以使用 JNDI 中的现有会话配置 `JavaMailSender`：\n\n```\nspring.mail.jndi-name=mail/Session\n```\n\n以下为 Spring Boot 关于 Mail 的配置：\n\n有关更多详细信息，请参阅 [`MailProperties`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java)。\n\n```properties\n# Email (MailProperties)\nspring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.\nspring.mail.host= # SMTP server host. For instance, `smtp.example.com`.\nspring.mail.jndi-name= # Session JNDI name. When set, takes precedence over other Session settings.\nspring.mail.password= # Login password of the SMTP server.\nspring.mail.port= # SMTP server port.\nspring.mail.properties.*= # Additional JavaMail Session properties.\nspring.mail.protocol=smtp # Protocol used by the SMTP server.\nspring.mail.test-connection=false # Whether to test that the mail server is available on startup.\nspring.mail.username= # Login user of the SMTP server.\n```\n\n## 实战\n\n### 引入依赖\n\n```xml\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>com.github.dozermapper</groupId>\n    <artifactId>dozer-spring-boot-starter</artifactId>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>\n```\n\n### 配置邮件属性\n\n在 `src/main/resources` 目录下添加 `application-163.properties` 配置文件，内容如下：\n\n```properties\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = UTF-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}\n```\n\n注：需替换有效的 `spring.mail.username`、`spring.mail.password`。\n\n`application-163.properties` 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 `spring.profiles.active = 163` 来激活它。\n\n在 `src/main/resources` 目录下添加 `application.properties` 配置文件，内容如下：\n\n```properties\nspring.profiles.active = 163\n```\n\n### Java 代码\n\n首先，需要读取部分配置属性，方法如下：\n\n```java\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.annotation.Validated;\n\n@Validated\n@Component\n@ConfigurationProperties(prefix = "mail")\npublic class MailProperties {\n    private String domain;\n    private String from;\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n}\n```\n\n接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：\n\n```java\nimport lombok.Data;\nimport java.util.Date;\n\n@Data\npublic class MailDTO {\n    private String from;\n    private String replyTo;\n    private String[] to;\n    private String[] cc;\n    private String[] bcc;\n    private Date sentDate;\n    private String subject;\n    private String text;\n    private String[] filenames;\n}\n```\n\n接着，实现发送邮件的功能接口：\n\n```java\nimport com.github.dozermapper.core.Mapper;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.stereotype.Service;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.io.IOException;\n\n@Service\npublic class MailService {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private Mapper mapper;\n\n    public void sendSimpleMailMessage(MailDTO mailDTO) {\n        SimpleMailMessage simpleMailMessage = mapper.map(mailDTO, SimpleMailMessage.class);\n        if (StringUtils.isEmpty(mailDTO.getFrom())) {\n            mailDTO.setFrom(mailProperties.getFrom());\n        }\n        javaMailSender.send(simpleMailMessage);\n    }\n\n    public void sendMimeMessage(MailDTO mailDTO) {\n\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        MimeMessageHelper messageHelper;\n        try {\n            messageHelper = new MimeMessageHelper(mimeMessage, true);\n\n            if (StringUtils.isEmpty(mailDTO.getFrom())) {\n                messageHelper.setFrom(mailProperties.getFrom());\n            }\n            messageHelper.setTo(mailDTO.getTo());\n            messageHelper.setSubject(mailDTO.getSubject());\n\n            mimeMessage = messageHelper.getMimeMessage();\n            MimeBodyPart mimeBodyPart = new MimeBodyPart();\n            mimeBodyPart.setContent(mailDTO.getText(), "text/html;charset=UTF-8");\n\n            // 描述数据关系\n            MimeMultipart mm = new MimeMultipart();\n            mm.setSubType("related");\n            mm.addBodyPart(mimeBodyPart);\n\n            // 添加邮件附件\n            for (String filename : mailDTO.getFilenames()) {\n                MimeBodyPart attachPart = new MimeBodyPart();\n                try {\n                    attachPart.attachFile(filename);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                mm.addBodyPart(attachPart);\n            }\n            mimeMessage.setContent(mm);\n            mimeMessage.saveChanges();\n\n        } catch (MessagingException e) {\n            e.printStackTrace();\n        }\n\n        javaMailSender.send(mimeMessage);\n    }\n}\n```\n\n## 示例源码\n\n> 示例源码：[spring-boot-mail](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-mail)\n\n## 参考资料\n\n- [Spring Boot 官方文档之 Sending Email](https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-email)'},{title:"Spring IO",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/56581b/",pathLocale:"/",extraFields:"---\ntitle: Spring IO\ndate: 2022-09-18 11:34:00\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - SpringIO\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - IO\npermalink: /pages/56581b/\nhidden: true\nindex: false\n---\n\n# Spring IO\n\n## 📖 内容\n\n- [SpringBoot 之异步请求](01.SpringBoot之异步请求.md)\n- [SpringBoot 之 Json](02.SpringBoot之Json.md)\n- [SpringBoot 之邮件](03.SpringBoot之邮件.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"Spring集成缓存",headers:[{level:2,title:"缓存接口",slug:"缓存接口",link:"#缓存接口",children:[{level:3,title:"开启注解",slug:"开启注解",link:"#开启注解",children:[]},{level:3,title:"缓存注解使用",slug:"缓存注解使用",link:"#缓存注解使用",children:[]}]},{level:2,title:"缓存存储",slug:"缓存存储",link:"#缓存存储",children:[{level:3,title:"使用 ConcurrentHashMap 作为缓存",slug:"使用-concurrenthashmap-作为缓存",link:"#使用-concurrenthashmap-作为缓存",children:[]},{level:3,title:"使用 Ehcache 作为缓存",slug:"使用-ehcache-作为缓存",link:"#使用-ehcache-作为缓存",children:[]},{level:3,title:"使用 Caffeine 作为缓存",slug:"使用-caffeine-作为缓存",link:"#使用-caffeine-作为缓存",children:[]}]},{level:2,title:"示例代码",slug:"示例代码",link:"#示例代码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a311cb/",pathLocale:"/",extraFields:'---\ntitle: Spring集成缓存\ndate: 2017-11-08 16:53:27\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring集成\ntags:\n  - Java\n  - 框架\n  - Spring\n  - 集成\n  - 缓存\npermalink: /pages/a311cb/\n---\n\n# Spring 集成缓存中间件\n\n> Spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。\n\n## 缓存接口\n\nSpring 的缓存 API 以注解方式提供。\n\n### 开启注解\n\nSpring 为缓存功能提供了注解功能，但是你必须启动注解。\n你有两个选择：\n(1) 在 xml 中声明\n像上一节 spring-ehcache.xml 中的做法一样，使用`<cache:annotation-driven/>`\n\n```xml\n<cache:annotation-driven cache-manager="cacheManager"/>\n```\n\n(2) 使用标记注解\n你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。\n范例如下：\n\n```java\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}\n```\n\n### 缓存注解使用\n\nSpring 对缓存的支持类似于对事务的支持。\n首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n下面三个注解都是方法级别：\n\n#### @Cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。\n这个注解可以用`condition`属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。\n可以使用`key`属性来指定 key 的生成规则。\n\n#### @CachePut\n\n与`@Cacheable`不同，`@CachePut`不仅会缓存方法的结果，还会执行方法的代码段。\n它支持的属性和用法都与`@Cacheable`一致。\n\n#### @CacheEvict\n\n与`@Cacheable`功能相反，`@CacheEvict`表明所修饰的方法是用来删除失效或无用的缓存数据。\n下面是`@Cacheable`、`@CacheEvict`和`@CachePut`基本使用方法的一个集中展示：\n\n```java\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}\n```\n\n#### @Caching\n\n如果需要使用同一个缓存注解（`@Cacheable`、`@CacheEvict`或`@CachePut`）多次修饰一个方法，就需要用到`@Caching`。\n\n```java\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)\n```\n\n#### @CacheConfig\n\n与前面的缓存注解不同，这是一个类级别的注解。\n如果类的所有操作都是缓存操作，你可以使用`@CacheConfig`来指定类，省去一些配置。\n\n```java\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n\t@Cacheable\n\tpublic Book findBook(ISBN isbn) {...}\n}\n```\n\n## 缓存存储\n\nSpring 允许通过配置方式接入多种不同的缓存存储。用户可以根据实际需要选择。\n\n不同的缓存存储，具有不同的性能和特性，如果想了解具体原理，可以参考：[全面理解缓存原理](https://dunwu.github.io/javatech/#/technology/cache/cache-theory?id=%e5%85%a8%e9%9d%a2%e7%90%86%e8%a7%a3%e7%bc%93%e5%ad%98%e5%8e%9f%e7%90%86)。这里不再赘述。\n\n### 使用 ConcurrentHashMap 作为缓存\n\n参考配置：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ConcurrentHashMap 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simpleCacheManager" class="org.springframework.cache.support.SimpleCacheManager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simpleCacheManager"/>\n</beans>\n```\n\n### 使用 Ehcache 作为缓存\n\n参考配置：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 EhCache 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">\n    <property name="configLocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcacheCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">\n    <property name="cacheManager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcacheCacheManager"/>\n</beans>\n```\n\nehcache.xml 中的配置内容完全符合 Ehcache 的官方配置标准。\n\n### 使用 Caffeine 作为缓存\n\n参考配置：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 Caffeine 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeineCacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"/>\n\n  <cache:annotation-driven cache-manager="caffeineCacheManager"/>\n</beans>\n```\n\n## 示例代码\n\n我的示例代码地址：[spring-tutorial-integration-cache](https://github.com/dunwu/spring-tutorial/tree/master/spring-tutorial/spring-tutorial-integration/spring-tutorial-integration-cache)\n\n## 参考资料\n\n- [Spring 官方文档之缓存抽象](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache)\n- [注释驱动的 Spring cache 缓存介绍](http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/)'},{title:"Spring 集成调度器",headers:[{level:2,title:"概述",slug:"概述",link:"#概述",children:[]},{level:2,title:"实时触发调度任务",slug:"实时触发调度任务",link:"#实时触发调度任务",children:[{level:3,title:"TaskScheduler 接口",slug:"taskscheduler-接口",link:"#taskscheduler-接口",children:[]},{level:3,title:"@Scheduler 的使用方法",slug:"scheduler-的使用方法",link:"#scheduler-的使用方法",children:[]}]},{level:2,title:"参考",slug:"参考",link:"#参考",children:[]}],path:"/pages/a187f0/",pathLocale:"/",extraFields:'---\ntitle: Spring 集成调度器\ndate: 2017-11-08 16:53:27\norder: 02\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring集成\ntags:\n  - Java\n  - 框架\n  - Spring\n  - 集成\n  - 调度器\npermalink: /pages/a187f0/\n---\n\n# Spring 集成调度器\n\n## 概述\n\n如果想在 Spring 中使用任务调度功能，除了集成调度框架 Quartz 这种方式，也可以使用 Spring 自己的调度任务框架。\n使用 Spring 的调度框架，优点是：支持注解`@Scheduler`，可以省去大量的配置。\n\n## 实时触发调度任务\n\n### TaskScheduler 接口\n\nSpring3 引入了`TaskScheduler`接口，这个接口定义了调度任务的抽象方法。\nTaskScheduler 接口的声明：\n\n```java\npublic interface TaskScheduler {\n\n    ScheduledFuture schedule(Runnable task, Trigger trigger);\n\n    ScheduledFuture schedule(Runnable task, Date startTime);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);\n\n}\n```\n\n从以上方法可以看出 TaskScheduler 有两类重要参数：\n\n- 一个是要调度的方法，即一个实现了 Runnable 接口的线程类的 run()方法；\n- 另一个就是触发条件。\n\n**TaskScheduler 接口的实现类**\n它有三个实现类：`DefaultManagedTaskScheduler`、`ThreadPoolTaskScheduler`、`TimerManagerTaskScheduler`。\n**DefaultManagedTaskScheduler**：基于 JNDI 的调度器。\n**TimerManagerTaskScheduler**：托管`commonj.timers.TimerManager`实例的调度器。\n**ThreadPoolTaskScheduler**：提供线程池管理的调度器，它也实现了`TaskExecutor`接口，从而使的单一的实例可以尽可能快地异步执行。\n\n#### Trigger 接口\n\nTrigger 接口抽象了触发条件的方法。\nTrigger 接口的声明：\n\n```\npublic interface Trigger {\n    Date nextExecutionTime(TriggerContext triggerContext);\n}\n```\n\n**Trigger 接口的实现类**\n**CronTrigger**：实现了 cron 规则的触发器类（和 Quartz 的 cron 规则相同）。\n**PeriodicTrigger**：实现了一个周期性规则的触发器类（例如：定义触发起始时间、间隔时间等）。\n\n#### 完整范例\n\n实现一个调度任务的功能有以下几个关键点：\n**(1) 定义调度器**\n在 spring-bean.xml 中进行配置\n使用`task:scheduler`标签定义一个大小为 10 的线程池调度器，spring 会实例化一个`ThreadPoolTaskScheduler`。\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n```\n\n**_注：不要忘记引入 xsd：_**\n\n```xml\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd\n```\n\n**(2) 定义调度任务**\n定义实现`Runnable`接口的线程类。\n\n```\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DemoTask implements Runnable {\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void run() {\n        logger.info("call DemoTask.run");\n    }\n}\n```\n\n**(3) 装配调度器，并执行调度任务**\n在一个`Controller`类中用`@Autowired`注解装配`TaskScheduler`。\n然后调动 TaskScheduler 对象的 schedule 方法启动调度器，就可以执行调度任务了。\n\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.TaskScheduler;\nimport org.springframework.scheduling.support.CronTrigger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping("/scheduler")\npublic class SchedulerController {\n    @Autowired\n    TaskScheduler scheduler;\n\n    @RequestMapping(value = "/start", method = RequestMethod.POST)\n    public void start() {\n        scheduler.schedule(new DemoTask(), new CronTrigger("0/5 * * * * *"));\n    }\n}\n```\n\n访问/scheduler/start 接口，启动调度器，可以看到如下日志内容：\n\n```\n13:53:15.010 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:20.003 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:25.004 myScheduler-2 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:30.005 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n```\n\n### @Scheduler 的使用方法\n\nSpring 的调度器一个很大的亮点在于`@Scheduler`注解，这可以省去很多繁琐的配置。\n\n#### 启动注解\n\n使用@Scheduler 注解先要使用`<task:annotation-driven>`启动注解开关。\n**_例：_**\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n```\n\n#### @Scheduler 定义触发条件\n\n例：使用`fixedDelay`指定触发条件为每 5000 毫秒执行一次。注意：必须在上一次调度成功后的 5000 秒才能执行。\n\n```java\n@Scheduled(fixedDelay=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n```\n\n例：使用`fixedRate`指定触发条件为每 5000 毫秒执行一次。注意：无论上一次调度是否成功，5000 秒后必然执行。\n\n```java\n@Scheduled(fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n```\n\n例：使用`initialDelay`指定方法在初始化 1000 毫秒后才开始调度。\n\n```java\n@Scheduled(initialDelay=1000, fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n```\n\n例：使用`cron`表达式指定触发条件为每 5000 毫秒执行一次。cron 规则和 Quartz 中的 cron 规则一致。\n\n```java\n@Scheduled(cron="*/5 * * * * MON-FRI")\npublic void doSomething() {\n    // something that should execute on weekdays only\n}\n```\n\n#### 完整范例\n\n**(1) 启动注解开关，并定义调度器和执行器**\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n```\n\n**(2) 使用@Scheduler 注解来修饰一个要调度的方法**\n下面的例子展示了@Scheduler 注解定义触发条件的不同方式。\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @description 使用@Scheduler注解调度任务范例\n * @author Vicotr Zhang\n * @date 2016年8月31日\n */\n@Component\npublic class ScheduledMgr {\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public ScheduledMgr() {\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedDelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @Scheduled(fixedDelay = 5000)\n    public void testFixedDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedRate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @Scheduled(fixedRate = 5000)\n    public void testFixedRate() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * initialDelay属性定义初始化后的启动延迟时间\n     */\n    @Scheduled(initialDelay = 1000, fixedRate = 5000)\n    public void testInitialDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void testCron() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n}\n```\n\n我刻意设置触发方式的间隔都是 5s，且方法中均有 Thread.sleep(6000);语句。从而确保方法在下一次调度触发时间点前无法完成执行，来看一看各种方式的表现吧。\n启动 spring 项目后，spring 会扫描`@Component`注解，然后初始化 ScheduledMgr。\n接着，spring 会扫描`@Scheduler`注解，初始化调度器。调度器在触发条件匹配的情况下开始工作，输出日志。\n截取部分打印日志来进行分析。\n\n```\n10:58:46.479 localhost-startStop-1 o.z.n.s.scheduler.ScheduledTasks.<init> - Current time: 2016-08-31 10:58:46\n10:58:52.523 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:52\n10:58:52.523 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:58:52\n10:58:53.524 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:53\n10:58:55.993 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:58:55\n10:58:58.507 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:58\n10:58:59.525 myScheduler-5 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:59\n10:59:03.536 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:03\n10:59:04.527 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:04\n10:59:05.527 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:05\n10:59:06.032 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:06\n10:59:10.534 myScheduler-9 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:10\n10:59:11.527 myScheduler-10 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:11\n10:59:14.524 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:14\n10:59:15.987 myScheduler-6 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:15\n```\n\n构造方法打印一次，时间点在 10:58:46。\ntestFixedRate 打印四次，每次间隔 6 秒。说明，fixedRate 不等待上一次调度执行完成，在间隔时间达到时立即执行。\ntestFixedDelay 打印三次，每次间隔大于 6 秒，且时间不固定。说明，fixedDelay 等待上一次调度执行成功后，开始计算间隔时间，再执行。\ntestInitialDelay 第一次调度时间和构造方法调度时间相隔 7 秒。说明，initialDelay 在初始化后等待指定的延迟时间才开始调度。\ntestCron 打印三次，时间间隔并非 5 秒或 6 秒，显然，cron 等待上一次调度执行成功后，开始计算间隔时间，再执行。\n此外，可以从日志中看出，打印日志的线程最多只有 10 个，说明 2.1 中的调度器线程池配置生效。\n\n## 参考\n\n[Spring Framework 官方文档](http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/)'},{title:"Spring集成Dubbo",headers:[{level:2,title:"ZooKeeper",slug:"zookeeper",link:"#zookeeper",children:[]},{level:2,title:"Dubbo",slug:"dubbo",link:"#dubbo",children:[]},{level:2,title:"服务提供者",slug:"服务提供者",link:"#服务提供者",children:[{level:3,title:"定义服务接口",slug:"定义服务接口",link:"#定义服务接口",children:[]},{level:3,title:"在服务提供方实现接口",slug:"在服务提供方实现接口",link:"#在服务提供方实现接口",children:[]},{level:3,title:"用 Spring 配置声明暴露服务",slug:"用-spring-配置声明暴露服务",link:"#用-spring-配置声明暴露服务",children:[]},{level:3,title:"加载 Spring 配置",slug:"加载-spring-配置",link:"#加载-spring-配置",children:[]}]},{level:2,title:"服务消费者",slug:"服务消费者",link:"#服务消费者",children:[{level:3,title:"通过 Spring 配置引用远程服务",slug:"通过-spring-配置引用远程服务",link:"#通过-spring-配置引用远程服务",children:[]},{level:3,title:"加载 Spring 配置，并调用远程服务",slug:"加载-spring-配置-并调用远程服务",link:"#加载-spring-配置-并调用远程服务",children:[]}]},{level:2,title:"FAQ",slug:"faq",link:"#faq",children:[]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/274fd7/",pathLocale:"/",extraFields:'---\ntitle: Spring集成Dubbo\ndate: 2017-10-27 17:30:41\norder: 03\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring集成\ntags:\n  - Java\n  - 框架\n  - Spring\n  - 集成\n  - Dubbo\npermalink: /pages/274fd7/\n---\n\n# Spring 集成 Dubbo\n\n## ZooKeeper\n\nZooKeeper 可以作为 Dubbo 的注册中心。\n\nDubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。\n\n**安装**\n\n在 [ZooKeeper 发布中心](http://zookeeper.apache.org/releases.html) 选择需要的版本，下载后解压到本地。\n\n**配置**\n\n```\nvi conf/zoo.cfg\n\n```\n\n如果不需要集群，`zoo.cfg` 的内容如下 [2](https://dubbo.gitbooks.io/dubbo-admin-book/content/install/zookeeper.html#fn_2)：\n\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\n```\n\n如果需要集群，`zoo.cfg` 的内容如下 [3](https://dubbo.gitbooks.io/dubbo-admin-book/content/install/zookeeper.html#fn_3)：\n\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555\n\n```\n\n并在 data 目录 [4](https://dubbo.gitbooks.io/dubbo-admin-book/content/install/zookeeper.html#fn_4) 下放置 myid 文件：\n\n```\nmkdir data\nvi myid\n\n```\n\nmyid 指明自己的 id，对应上面 `zoo.cfg` 中 `server.` 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n\n```\n1\n\n```\n\n**启动**\n\nLinux 下执行 `bin/zkServer.sh` ；Windows `bin/zkServer.cmd` 启动 ZooKeeper 。\n\n**命令行**\n\n```\ntelnet 127.0.0.1 2181\ndump\n```\n\n或者:\n\n```\necho dump | nc 127.0.0.1 2181\n```\n\n用法:\n\n```\ndubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181\n\n```\n\n或者:\n\n```\n<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />\n\n```\n\n> 1. Zookeeper 是 Apache Hadoop 的子项目，强度相对较好，建议生产环境使用该注册中心\n> 2. 其中 data 目录需改成你真实输出目录\n> 3. 其中 data 目录和 server 地址需改成你真实部署机器的信息\n> 4. 上面 `zoo.cfg` 中的 `dataDir`\n> 5. [http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html](http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html)\n\n## Dubbo\n\nDubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。\n\n如果不想使用 Spring 配置，可以通过 [API 的方式](https://dubbo.gitbooks.io/configuration/api.md) 进行调用。\n\n## 服务提供者\n\n完整安装步骤，请参见：[示例提供者安装](https://dubbo.gitbooks.io/dubbo-admin-book/install/provider-demo.html)\n\n### 定义服务接口\n\nDemoService.java [1](https://dubbo.gitbooks.io/dubbo-user-book/quick-start.html#fn_1)：\n\n```java\npackage com.alibaba.dubbo.demo;\n\npublic interface DemoService {\n    String sayHello(String name);\n}\n```\n\n### 在服务提供方实现接口\n\nDemoServiceImpl.java [2](https://dubbo.gitbooks.io/dubbo-user-book/quick-start.html#fn_2)：\n\n```java\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class DemoServiceImpl implements DemoService {\n    public String sayHello(String name) {\n        return "Hello " + name;\n    }\n}\n```\n\n### 用 Spring 配置声明暴露服务\n\nprovider.xml：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />\n</beans>\n```\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n### 加载 Spring 配置\n\nProvider.java：\n\n```java\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Provider {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        System.in.read(); // 按任意键退出\n    }\n}\n```\n\n## 服务消费者\n\n完整安装步骤，请参见：[示例消费者安装](https://dubbo.gitbooks.io/dubbo-admin-book/install/consumer-demo.html)\n\n### 通过 Spring 配置引用远程服务\n\nconsumer.xml：\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\x3e\n    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" />\n</beans>\n```\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n### 加载 Spring 配置，并调用远程服务\n\nConsumer.java [3](https://dubbo.gitbooks.io/dubbo-user-book/quick-start.html#fn_3)：\n\n```\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class Consumer {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理\n        String hello = demoService.sayHello("world"); // 执行远程方法\n        System.out.println( hello ); // 显示调用结果\n    }\n}\n```\n\n> 1. 该接口需单独打包，在服务提供方和消费方共享\n> 2. 对服务消费方隐藏实现\n> 3. 也可以使用 IoC 注入\n\n## FAQ\n\n建议使用 `dubbo-2.3.3` 以上版本的 zookeeper 注册中心客户端。\n\n## 资料\n\n**Dubbo**\n\n[Github](https://github.com/alibaba/dubbo) | [用户手册](https://dubbo.gitbooks.io/dubbo-user-book/content/) | [开发手册](https://dubbo.gitbooks.io/dubbo-dev-book/content/) | [管理员手册](https://dubbo.gitbooks.io/dubbo-admin-book/content/)\n\n**ZooKeeper**\n\n[官网](http://zookeeper.apache.org/) | [官方文档](http://zookeeper.apache.org/doc/trunk/)'},{title:"Spring 集成",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/d6025b/",pathLocale:"/",extraFields:"---\ntitle: Spring 集成\ndate: 2020-02-26 23:47:47\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring集成\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 集成\npermalink: /pages/d6025b/\nhidden: true\nindex: false\n---\n\n# Spring 集成\n\n> 章节主要针对：Spring 与第三方框架、库集成。如：Cache、Scheduling、JMS、JMX 等。\n\n## 📖 内容\n\n- [Spring 集成缓存中间件](01.Spring集成缓存.md)\n- [Spring 集成定时任务中间件](02.Spring集成调度器.md)\n- [Spring 集成 Dubbo](03.Spring集成Dubbo.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"SpringBoot 之安全快速入门",headers:[{level:2,title:"QuickStart",slug:"quickstart",link:"#quickstart",children:[]}],path:"/pages/568352/",pathLocale:"/",extraFields:"---\ntitle: SpringBoot 之安全快速入门\ndate: 2021-05-13 18:21:56\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring安全\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\n  - 安全\npermalink: /pages/568352/\n---\n\n# SpringBoot 之安全快速入门\n\n## QuickStart\n\n（1）添加依赖\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>\n```\n\n（2）添加配置\n\n```properties\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = USER\n```\n\n（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root/root）即可访问应用页面。\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/image-20191118150326556.png)"},{title:"Spring 4 升级踩雷指南",headers:[{level:2,title:"前言",slug:"前言",link:"#前言",children:[]},{level:2,title:"为什么升级 spring4",slug:"为什么升级-spring4",link:"#为什么升级-spring4",children:[]},{level:2,title:"spring 4 重要新特性",slug:"spring-4-重要新特性",link:"#spring-4-重要新特性",children:[]},{level:2,title:"升级 spring 4 步骤",slug:"升级-spring-4-步骤",link:"#升级-spring-4-步骤",children:[{level:3,title:"修改 spring 版本",slug:"修改-spring-版本",link:"#修改-spring-版本",children:[]},{level:3,title:"修改 spring xml 文件的 xsd",slug:"修改-spring-xml-文件的-xsd",link:"#修改-spring-xml-文件的-xsd",children:[]},{level:3,title:"修改 spring xml 文件",slug:"修改-spring-xml-文件",link:"#修改-spring-xml-文件",children:[]},{level:3,title:"加入 spring support",slug:"加入-spring-support",link:"#加入-spring-support",children:[]},{level:3,title:"更换 spring-mvc jackson",slug:"更换-spring-mvc-jackson",link:"#更换-spring-mvc-jackson",children:[]},{level:3,title:"解决 ibatis 兼容问题",slug:"解决-ibatis-兼容问题",link:"#解决-ibatis-兼容问题",children:[]},{level:3,title:"升级 Dubbo",slug:"升级-dubbo",link:"#升级-dubbo",children:[]},{level:3,title:"升级 Jedis",slug:"升级-jedis",link:"#升级-jedis",children:[]}]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/752c6a/",pathLocale:"/",extraFields:'---\ntitle: Spring 4 升级踩雷指南\ndate: 2017-12-15 15:10:32\norder: 01\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring其他\ntags:\n  - Java\n  - 框架\n  - Spring\npermalink: /pages/752c6a/\n---\n\n# Spring 4 升级踩雷指南\n\n## 前言\n\n最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 JDK8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。\n\n总之，这是个费劲的活啊。\n\n本文小结一下升级 Spring4 的连锁问题。\n\n## 为什么升级 spring4\n\n升级 Spring4 的原因是：Spring 4 以前的版本不兼容 JDK8。当你的项目同时使用 Spring3 和 JDK8，如果代码中有使用 JDK8 字节码或 Lambada 表达式，那么会出问题。\n\n也许你会问，为什么不使用最新的 Spring 5 呢？因为作为企业软件，一般更倾向使用稳定的版本（bug 少），而不是最新的版本，尤其是一些核心库。\n\n更多细节可以参考：\n\nhttps://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n\n## spring 4 重要新特性\n\nSpring 4 相比 Spring 3，引入许多新特性，这里列举几条较为重要的：\n\n1. 支持 `JDK8` （这个是最主要的）。\n2. `Groovy Bean Definition DSL` 风格配置。\n3. 支持 WebSocket、SockJS、STOMP 消息\n4. 移除 Deprecated 包和方法\n5. 一些功能加强，如：核心容器、Web、Test 等等，不一一列举。\n\n更多 Spring 4 新特性可以参考：\n\nhttps://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n\nhttp://jinnianshilongnian.iteye.com/blog/1995111\n\n## 升级 spring 4 步骤\n\n了解了前面内容，我们知道了升级 Spring 4 带来的好处。现在开始真刀真枪的升级了。\n\n不要以为升级一下 Spring 4，仅仅是改一下版本号，那么简单，细节处多着呢。\n\n下面，结合我在公司项目升级 Spring4 时遇到的一系列坑，希望能帮助各位少走弯路。\n\n> **注**\n>\n> 下文内容基于假设你的项目是用 maven 管理这一前提。如果不满足这一前提，那么这篇文章对你没什么太大帮助。\n\n### 修改 spring 版本\n\n第一步，当然是修改 pom.xml 中的 spring 版本。\n\n`3.x.x.RELEASE` > `4.x.x.RELEASE`\n\n实例：升级 spring-core\n\n其它 spring 库的升级也如此：\n\n```xml\n<properties>\n  <spring.version>4.3.13.RELEASE</spring.version>\n</properties>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>${spring.version}</version>\n</dependency>\n```\n\n### 修改 spring xml 文件的 xsd\n\n用过 spring 的都知道，spring 通常依赖于大量的 xml 配置。\n\nspring 的 xml 解析器在解析 xml 时，需要读取 xml schema，schema 定义了 xml 的命名空间。它的好处在于可以避免命名冲突，有点像 Java 中的 package。\n\n实例：一个 spring xml 的 schema\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">\n```\n\n> **说明**\n>\n> - `xmlns="http://www.springframework.org/schema/beans"` 声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。\n>\n> - `xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"` 声明 XML Schema 实例，声明后就可以使用 schemaLocation 属性了。\n>\n> - `xmlns:mvc="http://www.springframework.org/schema/mvc"`\n>   声明前缀为 mvc 的命名空间，后面的 URL 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 其它的类似 `xmlns:context` 、`xmlns:jdbc` 等等同样如此。\n>\n> - ```\n>   xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>   ..."\n>   ```\n>\n>   这个从命名可以看出个大概，指定 schema 位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 xml schema 的位置。\n\n上面示例中的 xsd 版本是 `3.1.xsd` ，表示 spring 的 xml 解析器会将其视为 3.1 版本的 xml 文件来处理。\n\n现在，我们使用了 Spring 4，`3.1.xsd` 版本显然就不正确了，我们可以根据自己引入的 Spring 4 的子版本号将其改为 `4.x.xsd` 。\n\n但是，还有一种更好的做法：把这个指定 xsd 版本的关键字干掉，类似这样：`http://www.springframework.org/schema/tx/spring-tx.xsd` 。\n\n**这么做的原因如下：**\n\n- Spring 默认在启动时要加载 xsd 文件来验证 xml 文件。\n- 如果没有提供 `schemaLocation`，那么 spring 的 xml 解析器会从 namespace 的 uri 里加载 xsd 文件。\n- `schemaLocation` 提供了一个 xml namespace 到对应的 xsd 文件的一个映射。\n- 如果不指定 spring xsd 的版本号，spring 取的就是当前本地 jar 里的 xsd 文件，减少了各种风险（比如 xsd 与实际 spring jar 版本不一致）。\n\n更多详细内容可以参考这篇文章：[为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号](http://blog.csdn.net/hengyunabc/article/details/22295749)\n\n### 修改 spring xml 文件\n\nspring 4 对 xml 做了一些改动。这里说一个最常用的改动：\n\n#### ref local\n\nspring 不再支持 `ref` 元素的 `local` 属性，如果你的项目中使用了，需要改为 `bean`。\n\nshi\n\nspring 4 以前：\n\n```xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref local="dataSource" />\n  </property>\n</bean>\n```\n\nspring 4 以后：\n\n```xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref bean="dataSource" />\n  </property>\n</bean>\n```\n\n如果不改启动会报错：\n\n```\nCaused by: org.xml.sax.SAXParseException: cvc-complex-type.3.2.2: Attribute \'local\' is not allowed to appear in element \'ref\'.\n```\n\n当然，可能还有一些其他配置改动，这个只能说兵来将挡水来土掩，遇到了再去查官方文档吧。\n\n### 加入 spring support\n\nspring 3 中很多的扩展内容不需要引入 support 。但是 spring 4 中分离的更彻底了，如果不分离，会有很多`ClassNotFound` 。\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.2.3.RELEASE</version>\n</dependency>\n```\n\n### 更换 spring-mvc jackson\n\nspring mvc 中如果返回结果为 json 需要依赖 jackson 的 jar 包，但是他升级到了 2, 以前是 `codehaus.jackson`，现在换成了 `fasterxml.jackson`\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.7.0</version>\n</dependency>\n```\n\n同时修改 spring mvc 的配置文件：\n\n```xml\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">\n\t<property name="messageConverters">\n\t\t<list>\n\t\t\t <ref bean="stringHttpMessageConverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringHttpMessageConverter"\n\tclass="org.springframework.http.converter.StringHttpMessageConverter">\n\t<property name="supportedMediaTypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=UTF-8</value>\n\t\t</list>\n\t</property>\n</bean>\n```\n\n### 解决 ibatis 兼容问题\n\n**问题**\n\n如果你的项目中使用了 ibatis (mybatis 的前身)这个 orm 框架，当 spring3 升级 spring4 后，会出现兼容性问题，编译都不能通过。\n\n这是因为 Spring4 官方已经不再支持 ibatis。\n\n**解决方案**\n\n添加兼容性 jar 包\n\n```xml\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-2-spring</artifactId>\n    <version>1.0.1</version>\n</dependency>\n```\n\n更多内容可参考：https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n\n### 升级 Dubbo\n\n我们的项目中使用了 soa 框架 Dubbo 。由于 Dubbo 是老版本的，具体来说是（2013 年的 2.4.10），而老版本中使用的 spirng 版本为 2.x，有兼容性问题。\n\nDubbo 项目从今年开始恢复维护了，首先把一些落后的库升级到较新版本，比如 jdk8，spring4 等，并修复了一些 bug。所以，我们可以通过升级一下 Dubbo 版本来解决问题。\n\n```xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>dubbo</artifactId>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.javassist</groupId>\n      <artifactId>javassist</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n```\n\n### 升级 Jedis\n\n升级 Dubbo 为当前最新的 2.5.8 版本后，运行时报错：\n\n- **JedisPoolConfig 配置错误**\n\n```\nCaused by: java.lang.ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig\n```\n\n由于项目中使用了 redis，版本为 2.0.0 ，这个问题是由于 jedis 需要升级：\n\n```xml\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>\n```\n\njedis 2.4.1 以上版本的 `JedisPoolConfig` 已经没有了`maxActive` 和 `maxWait` 属性。\n\n修改方法如下：\n\n**maxActive** > **maxTotal**\n\n**maxWait** > **maxWaitMillis**\n\n```xml\n<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">\n  <property name="maxTotal" value="200" />\n  <property name="maxIdle" value="10" />\n  <property name="maxWaitMillis" value="1000" />\n  <property name="testOnBorrow" value="true" />\n</bean>\n```\n\nJedisPool 配置错误\n\n```\nInvalidURIException: Cannot open Redis connection due invalid URI\n```\n\n原来的配置如下：\n\n```xml\n<bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="destroy" depends-on="jedisPoolConfig">\n  <constructor-arg ref="jedisPoolConfig" />\n  <constructor-arg type="java.lang.String" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>\n```\n\n查看源码可以发现，初始化 JedisPool 时未指定结构方法参数的类型，导致 host 字符串值被视为 URI 类型，当然类型不匹配。\n\n解决方法是修改上面的 host 配置，为：`<constructor-arg type="java.lang.String" value="${redis.host}" />`\n\n---\n\n至此，spring 4 升级结束。后面如果遇到其他升级问题再补充。\n\n## 资料\n\n- https://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n- https://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n- [Spring 3.x 升级到 Spring 4.x 注意事项和步骤，错误解决方法](http://www.sojson.com/blog/145.html)\n- http://jinnianshilongnian.iteye.com/blog/1995111\n- [为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号](http://blog.csdn.net/hengyunabc/article/details/22295749)\n- https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n'},{title:"SpringBoot 之 banner 定制",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"变量",slug:"变量",link:"#变量",children:[]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"编程",slug:"编程",link:"#编程",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/bac2ce/",pathLocale:"/",extraFields:"---\ntitle: SpringBoot 之 banner 定制\ndate: 2018-12-21 23:22:44\norder: 21\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring其他\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/bac2ce/\n---\n\n# SpringBoot 之 banner 定制\n\n## 简介\n\nSpring Boot 启动时默认会显示以下 LOGO：\n\n```\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.1.1.RELEASE)\n```\n\n实际上，Spring Boot 支持自定义 logo 的功能。\n\n让我们来看看如何实现的。\n\n只要你在 `resources` 目录下放置名为 `banner.txt`、`banner.gif` 、`banner.jpg` 或 `banner.png` 的文件，Spring Boot 会自动加载，将其作为启动时打印的 logo。\n\n- 对于文本文件，Spring Boot 会将其直接输出。\n- 对于图像文件（ `banner.gif` 、`banner.jpg` 或 `banner.png` ），Spring Boot 会将图像转为 ASCII 字符，然后输出。\n\n## 变量\n\nbanner.txt 文件中还可以使用变量来设置字体、颜色、版本号。\n\n| 变量                                                                                   | 描述                                                                                                                                                                                                                              |\n| :------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `${application.version}`                                                               | `MANIFEST.MF` 中定义的版本。如：`1.0`                                                                                                                                                                                             |\n| `${application.formatted-version}`                                                     | `MANIFEST.MF` 中定义的版本，并添加一个 `v` 前缀。如：`v1.0`                                                                                                                                                                       |\n| `${spring-boot.version}`                                                               | Spring Boot 版本。如：`2.1.1.RELEASE`.                                                                                                                                                                                            |\n| `${spring-boot.formatted-version}`                                                     | Spring Boot 版本，并添加一个 `v` 前缀。如：`v2.1.1.RELEASE`                                                                                                                                                                       |\n| `${Ansi.NAME}` (or `${AnsiColor.NAME}`, `${AnsiBackground.NAME}`, `${AnsiStyle.NAME}`) | ANSI 颜色、字体。更多细节，参考：[`AnsiPropertySource`](https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java)。 |\n| `${application.title}`                                                                 | `MANIFEST.MF` 中定义的应用名。                                                                                                                                                                                                    |\n\n示例：\n\n在 Spring Boot 项目中的 `resources` 目录下添加一个名为 banner.txt 的文件，内容如下：\n\n```\n${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}\n:: Spring Boot ::             (v${spring-boot.version})\n:: Spring Boot Tutorial ::    (v1.0.0)\n```\n\n> 注：`${}` 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。\n\n启动应用后，控制台将打印如下 logo：\n\n![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20181221231330.png)\n推荐两个生成字符画的网站，可以将生成的字符串放入这个`banner.txt` 文件：\n\n- <http://www.network-science.de/ascii/>\n- <http://patorjk.com/software/taag/>\n\n## 配置\n\n`application.properties` 中与 Banner 相关的配置：\n\n```properties\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 System.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = UTF-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false\n```\n\n当然，你也可以在 YAML 文件中配置，例如：\n\n```yml\nspring:\n  main:\n    banner-mode: off\n```\n\n## 编程\n\n默认，Spring Boot 会注册一个 `SpringBootBanner` 的单例 Bean，用来负责打印 Banner。\n\n如果想完全个人定制 Banner，可以这么做：先实现 `org.springframework.boot.Banner#printBanner` 接口来自己定制 Banner。在将这个 Banner 通过 `SpringApplication.setBanner(…)` 方法注入 Spring Boot。\n\n## 示例源码\n\n> 示例源码：[spring-boot-banner](https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/spring-boot-banner)\n\n## 参考资料\n\n- [Spring Boot 官方文档之 Customizing the Banner](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-banner)"},{title:"SpringBoot Actuator 快速入门",headers:[{level:2,title:"端点（Endpoint）",slug:"端点-endpoint",link:"#端点-endpoint",children:[{level:3,title:"启用端点",slug:"启用端点",link:"#启用端点",children:[]},{level:3,title:"暴露端点",slug:"暴露端点",link:"#暴露端点",children:[]},{level:3,title:"安全",slug:"安全",link:"#安全",children:[]},{level:3,title:"配置端点",slug:"配置端点",link:"#配置端点",children:[]},{level:3,title:"Actuator Web 端点的超媒体",slug:"actuator-web-端点的超媒体",link:"#actuator-web-端点的超媒体",children:[]},{level:3,title:"跨域支持",slug:"跨域支持",link:"#跨域支持",children:[]},{level:3,title:"自定义端点",slug:"自定义端点",link:"#自定义端点",children:[]}]},{level:2,title:"通过 HTTP 进行监控和管理",slug:"通过-http-进行监控和管理",link:"#通过-http-进行监控和管理",children:[{level:3,title:"自定义管理端点路径",slug:"自定义管理端点路径",link:"#自定义管理端点路径",children:[]},{level:3,title:"自定义管理服务器端口",slug:"自定义管理服务器端口",link:"#自定义管理服务器端口",children:[]},{level:3,title:"配置 SSL",slug:"配置-ssl",link:"#配置-ssl",children:[]},{level:3,title:"自定义管理服务器地址",slug:"自定义管理服务器地址",link:"#自定义管理服务器地址",children:[]},{level:3,title:"禁用 HTTP 端点",slug:"禁用-http-端点",link:"#禁用-http-端点",children:[]}]},{level:2,title:"通过 JMX 进行监控和管理",slug:"通过-jmx-进行监控和管理",link:"#通过-jmx-进行监控和管理",children:[{level:3,title:"定制化 MBean Names",slug:"定制化-mbean-names",link:"#定制化-mbean-names",children:[]},{level:3,title:"禁用 JMX 端点",slug:"禁用-jmx-端点",link:"#禁用-jmx-端点",children:[]},{level:3,title:"将 Jolokia 用于基于 HTTP 的 JMX",slug:"将-jolokia-用于基于-http-的-jmx",link:"#将-jolokia-用于基于-http-的-jmx",children:[]}]},{level:2,title:"日志",slug:"日志",link:"#日志",children:[]},{level:2,title:"指标",slug:"指标",link:"#指标",children:[]},{level:2,title:"审计",slug:"审计",link:"#审计",children:[]},{level:2,title:"HTTP 追踪",slug:"http-追踪",link:"#http-追踪",children:[]},{level:2,title:"处理监控",slug:"处理监控",link:"#处理监控",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/c013cc/",pathLocale:"/",extraFields:'---\ntitle: SpringBoot Actuator 快速入门\ndate: 2022-06-14 20:51:22\norder: 22\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring其他\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/c013cc/\n---\n\n# SpringBoot Actuator 快速入门\n\n[`spring-boot-actuator`](https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-actuator) 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 `spring-boot-starter-actuator` 依赖。\n\n如果是 Maven 项目，添加以下依赖：\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n```\n\n如果是 Gradle 项目，添加以下声明：\n\n```groovy\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-actuator\'\n}\n```\n\n## 端点（Endpoint）\n\nActuator Endpoint 使 Spring Boot 用户可以监控应用，并和应用进行交互。Spring Boot 内置了许多 端点，并允许用户自定义端点。例如，`health` 端点提供基本的应用健康信息。\n\n用户可以启用或禁用每个单独的端点并通过 HTTP 或 JMX 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 HTTP 公开。例如，默认情况下，`health` 端点映射到 `/actuator/health`。\n\n### 启用端点\n\n默认情况下，除了 `shutdown` 之外的所有端点都已启用。要配置端点的启用，请使用 `management.endpoint.<id>.enabled` 属性。以下示例启用 `shutdown` 端点：\n\n```properties\nmanagement.endpoint.shutdown.enabled=true\n```\n\n如果您希望端点是明确指定才启用，请将 `management.endpoints.enabled-by-default` 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：\n\n```properties\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true\n```\n\n### 暴露端点\n\n由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：\n\n| ID                 | JMX | Web |\n| :----------------- | :-- | :-- |\n| `auditevents`      | Yes | No  |\n| `beans`            | Yes | No  |\n| `caches`           | Yes | No  |\n| `conditions`       | Yes | No  |\n| `configprops`      | Yes | No  |\n| `env`              | Yes | No  |\n| `flyway`           | Yes | No  |\n| `health`           | Yes | Yes |\n| `heapdump`         | N/A | No  |\n| `httptrace`        | Yes | No  |\n| `info`             | Yes | No  |\n| `integrationgraph` | Yes | No  |\n| `jolokia`          | N/A | No  |\n| `logfile`          | N/A | No  |\n| `loggers`          | Yes | No  |\n| `liquibase`        | Yes | No  |\n| `metrics`          | Yes | No  |\n| `mappings`         | Yes | No  |\n| `prometheus`       | N/A | No  |\n| `quartz`           | Yes | No  |\n| `scheduledtasks`   | Yes | No  |\n| `sessions`         | Yes | No  |\n| `shutdown`         | Yes | No  |\n| `startup`          | Yes | No  |\n| `threaddump`       | Yes | No  |\n\n要更改暴露的端点，请使用以下特定于技术的包含和排除属性：\n\n| Property                                    | Default  |\n| :------------------------------------------ | :------- |\n| `management.endpoints.jmx.exposure.exclude` |          |\n| `management.endpoints.jmx.exposure.include` | `*`      |\n| `management.endpoints.web.exposure.exclude` |          |\n| `management.endpoints.web.exposure.include` | `health` |\n\n`include` 属性列出了暴露的端点的 ID。 `exclude` 属性列出了不应暴露的端点的 ID。 `exclude` 属性优先于 `include` 属性。您可以使用端点 ID 列表配置包含和排除属性。\n\n例如，仅暴露 `health` 和 info 端点，其他端点都不通过 JMX 暴露，可以按如下配置：\n\n```properties\nmanagement.endpoints.jmx.exposure.include=health,info\n```\n\n注意：`*` 可用于选择所有端点。\n\n### 安全\n\n出于安全考虑，只有 `/health` 端点会通过 HTTP 方式暴露。用户可以通过 `management.endpoints.web.exposure.include` 决定哪些端点可以通过 HTTP 方式暴露。\n\n如果 Spring Security 在类路径上并且不存在其他 `WebSecurityConfigurerAdapter` 或 `SecurityFilterChain` bean，则除 `/health` 之外的所有 actuator 都由 Spring Boot 自动启用安全控制。如果用户自定义了 `WebSecurityConfigurerAdapter` 或 `SecurityFilterChain` bean，Spring Boot 不再启用安全控制，由用户自行控制访问规则。\n\n如果您希望为 HTTP 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），Spring Boot 提供了一些方便的 `RequestMatcher` 对象，您可以将它们与 Spring Security 结合使用。\n\n下面是一个典型的 Spring Security 配置示例：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));\n        http.httpBasic();\n        return http.build();\n    }\n\n}\n```\n\n前面的示例使用 EndpointRequest.toAnyEndpoint() 将请求匹配到任何端点，然后确保所有端点都具有 ENDPOINT_ADMIN 角色。 EndpointRequest 上还提供了其他几种匹配器方法。\n\n如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：\n\n```properties\nmanagement.endpoints.web.exposure.include=*\n```\n\n此外，如果存在 Spring Security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().permitAll());\n        return http.build();\n    }\n\n}\n```\n\n由于 Spring Boot 依赖于 Spring Security 的默认设置，因此 CSRF 保护默认开启。这意味着在使用默认安全配置时，需要 POST（关闭和记录器端点）、PUT 或 DELETE 的执行器端点会收到 403（禁止）错误。\n\n> 建议仅在创建非浏览器客户端使用的服务时完全禁用 CSRF 保护。\n\n### 配置端点\n\n端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 `cache.time-to-live` 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：\n\n```properties\nmanagement.endpoint.beans.cache.time-to-live=10s\n```\n\n### Actuator Web 端点的超媒体\n\nSpring Boot Actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 `/actuator` 上可用。\n\n要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：\n\n```properties\nmanagement.endpoints.web.discovery.enabled=false\n```\n\n配置自定义管理上下文路径后，“发现页面”会自动从 `/actuator` 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 `/management`，则发现页面可从 `/management` 获得。当管理上下文路径设置为 / 时，发现页面被禁用以防止与其他映射发生冲突的可能性。\n\n### 跨域支持\n\nCORS 是一种 W3C 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web 端点以支持此类场景。\n\nCORS 支持默认是禁用的，只有在设置 `management.endpoints.web.cors.allowed-origins` 属性后才会启用。以下配置允许来自 example.com 域的 GET 和 POST 调用：\n\n```properties\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n```\n\n### 自定义端点\n\n如果添加带有 `@Endpoint` 注释的 `@Bean`，则任何带有 `@ReadOperation`、`@WriteOperation` 或 `@DeleteOperation` 注释的方法都会自动通过 JMX 公开，并且在 Web 应用程序中，也可以通过 HTTP 公开。可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。如果 Jersey 和 Spring MVC 都可用，则使用 Spring MVC。\n\n以下示例公开了一个返回自定义对象的读取操作：\n\n```java\n@ReadOperation\npublic CustomData getData() {\n    return new CustomData("test", 5);\n}\n```\n\n您还可以使用 `@JmxEndpoint` 或 `@WebEndpoint` 编写特定技术的端点。这些端点仅限于各自的技术。例如，`@WebEndpoint` 仅通过 HTTP 而不是通过 JMX 公开。\n\n您可以使用 `@EndpointWebExtension` 和 `@EndpointJmxExtension` 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。\n\n最后，如果您需要访问 Web 框架的功能，您可以实现 servlet 或 Spring `@Controller` 和 `@RestController` 端点，但代价是它们无法通过 JMX 或使用不同的 Web 框架获得。\n\n## 通过 HTTP 进行监控和管理\n\n### 自定义管理端点路径\n\n如果是 Web 应用，Spring Boot Actuator 会自动将所有启用的端点通过 HTTP 方式暴露。默认约定是使用前缀为 `/actuator` 的端点的 id 作为 URL 路径。例如，健康被暴露为 `/actuator/health`。\n\n有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 `/actuator` 用于其他目的。您可以使用 `management.endpoints.web.base-path` 属性更改管理端点的前缀，如以下示例所示：\n\n```properties\nmanagement.endpoints.web.base-path=/manage\n```\n\n该示例将端点从 `/actuator/{id}` 更改为 `/manage/{id}`（例如，`/manage/info`）。\n\n### 自定义管理服务器端口\n\n```properties\nmanagement.server.port=8081\n```\n\n### 配置 SSL\n\n当配置为使用自定义端口时，还可以使用各种 `management.server.ssl.*` 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：\n\n```properties\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false\n```\n\n或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：\n\n```properties\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret\n```\n\n### 自定义管理服务器地址\n\n```properties\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1\n```\n\n### 禁用 HTTP 端点\n\n如果您不想通过 HTTP 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：\n\n```properties\nmanagement.server.port=-1\n```\n\n也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：\n\n```properties\nmanagement.endpoints.web.exposure.exclude=*\n```\n\n## 通过 JMX 进行监控和管理\n\nJava 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 `spring.jmx.enabled` 配置属性设置为 true 来打开它。 Spring Boot 将最合适的 `MBeanServer` 暴露为 ID 为 `mbeanServer` 的 bean。使用 Spring JMX 注释（`@ManagedResource`、`@ManagedAttribute` 或 `@ManagedOperation`）注释的任何 bean 都会暴露给它。\n\n如果您的平台提供标准 `MBeanServer`，则 Spring Boot 会使用该标准并在必要时默认使用 VM `MBeanServer`。如果一切都失败了，则创建一个新的 `MBeanServer`。\n\n有关更多详细信息，请参阅 [`JmxAutoConfiguration`](https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java) 类。\n\n默认情况下，Spring Boot 还将管理端点公开为 `org.springframework.boot` 域下的 JMX MBean。要完全控制 JMX 域中的端点注册，请考虑注册您自己的 `EndpointObjectNameFactory` 实现。\n\n### 定制化 MBean Names\n\nMBean 的名称通常由端点的 id 生成。例如，健康端点公开为 `org.springframework.boot:type=Endpoint,name=Health`。\n\n如果您的应用程序包含多个 Spring `ApplicationContext`，您可能会发现名称冲突。要解决此问题，您可以将 `spring.jmx.unique-names` 属性设置为 true，以便 MBean 名称始终是唯一的。\n\n如果需要定制，跨域按如下配置：\n\n```properties\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp\n```\n\n### 禁用 JMX 端点\n\n想禁用 JMX 端点，可以按如下配置：\n\n```\nmanagement.endpoints.jmx.exposure.exclude=*\n```\n\n### 将 Jolokia 用于基于 HTTP 的 JMX\n\nJolokia 是一个 JMX-HTTP 的桥接工具，它提供了另一种访问 JMX bean 的方法。要使用 Jolokia，需要先添加依赖：\n\n```xml\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency\n```\n\n然后，您可以通过将 `jolokia` 或 `*` 添加到 `Management.Endpoints.web.exposure.include` 属性来暴露 Jolokia 端点。然后，您可以在管理 HTTP 服务器上使用 `/actuator/jolokia` 访问它。\n\n## 日志\n\nSpring Boot Actuator 支持查看和配置应用日志级别。\n\n日志级别的可选值如下：\n\n- `TRACE`\n- `DEBUG`\n- `INFO`\n- `WARN`\n- `ERROR`\n- `FATAL`\n- `OFF`\n- `null`\n\n`null` 表示没有显式配置。\n\n## 指标\n\n## 审计\n\nSpring Boot Actuator 支持简单的审计功能。如果应用中启用了 Spring Security，Spring Boot Actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。\n\n可以通过在应用的配置中提供 `AuditEventRepository` 类型的 bean 来启用审计。为方便起见，Spring Boot 提供了一个 `InMemoryAuditEventRepository`。 `InMemoryAuditEventRepository` 的功能有限，建议仅将其用于开发环境。\n\n如果要自定义安全事件，可以提供 `AbstractAuthenticationAuditListener` 和 `AbstractAuthorizationAuditListener` 实现。\n\n此外，还可以将审计服务用于业务活动。为此，要么将 `AuditEventRepository` bean 注入组件并直接使用它，要么使用 Spring `ApplicationEventPublisher` 发布 `AuditApplicationEvent`（通过实现 `ApplicationEventPublisherAware`）。\n\n## HTTP 追踪\n\n用户可以通过在应用中提供 `HttpTraceRepository` 类型的 bean 来启用 HTTP 跟踪。Spring Boot 提供了内置的 `InMemoryHttpTraceRepository`，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 HTTP 追踪解决方案相比，`InMemoryHttpTraceRepository` 比较受限，建议仅用于开发环境。对于生产环境，建议使用 Zipkin 或 Spring Cloud Sleuth。\n\n或者，可以自定义 `HttpTraceRepository`。\n\n## 处理监控\n\n在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：\n\n- `ApplicationPidFileWriter` 创建一个包含应用程序 PID 的文件（默认情况下，在应用程序目录中，文件名为 `application.pid`）。\n- `WebServerPortFileWriter` 创建一个文件（或多个文件），其中包含正在运行的 Web 服务器的端口（默认情况下，在应用程序目录中，文件名为 `application.port`）。\n\n## 参考资料\n\n- [Spring Boot 官方文档之 Production-ready Features](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator)'},{title:"Spring 其他",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/6bb8c1/",pathLocale:"/",extraFields:"---\ntitle: Spring 其他\ndate: 2020-02-26 23:48:06\ncategories:\n  - Java\n  - 框架\n  - Spring\n  - Spring其他\ntags:\n  - Java\n  - 框架\n  - Spring\n  - SpringBoot\npermalink: /pages/6bb8c1/\nhidden: true\nindex: false\n---\n\n# Spring 其他\n\n## 📖 内容\n\n- [Spring4 升级](01.Spring4升级.md)\n- [SpringBoot 之 banner](21.SpringBoot之banner.md)\n- [SpringBoot 之 Actuator](22.SpringBoot之Actuator.md)\n\n## 📚 资料\n\n- **官方**\n  - [Spring 官网](https://spring.io/)\n  - [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)\n  - [Spring Github](https://github.com/spring-projects/spring-framework)\n- **书籍**\n  - [《Spring In Action》](https://item.jd.com/12622829.html)\n- **教程**\n  - [《小马哥讲 Spring 核心编程思想》](https://time.geekbang.org/course/intro/265)\n  - [geekbang-lessons](https://github.com/geektime-geekbang/geekbang-lessons)\n  - [跟我学 Spring3](http://jinnianshilongnian.iteye.com/blog/1482071)\n\n## 🚪 传送\n\n◾ 💧 [钝悟的 IT 知识图谱](https://dunwu.github.io/waterdrop/) ◾ 🎯 [我的博客](https://github.com/dunwu/blog) ◾"},{title:"日志",headers:[{level:2,title:"1.1 作用：",slug:"_1-1-作用",link:"#_1-1-作用",children:[]},{level:2,title:"1.2 使用步骤：",slug:"_1-2-使用步骤",link:"#_1-2-使用步骤",children:[]},{level:2,title:"1.3 日志级别",slug:"_1-3-日志级别",link:"#_1-3-日志级别",children:[]},{level:2,title:"1.4 配置文件",slug:"_1-4-配置文件",link:"#_1-4-配置文件",children:[]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html",pathLocale:"/",extraFields:'---\ntitle: 日志\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n日志\n\n\x3c!-- more --\x3e\n# 日志\n\n## 1.1 作用：\n\n​\t跟输出语句一样，可以把程序在运行过程中的详细信息都打印在控制台上。\n\n​\t利用log日志还可以把这些详细信息保存到文件和数据库中。\n\n## 1.2 使用步骤：\n\n​\t不是java的，也不是自己写的，是第三方提供的代码，所以我们要导入jar包。\n\n* 把第三方的代码导入到当前的项目当中\n\n  新建lib文件夹，把jar粘贴到lib文件夹当中，全选后右键点击选择add as a ....\n\n  检测导入成功：导入成功后jar包可以展开。在项目重构界面可以看到导入的内容\n\n* 把配置文件粘贴到src文件夹下\n\n* 在代码中获取日志对象\n\n* 调用方法打印日志\n\n## 1.3 日志级别\n\n```\nTRACE, DEBUG, INFO, WARN, ERROR\n```\n\n还有两个特殊的：\n\n​\tALL：输出所有日志\n\n​\tOFF：关闭所有日志\n\n日志级别从小到大的关系：\n\n​\tTRACE < DEBUG < INFO < WARN < ERROR\n\n## 1.4 配置文件\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<configuration>\n    \x3c!--\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\n    --\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--输出流对象 默认 System.out 改为 System.err--\x3e\n        <target>System.out</target>\n        <encoder>\n            \x3c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度\n                %msg：日志消息，%n是换行符--\x3e\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    \x3c!-- File是输出的方向通向文件的 --\x3e\n    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n            <charset>utf-8</charset>\n        </encoder>\n        \x3c!--日志输出路径--\x3e\n        <file>C:/code/itheima-data.log</file>\n        \x3c!--指定日志文件拆分和压缩规则--\x3e\n        <rollingPolicy\n                       class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">\n            \x3c!--通过指定压缩文件名称，来确定分割文件方式--\x3e\n            <fileNamePattern>C:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz</fileNamePattern>\n            \x3c!--文件拆分大小--\x3e\n            <maxFileSize>1MB</maxFileSize>\n        </rollingPolicy>\n    </appender>\n\n    \x3c!--\n\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\n   ， 默认debug\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\n    --\x3e\n    <root level="info">\n        <appender-ref ref="CONSOLE"/>\n        <appender-ref ref="FILE" />\n    </root>\n</configuration>\n```\n\n'},{title:"类加载器",headers:[{level:2,title:"1.类加载器",slug:"_1-类加载器",link:"#_1-类加载器",children:[{level:3,title:"1.1类加载器",slug:"_1-1类加载器",link:"#_1-1类加载器",children:[]},{level:3,title:"1.2类加载的完整过程",slug:"_1-2类加载的完整过程",link:"#_1-2类加载的完整过程",children:[]},{level:3,title:"1.3类加载的分类【理解】",slug:"_1-3类加载的分类【理解】",link:"#_1-3类加载的分类【理解】",children:[]},{level:3,title:"1.4双亲委派模型【理解】",slug:"_1-4双亲委派模型【理解】",link:"#_1-4双亲委派模型【理解】",children:[]},{level:3,title:"1.5ClassLoader 中的两个方法【应用】",slug:"_1-5classloader-中的两个方法【应用】",link:"#_1-5classloader-中的两个方法【应用】",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",pathLocale:"/",extraFields:'---\ntitle: 类加载器\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n类加载器\n\n\x3c!-- more --\x3e\n# 写在前面的话：\n\n> 基础加强包含了：\n>\n> 反射，动态代理，类加载器，xml，注解，日志，单元测试等知识点\n>\n> 其中最难的是反射和动态代理，其他知识点都非常简单\n>\n> 由于B站P数限制，xml，注解等知识点，阿玮写了详细文档供大家学习\n\n## 1.类加载器\n\n### 1.1类加载器\n\n+ 作用\n\n  负责将.class文件（存储的物理文件）加载在到内存中\n\n  ![01_类加载器](.\\img\\01_类加载器.png)\n\n### 1.2类加载的完整过程\n\n+ 类加载时机\n\n  简单理解：字节码文件什么时候会被加载到内存中？\n\n  有以下的几种情况：\n\n  + 创建类的实例（对象）\n  + 调用类的类方法\n  + 访问类或者接口的类变量，或者为该类变量赋值\n  + 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n  + 初始化某个类的子类\n  + 直接使用java.exe命令来运行某个主类\n\n  总结而言：用到了就加载，不用不加载\n\n+ 类加载过程\n\n  1. 加载\n\n     + 通过包名 + 类名，获取这个类，准备用流进行传输\n     + 在这个类加载到内存中\n     + 加载完毕创建一个class对象\n\n     ![02_类加载过程加载](.\\img\\02_类加载过程加载.png)\n\n  2. 链接\n\n     + 验证\n\n       确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n\n       (文件中的信息是否符合虚拟机规范有没有安全隐患)\n\n     ![03_类加载过程验证](.\\img\\03_类加载过程验证.png)\n\n     + 准备\n\n       负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值\n\n       (初始化静态变量)\n\n     ![04_类加载过程准备](.\\img\\04_类加载过程准备.png)\n\n     + 解析\n\n       将类的二进制数据流中的符号引用替换为直接引用\n\n       (本类中如果用到了其他类，此时就需要找到对应的类)\n\n     ![05_类加载过程解析](.\\img\\05_类加载过程解析.png)\n\n  3. 初始化\n\n     根据程序员通过程序制定的主观计划去初始化类变量和其他资源\n\n     (静态变量赋值以及初始化其他资源)\n\n     ![06_类加载过程初始化](.\\img\\06_类加载过程初始化.png)\n\n+ 小结\n\n  + 当一个类被使用的时候，才会加载到内存\n  + 类加载的过程: 加载、验证、准备、解析、初始化\n\n### 1.3类加载的分类【理解】\n\n+ 分类\n  + Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null\n  + Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块\n  + System class loader：系统类加载器,负责加载用户类路径上所指定的类库\n\n+ 类加载器的继承关系\n\n  + System的父加载器为Platform\n  + Platform的父加载器为Bootstrap\n\n+ 代码演示\n\n  ```java\n  public class ClassLoaderDemo1 {\n      public static void main(String[] args) {\n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n\n          //获取系统类加载器的父加载器 --- 平台类加载器\n          ClassLoader classLoader1 = systemClassLoader.getParent();\n\n          //获取平台类加载器的父加载器 --- 启动类加载器\n          ClassLoader classLoader2 = classLoader1.getParent();\n\n          System.out.println("系统类加载器" + systemClassLoader);\n          System.out.println("平台类加载器" + classLoader1);\n          System.out.println("启动类加载器" + classLoader2);\n\n      }\n  }\n  ```\n\n### 1.4双亲委派模型【理解】\n\n+ 介绍\n\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\n\n  ![07_双亲委派模型](.\\img\\07_双亲委派模型.png)\n\n\n### 1.5ClassLoader 中的两个方法【应用】\n\n- 方法介绍\n\n  | 方法名                                      | 说明        |\n  | ---------------------------------------- | --------- |\n  | public static ClassLoader getSystemClassLoader() | 获取系统类加载器  |\n  | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\n\n- 示例代码\n\n  ```java\n  public class ClassLoaderDemo2 {\n      public static void main(String[] args) throws IOException {\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\n\n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n\n          //利用加载器去加载一个指定的文件\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\n          //返回值：字节流。\n          InputStream is = systemClassLoader.getResourceAsStream("prop.properties");\n\n          Properties prop = new Properties();\n          prop.load(is);\n\n          System.out.println(prop);\n\n          is.close();\n      }\n  }\n  ```\n'},{title:"xml",headers:[{level:2,title:"1.xml",slug:"_1-xml",link:"#_1-xml",children:[{level:3,title:"1.1概述【理解】",slug:"_1-1概述【理解】",link:"#_1-1概述【理解】",children:[]},{level:3,title:"1.2标签的规则【应用】",slug:"_1-2标签的规则【应用】",link:"#_1-2标签的规则【应用】",children:[]},{level:3,title:"1.3语法规则【应用】",slug:"_1-3语法规则【应用】",link:"#_1-3语法规则【应用】",children:[]},{level:3,title:"1.4xml解析【应用】",slug:"_1-4xml解析【应用】",link:"#_1-4xml解析【应用】",children:[]},{level:3,title:"1.5DTD约束【理解】",slug:"_1-5dtd约束【理解】",link:"#_1-5dtd约束【理解】",children:[]},{level:3,title:"1.6schema约束【理解】",slug:"_1-6schema约束【理解】",link:"#_1-6schema约束【理解】",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html",pathLocale:"/",extraFields:'---\ntitle: xml\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\nxml\n\n\x3c!-- more --\x3e\n## 1.xml\n\n### 1.1概述【理解】\n\n+ 万维网联盟(W3C)\n\n  万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。\n  建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。\n  是Web技术领域最具权威和影响力的国际中立性技术标准机构。\n  到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，\n\n  + 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、\n\n  + 可扩展标记语言XML（标准通用标记语言下的一个子集）\n\n  + 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等\n\n    ![01_w3c概述](.\\img\\01_w3c概述.png)\n\n+ xml概述\n\n  XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言\n  标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)\n  可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的\n\n+ 作用\n\n  + 用于进行存储数据和传输数据\n  + 作为软件的配置文件\n\n+ 作为配置文件的优势\n\n  + 可读性好\n  + 可维护性高\n\n### 1.2标签的规则【应用】\n\n+ 标签由一对尖括号和合法标识符组成\n\n  ```java\n  <student>\n  ```\n\n+ 标签必须成对出现\n\n  ```java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签\n  ```\n\n+ 特殊的标签可以不成对,但是必须有结束标记\n\n  ```java\n  <address/>\n  ```\n\n+ 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来\n\n  ```java\n  <student id="1"> </student>\n  ```\n\n+ 标签需要正确的嵌套\n\n  ```java\n  这是正确的: <student id="1"> <name>张三</name> </student>\n  这是错误的: <student id="1"><name>张三</student></name>\n  ```\n\n### 1.3语法规则【应用】\n\n+ 语法规则\n\n  + XML文件的后缀名为：xml\n\n  + 文档声明必须是第一行第一列\n\n   ` <?xml version=“1.0” encoding=“UTF-8” standalone=“yes”?>`\n    version：该属性是必须存在的\n    encoding：该属性不是必须的\n\n    ​\t打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)\n\n    standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no\n\n  + 必须存在一个根标签，有且只能有一个\n\n  + XML文件中可以定义注释信息\n\n  + XML文件中可以存在以下特殊字符\n\n    ```java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; \' 单引号\n    &quot; " 引号\n    ```\n\n  + XML文件中可以存在CDATA区\n\n    `<![CDATA[ …内容… ]]>`\n\n+ 示例代码\n\n  ```xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n  ```\n\n### 1.4xml解析【应用】\n\n+ 概述\n\n  xml解析就是从xml中获取到数据\n\n+ 常见的解析思想\n\n  DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。\n  会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值\n\n  ![02_dom解析概述](.\\img\\02_dom解析概述.png)\n\n+ 常见的解析工具\n\n  + JAXP: SUN公司提供的一套XML的解析的API\n  + JDOM: 开源组织提供了一套XML的解析的API-jdom\n  + DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java\n  + pull: 主要应用在Android手机端解析XML\n\n+ 解析的准备工作\n\n  1. 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j\n\n     今天的资料中已经提供,我们不用再单独下载了,直接使用即可\n\n  2. 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar\n\n  3. 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中\n\n  4. 选中jar包 -> 右键 -> 选择add as library即可\n\n+ 需求\n\n  + 解析提供好的xml文件\n  + 将解析到的数据封装到学生对象中\n  + 并将学生对象存储到ArrayList集合中\n  + 遍历集合\n\n+ 代码实现\n\n  ```java\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n\n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "id=\'" + id + \'\\\'\' +\n                  ", name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n\n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File("myxml\\\\xml\\\\student.xml"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements("student");\n          //System.out.println(list.size());\n\n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n\n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute("id");\n              //获取id的属性值\n              String id = attribute.getValue();\n\n              //获取name标签\n              //element("标签名"):获取调用者指定的子标签\n              Element nameElement = element.element("name");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n\n              //获取age标签\n              Element ageElement = element.element("age");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n\n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n\n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }\n  ```\n\n### 1.5DTD约束【理解】\n\n+ 什么是约束\n\n  用来限定xml文件中可使用的标签以及属性\n\n+ 约束的分类\n\n  + DTD\n  + schema\n\n+ 编写DTD约束\n\n  + 步骤\n\n    1. 创建一个文件，这个文件的后缀名为.dtd\n\n    2. 看xml文件中使用了哪些元素\n\n       <!ELEMENT> 可以定义元素\n\n    3. 判断元素是简单元素还是复杂元素\n\n       简单元素：没有子元素。\n       复杂元素：有子元素的元素；\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    ```\n  ```\n\n  ```\n\n+ 引入DTD约束\n\n  + 引入DTD约束的三种方法\n\n    + 引入本地dtd\n\n      <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径\'>\n\n    + 在xml文件内部引入\n\n      <!DOCTYPE 根元素名称 [ dtd文件内容 ]>\n\n    + 引入网络dtd\n\n      <!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL">\n\n  + 代码实现\n\n    + 引入本地DTD约束\n\n      ```xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 在xml文件内部引入\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n    + 引入网络dtd\n\n      ```xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL">\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>\n      ```\n\n+ DTD语法\n\n  + 定义元素\n\n    定义一个元素的格式为：<!ELEMENT 元素名 元素类型>\n    简单元素：\n\n    ​\tEMPTY: 表示标签体为空\n\n    ​\tANY: 表示标签体可以为空也可以不为空\n\n    ​\tPCDATA: 表示该元素的内容部分为字符串\n\n    复杂元素：\n    ​\t直接写子元素名称. 多个子元素可以使用","或者"|"隔开；\n    ​\t","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个\n    ​\t"?"零次或一次, "+"一次或多次, "*"零次或多次;如果不写则表示出现一次\n\n    ![03_DTD语法定义元素](.\\img\\03_DTD语法定义元素.png)\n\n\n  + 定义属性\n\n    格式\n\n    定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>\n    属性的类型：\n    ​\tCDATA类型：普通的字符串\n\n    属性的约束:\n\n    ​\t// #REQUIRED： 必须的\n    ​\t// #IMPLIED： 属性不是必需的\n    ​\t// #FIXED value：属性值是固定的\n\n  + 代码实现\n\n    ```java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n    <persons>\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n        <person id = "002">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![04_schema约束介绍](.\\img\\04_schema约束介绍.png)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： `<schema>`\n    4，在`<schema>`中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在`<schema>`中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在`<schema>`中定义属性 ：\n    ​\t`elementFormDefault="qualified“`，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![05_schema约束编写](.\\img\\05_schema约束编写.png)\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                        </complexType>\n                    </element>\n                </sequence>\n            </complexType>\n\n        </element>\n\n    </schema>\n\n    ```\n\n+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = "名称空间url 文件路径“\n\n  + 代码实现\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person>\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n\n+ schema约束定义属性\n\n  + 代码示例\n\n    ```java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                            \x3c!--定义属性，required( 必须的)/optional( 可选的)--\x3e\n                            <attribute name="id" type="string" use="required"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​```\n    ```\n'},{title:"单元测试Junit",headers:[{level:2,title:"1.1 什么是单元测试？（掌握）",slug:"_1-1-什么是单元测试-掌握",link:"#_1-1-什么是单元测试-掌握",children:[]},{level:2,title:"1.2 Junit的特点？（掌握）",slug:"_1-2-junit的特点-掌握",link:"#_1-2-junit的特点-掌握",children:[]},{level:2,title:"1.3 基本用法：（掌握）",slug:"_1-3-基本用法-掌握",link:"#_1-3-基本用法-掌握",children:[{level:3,title:"手动导包（掌握）",slug:"手动导包-掌握",link:"#手动导包-掌握",children:[]},{level:3,title:"运行测试代码（掌握）",slug:"运行测试代码-掌握",link:"#运行测试代码-掌握",children:[]},{level:3,title:"Junit正确的打开方式（正确的使用方式）（掌握）",slug:"junit正确的打开方式-正确的使用方式-掌握",link:"#junit正确的打开方式-正确的使用方式-掌握",children:[]},{level:3,title:"正确的使用方式：（掌握）",slug:"正确的使用方式-掌握",link:"#正确的使用方式-掌握",children:[]},{level:3,title:"实际开发中单元测试的使用方式（掌握）",slug:"实际开发中单元测试的使用方式-掌握",link:"#实际开发中单元测试的使用方式-掌握",children:[]},{level:3,title:"扩展点：",slug:"扩展点",link:"#扩展点",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",pathLocale:"/",extraFields:'---\ntitle: 单元测试Junit\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n单元测试Junit\n\n\x3c!-- more --\x3e\n# 1. 单元测试Junit\n\n## 1.1 什么是单元测试？（掌握）\n\n对部分代码进行测试。\n\n## 1.2 Junit的特点？（掌握）\n\n* 是一个第三方的工具。（把别人写的代码导入项目中）（专业叫法：导jar包）\n\n* 如果运行结果显示绿色，表示运行结果是正确的。\n\n  如果运行结果显示红色，表示运行结果是错误的。\n\n## 1.3 基本用法：（掌握）\n\n1，一定要先写一个方法。\n\n2，在这个方法的上面写@Test\n\n3，鼠标点一下@Test  按alt + 回车，点击Junit4\n\n​\t此时就可以自动导包。\n\n​\t如果自动导包失败（连接外网，或者自己手动导包）\n\n​\t如果导包成功在左下角就会出现Junit4的相关jar包\n\n### 手动导包（掌握）\n\n1，在当前模块下，右键新建一个文件夹（lib）\n\n2，把今天资料里面的两个jar包，拷贝到lib文件夹里面\n\n3，选中两个jar右键点击add as a lib....\n\n4，到代码中，找到@Test，按alt + 回车，再来导入。\n\n### 运行测试代码（掌握）\n\n* 只能直接运行无参无返回值的非静态方法\n* 想要运行谁，就右键点击哪个方法。如果想要运行一个类里面所有的测试方法，选择类名，有点点击即可。\n\n### Junit正确的打开方式（正确的使用方式）（掌握）\n\n注意点：并不是直接在要测试的方法上面直接加@Test\n\n原因：因为要测试的方法有可能是有参数的，有返回值，或者是静态的。\n\n### 正确的使用方式：（掌握）\n\n1，新建测试类\n\n2，新建测试方法（要测试的方法名 + Test） methodTest\n\n3，在这个方法中直接调用要测试的方法\n\n4，在测试方法的上面写@Test\n\n代码示例：\n\n```java\n//真正用来测试的类\n//测试用例（测试类）\npublic class JunitTest {\n\n    //在这个类里面再写无参无返回值的非静态方法\n    //在方法中调用想要测试的方法\n\n    @Test\n    public void method2Test(){\n        //调用要测试的方法\n        JunitDemo1 jd = new JunitDemo1();\n        jd.method2(10);\n    }\n}\n```\n\n### 实际开发中单元测试的使用方式（掌握）\n\n需求：测试File中的delete方法，写的是否正确（掌握）\n\n开发中的测试原则：\n\n不污染原数据。\n\n代码示例：\n\n```java\npublic class JunitDemo3 {\n    //在实际开发中，真正完整的单元测试该怎么写？\n    //前提：\n    //以后在工作的时候，测试代码不能污染原数据。（修改，篡改）\n    //1.利用Before去对数据做一个初始化的动作\n    //2.利用Test真正的去测试方法\n    //3.利用After去还原数据\n    \n    //需求：测试File类中的delete方法是否书写正确？？？\n    @Before\n    public void beforemethod() throws IOException {\n        //先备份\n        File src = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n        File dest = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n    }\n\n    //作为一个标准的测试人员，运行完单元测试之后，不能污染原数据\n    //需要达到下面两个要求：\n    //1.得到结果\n    //2.a.txt还在而且其他的备份文件消失\n    @Test\n    public void method(){\n        File file = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n        boolean delete = file.delete();\n\n        //检查a.txt是否存在\n        boolean exists = file.exists();\n\n        //只有同时满足了下面所有的断言，才表示delete方法编写正确\n        Assert.assertEquals("delete方法出错了",delete,true);\n        Assert.assertEquals("delete方法出错了",exists,false);\n    }\n\n\n    @After\n    public void aftermethod() throws IOException {\n        //还要对a.txt做一个还原\n        File src = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt");\n        File dest = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n\n        //备份数据要删除\n        src.delete();\n\n    }\n}\n```\n\n作业：\n\n​\t测试Properties类中的store方法是否书写正确？\n\n开发心得：\n\n1.Before  准备数据\n\n2.Test  测试方法\n\n3.After 还原\n\n\n\nBefore\n\n```java\n准备数据\n1.创建Properties的对象\n2.put数据到集合当中\n//只不过在下面的方法中，我们也需要用到Properties的对象，所以写完之后要挪到成员位置\n```\n\nTest\n\n```java\n调用store方法，保存数据到本地文件\n\n断言1：\n\t判断当前文件是否存在\n断言2：\n\t文件的大小一定是大于0\n断言3：\n\t再次读取文件中的数据，判断是否跟集合中一致\n\n结论：\n\t如果所有的断言都通过了，表示store方法是正确的\n```\n\nAfter\n\n```java\n把本地文件给删除\n```\n\n### 扩展点：\n\n在单元测试中，相对路径是相对当前模块而言的。\n\n代码示例：\n\n```java\nFile file = new File("aweihaoshuai.txt");\nfile.createNewFile();\n//此时是把aweihaoshuai.txt这个文件新建到模块中了。\n```\n\n\n\n'},{title:"注解",headers:[{level:2,title:"1.1 注释和注解的区别？（掌握）",slug:"_1-1-注释和注解的区别-掌握",link:"#_1-1-注释和注解的区别-掌握",children:[]},{level:2,title:"1.3 Java中已经存在的注解（掌握）",slug:"_1-3-java中已经存在的注解-掌握",link:"#_1-3-java中已经存在的注解-掌握",children:[]},{level:2,title:"1.4 自定义注解（了解）",slug:"_1-4-自定义注解-了解",link:"#_1-4-自定义注解-了解",children:[]},{level:2,title:"1.5 特殊属性（掌握）",slug:"_1-5-特殊属性-掌握",link:"#_1-5-特殊属性-掌握",children:[]},{level:2,title:"1.6 元注解（了解）",slug:"_1-6-元注解-了解",link:"#_1-6-元注解-了解",children:[]},{level:2,title:"1.7 模拟JUnit自带的@Test注解（了解）",slug:"_1-7-模拟junit自带的-test注解-了解",link:"#_1-7-模拟junit自带的-test注解-了解",children:[]},{level:2,title:"1.8 注解小结：",slug:"_1-8-注解小结",link:"#_1-8-注解小结",children:[]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html",pathLocale:"/",extraFields:'---\ntitle: 注解\nicon: pen-to-square\n# cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png\ndate: 2023-02-24\nlastUpdated: true\norder: 1\nauthor: \n    - name: xuyong\n    - name: 黑马程序员\ncategory:\n  - java\ntag:\n  - java-basic\n---\n\n注解\n\n\x3c!-- more --\x3e\n# 1. 注解 \n\n## 1.1 注释和注解的区别？（掌握）\n\n共同点：都可以对程序进行解释说明。\n\n不同点：注释，是给程序员看的。只在Java中有效。在class文件中不存在注释的。\n\n​\t\t当编译之后，会进行注释擦除。\n\n​\t\t注解，是给虚拟机看的。当虚拟机看到注解之后，就知道要做什么事情了。\n\n##1.2 如何使用注解（掌握）\n\n在以前看过注解@Override。\n\n当子类重写父类方法的时候，在重写的方法上面写@Override。\n\n当虚拟机看到@Override的时候，就知道下面的方法是重写的父类的。检查语法，如果语法正确编译正常，如果语法错误，就会报错。\n\n## 1.3 Java中已经存在的注解（掌握）\n\n@Override：表示方法的重写\n\n@Deprecated：表示修饰的方法已过时\n\n@SuppressWarnings("all")：压制警告\n\n\n\n除此之外，还需要掌握第三方框架中提供的注解：\n\n比如：Junit\n\n@Test 表示运行测试方法\n\n@Before 表示在Test之前运行，进行数据的初始化\n\n@After 表示在Test之后运行，进行数据的还原\n\n\n\n## 1.4 自定义注解（了解）\n\n自定义注解单独存在是没有什么意义的，一般会跟反射结合起来使用，会用发射去解析注解。\n\n针对于注解，只要掌握会使用别人已经写好的注解即可。\n\n关于注解的解析，一般是在框架的底层已经写好了。\n\n## 1.5 特殊属性（掌握）\n\nvalue：\n\n​\t当注解中只有"一个属性",并且属性名是"value",使用注解时,可以省略value属性名\n\n代码示例：\n\n```java\n//注解的定义\npublic @interface Anno2 {\n    public String value();\n\n    public int age() default 23;\n}\n\n//注解的使用\n@Anno2("123")\npublic class AnnoDemo2 {\n\n    @Anno2("123")\n    public void method(){\n\n    }\n}\n```\n\n## 1.6 元注解（了解）\n\n可以写在注解上面的注解\n\n@Target ：指定注解能在哪里使用\n\n@Retention ：可以理解为保留时间(生命周期) \n\n#### Target:\n\n​    作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。\n\n​    可使用的值定义在ElementType枚举类中，常用值如下\n\n* TYPE，类，接口\n* FIELD, 成员变量\n* METHOD, 成员方法\n* PARAMETER, 方法参数\n* CONSTRUCTOR, 构造方法\n* LOCAL_VARIABLE, 局部变量\n\n#### Retention：\n\n​    作用：用来标识注解的生命周期(有效范围)\n\n​    可使用的值定义在RetentionPolicy枚举类中，常用值如下\n\n* SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在\n* CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值\n* RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段\n\n注解的解析：\n\n## 1.7 模拟JUnit自带的@Test注解（了解）\n\n代码示例：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyTest {\n}\n\npublic class MyTestMethod {\n\n    @MyTest\n    public void method1(){\n        System.out.println("method1");\n    }\n\n    public void method2(){\n        System.out.println("method2");\n    }\n\n    @MyTest\n    public void method3(){\n        System.out.println("method3");\n    }\n}\n\npublic class MyTestDemo {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        //1,获取class对象\n        Class clazz = Class.forName("com.itheima.test2.MyTestMethod");\n\n        //获取对象\n        Object o = clazz.newInstance();\n\n        //2.获取所有方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            //method依次表示类里面的每一个方法\n            method.setAccessible(true);\n            //判断当前方法有没有MyTest注解\n            if(method.isAnnotationPresent(MyTest.class)){\n                method.invoke(o);\n            }\n        }\n    }\n}\n```\n\n## 1.8 注解小结：\n\n掌握如何使用已经存在的注解即可。\n\n@Override：表示方法的重写\n\n@Deprecated：表示修饰的方法已过时\n\n@SuppressWarnings("all")：压制警告\n\n@Test：表示要运行的方法\n\n在以后的实际开发中，注解是使用框架已经提供好的注解。\n\n自定义注解+解析注解（很难的，**了解**），一般会出现在框架的底层。当以后我们要自己写一个框架的时候，才会用到自定义注解+解析注解。\n'},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:"404 Not Found"},{title:"Posts",headers:[],path:"/posts/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Linux",headers:[],path:"/posts/linux/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Idea",headers:[],path:"/posts/idea/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Mysql",headers:[],path:"/posts/mysql/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Network",headers:[],path:"/posts/network/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Redis",headers:[],path:"/posts/redis/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Shell",headers:[],path:"/posts/shell/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Windows",headers:[],path:"/posts/windows/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Basic",headers:[],path:"/posts/java/basic/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Java",headers:[],path:"/posts/java/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Bug",headers:[],path:"/posts/java/bug/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Dependence",headers:[],path:"/posts/java/dependence/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Netty",headers:[],path:"/posts/java/netty/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Spring",headers:[],path:"/posts/java/spring/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Springboot",headers:[],path:"/posts/java/springboot/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Web",headers:[],path:"/posts/java/web/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Django",headers:[],path:"/posts/python/django/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Python",headers:[],path:"/posts/python/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"01 Java入门",headers:[],path:"/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"02 Java基础概念",headers:[],path:"/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"03 Java运算符",headers:[],path:"/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"04 判断和循环",headers:[],path:"/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"05 循环高级和数组",headers:[],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"06 方法",headers:[],path:"/posts/java/basic/06-%E6%96%B9%E6%B3%95/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"07 综合练习",headers:[],path:"/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"08 面向对象",headers:[],path:"/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"09 面向对象综合训练",headers:[],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"10 字符串",headers:[],path:"/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"11 集合 学生管理系统",headers:[],path:"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"13 面向对象进阶（static 继承）",headers:[],path:"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"14 面向对象进阶（多态 包 Final 权限修饰符 代码块）",headers:[],path:"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"15 面向对象进阶（抽象类 接口 内部类）",headers:[],path:"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"16 面向对象综合练习（上）",headers:[],path:"/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"17 面向对象综合练习（下）",headers:[],path:"/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"18 API（常见 API，对象克隆）",headers:[],path:"/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"19 API（正则表达式）",headers:[],path:"/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"20 API（时间，包装类，练习）",headers:[],path:"/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"21 API（算法，lambda，练习）",headers:[],path:"/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"22 集合（ List集合）",headers:[],path:"/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"23 集合（泛型 Set 数据结构）",headers:[],path:"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"24 集合（ Map 可变参数 集合工具类）",headers:[],path:"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"25 阶段项目（综合练习 Doudizhu游戏）",headers:[],path:"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"26 集合（ Stream流 方法引用）",headers:[],path:"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"27 IO(异常 File 综合案例）",headers:[],path:"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"28 IO（字节流 字符流）",headers:[],path:"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"29 IO（其他流）",headers:[],path:"/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"30 多线程",headers:[],path:"/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"31 多线程 Juc",headers:[],path:"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"32 网络编程",headers:[],path:"/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"33 基础加强（反射，动态代理）",headers:[],path:"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"Pages",headers:[],path:"/pages/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"01 Log日志",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"34 基础加强（日志，类加载器，单元测试，xml，注解）",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"02 类加载器",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"03 Xml",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"04 单元测试",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"05 注解",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/",pathLocale:"/",extraFields:"<Catalog/>\n"},{title:"分类",headers:[],path:"/category/",pathLocale:"/",extraFields:""},{title:"使用指南 分类",headers:[],path:"/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",pathLocale:"/",extraFields:""},{title:"linux 分类",headers:[],path:"/category/linux/",pathLocale:"/",extraFields:""},{title:"idea 分类",headers:[],path:"/category/idea/",pathLocale:"/",extraFields:""},{title:"mysql 分类",headers:[],path:"/category/mysql/",pathLocale:"/",extraFields:""},{title:"java 分类",headers:[],path:"/category/java/",pathLocale:"/",extraFields:""},{title:"network 分类",headers:[],path:"/category/network/",pathLocale:"/",extraFields:""},{title:"redis 分类",headers:[],path:"/category/redis/",pathLocale:"/",extraFields:""},{title:"windows 分类",headers:[],path:"/category/windows/",pathLocale:"/",extraFields:""},{title:"dependence 分类",headers:[],path:"/category/dependence/",pathLocale:"/",extraFields:""},{title:"spring 分类",headers:[],path:"/category/spring/",pathLocale:"/",extraFields:""},{title:"python 分类",headers:[],path:"/category/python/",pathLocale:"/",extraFields:""},{title:"Java 分类",headers:[],path:"/category/java/",pathLocale:"/",extraFields:""},{title:"框架 分类",headers:[],path:"/category/%E6%A1%86%E6%9E%B6/",pathLocale:"/",extraFields:""},{title:"Spring 分类",headers:[],path:"/category/spring/",pathLocale:"/",extraFields:""},{title:"Spring综合 分类",headers:[],path:"/category/spring%E7%BB%BC%E5%90%88/",pathLocale:"/",extraFields:""},{title:"Spring核心 分类",headers:[],path:"/category/spring%E6%A0%B8%E5%BF%83/",pathLocale:"/",extraFields:""},{title:"Spring数据 分类",headers:[],path:"/category/spring%E6%95%B0%E6%8D%AE/",pathLocale:"/",extraFields:""},{title:"SpringWeb 分类",headers:[],path:"/category/springweb/",pathLocale:"/",extraFields:""},{title:"SpringIO 分类",headers:[],path:"/category/springio/",pathLocale:"/",extraFields:""},{title:"Spring集成 分类",headers:[],path:"/category/spring%E9%9B%86%E6%88%90/",pathLocale:"/",extraFields:""},{title:"Spring安全 分类",headers:[],path:"/category/spring%E5%AE%89%E5%85%A8/",pathLocale:"/",extraFields:""},{title:"Spring其他 分类",headers:[],path:"/category/spring%E5%85%B6%E4%BB%96/",pathLocale:"/",extraFields:""},{title:"标签",headers:[],path:"/tag/",pathLocale:"/",extraFields:""},{title:"标签: 页面配置",headers:[],path:"/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",pathLocale:"/",extraFields:""},{title:"标签: 使用指南",headers:[],path:"/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",pathLocale:"/",extraFields:""},{title:"标签: linux",headers:[],path:"/tag/linux/",pathLocale:"/",extraFields:""},{title:"标签: tomcat",headers:[],path:"/tag/tomcat/",pathLocale:"/",extraFields:""},{title:"标签: shell",headers:[],path:"/tag/shell/",pathLocale:"/",extraFields:""},{title:"标签: sql",headers:[],path:"/tag/sql/",pathLocale:"/",extraFields:""},{title:"标签: bug",headers:[],path:"/tag/bug/",pathLocale:"/",extraFields:""},{title:"标签: internet",headers:[],path:"/tag/internet/",pathLocale:"/",extraFields:""},{title:"标签: java",headers:[],path:"/tag/java/",pathLocale:"/",extraFields:""},{title:"标签: spring",headers:[],path:"/tag/spring/",pathLocale:"/",extraFields:""},{title:"标签: springboot",headers:[],path:"/tag/springboot/",pathLocale:"/",extraFields:""},{title:"标签: redis",headers:[],path:"/tag/redis/",pathLocale:"/",extraFields:""},{title:"标签: script",headers:[],path:"/tag/script/",pathLocale:"/",extraFields:""},{title:"标签: java-basic",headers:[],path:"/tag/java-basic/",pathLocale:"/",extraFields:""},{title:"标签: logback",headers:[],path:"/tag/logback/",pathLocale:"/",extraFields:""},{title:"标签: maven",headers:[],path:"/tag/maven/",pathLocale:"/",extraFields:""},{title:"标签: mybatis",headers:[],path:"/tag/mybatis/",pathLocale:"/",extraFields:""},{title:"标签: netty",headers:[],path:"/tag/netty/",pathLocale:"/",extraFields:""},{title:"标签: nio",headers:[],path:"/tag/nio/",pathLocale:"/",extraFields:""},{title:"标签: javaweb",headers:[],path:"/tag/javaweb/",pathLocale:"/",extraFields:""},{title:"标签: http",headers:[],path:"/tag/http/",pathLocale:"/",extraFields:""},{title:"标签: servlet",headers:[],path:"/tag/servlet/",pathLocale:"/",extraFields:""},{title:"标签: Request",headers:[],path:"/tag/request/",pathLocale:"/",extraFields:""},{title:"标签: Response",headers:[],path:"/tag/response/",pathLocale:"/",extraFields:""},{title:"标签: jdbc",headers:[],path:"/tag/jdbc/",pathLocale:"/",extraFields:""},{title:"标签: djgango",headers:[],path:"/tag/djgango/",pathLocale:"/",extraFields:""},{title:"标签: Java",headers:[],path:"/tag/java/",pathLocale:"/",extraFields:""},{title:"标签: 框架",headers:[],path:"/tag/%E6%A1%86%E6%9E%B6/",pathLocale:"/",extraFields:""},{title:"标签: Spring",headers:[],path:"/tag/spring/",pathLocale:"/",extraFields:""},{title:"标签: SpringBoot",headers:[],path:"/tag/springboot/",pathLocale:"/",extraFields:""},{title:"标签: 面试",headers:[],path:"/tag/%E9%9D%A2%E8%AF%95/",pathLocale:"/",extraFields:""},{title:"标签: Bean",headers:[],path:"/tag/bean/",pathLocale:"/",extraFields:""},{title:"标签: BeanDefinition",headers:[],path:"/tag/beandefinition/",pathLocale:"/",extraFields:""},{title:"标签: IOC",headers:[],path:"/tag/ioc/",pathLocale:"/",extraFields:""},{title:"标签: 依赖查找",headers:[],path:"/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",pathLocale:"/",extraFields:""},{title:"标签: 依赖注入",headers:[],path:"/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",pathLocale:"/",extraFields:""},{title:"标签: AOP",headers:[],path:"/tag/aop/",pathLocale:"/",extraFields:""},{title:"标签: Resource",headers:[],path:"/tag/resource/",pathLocale:"/",extraFields:""},{title:"标签: 数据绑定",headers:[],path:"/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",pathLocale:"/",extraFields:""},{title:"标签: 数据库",headers:[],path:"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",pathLocale:"/",extraFields:""},{title:"标签: DataSource",headers:[],path:"/tag/datasource/",pathLocale:"/",extraFields:""},{title:"标签: JDBC",headers:[],path:"/tag/jdbc/",pathLocale:"/",extraFields:""},{title:"标签: JdbcTemplate",headers:[],path:"/tag/jdbctemplate/",pathLocale:"/",extraFields:""},{title:"标签: 事务",headers:[],path:"/tag/%E4%BA%8B%E5%8A%A1/",pathLocale:"/",extraFields:""},{title:"标签: JPA",headers:[],path:"/tag/jpa/",pathLocale:"/",extraFields:""},{title:"标签: MyBatis",headers:[],path:"/tag/mybatis/",pathLocale:"/",extraFields:""},{title:"标签: PageHelper",headers:[],path:"/tag/pagehelper/",pathLocale:"/",extraFields:""},{title:"标签: Mapper",headers:[],path:"/tag/mapper/",pathLocale:"/",extraFields:""},{title:"标签: Redis",headers:[],path:"/tag/redis/",pathLocale:"/",extraFields:""},{title:"标签: MongoDB",headers:[],path:"/tag/mongodb/",pathLocale:"/",extraFields:""},{title:"标签: Elasticsearch",headers:[],path:"/tag/elasticsearch/",pathLocale:"/",extraFields:""},{title:"标签: Web",headers:[],path:"/tag/web/",pathLocale:"/",extraFields:""},{title:"标签: Controller",headers:[],path:"/tag/controller/",pathLocale:"/",extraFields:""},{title:"标签: DispatcherServlet",headers:[],path:"/tag/dispatcherservlet/",pathLocale:"/",extraFields:""},{title:"标签: Filter",headers:[],path:"/tag/filter/",pathLocale:"/",extraFields:""},{title:"标签: CORS",headers:[],path:"/tag/cors/",pathLocale:"/",extraFields:""},{title:"标签: View",headers:[],path:"/tag/view/",pathLocale:"/",extraFields:""},{title:"标签: 异步",headers:[],path:"/tag/%E5%BC%82%E6%AD%A5/",pathLocale:"/",extraFields:""},{title:"标签: JSON",headers:[],path:"/tag/json/",pathLocale:"/",extraFields:""},{title:"标签: 邮件",headers:[],path:"/tag/%E9%82%AE%E4%BB%B6/",pathLocale:"/",extraFields:""},{title:"标签: IO",headers:[],path:"/tag/io/",pathLocale:"/",extraFields:""},{title:"标签: 集成",headers:[],path:"/tag/%E9%9B%86%E6%88%90/",pathLocale:"/",extraFields:""},{title:"标签: 缓存",headers:[],path:"/tag/%E7%BC%93%E5%AD%98/",pathLocale:"/",extraFields:""},{title:"标签: 调度器",headers:[],path:"/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",pathLocale:"/",extraFields:""},{title:"标签: Dubbo",headers:[],path:"/tag/dubbo/",pathLocale:"/",extraFields:""},{title:"标签: 安全",headers:[],path:"/tag/%E5%AE%89%E5%85%A8/",pathLocale:"/",extraFields:""},{title:"文章",headers:[],path:"/article/",pathLocale:"/",extraFields:""},{title:"星标",headers:[],path:"/star/",pathLocale:"/",extraFields:""},{title:"时间轴",headers:[],path:"/timeline/",pathLocale:"/",extraFields:""}]},58761:(n,e,t)=>{t.d(e,{U:()=>i});const i=JSON.parse('{"base":"/blog/","lang":"zh-CN","title":"coder-xuyong","description":"以 vuepress-theme-hope 为模板的博客","head":[["script",{},"\\n      // console.log(666)\\n      "],["link",{"rel":"icon","href":"logo.png"}]],"locales":{}}')},26653:(n,e,t)=>{t.d(e,{K:()=>i});const i=JSON.parse('{"encrypt":{"config":{"/demo/encrypt.html":["$2a$10$EfOuAugClYm45dJQ2yHICeUchPxtX.L1isFvUsa77HeklhHJw3dSy"]}},"author":{"name":"xuyong","url":"https://github.com/coder-xuyong"},"logo":"/logo.svg","repo":"coder-xuyong/blog","docsDir":"src","focus":false,"pure":false,"print":false,"footer":"我虽无意逐鹿 却知苍生苦楚","displayFooter":true,"navbarLayout":{"start":["Brand"],"end":["Links","Repo","Outlook","Search"]},"blog":{"description":"重生之我在提瓦特大陆当牛做马","intro":"/intro.html","medias":{"Baidu":"https://www.baidu.com","BiliBili":"https://www.bilibili.com","GitHub":"https://github.com","Overflow":{"icon":"https://stackoverflow.co/favicon.ico","link":"https://stackoverflow.co"},"Tongyi":{"icon":"https://img.alicdn.com/imgextra/i1/O1CN01asLYeX1WhbsyEZn5u_!!6000000002820-55-tps-56-56.svg","link":"https://tongyi.aliyun.com"},"Vuepress":{"icon":"https://theme-hope-assets.vuejs.press/logo.svg","link":"https://vuepress.vuejs.org/zh/"},"Yuanshen":{"icon":"https://ys.mihoyo.com/main/favicon.ico","link":"https://ys.mihoyo.com/main/"},"fontawesome":{"icon":"https://fontawesome.com/favicon.ico","link":"https://fontawesome.com/search?o=r&m=free"},"Doubao":{"icon":"https://img-s.msn.cn/tenant/amp/entityid/BB1qZI2R.img","link":"https://www.doubao.com/"},"ChatGPT":{"icon":"https://cdn.oaistatic.com/assets/favicon-o20kmmos.svg","link":"https://chatgpt.com/"}}},"locales":{"/":{"lang":"zh-CN","navbarLocales":{"langName":"简体中文","selectLangAriaLabel":"选择语言"},"metaLocales":{"author":"作者","date":"写作日期","origin":"原创","views":"访问量","category":"分类","tag":"标签","readingTime":"阅读时间","words":"字数","toc":"此页内容","prev":"上一页","next":"下一页","lastUpdated":"上次编辑于","contributors":"贡献者","editLink":"在 GitHub 上编辑此页","print":"打印"},"blogLocales":{"article":"文章","articleList":"文章列表","category":"分类","tag":"标签","timeline":"时间轴","timelineTitle":"昨日不在","all":"全部","intro":"个人介绍","star":"星标","empty":"$text 为空"},"paginationLocales":{"prev":"上一页","next":"下一页","navigate":"跳转到","action":"前往","errorText":"请输入 1 到 $page 之前的页码！"},"outlookLocales":{"themeColor":"主题色","darkmode":"外观","fullscreen":"全屏"},"encryptLocales":{"iconLabel":"文章已加密","placeholder":"输入密码","remember":"记住密码","errorHint":"请输入正确的密码"},"routeLocales":{"skipToContent":"跳至主要內容","notFoundTitle":"页面不存在","notFoundMsg":["这里什么也没有","我们是怎么来到这儿的？","这 是 四 零 四 !","看起来你访问了一个失效的链接"],"back":"返回上一页","home":"带我回家"},"navbar":["/",{"text":"java 基础","icon":"fa-brands fa-java","link":"/posts/java/basic/"},{"text":"spring","icon":"fa-solid fa-glasses","link":"/posts/java/spring/"},{"text":"框架","icon":"fa-solid fa-book","prefix":"/posts/java/","children":[{"text":"netty","prefix":"netty/","children":["Netty01-nio","Netty02-入门","Netty03-进阶","Netty04-优化与源码"]},{"text":"spring","prefix":"spring/","children":["spring"]},{"text":"spring","icon":"fa-solid fa-glasses","link":"/posts/java/spring/"}]},{"text":"V2 文档","icon":"book","link":"https://theme-hope.vuejs.press/zh/"}],"sidebar":{"/":["","intro",{"text":"文章","icon":"book","prefix":"posts/","children":"structure"}]}}}}')},74923:(n,e,t)=>{},38123:(n,e,t)=>{t.d(e,{v:()=>i});const i={"/posts/":["markdown",{text:"Idea",prefix:"idea/",collapsible:!0,children:["idea"]},{text:"Java",prefix:"java/",collapsible:!0,children:[{text:"Basic",prefix:"basic/",collapsible:!0,children:[{text:"01 Java入门",prefix:"01-Java入门/",collapsible:!0,children:["01-Java基础语法"]},{text:"02 Java基础概念",prefix:"02-Java基础概念/",collapsible:!0,children:["02-Java基础语法"]},{text:"03 Java运算符",prefix:"03-Java运算符/",collapsible:!0,children:["03笔记"]},{text:"04 判断和循环",prefix:"04-判断和循环/",collapsible:!0,children:["day04-流程控制语句"]},{text:"05 循环高级和数组",prefix:"05-循环高级和数组/",collapsible:!0,children:["循环高级","数组"]},{text:"06 方法",prefix:"06-方法/",collapsible:!0,children:["方法"]},{text:"07 综合练习",prefix:"07-综合练习/",collapsible:!0,children:["综合练习"]},{text:"08 面向对象",prefix:"08-面向对象/",collapsible:!0,children:["day08-面向对象"]},{text:"09 面向对象综合训练",prefix:"09-面向对象综合训练/",collapsible:!0,children:["扩展：键盘录入笔记","面向对象综合训练综合练习"]},{text:"10 字符串",prefix:"10-字符串/",collapsible:!0,children:["常用API"]},{text:"11 集合&学生管理系统",prefix:"11-集合_学生管理系统/",collapsible:!0,children:["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html"]},{text:"13 面向对象进阶（static&继承）",prefix:"13-面向对象进阶（static_继承）/",collapsible:!0,children:["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html"]},{text:"14 面向对象进阶（多态&包&final&权限修饰符&代码块）",prefix:"14-面向对象进阶（多态_包_final_权限修饰符_代码块）/",collapsible:!0,children:["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html"]},{text:"15 面向对象进阶（抽象类&接口&内部类）",prefix:"15-面向对象进阶（抽象类_接口_内部类）/",collapsible:!0,children:["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html"]},{text:"16 面向对象综合练习（上）",prefix:"16-面向对象综合练习（上）/",collapsible:!0,children:["day16-面向对象综合练习（上）"]},{text:"17 面向对象综合练习（下）",prefix:"17-面向对象综合练习（下）/",collapsible:!0,children:["day17-面向对象综合练习（下）"]},{text:"18 API（常见 API，对象克隆）",prefix:"18-API（常见API，对象克隆）/",collapsible:!0,children:["API"]},{text:"19 API（正则表达式）",prefix:"19-API（正则表达式）/",collapsible:!0,children:["正则表达式"]},{text:"20 API（时间，包装类，练习）",prefix:"20-API（时间，包装类，练习）/",collapsible:!0,children:["API"]},{text:"21 API（算法，lambda，练习）",prefix:"21-API（算法，lambda，练习）/",collapsible:!0,children:["算法"]},{text:"22 集合（ List集合）",prefix:"22-集合（List集合）/",collapsible:!0,children:["集合01"]},{text:"23 集合（泛型& Set&数据结构）",prefix:"23-集合（泛型_Set_数据结构）/",collapsible:!0,children:["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html"]},{text:"24 集合（ Map&可变参数&集合工具类）",prefix:"24-集合（Map_可变参数_集合工具类）/",collapsible:!0,children:["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html"]},{text:"25 阶段项目（综合练习&doudizhu游戏）",prefix:"25-阶段项目（综合练习_doudizhu游戏）/",collapsible:!0,children:["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html"]},{text:"26 集合（ Stream流&方法引用）",prefix:"26-集合（Stream流_方法引用）/",collapsible:!0,children:["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html"]},{text:"27 IO(异常& File&综合案例）",prefix:"27-IO(异常_File_综合案例）/",collapsible:!0,children:["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html"]},{text:"28 IO（字节流&字符流）",prefix:"28-IO（字节流_字符流）/",collapsible:!0,children:["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html"]},{text:"29 IO（其他流）",prefix:"29-IO（其他流）/",collapsible:!0,children:["IO流（其他流）"]},{text:"30 多线程",prefix:"30-多线程/",collapsible:!0,children:["多线程01"]},{text:"31 多线程&juc",prefix:"31-多线程_juc/",collapsible:!0,children:["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html"]},{text:"32 网络编程",prefix:"32-网络编程/",collapsible:!0,children:["网络编程"]},{text:"33 基础加强（反射，动态代理）",prefix:"33-基础加强（反射，动态代理）/",collapsible:!0,children:["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"]},{text:"34 基础加强（日志，类加载器，单元测试，xml，注解）",prefix:"34-基础加强（日志，类加载器，单元测试，xml，注解）/",collapsible:!0,children:[{text:"01 Log日志",prefix:"01-log日志/",collapsible:!0,children:["log日志"]},{text:"02 类加载器",prefix:"02-类加载器/",collapsible:!0,children:["类加载器"]},{text:"03 Xml",prefix:"03-xml/",collapsible:!0,children:["xml"]},{text:"04 单元测试",prefix:"04-单元测试/",collapsible:!0,children:["单元测试"]},{text:"05 注解",prefix:"05-注解/",collapsible:!0,children:["注解"]}]},"ioStream","regularExpression","3.java-basic","4.collection","jottings","java8Stream","comparator","1.object-oriented-programming","multithreading","2.three-features"]},{text:"Bug",prefix:"bug/",collapsible:!0,children:["bug"]},{text:"Dependence",prefix:"dependence/",collapsible:!0,children:["docx4j","log","mybatis","netty","maven"]},{text:"Netty",prefix:"netty/",collapsible:!0,children:["Netty01-nio","Netty02-入门","Netty03-进阶","Netty04-优化与源码"]},{text:"Spring",prefix:"spring/",collapsible:!0,children:[{text:"10 Spring安全",prefix:"10-Spring安全/",collapsible:!0,children:["/pages/568352/"]},{text:"Spring IO",prefix:"04-SpringIO/",collapsible:!0,children:["/pages/92add2/","/pages/676725/","/pages/2586f1/"]},{text:"Spring Web",prefix:"03-SpringWeb/",collapsible:!0,children:["/pages/ad0516/","/pages/20287b/","/pages/251e31/","/pages/1d2954/","/pages/4a164d/","/pages/5d002f/","/pages/65351b/"]},{text:"Spring 其他",prefix:"99-Spring其他/",collapsible:!0,children:["/pages/752c6a/","/pages/bac2ce/","/pages/c013cc/"]},"spring",{text:"Spring 数据篇",prefix:"02-Spring数据/",collapsible:!0,children:["/pages/1b774c/","/pages/cf19fd/","/pages/128c54/","/pages/a03d7b/","/pages/88219e/","/pages/191cdb/","/pages/65e4a2/","/pages/db2a41/","/pages/fac14c/"]},{text:"Spring 核心",prefix:"01-Spring核心/",collapsible:!0,children:["/pages/68097d/","/pages/915530/","/pages/9a6f6b/","/pages/f61a1c/","/pages/a5f257/","/pages/8289f5/","/pages/4ab176/","/pages/55f315/","/pages/ad472e/","/pages/53aedb/","/pages/a1549f/","/pages/fe6aad/","/pages/267b4c/","/pages/6662dc/","/pages/1f743f/","/pages/cca414/","/pages/b5b8ad/","/pages/175cbd/","/pages/b6556f/","/pages/03d838/","/pages/950e4d/","/pages/0fb992/","/pages/cb598e/"]},{text:"Spring 综述",prefix:"00-Spring综合/",collapsible:!0,children:["/pages/9d3091/","/pages/db33b0/","/pages/dbf521/","/pages/430f53/"]},{text:"Spring 集成",prefix:"05-Spring集成/",collapsible:!0,children:["/pages/a311cb/","/pages/a187f0/","/pages/274fd7/"]},"spring面试题"]},{text:"Springboot",prefix:"springboot/",collapsible:!0,children:["workcondition"]},{text:"Web",prefix:"web/",collapsible:!0,children:["/posts/java/web/HTTP_Tomcat_Servlet.html","jdbc","/posts/java/web/Request_Response.html"]}]},{text:"Linux",prefix:"linux/",collapsible:!0,children:["linux","linuxWork"]},{text:"Mysql",prefix:"mysql/",collapsible:!0,children:["DDL","/posts/mysql/DML_DQL.html","mysql存储过程","mysql安装","mysql数据格式","mysqlBug","mysql约束","mysql自定义函数","mysql触发器"]},{text:"Network",prefix:"network/",collapsible:!0,children:["ftp","internet"]},{text:"Python",prefix:"python/",collapsible:!0,children:[{text:"Django",prefix:"django/",collapsible:!0,children:["djangoWork"]}]},{text:"Redis",prefix:"redis/",collapsible:!0,children:["redisBUG","redis 学习笔记之实战篇","redis 学习笔记之快速入门"]},{text:"Shell",prefix:"shell/",collapsible:!0,children:["shell","shellWork"]},{text:"Windows",prefix:"windows/",collapsible:!0,children:["workcondition"]}]}},32878:(n,e,t)=>{t.d(e,{P:()=>i});const i={Baidu:'<svg xmlns="http://www.w3.org/2000/svg" class="icon baidu-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#2319DC"/><path fill="#FFF" d="M320 528c65-14 56-92 54-109-3-26-34-72-76-68-52 4-60 81-60 81-7 35 17 110 82 96m121-131c36 0 65-41 65-92 0-52-29-93-65-93s-65 41-65 93c0 51 29 92 65 92m155 7c48 6 79-46 86-85 6-38-25-84-59-91-35-8-77 46-81 82-5 44 6 87 54 94m191 65c0-19-15-75-73-75-57 0-65 53-65 91 0 35 3 85 75 84 71-2 63-81 63-100m-73 163s-74-57-118-119c-59-92-142-55-170-8s-72 76-78 84-90 53-71 135c18 83 83 81 83 81s49 5 104-7c56-13 104 3 104 3s131 43 166-41c36-84-20-128-20-128"/><path fill="#2319DC" d="M453 552v56h-45s-46 3-61 54c-6 35 4 55 6 59s17 29 53 37h85V553zm-1 172h-34s-24-1-31-29c-4-12 0-26 2-31 2-6 10-19 26-23h37zm60-111v107s2 27 39 37h98V613h-42v108h-40s-13-2-16-12v-97z"/></svg>',BiliBili:'<svg xmlns="http://www.w3.org/2000/svg" class="icon bilibili-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#1296db"/><path fill="#fff" d="M745.363 177.725a47 47 0 0 1 0 66.3L702.5 286.85h44A141 141 0 0 1 887 427.512v281.25a141 141 0 0 1-141 140.626H277.25A141 141 0 0 1 137 708.763v-281.25a141 141 0 0 1 141-141h43.725l-42.788-42.825a47 47 0 1 1 66.263-66.3l99.45 99.45c2.963 2.962 5.438 6.187 7.425 9.637h120.487c1.988-3.45 4.5-6.75 7.463-9.675l99.413-99.45a47 47 0 0 1 66.3 0zm1.012 203.25h-468.75a47 47 0 0 0-46.763 43.388l-.112 3.525v281.25c0 24.712 19.125 44.962 43.387 46.724l3.488.15h468.75a47 47 0 0 0 46.763-43.387l.112-3.487v-281.25c0-26-21-47-47-46.876zm-375 93.75c26 0 47 21 47 47v47a47 47 0 1 1-93.75 0V521.6c0-26 21-47 47-47zm281.25 0c26 0 47 21 47 47v47a47 47 0 1 1-93.75 0V521.6c0-26 21-47 47-47z"/></svg>',GitHub:'<svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#171515"/><path fill="#fff" d="M509.423 146.442c-200.317 0-362.756 162.42-362.756 362.8 0 160.266 103.936 296.24 248.109 344.217 18.139 3.327 24.76-7.872 24.76-17.486 0-8.613-.313-31.427-.49-61.702-100.912 21.923-122.205-48.63-122.205-48.63-16.495-41.91-40.28-53.067-40.28-53.067-32.937-22.51 2.492-22.053 2.492-22.053 36.407 2.566 55.568 37.386 55.568 37.386 32.362 55.438 84.907 39.43 105.58 30.143 3.296-23.444 12.667-39.43 23.032-48.498-80.557-9.156-165.246-40.28-165.246-179.297 0-39.604 14.135-71.988 37.342-97.348-3.731-9.178-16.18-46.063 3.556-96.009 0 0 30.46-9.754 99.76 37.19 28.937-8.048 59.97-12.071 90.823-12.211 30.807.14 61.843 4.165 90.822 12.21 69.26-46.944 99.663-37.189 99.663-37.189 19.792 49.946 7.34 86.831 3.61 96.01 23.25 25.359 37.29 57.742 37.29 97.347 0 139.366-84.82 170.033-165.637 179.013 13.026 11.2 24.628 33.342 24.628 67.182 0 48.498-.445 87.627-.445 99.521 0 9.702 6.535 20.988 24.945 17.444 144.03-48.067 247.881-183.95 247.881-344.175 0-200.378-162.442-362.798-362.802-362.798z"/></svg>'}}},n=>{n.O(0,[815,7059],(()=>n(n.s=38731))),n.O()}]);