"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3524],{61709:(n,e,t)=>{t.d(e,{l:()=>i});const i={category:{"/":{path:"/category/",map:{使用指南:{path:"/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",indexes:[0]},linux:{path:"/category/linux/",indexes:[1,2]},idea:{path:"/category/idea/",indexes:[3]},mysql:{path:"/category/mysql/",indexes:[4,5,6,7,8,9,10,11,12]},java:{path:"/category/java/",indexes:[13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]},network:{path:"/category/network/",indexes:[74]},redis:{path:"/category/redis/",indexes:[75,76,77]},windows:{path:"/category/windows/",indexes:[78,79]},dependence:{path:"/category/dependence/",indexes:[80,81,82,83,84]},spring:{path:"/category/spring/",indexes:[85]},python:{path:"/category/python/",indexes:[86]},Java:{path:"/category/java/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},框架:{path:"/category/%E6%A1%86%E6%9E%B6/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring:{path:"/category/spring/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring综合:{path:"/category/spring%E7%BB%BC%E5%90%88/",indexes:[118,119,120,126,140]},Spring核心:{path:"/category/spring%E6%A0%B8%E5%BF%83/",indexes:[94,95,96,97,98,99,100,101,102,103,104,105,106,107,112,113,115,116,117,123,124,128,130,134]},Spring数据:{path:"/category/spring%E6%95%B0%E6%8D%AE/",indexes:[92,93,108,110,131,132,133,137,139,146]},SpringWeb:{path:"/category/springweb/",indexes:[87,88,89,90,91,121,135,142]},SpringIO:{path:"/category/springio/",indexes:[109,127,129,136]},Spring集成:{path:"/category/spring%E9%9B%86%E6%88%90/",indexes:[125,143,144,145]},Spring安全:{path:"/category/spring%E5%AE%89%E5%85%A8/",indexes:[114]},Spring其他:{path:"/category/spring%E5%85%B6%E4%BB%96/",indexes:[111,122,138,141]}}}},tag:{"/":{path:"/tag/",map:{页面配置:{path:"/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",indexes:[0]},使用指南:{path:"/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",indexes:[0,3]},linux:{path:"/tag/linux/",indexes:[1,2]},tomcat:{path:"/tag/tomcat/",indexes:[2,32]},shell:{path:"/tag/shell/",indexes:[78,79,2,29]},sql:{path:"/tag/sql/",indexes:[4,5,6,7,8,9,10,11,12]},bug:{path:"/tag/bug/",indexes:[23,25]},internet:{path:"/tag/internet/",indexes:[74]},java:{path:"/tag/java/",indexes:[80,75,76,77,29,81,82,83,84,85,30,31]},spring:{path:"/tag/spring/",indexes:[75,76,77,29,81,82,83,84,85,30,31]},springboot:{path:"/tag/springboot/",indexes:[75,76,77,29,81,82,83,84,85,30,31]},redis:{path:"/tag/redis/",indexes:[75,76,77]},script:{path:"/tag/script/",indexes:[78,79]},"java-basic":{path:"/tag/java-basic/",indexes:[13,14,15,16,17,18,24,26,27,28,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]},logback:{path:"/tag/logback/",indexes:[81]},maven:{path:"/tag/maven/",indexes:[82]},mybatis:{path:"/tag/mybatis/",indexes:[83]},netty:{path:"/tag/netty/",indexes:[19,20,21,22,84]},nio:{path:"/tag/nio/",indexes:[19]},javaweb:{path:"/tag/javaweb/",indexes:[32,33,34]},http:{path:"/tag/http/",indexes:[32]},servlet:{path:"/tag/servlet/",indexes:[32]},Request:{path:"/tag/request/",indexes:[33]},Response:{path:"/tag/response/",indexes:[33]},jdbc:{path:"/tag/jdbc/",indexes:[34]},djgango:{path:"/tag/djgango/",indexes:[86]},Java:{path:"/tag/java/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},框架:{path:"/tag/%E6%A1%86%E6%9E%B6/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},Spring:{path:"/tag/spring/",indexes:[87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]},SpringBoot:{path:"/tag/springboot/",indexes:[92,93,108,109,110,111,113,114,118,119,120,121,122,124,125,127,128,129,131,132,133,134,135,136,137,138,139,146]},面试:{path:"/tag/%E9%9D%A2%E8%AF%95/",indexes:[140]},Bean:{path:"/tag/bean/",indexes:[104,105,106,112]},BeanDefinition:{path:"/tag/beandefinition/",indexes:[112]},IOC:{path:"/tag/ioc/",indexes:[107,115,116,117]},依赖查找:{path:"/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",indexes:[116]},依赖注入:{path:"/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",indexes:[107,117]},AOP:{path:"/tag/aop/",indexes:[123]},Resource:{path:"/tag/resource/",indexes:[130]},数据绑定:{path:"/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",indexes:[101]},数据库:{path:"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",indexes:[110,146]},DataSource:{path:"/tag/datasource/",indexes:[146]},JDBC:{path:"/tag/jdbc/",indexes:[132]},JdbcTemplate:{path:"/tag/jdbctemplate/",indexes:[132]},事务:{path:"/tag/%E4%BA%8B%E5%8A%A1/",indexes:[108]},JPA:{path:"/tag/jpa/",indexes:[133]},MyBatis:{path:"/tag/mybatis/",indexes:[131]},PageHelper:{path:"/tag/pagehelper/",indexes:[131]},Mapper:{path:"/tag/mapper/",indexes:[131]},Redis:{path:"/tag/redis/",indexes:[93]},MongoDB:{path:"/tag/mongodb/",indexes:[139]},Elasticsearch:{path:"/tag/elasticsearch/",indexes:[137]},Web:{path:"/tag/web/",indexes:[87,88,89,90,91,121,135,142]},Controller:{path:"/tag/controller/",indexes:[89]},DispatcherServlet:{path:"/tag/dispatcherservlet/",indexes:[91]},Filter:{path:"/tag/filter/",indexes:[90]},CORS:{path:"/tag/cors/",indexes:[88]},View:{path:"/tag/view/",indexes:[87]},异步:{path:"/tag/%E5%BC%82%E6%AD%A5/",indexes:[129]},JSON:{path:"/tag/json/",indexes:[136]},邮件:{path:"/tag/%E9%82%AE%E4%BB%B6/",indexes:[127]},IO:{path:"/tag/io/",indexes:[109]},集成:{path:"/tag/%E9%9B%86%E6%88%90/",indexes:[125,143,144,145]},缓存:{path:"/tag/%E7%BC%93%E5%AD%98/",indexes:[143]},调度器:{path:"/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",indexes:[144]},Dubbo:{path:"/tag/dubbo/",indexes:[145]},安全:{path:"/tag/%E5%AE%89%E5%85%A8/",indexes:[114]}}}}}},94776:(n,e,t)=>{t.d(e,{M:()=>i});const i=["/posts/markdown.html","/posts/linux/linux.html","/posts/linux/linuxWork.html","/posts/idea/idea.html","/posts/mysql/DDL.html","/posts/mysql/DML_DQL.html","/posts/mysql/mysqlBug.html","/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html","/posts/mysql/mysql%E5%AE%89%E8%A3%85.html","/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html","/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html","/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html","/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html","/posts/java/basic/3.java-basic.html","/posts/java/basic/4.collection.html","/posts/java/basic/2.three-features.html","/posts/java/basic/1.object-oriented-programming.html","/posts/java/basic/comparator.html","/posts/java/basic/regularExpression.html","/posts/java/netty/Netty01-nio.html","/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html","/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html","/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html","/posts/network/ftp.html","/posts/java/basic/ioStream.html","/posts/java/bug/bug.html","/posts/java/basic/jottings.html","/posts/java/basic/java8Stream.html","/posts/java/basic/multithreading.html","/posts/windows/workcondition.html","/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html","/posts/java/springboot/workcondition.html","/posts/java/web/HTTP_Tomcat_Servlet.html","/posts/java/web/Request_Response.html","/posts/java/web/jdbc.html","/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html","/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html","/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html","/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html","/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html","/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html","/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html","/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html","/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html","/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html","/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html","/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html","/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html","/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html","/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html","/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html","/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html","/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html","/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html","/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html","/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html","/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html","/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html","/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html","/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html","/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html","/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html","/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html","/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html","/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html","/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html","/posts/network/internet.html","/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html","/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html","/posts/redis/redisBUG.html","/posts/shell/shellWork.html","/posts/shell/shell.html","/posts/java/dependence/docx4j.html","/posts/java/dependence/log.html","/posts/java/dependence/maven.html","/posts/java/dependence/mybatis.html","/posts/java/dependence/netty.html","/posts/java/spring/spring.html","/posts/python/django/djangoWork.html","/pages/251e31/","/pages/1d2954/","/pages/5d002f/","/pages/4a164d/","/pages/20287b/","/pages/191cdb/","/pages/65e4a2/","/pages/1f743f/","/pages/ad472e/","/pages/03d838/","/pages/b6556f/","/pages/cca414/","/pages/175cbd/","/pages/6662dc/","/pages/267b4c/","/pages/fe6aad/","/pages/b5b8ad/","/pages/55f315/","/pages/4ab176/","/pages/8289f5/","/pages/a5f257/","/pages/128c54/","/pages/56581b/","/pages/b912d1/","/pages/c013cc/","/pages/68097d/","/pages/950e4d/","/pages/568352/","/pages/915530/","/pages/9a6f6b/","/pages/f61a1c/","/pages/430f53/","/pages/dbf521/","/pages/9e0b67/","/pages/e2586a/","/pages/6bb8c1/","/pages/53aedb/","/pages/5e7c20/","/pages/d6025b/","/pages/9d3091/","/pages/2586f1/","/pages/cb598e/","/pages/92add2/","/pages/a1549f/","/pages/88219e/","/pages/cf19fd/","/pages/a03d7b/","/pages/0fb992/","/pages/ad0516/","/pages/676725/","/pages/fac14c/","/pages/bac2ce/","/pages/db2a41/","/pages/db33b0/","/pages/752c6a/","/pages/65351b/","/pages/a311cb/","/pages/a187f0/","/pages/274fd7/","/pages/1b774c/","/intro.html"]},53781:(n,e,t)=>{t.d(e,{U:()=>i});const i={article:{"/":{path:"/article/",indexes:[0,13,14,15,16,3,147,17,18,80,19,20,21,22,86,78,23,74,79,24,25,26,27,28,1,2,4,5,6,7,8,9,10,11,12,75,76,77,29,81,82,83,84,85,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]}},star:{"/":{path:"/star/",indexes:[0,147]}},timeline:{"/":{path:"/timeline/",indexes:[13,14,15,16,0,3,147,17,18,80,19,20,21,22,86,78,23,74,79,24,25,26,27,28,1,2,4,5,6,7,8,9,10,11,12,75,76,77,29,81,82,83,84,85,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146]}}}},88965:(n,e,t)=>{t.d(e,{B:()=>J});var i={};t.r(i);var a={};t.r(a);var r={};t.r(r);var l={};t.r(l),t.d(l,{default:()=>h});var s={};t.r(s),t.d(s,{default:()=>S});var o={};t.r(o);var c={};t.r(c),t.d(c,{default:()=>j});var p={};t.r(p),t.d(p,{default:()=>N});var d={};t.r(d),t.d(d,{default:()=>H});var u=t(33349),g=t(11781),m=t(19212);const h={enhance:({app:n})=>{n.component("CodeTabs",g.S),n.component("Tabs",m.t)}};var v=t(58031),b=t(83027);const S={enhance:({app:n})=>{n.component("CodeDemo",v.A),n.component("MdDemo",b.A)}};var E=t(38913),y=t(80355),f=t(80457),k=t(6990),B=t(42402),w=t(97786),x=t(79403),A=t(70596),C=t(38831);const j={enhance:({app:n})=>{(0,B.L4)("FontIcon")||n.component("FontIcon",x.A),(0,B.L4)("Badge")||n.component("Badge",A.A),(0,B.L4)("VPCard")||n.component("VPCard",C.A)},setup:()=>{(0,w.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/brands.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,w.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/solid.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}}),(0,w.r9V)("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/js/fontawesome.min.js",(()=>{}),{attrs:{"data-auto-replace-svg":"nest"}})},rootComponents:[]};var F=t(26358),I=t(23827),T=t(31599),_=t(22614),D=t(75054),L=t(80783),R=t(38465),O=t(20641),M=t(77107),P=t(79920);(0,R.M_)((n=>{const e=n.t,t=!1!==n.I,i=n.i;return t?{title:e,content:i?()=>[(0,O.h)(L.GB,{icon:i}),e]:null,order:n.O,index:n.I}:null}));const N={enhance:({app:n,router:e})=>{const{scrollBehavior:t}=e.options;e.options.scrollBehavior=async(...n)=>(await L.lE.wait(),t(...n)),(0,L.fk)(n),n.component("HopeIcon",L.GB),n.component("BloggerInfo",M.tI),n.component("SocialMedias",M.rS),n.component("GlobalEncrypt",P.J),n.component("LocalEncrypt",P.n)},setup:()=>{(0,L.PV)(),(0,L.i$)(),(0,M.su)()},layouts:{Layout:L.PE,NotFound:L.Mk,BlogCategory:M.Pn,BlogHome:M.qX,BlogType:M.z7,Timeline:M.Kf}};var q=t(8278),U=t(61428);const H=(0,q.re)({setup(){(0,U.H)(new Date("2024-12-18"),{"/":"已运行 :day 天 :hour 小时 :minute 分钟 :second 秒"},!0)}}),J=[i,a,r,u,l,s,o,r,E,y,f,k,c,F,I,T,_,D,p,d].map((n=>n.default)).filter(Boolean)},68164:(n,e,t)=>{t.d(e,{J:()=>a,c:()=>i});const i=JSON.parse('{"/posts/mysql/DML&DQL.html":"/posts/mysql/DML_DQL.html","/posts/java/web/HTTP&Tomcat&Servlet.html":"/posts/java/web/HTTP_Tomcat_Servlet.html","/posts/java/web/Request&Response.html":"/posts/java/web/Request_Response.html","/posts/java/basic/11-%E9%9B%86%E5%90%88&%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList&%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html":"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html","/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static&%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html":"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html","/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81&%E5%8C%85&final&%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6&%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html":"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html","/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB&%E6%8E%A5%E5%8F%A3&%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html":"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html","/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B&Set&%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html":"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html","/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map&%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0&%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html":"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html","/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0&doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0&%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html":"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html","/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81&%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html":"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html","/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8&File&%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8&File&%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html":"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html","/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html":"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html","/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html":"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html","/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html":"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html":"/pages/9d3091/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html":"/pages/430f53/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html":"/pages/dbf521/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html":"/pages/db33b0/","/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/":"/pages/9e0b67/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html":"/pages/68097d/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html":"/pages/915530/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html":"/pages/9a6f6b/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html":"/pages/f61a1c/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html":"/pages/a5f257/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html":"/pages/8289f5/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html":"/pages/4ab176/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html":"/pages/55f315/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/09.Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html":"/pages/ad472e/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html":"/pages/53aedb/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html":"/pages/a1549f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html":"/pages/fe6aad/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html":"/pages/267b4c/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html":"/pages/6662dc/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html":"/pages/1f743f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html":"/pages/cca414/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html":"/pages/b5b8ad/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html":"/pages/175cbd/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html":"/pages/b6556f/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/29.SpringEnvironment%E6%8A%BD%E8%B1%A1.html":"/pages/03d838/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html":"/pages/950e4d/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html":"/pages/0fb992/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html":"/pages/cb598e/","/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/":"/pages/5e7c20/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html":"/pages/1b774c/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html":"/pages/cf19fd/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html":"/pages/128c54/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html":"/pages/a03d7b/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html":"/pages/88219e/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/20.SpringData%E7%BB%BC%E5%90%88.html":"/pages/191cdb/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html":"/pages/65e4a2/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html":"/pages/db2a41/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html":"/pages/fac14c/","/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/":"/pages/b912d1/","/posts/java/spring/03-SpringWeb/01.SpringWeb%E7%BB%BC%E8%BF%B0.html":"/pages/65351b/","/posts/java/spring/03-SpringWeb/02.SpringWeb%E5%BA%94%E7%94%A8.html":"/pages/5d002f/","/posts/java/spring/03-SpringWeb/03.DispatcherServlet.html":"/pages/20287b/","/posts/java/spring/03-SpringWeb/04.Spring%E8%BF%87%E6%BB%A4%E5%99%A8.html":"/pages/4a164d/","/posts/java/spring/03-SpringWeb/05.Spring%E8%B7%A8%E5%9F%9F.html":"/pages/1d2954/","/posts/java/spring/03-SpringWeb/06.Spring%E8%A7%86%E5%9B%BE.html":"/pages/251e31/","/posts/java/spring/03-SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html":"/pages/ad0516/","/posts/java/spring/03-SpringWeb/":"/pages/e2586a/","/posts/java/spring/04-SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html":"/pages/92add2/","/posts/java/spring/04-SpringIO/02.SpringBoot%E4%B9%8BJson.html":"/pages/676725/","/posts/java/spring/04-SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html":"/pages/2586f1/","/posts/java/spring/04-SpringIO/":"/pages/56581b/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html":"/pages/a311cb/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html":"/pages/a187f0/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html":"/pages/274fd7/","/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/":"/pages/d6025b/","/posts/java/spring/10-Spring%E5%AE%89%E5%85%A8/01.SpringBoot%E4%B9%8B%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html":"/pages/568352/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html":"/pages/752c6a/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html":"/pages/bac2ce/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html":"/pages/c013cc/","/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/":"/pages/6bb8c1/"}'),a=Object.fromEntries([["/",{loader:()=>t.e(4470).then(t.bind(t,62744)),meta:{t:"主页",i:"home"}}],["/intro.html",{loader:()=>t.e(1531).then(t.bind(t,6924)),meta:{d:1734619579e3,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/e699d7e2413ed5dfb384ee48c2b872d3_5181262111088024686.png",e:"\n<p>重生之我在提瓦特大陆当牛马</p>\n",r:{minutes:.09,words:26},t:"介绍页",i:"circle-info",y:"a"}}],["/demo/",{loader:()=>t.e(3320).then(t.bind(t,85351)),meta:{t:"主要功能与配置演示",i:"laptop-code"}}],["/demo/disable.html",{loader:()=>t.e(2756).then(t.bind(t,24139)),meta:{t:"布局与功能禁用",i:"gears",O:4}}],["/demo/encrypt.html",{loader:()=>t.e(2581).then(t.bind(t,71314)),meta:{t:"密码加密的文章",i:"lock"}}],["/demo/layout.html",{loader:()=>t.e(6216).then(t.bind(t,74087)),meta:{t:"布局",i:"object-group",O:2}}],["/demo/markdown.html",{loader:()=>t.e(8711).then(t.bind(t,36175)),meta:{t:"Markdown 展示",i:"fab fa-markdown",O:2}}],["/demo/page.html",{loader:()=>t.e(645).then(t.bind(t,95397)),meta:{t:"页面配置使用说明",i:"file",O:3}}],["/posts/markdown.html",{loader:()=>t.e(1629).then(t.bind(t,49531)),meta:{a:"xuyong",d:17347392e5,l:"2024年12月21日",c:["使用指南"],g:["页面配置","使用指南"],u:!0,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/fdcbc9ef8859b7077d92ae38d925e15e_7767077963502328666.png",e:"<p><code>more</code> 注释之前的内容被视为文章摘要。</p>\n",r:{minutes:2.02,words:606},t:"页面配置使用说明",i:"file",O:3,y:"a"}}],["/posts/linux/linux.html",{loader:()=>t.e(4261).then(t.bind(t,15628)),meta:{d:16855776e5,l:"2023年6月1日",c:["linux"],g:["linux"],e:"<p>linux 命令集</p>\n",r:{minutes:29.18,words:8754},t:"linux 命令集",i:"pen-to-square",y:"a"}}],["/posts/linux/linuxWork.html",{loader:()=>t.e(4292).then(t.bind(t,60195)),meta:{d:16855776e5,l:"2023年6月1日",c:["linux"],g:["linux","tomcat","shell"],e:"<p>在工作中遇到的有关Linux的问题</p>\n",r:{minutes:2.81,words:842},t:"在工作中遇到的有关Linux的问题",i:"pen-to-square",y:"a"}}],["/posts/idea/idea.html",{loader:()=>t.e(8565).then(t.bind(t,18830)),meta:{a:"xuyong",d:17347392e5,l:"2024年12月21日",c:["idea"],g:["使用指南"],u:!1,v:"https://webstatic.mihoyo.com/upload/contentweb/2022/07/04/d063646e97392638e07da24ce6b8c3cb_3567507076955258130.png",e:"<p>记录 idea 使用过程中遇到的问题</p>\n",r:{minutes:.98,words:294},t:"idea 使用方便记录",i:"file",y:"a"}}],["/posts/mysql/DDL.html",{loader:()=>t.e(779).then(t.bind(t,35486)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DDL常用命令，操作数据库和表结构</p>\n",r:{minutes:1.88,words:564},t:"DDL常用命令，操作数据库和表结构",i:"pen-to-square",y:"a"}}],["/posts/mysql/DML_DQL.html",{loader:()=>t.e(532).then(t.bind(t,29099)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DML和DQL常用命令，操作表数据</p>\n",r:{minutes:1.84,words:551},t:"DML和DQL常用命令，操作表数据",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysqlBug.html",{loader:()=>t.e(2755).then(t.bind(t,57114)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql使用中遇到的问题记录</p>\n",r:{minutes:.53,words:160},t:"mysql使用中遇到的问题记录",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html",{loader:()=>t.e(7219).then(t.bind(t,59e3)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>DDL常用命令，操作数据库和表结构</p>\n",r:{minutes:2.33,words:698},t:"mysql 存储过程",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E5%AE%89%E8%A3%85.html",{loader:()=>t.e(2851).then(t.bind(t,74326)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql 安装指南</p>\n",r:{minutes:.96,words:287},t:"mysql 安装",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html",{loader:()=>t.e(8122).then(t.bind(t,72388)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql 数据格式</p>\n",r:{minutes:1.36,words:409},t:"mysql 数据格式",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html",{loader:()=>t.e(9610).then(t.bind(t,88366)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql约束</p>\n",r:{minutes:7.92,words:2376},t:"mysql约束",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html",{loader:()=>t.e(8587).then(t.bind(t,33636)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>mysql自定义函数</p>\n",r:{minutes:3.32,words:996},t:"mysql自定义函数",i:"pen-to-square",y:"a"}}],["/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html",{loader:()=>t.e(5558).then(t.bind(t,32454)),meta:{d:16855776e5,l:"2023年6月1日",c:["mysql"],g:["sql"],e:"<p>触发器</p>\n",r:{minutes:.74,words:221},t:"触发器",i:"pen-to-square",y:"a"}}],["/posts/network/ftp.html",{loader:()=>t.e(9434).then(t.bind(t,48704)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["bug"],e:"<p>ftp 的一些基础内容</p>\n",r:{minutes:1.6,words:481},t:"ftp",i:"pen-to-square",y:"a"}}],["/posts/network/internet.html",{loader:()=>t.e(638).then(t.bind(t,30020)),meta:{d:16859232e5,l:"2023年6月5日",c:["network"],g:["internet"],e:"<p>计算机网络学习笔记</p>\n",r:{minutes:14.73,words:4418},t:"计算机网络",i:"pen-to-square",y:"a"}}],["/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html",{loader:()=>t.e(6059).then(t.bind(t,17549)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 学习笔记之实战篇</p>\n",r:{minutes:47.09,words:14126},t:"redis 学习笔记之实战篇",i:"pen-to-square",y:"a"}}],["/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",{loader:()=>t.e(9793).then(t.bind(t,61419)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 学习笔记之快速入门</p>\n",r:{minutes:16.98,words:5093},t:"redis 学习笔记之快速入门",i:"pen-to-square",y:"a"}}],["/posts/redis/redisBUG.html",{loader:()=>t.e(5183).then(t.bind(t,69299)),meta:{d:16855776e5,l:"2023年6月1日",c:["redis"],g:["java","spring","springboot","redis"],e:"<p>redis 使用过程中的bug记录</p>\n",r:{minutes:1.42,words:427},t:"redis 使用过程中的bug记录",i:"pen-to-square",y:"a"}}],["/posts/shell/shell.html",{loader:()=>t.e(1669).then(t.bind(t,73730)),meta:{d:16859232e5,l:"2023年6月5日",c:["windows"],g:["script","shell"],e:"<p>入门 shell 脚本的基础知识</p>\n",r:{minutes:34.53,words:10358},t:"shell 基础知识",i:"pen-to-square",y:"a"}}],["/posts/shell/shellWork.html",{loader:()=>t.e(8628).then(t.bind(t,81709)),meta:{d:17155584e5,l:"2024年5月13日",c:["windows"],g:["script","shell"],e:"<p>工作中遇到有关 shell 脚本的情景和处理记录</p>\n",r:{minutes:.69,words:208},t:"工作中遇到的 shell",i:"pen-to-square",y:"a"}}],["/posts/windows/workcondition.html",{loader:()=>t.e(486).then(t.bind(t,75994)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot","shell"],e:"<p>Windows 工作中遇到的问题</p>\n",r:{minutes:2.66,words:797},t:"Windows 工作中遇到的问题",i:"pen-to-square",y:"a"}}],["/posts/java/basic/1.object-oriented-programming.html",{loader:()=>t.e(6233).then(t.bind(t,92717)),meta:{d:1734912e6,l:"2024年12月23日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/4c4b8babc68ffedce9bd5766b60e1ae5_8781849729625946129.png",e:"<p>java 面向对象基本信息介绍</p>\n",r:{minutes:10.38,words:3115},t:"什么是面向对象编程",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/2.three-features.html",{loader:()=>t.e(1088).then(t.bind(t,66658)),meta:{d:17349984e5,l:"2024年12月24日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2023/02/06/df329c62acad08953832134777166e57_5667154156652123154.png",e:"<p>java 封装、继承、多态介绍</p>\n",r:{minutes:10.28,words:3083},t:"面向对象的三大基本特征",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/3.java-basic.html",{loader:()=>t.e(7462).then(t.bind(t,41909)),meta:{d:17352576e5,l:"2024年12月27日",c:["java"],g:["java-basic"],v:"https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png",e:"<p>java 基本类型、String、关键字等内容介绍</p>\n",r:{minutes:6.86,words:2059},t:"java 基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/basic/4.collection.html",{loader:()=>t.e(8653).then(t.bind(t,96534)),meta:{d:17352576e5,l:"2024年12月27日",c:["java"],g:["java-basic"],v:"https://uploadstatic.mihoyo.com/contentweb/20200312/2020031219451784892.png",e:"<p>java 集合相关内容</p>\n",r:{minutes:6.87,words:2060},t:"java 集合",i:"pen-to-square",y:"a"}}],["/posts/java/basic/comparator.html",{loader:()=>t.e(7352).then(t.bind(t,89030)),meta:{d:17343936e5,l:"2024年12月17日",c:["java"],g:["java-basic"],e:"<p>Comparator 的一些基本使用</p>\n",r:{minutes:2.57,words:770},t:"comparator 基本使用",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/ioStream.html",{loader:()=>t.e(1816).then(t.bind(t,87982)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["java-basic"],e:"<p>IO 流的一些基本使用，后续记得完善</p>\n",r:{minutes:.25,words:76},t:"io 流的基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/basic/java8Stream.html",{loader:()=>t.e(8810).then(t.bind(t,93838)),meta:{d:16857504e5,l:"2023年6月3日",c:["java"],g:["java-basic"],e:"<p>java8 stream 梳理</p>\n",r:{minutes:17.43,words:5228},t:"java8 stream",i:"pen-to-square",y:"a"}}],["/posts/java/basic/jottings.html",{loader:()=>t.e(2222).then(t.bind(t,65432)),meta:{d:16858368e5,l:"2023年6月4日",c:["java"],g:["java-basic"],e:"<p>java 零碎知识点记录</p>\n",r:{minutes:2.55,words:764},t:"java 零碎知识点",i:"pen-to-square",y:"a"}}],["/posts/java/basic/multithreading.html",{loader:()=>t.e(5763).then(t.bind(t,98773)),meta:{d:1685664e6,l:"2023年6月2日",c:["java"],g:["java-basic"],e:"<p>多线程基础</p>\n",r:{minutes:13.31,words:3993},t:"多线程基础",i:"pen-to-square",O:-1,y:"a"}}],["/posts/java/basic/regularExpression.html",{loader:()=>t.e(3512).then(t.bind(t,68589)),meta:{d:17343936e5,l:"2024年12月17日",c:["java"],g:["java-basic"],e:"<p>java 正则表达式的基础使用</p>\n",r:{minutes:5.53,words:1658},t:"java 使用正则表达式",i:"pen-to-square",y:"a"}}],["/posts/java/bug/bug.html",{loader:()=>t.e(1796).then(t.bind(t,75441)),meta:{d:16859232e5,l:"2023年6月5日",c:["java"],g:["bug"],e:"<p>记录遇见的 Java 相关疑难杂症的 bug</p>\n",r:{minutes:.3,words:89},t:"java bug 合集",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/docx4j.html",{loader:()=>t.e(4337).then(t.bind(t,45574)),meta:{d:17343936e5,l:"2024年12月17日",c:["dependence"],g:["java"],e:"<p>docx4j 的一些基本使用</p>\n",r:{minutes:4.43,words:1330},t:"docx4j 基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/log.html",{loader:()=>t.e(7119).then(t.bind(t,34513)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","logback"],e:"<p>Java 有关log的第三方依赖的使用</p>\n",r:{minutes:5.86,words:1758},t:"Java 有关log的第三方依赖的使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/maven.html",{loader:()=>t.e(6574).then(t.bind(t,40565)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","maven"],e:"<p>maven的基本使用</p>\n",r:{minutes:9.77,words:2931},t:"有关maven的使用",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/mybatis.html",{loader:()=>t.e(5304).then(t.bind(t,55831)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","mybatis"],e:"<p>mybatis 的基本使用</p>\n",r:{minutes:21.93,words:6580},t:"mybatis 的基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/dependence/netty.html",{loader:()=>t.e(2709).then(t.bind(t,93595)),meta:{d:16855776e5,l:"2023年6月1日",c:["dependence"],g:["java","spring","springboot","netty"],e:"<p>netty 学习</p>\n",r:{minutes:1.15,words:344},t:"netty 学习",i:"pen-to-square",y:"a"}}],["/posts/java/netty/Netty01-nio.html",{loader:()=>t.e(1100).then(t.bind(t,65497)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty","nio"],e:"<p>non-blocking io 非阻塞 IO</p>\n",r:{minutes:32.01,words:9603},t:"NIO 基础",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html",{loader:()=>t.e(2022).then(t.bind(t,70471)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>Netty 入门</p>\n",r:{minutes:30.61,words:9183},t:"Netty 入门",i:"pen-to-square",O:2,y:"a"}}],["/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html",{loader:()=>t.e(4051).then(t.bind(t,49242)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>Netty 进阶</p>\n",r:{minutes:29.55,words:8865},t:"Netty 进阶",i:"pen-to-square",O:3,y:"a"}}],["/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html",{loader:()=>t.e(3222).then(t.bind(t,98228)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:17217792e5,l:"2024年7月24日",c:["java"],g:["netty"],e:"<p>优化与源码</p>\n",r:{minutes:21.53,words:6459},t:"优化与源码",i:"pen-to-square",O:4,y:"a"}}],["/posts/java/spring/spring.html",{loader:()=>t.e(3516).then(t.bind(t,6634)),meta:{d:16855776e5,l:"2023年6月1日",c:["spring"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:8.54,words:2562},t:"spring 学习笔记",i:"pen-to-square",y:"a"}}],["/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html",{loader:()=>t.e(3117).then(t.bind(t,64728)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:.73,words:219},t:"spring面试题",i:"pen-to-square",y:"a"}}],["/posts/java/springboot/workcondition.html",{loader:()=>t.e(5227).then(t.bind(t,57119)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["java","spring","springboot"],e:"<p>上帝赋予java生命，spring赋予java生命的延续</p>\n",r:{minutes:20.72,words:6215},t:"springboot 工作中遇到的问题",i:"pen-to-square",y:"a"}}],["/posts/java/web/HTTP_Tomcat_Servlet.html",{loader:()=>t.e(3821).then(t.bind(t,14485)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","http","tomcat","servlet"],e:"<p>HTTP tomcat Servlet 基础知识</p>\n",r:{minutes:38.71,words:11612},t:"HTTP tomcat Servlet 基础知识",i:"pen-to-square",y:"a"}}],["/posts/java/web/Request_Response.html",{loader:()=>t.e(9861).then(t.bind(t,8994)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","Request","Response"],e:"<p>Request&amp;Response 基础知识</p>\n",r:{minutes:39.2,words:11761},t:"Request&Response 的基本使用",i:"pen-to-square",y:"a"}}],["/posts/java/web/jdbc.html",{loader:()=>t.e(57).then(t.bind(t,4634)),meta:{d:16855776e5,l:"2023年6月1日",c:["java"],g:["javaweb","jdbc"],e:"<p>jdbc 基础使用</p>\n",r:{minutes:21.81,words:6543},t:"jdbc 的基本使用",i:"pen-to-square",y:"a"}}],["/posts/python/django/djangoWork.html",{loader:()=>t.e(6855).then(t.bind(t,12215)),meta:{d:17169408e5,l:"2024年5月29日",c:["python"],g:["djgango"],e:"<p>在工作中遇到了 django  框架，记录一些使用过程中遇到的问题</p>\n",r:{minutes:2.18,words:655},t:"django 使用过程中发生的问题",i:"pen-to-square",y:"a"}}],["/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",{loader:()=>t.e(1664).then(t.bind(t,82832)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Java入门介绍，编写hello world</p>\n",r:{minutes:10.55,words:3165},t:"Java入门",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",{loader:()=>t.e(8906).then(t.bind(t,61025)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Java基础概念学习</p>\n",r:{minutes:22.64,words:6791},t:"Java基础概念",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(4417).then(t.bind(t,26525)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>运算符和表达式记录</p>\n",r:{minutes:14.82,words:4447},t:"运算符和表达式",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",{loader:()=>t.e(5404).then(t.bind(t,75772)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>流程控制语句</p>\n",r:{minutes:12.62,words:3785},t:"流程控制语句",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html",{loader:()=>t.e(2741).then(t.bind(t,56605)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>循环高级</p>\n",r:{minutes:6.78,words:2034},t:"循环高级",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",{loader:()=>t.e(1255).then(t.bind(t,5725)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>数组</p>\n",r:{minutes:11.52,words:3455},t:"数组",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html",{loader:()=>t.e(3266).then(t.bind(t,54768)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>方法概述</p>\n",r:{minutes:12.48,words:3745},t:"方法概述",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(843).then(t.bind(t,33838)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>综合练习</p>\n",r:{minutes:14.22,words:4267},t:"综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",{loader:()=>t.e(4867).then(t.bind(t,75470)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>类和对象</p>\n",r:{minutes:9.69,words:2908},t:"类和对象",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(1524).then(t.bind(t,9313)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>扩展：键盘录入笔记</p>\n",r:{minutes:3.97,words:1192},t:"扩展：键盘录入笔记",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(3870).then(t.bind(t,75761)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>面向对象综合训练综合练习</p>\n",r:{minutes:18.04,words:5413},t:"面向对象综合训练综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html",{loader:()=>t.e(8238).then(t.bind(t,73913)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常用API</p>\n",r:{minutes:15.69,words:4708},t:"常用API",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html",{loader:()=>t.e(689).then(t.bind(t,95292)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>ArrayList&amp;学生管理系统</p>\n",r:{minutes:10.94,words:3283},t:"ArrayList&学生管理系统",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html",{loader:()=>t.e(3336).then(t.bind(t,16982)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>面向对象进阶部分学习方法</p>\n",r:{minutes:24.27,words:7282},t:"面向对象进阶部分学习方法",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(9537).then(t.bind(t,78744)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>多态</p>\n",r:{minutes:15.02,words:4507},t:"多态",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html",{loader:()=>t.e(9094).then(t.bind(t,46259)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>抽象类</p>\n",r:{minutes:18.32,words:5497},t:"抽象类",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html",{loader:()=>t.e(8373).then(t.bind(t,25099)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>day16-面向对象综合练习（上）</p>\n",r:{minutes:13.04,words:3913},t:"day16-面向对象综合练习（上）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html",{loader:()=>t.e(2077).then(t.bind(t,35599)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>day16-面向对象综合练习（下）</p>\n",r:{minutes:19.75,words:5925},t:"day16-面向对象综合练习（下）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html",{loader:()=>t.e(6636).then(t.bind(t,27933)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常见API，对象克隆</p>\n",r:{minutes:39.65,words:11896},t:"常见API，对象克隆",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",{loader:()=>t.e(1361).then(t.bind(t,23839)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>正则表达式</p>\n",r:{minutes:22.4,words:6719},t:"正则表达式",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html",{loader:()=>t.e(743).then(t.bind(t,41897)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常用API</p>\n",r:{minutes:23.9,words:7169},t:"常用API",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html",{loader:()=>t.e(7848).then(t.bind(t,15853)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>常见的七种查找算法：</p>\n",r:{minutes:19.57,words:5871},t:"常见的七种查找算法",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html",{loader:()=>t.e(9740).then(t.bind(t,93939)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Collection集合</p>\n",r:{minutes:11.8,words:3539},t:"Collection集合",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html",{loader:()=>t.e(7509).then(t.bind(t,78110)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>泛型</p>\n",r:{minutes:11.69,words:3508},t:"泛型",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html",{loader:()=>t.e(1264).then(t.bind(t,34831)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>Map集合</p>\n",r:{minutes:6.37,words:1910},t:"Map集合",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",{loader:()=>t.e(9920).then(t.bind(t,77626)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>可变参数&amp;综合练习</p>\n",r:{minutes:10.91,words:3273},t:"可变参数&综合练习",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html",{loader:()=>t.e(2790).then(t.bind(t,55364)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>stream流和方法引用</p>\n",r:{minutes:17.44,words:5233},t:"stream流和方法引用",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html",{loader:()=>t.e(7343).then(t.bind(t,42136)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO(异常&amp;File&amp;综合案例）</p>\n",r:{minutes:21.44,words:6431},t:"IO(异常&File&综合案例）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html",{loader:()=>t.e(9227).then(t.bind(t,72275)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO流（字节流&amp;字符流）</p>\n",r:{minutes:21.1,words:6330},t:"IO流（字节流&字符流）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html",{loader:()=>t.e(7078).then(t.bind(t,94095)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>IO流（其他流）</p>\n",r:{minutes:23.73,words:7120},t:"IO流（其他流）",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html",{loader:()=>t.e(7378).then(t.bind(t,27970)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>实现多线程</p>\n",r:{minutes:20.83,words:6249},t:"实现多线程",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html",{loader:()=>t.e(2613).then(t.bind(t,29737)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>线程池</p>\n",r:{minutes:34.15,words:10245},t:"线程池",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html",{loader:()=>t.e(2193).then(t.bind(t,71946)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>网络编程入门</p>\n",r:{minutes:22.51,words:6753},t:"网络编程入门",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",{loader:()=>t.e(9484).then(t.bind(t,28492)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>反射&amp;动态代理</p>\n",r:{minutes:19.3,words:5791},t:"反射&动态代理",i:"pen-to-square",O:1,y:"a"}}],["/pages/9d3091/",{loader:()=>t.e(6026).then(t.bind(t,26057)),meta:{d:1574419562e3,l:"2019年11月22日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring"],e:"\n<h2>Spring Framework 简介</h2>\n<p>Spring Framework 是最受欢迎的企业级 Java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。</p>\n<p>当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。</p>\n<p>Spring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>\n<p>Spring Framework 设计理念如下：</p>",r:{minutes:9.58,words:2875},t:"Spring Framework 综述",y:"a"}}],["/pages/430f53/",{loader:()=>t.e(1909).then(t.bind(t,63511)),meta:{d:1597215686e3,l:"2020年8月12日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:"\n<blockquote>\n<ol>\n<li>预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章</li>\n<li>说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。</li>\n</ol>\n</blockquote>",r:{minutes:37.48,words:11245},t:"SpringBoot 知识图谱",y:"a"}}],["/pages/dbf521/",{loader:()=>t.e(4264).then(t.bind(t,66576)),meta:{d:1597215686e3,l:"2020年8月12日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:'\n<p>SpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。</p>\n<figure><img src="https:////upload-images.jianshu.io/upload_images/6430208-ebcb376f96103703.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',r:{minutes:6.26,words:1878},t:"SpringBoot 基本原理",y:"a"}}],["/pages/db33b0/",{loader:()=>t.e(9084).then(t.bind(t,26763)),meta:{d:1533231212e3,l:"2018年8月2日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","面试"],e:"\n<h2>综合篇</h2>\n<h3>不同版本的 Spring Framework 有哪些主要功能？</h3>\n<table>\n<thead>\n<tr>\n<th>Version</th>\n<th>Feature</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring 2.5</td>\n<td>发布于 2007 年。这是第一个支持注解的版本。</td>\n</tr>\n<tr>\n<td>Spring 3.0</td>\n<td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td>\n</tr>\n<tr>\n<td>Spring 4.0</td>\n<td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td>\n</tr>\n</tbody>\n</table>",r:{minutes:20.87,words:6260},t:"Spring 面试",y:"a"}}],["/pages/9e0b67/",{loader:()=>t.e(9797).then(t.bind(t,50729)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring综合"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html" target="_blank">Spring 概述</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html" target="_blank">SpringBoot 知识图谱</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html" target="_blank">SpringBoot 基本原理</a></li>\n<li><a href="/blog/posts/java/spring/00-Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html" target="_blank">Spring 面试</a></li>\n</ul>',r:{minutes:.48,words:144},t:"Spring 综述",y:"a"}}],["/pages/68097d/",{loader:()=>t.e(1804).then(t.bind(t,39763)),meta:{d:1639163742e3,l:"2021年12月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean","BeanDefinition"],e:"\n<p>在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。<strong>Bean 是由 Spring IoC 容器实例化、装配和管理的对象</strong>。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</p>\n<h2>Spring Bean 定义</h2>\n<h3>BeanDefinition</h3>\n<p>Spring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——<code>BeanDefinition</code> 对象。</p>\n<p><strong><code>BeanDefinition</code> 是 Spring 中定义 Bean 的配置元信息接口</strong>，它包含：</p>",r:{minutes:7.16,words:2147},t:"Spring Bean",y:"a"}}],["/pages/915530/",{loader:()=>t.e(4441).then(t.bind(t,52957)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC"],e:"\n<h2>IoC 简介</h2>\n<h3>IoC 是什么</h3>\n<p><strong>IoC</strong> 即<strong>控制反转</strong>（Inversion of Control，缩写为 IoC）。IoC 又称为<strong>依赖倒置原则</strong>（设计模式六大原则之一），它的要点在于：<strong>程序要依赖于抽象接口，不要依赖于具体实现</strong>。它的作用就是<strong>用于降低代码间的耦合度</strong>。</p>\n<p>IoC 的实现方式有两种：</p>\n<ul>\n<li><strong>依赖注入</strong>（Dependency Injection，简称 DI）：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</li>\n<li><strong>依赖查找</strong>（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。</li>\n</ul>",r:{minutes:23.88,words:7165},t:"Spring IoC",y:"a"}}],["/pages/9a6f6b/",{loader:()=>t.e(6724).then(t.bind(t,90468)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖查找"],e:"\n<p><strong>依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现</strong>。</p>\n<p>IoC 依赖查找大致可以分为以下几类：</p>\n<ul>\n<li>根据 Bean 名称查找</li>\n<li>根据 Bean 类型查找</li>\n<li>根据 Bean 名称 + 类型查找</li>\n<li>根据 Java 注解查找</li>\n</ul>\n<p>此外，根据查找的 Bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 API。</p>\n<h2>单一类型依赖查找</h2>\n<p>单一类型依赖查找接口- <code>BeanFactory</code></p>",r:{minutes:3.05,words:915},t:"Spring 依赖查找",y:"a"}}],["/pages/f61a1c/",{loader:()=>t.e(832).then(t.bind(t,72411)),meta:{d:159880357e4,l:"2020年8月30日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖注入"],e:"\n<p>DI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API。</p>\n<p>依赖注入 (Dependency Injection，简称 DI) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。</p>\n<p>使用 DI，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。</p>",r:{minutes:9.77,words:2931},t:"Spring 依赖注入",y:"a"}}],["/pages/a5f257/",{loader:()=>t.e(9136).then(t.bind(t,33121)),meta:{d:1671568431e3,l:"2022年12月20日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","IOC","依赖注入"],e:'\n<h2>依赖查找的来源</h2>\n<p>查找来源</p>\n<table>\n<thead>\n<tr>\n<th>来源</th>\n<th>配置元数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Spring BeanDefinition</td>\n<td><code>&lt;bean id ="user" class="xxx.xxx.User"&gt;</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>@Bean public User user() {...}</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>BeanDefinitionBuilder</code></td>\n</tr>\n<tr>\n<td>单例对象</td>\n<td>API 实现</td>\n</tr>\n</tbody>\n</table>',r:{minutes:2.33,words:698},t:"Spring IoC 依赖来源",y:"a"}}],["/pages/8289f5/",{loader:()=>t.e(9070).then(t.bind(t,63019)),meta:{d:167162292e4,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring Bean 作用域</h2>\n<table>\n<thead>\n<tr>\n<th>来源</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>singleton</td>\n<td>默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>原型作用域，每次依赖查找和依赖注入生成新 Bean 对象</td>\n</tr>\n<tr>\n<td>request</td>\n<td>将 Spring Bean 存储在 ServletRequest 上下文中</td>\n</tr>\n<tr>\n<td>session</td>\n<td>将 Spring Bean 存储在 HttpSession 中</td>\n</tr>\n<tr>\n<td>application</td>\n<td>将 Spring Bean 存储在 ServletContext 中</td>\n</tr>\n</tbody>\n</table>",r:{minutes:1.34,words:403},t:"Spring Bean 作用域",y:"a"}}],["/pages/4ab176/",{loader:()=>t.e(6149).then(t.bind(t,73057)),meta:{d:1671650761e3,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring Bean 元信息配置阶段</h2>\n<p>BeanDefinition 配置</p>\n<ul>\n<li>面向资源\n<ul>\n<li>XML 配置</li>\n<li>Properties 资源配置</li>\n</ul>\n</li>\n<li>面向注解</li>\n<li>面向 API</li>\n</ul>\n<h2>Spring Bean 元信息解析阶段</h2>\n<ul>\n<li>面向资源 BeanDefinition 解析\n<ul>\n<li>BeanDefinitionReader</li>\n<li>XML 解析器 - BeanDefinitionParser</li>\n</ul>\n</li>\n<li>面向注解 BeanDefinition 解析\n<ul>\n<li>AnnotatedBeanDefinitionReader</li>\n</ul>\n</li>\n</ul>",r:{minutes:2.62,words:787},t:"Spring Bean 生命周期",y:"a"}}],["/pages/55f315/",{loader:()=>t.e(7249).then(t.bind(t,98693)),meta:{d:1671652188e3,l:"2022年12月21日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Bean"],e:"\n<h2>Spring 配置元信息</h2>\n<ul>\n<li>Spring Bean 配置元信息 - BeanDefinition</li>\n<li>Spring Bean 属性元信息 - PropertyValues</li>\n<li>Spring 容器配置元信息</li>\n<li>Spring 外部化配置元信息 - PropertySource</li>\n<li>Spring Profile 元信息 - @Profile</li>\n</ul>\n<h2>Spring Bean 配置元信息</h2>\n<p>Bean 配置元信息 - BeanDefinition</p>\n<ul>\n<li>GenericBeanDefinition：通用型 BeanDefinition</li>\n<li>RootBeanDefinition：无 Parent 的 BeanDefinition 或者合并后 BeanDefinition</li>\n<li>AnnotatedBeanDefinition：注解标注的 BeanDefinition</li>\n</ul>",r:{minutes:5.73,words:1719},t:"Spring 配置元数据",y:"a"}}],["/pages/ad472e/",{loader:()=>t.e(2075).then(t.bind(t,93739)),meta:{d:1671789489e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 应用上下文启动准备阶段</h2>\n<p>AbstractApplicationContext#prepareRefresh() 方法</p>\n<ul>\n<li>启动时间 - startupDate</li>\n<li>状态标识 - closed(false)、active(true)</li>\n<li>初始化 PropertySources - initPropertySources()</li>\n<li>检验 Environment 中必须属性</li>\n<li>初始化事件监听器集合</li>\n<li>初始化早期 Spring 事件集合</li>\n</ul>\n<h2>BeanFactory 创建阶段</h2>",r:{minutes:2.77,words:831},t:"Spring 应用上下文生命周期",y:"a"}}],["/pages/53aedb/",{loader:()=>t.e(4882).then(t.bind(t,60915)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","AOP"],e:"\n<h2>AOP 概念</h2>\n<h3>什么是 AOP</h3>\n<p>AOP(Aspect-Oriented Programming，即 <strong>面向切面编程</strong>)与 OOP( Object-Oriented Programming，面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角。</p>\n<p>在 OOP 中，我们以类(class)作为我们的基本单元，而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>\n<h3>术语</h3>\n<h4>Aspect(切面)</h4>\n<p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br>\nAOP 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p>",r:{minutes:13.7,words:4109},t:"Spring AOP",y:"a"}}],["/pages/a1549f/",{loader:()=>t.e(2754).then(t.bind(t,74134)),meta:{d:1567626401e3,l:"2019年9月4日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","Resource"],e:'\n<blockquote>\n<p>Version 6.0.3</p>\n</blockquote>\n<h2>Resource 接口</h2>\n<p>相对标准 URL 访问机制，Spring 的 <code>org.springframework.core.io.Resource</code> 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Resource</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> InputStreamSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> exists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isReadable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isOpen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> isFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    URL</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getURL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    URI</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getURI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    File</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ReadableByteChannel</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> readableChannel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> contentLength</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> lastModified</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    Resource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> createRelative</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> relativePath</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> IOException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getFilename</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> getDescription</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:7.56,words:2269},t:"Spring 资源管理",y:"a"}}],["/pages/fe6aad/",{loader:()=>t.e(8555).then(t.bind(t,1332)),meta:{d:1671730948e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<p>Java API 规范(<code>JSR303</code>)定义了<code>Bean</code>校验的标准<code>validation-api</code>，但没有提供实现。<code>hibernate validation</code>是对这个规范的实现，并增加了校验注解如<code>@Email</code>、<code>@Length</code>等。<code>Spring Validation</code>是对<code>hibernate validation</code>的二次封装，用于支持<code>spring mvc</code>参数自动校验。</p>",r:{minutes:8.99,words:2696},t:"Spring 校验",y:"a"}}],["/pages/267b4c/",{loader:()=>t.e(6462).then(t.bind(t,34730)),meta:{d:1671737217e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","数据绑定"],e:'\n<p><strong>Spring 数据绑定(Data Binding)的作用是将用户的输入动态绑定到 JavaBean</strong>。换句话说，Spring 数据绑定机制是将属性值设置到目标对象中。</p>\n<p>在 Spring 中，数据绑定功能主要由 <code>DataBinder</code> 类实现。此外，<code>BeanWrapper</code> 也具有类似的功能，但 <code>DataBinder</code> 额外支持字段验证、字段格式化和绑定结果分析。</p>\n<figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230111150930.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',r:{minutes:3.22,words:967},t:"Spring 数据绑定",y:"a"}}],["/pages/6662dc/",{loader:()=>t.e(551).then(t.bind(t,15861)),meta:{d:1671738239e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 类型转换的实现</h2>\n<ul>\n<li>基于 JavaBeans 接口的类型转换实现\n<ul>\n<li>基于 java.beans.PropertyEditor 接口扩展</li>\n</ul>\n</li>\n<li>Spring 3.0+ 通用类型转换实现</li>\n</ul>\n<h2>使用场景</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>基于 JavaBeans 接口的类型转换实现</th>\n<th>Spring 3.0+ 通用类型转换实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据绑定</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>BeanWrapper</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Bean 属性类型转换</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>外部化属性类型转换</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>",r:{minutes:3.49,words:1047},t:"Spring 类型转换",y:"a"}}],["/pages/1f743f/",{loader:()=>t.e(4407).then(t.bind(t,93191)),meta:{d:1673555206e3,l:"2023年1月12日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:'\n<h2>参考资料</h2>\n<ul>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener noreferrer">Spring 官方文档之 Core Technologies</a></li>\n<li><a href="https://time.geekbang.org/course/intro/265" target="_blank" rel="noopener noreferrer">《小马哥讲 Spring 核心编程思想》</a></li>\n</ul>',r:{minutes:.22,words:66},t:"Spring EL 表达式",y:"a"}}],["/pages/cca414/",{loader:()=>t.e(6768).then(t.bind(t,12330)),meta:{d:1671741062e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Java 事件/监听器编程模型</h2>\n<p>设计模式 - 观察者模式扩展</p>\n<ul>\n<li>可观者对象（消息发送者） - java.util.Observable</li>\n<li>观察者 - java.util.Observer</li>\n</ul>\n<p>标准化接口</p>\n<ul>\n<li>事件对象 - java.util.EventObject</li>\n<li>事件监听器 - java.util.EventListener</li>\n</ul>\n<h2>面向接口的事件/监听器设计模式</h2>\n<p>事件/监听器场景举例</p>\n<table>\n<thead>\n<tr>\n<th>Java 技术规范</th>\n<th>事件接口</th>\n<th>监听器接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JavaBeans</td>\n<td>java.beans.PropertyChangeEvent</td>\n<td>java.beans.PropertyChangeListener</td>\n</tr>\n<tr>\n<td>Java AWT</td>\n<td>java.awt.event.MouseEvent</td>\n<td>java.awt.event.MouseListener</td>\n</tr>\n<tr>\n<td>Java Swing</td>\n<td>javax.swing.event.MenuEvent</td>\n<td>javax.swing.event.MenuListener</td>\n</tr>\n<tr>\n<td>Java Preference</td>\n<td>java.util.prefs.PreferenceChangeEvent</td>\n<td>java.util.prefs.PreferenceChangeListener</td>\n</tr>\n</tbody>\n</table>",r:{minutes:3.98,words:1194},t:"Spring 事件",y:"a"}}],["/pages/b5b8ad/",{loader:()=>t.e(7504).then(t.bind(t,32390)),meta:{d:1671709494e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 国际化使用场景</h2>\n<ul>\n<li>普通国际化文案</li>\n<li>Bean Validation 校验国际化文案</li>\n<li>Web 站点页面渲染</li>\n<li>Web MVC 错误消息提示</li>\n</ul>\n<h2>Spring 国际化接口</h2>\n<ul>\n<li>核心接口：<code>org.springframework.context.MessageSource</code></li>\n<li>主要概念\n<ul>\n<li>文案模板编码（code）</li>\n<li>文案模板参数（args）</li>\n<li>区域（Locale）</li>\n</ul>\n</li>\n</ul>",r:{minutes:1.69,words:507},t:"Spring 国际化",y:"a"}}],["/pages/175cbd/",{loader:()=>t.e(4736).then(t.bind(t,78724)),meta:{d:1671739912e3,l:"2022年12月22日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Java 泛型基础</h2>\n<p>泛型类型</p>\n<ul>\n<li>泛型类型是在类型上参数化的泛型类或接口</li>\n</ul>\n<p>泛型使用场景</p>\n<ul>\n<li>编译时强类型检查</li>\n<li>避免类型强转</li>\n<li>实现通用算法</li>\n</ul>\n<p>泛型类型擦写</p>\n<ul>\n<li>泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会<br>\n为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n<ul>\n<li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为<br>\n“Object”。因此，生成的字节码只包含普通类、接口和方法</li>\n<li>必要时插入类型转换以保持类型安全</li>\n<li>生成桥方法以保留扩展泛型类型中的多态性</li>\n</ul>\n</li>\n</ul>",r:{minutes:2.53,words:758},t:"Spring 泛型处理",y:"a"}}],["/pages/b6556f/",{loader:()=>t.e(6492).then(t.bind(t,37939)),meta:{d:1671786495e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>Spring 注解驱动编程发展历程</h2>\n<ul>\n<li>注解驱动启蒙时代：Spring Framework 1.x</li>\n<li>注解驱动过渡时代：Spring Framework 2.x</li>\n<li>注解驱动黄金时代：Spring Framework 3.x</li>\n<li>注解驱动完善时代：Spring Framework 4.x</li>\n<li>注解驱动当下时代：Spring Framework 5.x</li>\n</ul>\n<h2>Spring 核心注解场景分类</h2>\n<p>Spring 模式注解</p>\n<table>\n<thead>\n<tr>\n<th>Spring 注解</th>\n<th>场景说明</th>\n<th>起始版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Repository</td>\n<td>数据仓储模式注解</td>\n<td>2.0</td>\n</tr>\n<tr>\n<td>@Component</td>\n<td>通用组件模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Service</td>\n<td>服务模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Controller</td>\n<td>Web 控制器模式注解</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>@Configuration</td>\n<td>配置类模式注解</td>\n<td>3.0</td>\n</tr>\n</tbody>\n</table>",r:{minutes:2.48,words:745},t:"Spring 注解",y:"a"}}],["/pages/03d838/",{loader:()=>t.e(1592).then(t.bind(t,6554)),meta:{d:1671787664e3,l:"2022年12月23日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring"],e:"\n<h2>理解 Spring Environment 抽象</h2>\n<p>统一的 Spring 配置属性管理</p>\n<p>Spring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）</p>\n<p>条件化 Spring Bean 装配管理</p>\n<p>通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean</p>\n<h2>Spring Environment 接口使用场景</h2>",r:{minutes:2.28,words:684},t:"Spring Environment 抽象",y:"a"}}],["/pages/950e4d/",{loader:()=>t.e(7887).then(t.bind(t,339)),meta:{d:1639160546e3,l:"2021年12月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>Spring Boot 简介</h2>\n<p>Spring Boot 可以让使用者非常方便的创建 Spring 应用。</p>\n<p>Spring Boot 的目标是：</p>\n<ul>\n<li>为所有 Spring 开发者提供更快且可广泛访问的入门体验。</li>\n<li>开箱即用</li>\n<li>提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）</li>\n<li>完全不需要代码生成，也不需要 XML 配置。</li>\n</ul>\n<h2>Spring Boot 系统要求</h2>\n<p>Spring Boot 的构建工具要求：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">Build Tool</th>\n<th style="text-align:left">Version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">Maven</td>\n<td style="text-align:left">3.5+</td>\n</tr>\n<tr>\n<td style="text-align:left">Gradle</td>\n<td style="text-align:left">6.8.x, 6.9.x, and 7.x</td>\n</tr>\n</tbody>\n</table>',r:{minutes:7.74,words:2321},t:"SpringBoot 之快速入门",y:"a"}}],["/pages/0fb992/",{loader:()=>t.e(7882).then(t.bind(t,33833)),meta:{d:1547121354e3,l:"2019年1月10日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>加载 property 顺序</h2>\n<p>Spring Boot 加载 property 顺序如下：</p>\n<ol>\n<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-devtools-globalsettings" target="_blank" rel="noopener noreferrer">Devtools 全局配置</a> (当 devtools 被激活 <code>~/.spring-boot-devtools.properties</code>).</li>\n<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener noreferrer">测试环境中的 <code>@TestPropertySource</code> 注解配置</a></li>\n<li>测试环境中的属性 <code>properties</code>：<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener noreferrer"><code>@SpringBootTest</code></a> 和 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener noreferrer">测试注解</a>.</li>\n<li>命令行参数</li>\n<li><code>SPRING_APPLICATION_JSON</code> 属性</li>\n<li><code>ServletConfig</code> 初始化参数</li>\n<li><code>ServletContext</code> 初始化参数</li>\n<li>JNDI attributes from 通过 <code>java:comp/env</code> 配置的 JNDI 属性</li>\n<li>Java 系统属性 (<code>System.getProperties()</code>)</li>\n<li>操作系统环境比那里</li>\n<li><code>RandomValuePropertySource</code> 加载 <code>random.*</code> 形式的属性</li>\n<li>jar 包外的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 配置</li>\n<li>jar 包内的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 配置</li>\n<li>jar 包外的 <code>application.properties</code> 或 <code>application.yml</code> 配置</li>\n<li>jar 包内的 <code>application.properties</code> 或 <code>application.yml</code> 配置</li>\n<li><code>@PropertySource</code> 绑定的配置</li>\n<li>默认属性 (通过 <code>SpringApplication.setDefaultProperties</code> 指定)</li>\n</ol>',r:{minutes:4.9,words:1470},t:"SpringBoot 之属性加载详解",y:"a"}}],["/pages/cb598e/",{loader:()=>t.e(9886).then(t.bind(t,73723)),meta:{d:1574088901e3,l:"2019年11月18日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:"\n<blockquote>\n<p>一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。</p>\n<p>关键词： <code>@Profile</code>、<code>spring.profiles.active</code></p>\n</blockquote>\n<h2>区分环境的配置</h2>\n<h3>properties 配置</h3>\n<p>假设，一个应用的工作环境有：dev、test、prod</p>\n<p>那么，我们可以添加 4 个配置文件：</p>\n<ul>\n<li><code>applcation.properties</code> - 公共配置</li>\n<li><code>application-dev.properties</code> - 开发环境配置</li>\n<li><code>application-test.properties</code> - 测试环境配置</li>\n<li><code>application-prod.properties</code> - 生产环境配置</li>\n</ul>",r:{minutes:1.92,words:575},t:"SpringBoot 之 Profile",y:"a"}}],["/pages/5e7c20/",{loader:()=>t.e(2508).then(t.bind(t,19115)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring核心"],g:["Java","框架","Spring","SpringBoot"],e:'\n<blockquote>\n<p>章节主要针对：Spring &amp; Spring Boot 框架的核心技术。如；Spring Bean、IoC、依赖查找、依赖注入、AOP、数据绑定、资源管理等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html" target="_blank">Spring Bean</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html" target="_blank">Spring IoC</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html" target="_blank">Spring 依赖查找</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html" target="_blank">Spring 依赖注入</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html" target="_blank">Spring IoC 依赖来源</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html" target="_blank">Spring Bean 作用域</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" target="_blank">Spring Bean 生命周期</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html" target="_blank">Spring 配置元数据</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html" target="_blank">Spring AOP</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html" target="_blank">Spring 资源管理</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html" target="_blank">Spring 校验</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html" target="_blank">Spring 数据绑定</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html" target="_blank">Spring 类型转换</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html" target="_blank">Spring EL 表达式</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html" target="_blank">Spring 事件</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html" target="_blank">Spring 国际化</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html" target="_blank">Spring 泛型处理</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html" target="_blank">Spring 注解</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html" target="_blank">SpringBoot 教程之快速入门</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html" target="_blank">SpringBoot 之属性加载</a></li>\n<li><a href="/blog/posts/java/spring/01-Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html" target="_blank">SpringBoot 之 Profile</a></li>\n</ul>',r:{minutes:1.15,words:344},t:"Spring 核心",y:"a"}}],["/pages/1b774c/",{loader:()=>t.e(7106).then(t.bind(t,49977)),meta:{d:1508491675e3,l:"2017年10月20日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","数据库","DataSource"],e:'\n<blockquote>\n<p>本文基于 Spring Boot 2.7.3 版本。</p>\n</blockquote>\n<h2>Spring Boot 数据源基本配置</h2>\n<p>Spring Boot 提供了一系列 <code>spring.datasource.*</code> 配置来控制 <code>DataSource</code> 的配置。用户可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中指定数据源配置。这些配置项维护在 <a href="https://github.com/spring-projects/spring-boot/tree/v2.7.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java" target="_blank" rel="noopener noreferrer"><code>DataSourceProperties</code></a> 。</p>',r:{minutes:10.39,words:3117},t:"Spring 之数据源",y:"a"}}],["/pages/cf19fd/",{loader:()=>t.e(6435).then(t.bind(t,55490)),meta:{d:1550500435e3,l:"2019年2月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","JDBC","JdbcTemplate"],e:"\n<p>JDBC 是 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。</p>\n<h2>JDBC 入门示例</h2>\n<p>JDBC 的工作步骤大致如下：</p>\n<ol>\n<li>创建实体类。</li>\n<li>声明数据库读写接口的 DAO 接口。定义 DAO 的好处在于对于数据层上层的业务，调用 DAO 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。</li>\n<li>创建一个 DAO 接口的实现类，使用 Spring 的 JDBC 模板去实现接口。</li>\n<li>最后，定义一个 DAO 接口的实现类的 JavaBean，并将数据源注入进去。</li>\n</ol>",r:{minutes:9.71,words:2912},t:"Spring 之 JDBC",y:"a"}}],["/pages/128c54/",{loader:()=>t.e(9881).then(t.bind(t,57365)),meta:{d:1663832809e3,l:"2022年9月22日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","事务"],e:"\n<p>Spring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 <code>@Transactional</code> 注解，即可一键开启方法的事务性配置。</p>\n<h2>理解事务</h2>\n<p>在软件开发领域，全有或全无的操作被称为<strong>事务（transaction）</strong>。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：<strong>全局事务</strong>或<strong>本地事务</strong>，两者都有很大的局限性。</p>",r:{minutes:43.32,words:12995},t:"Spring 之事务",y:"a"}}],["/pages/a03d7b/",{loader:()=>t.e(4429).then(t.bind(t,62350)),meta:{d:1550500435e3,l:"2019年2月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","JPA"],e:'\n<p>JPA 为对象关系映射提供了一种基于 POJO 的持久化模型。</p>\n<ul>\n<li>简化数据持久化代码的开发</li>\n<li>为 Java 社区屏蔽不同持久化 API 的差异</li>\n</ul>\n<h2>快速入门</h2>\n<p>（1）在 pom.xml 中引入依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-data-jpa&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:10.65,words:3196},t:"Spring 之 JPA",y:"a"}}],["/pages/88219e/",{loader:()=>t.e(6405).then(t.bind(t,28065)),meta:{d:1557421765e3,l:"2019年5月9日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","MyBatis","PageHelper","Mapper"],e:'\n<p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener noreferrer">Mybatis 官网</a> 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<h2>快速入门</h2>\n<p>要使用 MyBatis， 只需将 <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener noreferrer">mybatis-x.x.x.jar</a> 文件置于类路径（classpath）中即可。</p>',r:{minutes:11.95,words:3586},t:"Spring 集成 Mybatis",y:"a"}}],["/pages/191cdb/",{loader:()=>t.e(8742).then(t.bind(t,51291)),meta:{d:1675847435e3,l:"2023年2月8日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot"],e:"\n<p>Spring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。</p>\n<h2>核心概念</h2>\n<p>Repository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。<code>CrudRepository</code> 和 <code>ListCrudRepository</code> 接口为被管理的实体类提供复杂的 CRUD 功能。<code>ListCrudRepository</code> 提供等效方法，但它们返回 <code>List</code>，而 <code>CrudRepository</code> 方法返回 <code>Iterable</code>。</p>",r:{minutes:6.76,words:2028},t:"Spring Data 综合",y:"a"}}],["/pages/65e4a2/",{loader:()=>t.e(97).then(t.bind(t,28752)),meta:{d:1675198482e3,l:"2023年1月31日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","Redis"],e:'\n<h2>简介</h2>\n<p><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。</p>\n<p>在 Spring 中，<a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener noreferrer">spring-data-redis</a> 项目对访问 <a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> 进行了 API 封装，提供了便捷的访问方式。 <a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener noreferrer">spring-data-redis</a></p>',r:{minutes:2.58,words:773},t:"Spring 访问 Redis",y:"a"}}],["/pages/db2a41/",{loader:()=>t.e(6258).then(t.bind(t,697)),meta:{d:1544894976e3,l:"2018年12月15日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","MongoDB"],e:'\n<h2>简介</h2>\n<p><a href="https://www.mongodb.org/" target="_blank" rel="noopener noreferrer">MongoDB</a> 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>\n<p>在 Spring 中，<a href="https://github.com/spring-projects/spring-data-mongodb" target="_blank" rel="noopener noreferrer">spring-data-mongodb</a> 项目对访问 <a href="https://www.mongodb.org/" target="_blank" rel="noopener noreferrer">MongoDB</a> 进行了 API 封装，提供了便捷的访问方式。 Spring Data MongoDB 的核心是一个以 POJO 为中心的模型，用于与 MongoDB <code>DBCollection</code> 交互并轻松编写 <code>Repository</code> 样式的数据访问层。</p>',r:{minutes:2.73,words:819},t:"Spring 访问 MongoDB",y:"a"}}],["/pages/fac14c/",{loader:()=>t.e(9638).then(t.bind(t,56481)),meta:{d:1545746796e3,l:"2018年12月25日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","Elasticsearch"],e:'\n<h2>简介</h2>\n<p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer">Elasticsearch</a> 是一个开源的、分布式的搜索和分析引擎。</p>\n<h3>通过 REST 客户端连接 Elasticsearch</h3>\n<p>如果在 classpath 路径下存在 <code>org.elasticsearch.client:elasticsearch-rest-client</code> jar 包，Spring Boot 会自动配置并注册一个 <code>RestClient</code> Bean，它的默认访问路径为：<code>localhost:9200</code>。</p>',r:{minutes:2.36,words:709},t:"Spring 访问 Elasticsearch",y:"a"}}],["/pages/b912d1/",{loader:()=>t.e(7143).then(t.bind(t,90665)),meta:{d:1663499136e3,l:"2022年9月18日",c:["Java","框架","Spring","Spring数据"],g:["Java","框架","Spring","SpringBoot","数据库"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html" target="_blank">Spring 之数据源</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html" target="_blank">Spring 之 JDBC</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html" target="_blank">Spring 之事务</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html" target="_blank">Spring 之 JPA</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html" target="_blank">Spring 集成 Mybatis</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html" target="_blank">Spring 访问 Redis</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html" target="_blank">Spring 访问 MongoDB</a></li>\n<li><a href="/blog/posts/java/spring/02-Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html" target="_blank">Spring 访问 Elasticsearch</a></li>\n</ul>',r:{minutes:2.09,words:628},t:"Spring 数据篇",y:"a"}}],["/pages/65351b/",{loader:()=>t.e(5372).then(t.bind(t,12372)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web"],e:'\n<h2>快速入门</h2>\n<p>下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。</p>\n<p>（1）<code>pom.xml</code> 中引入依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-web&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.42,words:727},t:"Spring Web 综述",y:"a"}}],["/pages/5d002f/",{loader:()=>t.e(3379).then(t.bind(t,49189)),meta:{d:1676402482e3,l:"2023年2月14日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","Controller"],e:'\n<p>Spring MVC 提供了一种基于注解的编程模型，<code>@Controller</code> 和 <code>@RestController</code> 组件使用注解来表达请求映射、请求输入、异常处理等。注解控制器具有灵活的方法签名，并且不必扩展基类或实现特定接口。以下示例显示了一个由注解定义的控制器：</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">Controller</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> HelloController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">GetMapping</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"/hello"</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> handle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Model</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> model</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B">        model</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">addAttribute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"message"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"Hello World!"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379"> "index"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:23.03,words:6909},t:"Spring Web 应用",y:"a"}}],["/pages/20287b/",{loader:()=>t.e(1259).then(t.bind(t,65465)),meta:{d:1676282272e3,l:"2023年2月13日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","DispatcherServlet"],e:'\n<h2>简介</h2>\n<p><code>DispatcherServlet</code> 是 Spring MVC 框架的核心组件，负责将<strong>客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果</strong>。</p>\n<h3>DispatcherServlet 工作原理</h3>\n<h4>DispatcherServlet 工作流程</h4>\n<p><code>DispatcherServlet</code> 的工作流程大致如下图所示：</p>\n<figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',r:{minutes:25.97,words:7791},t:"Spring MVC 之 DispatcherServlet",y:"a"}}],["/pages/4a164d/",{loader:()=>t.e(5842).then(t.bind(t,89148)),meta:{d:1676396649e3,l:"2023年2月14日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","Filter"],e:'\n<p><code>spring-web</code> 模块提供了一些有用的 Filter：</p>\n<ul>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-http-put" target="_blank" rel="noopener noreferrer">Form Data</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-forwarded-headers" target="_blank" rel="noopener noreferrer">Forwarded Headers</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-shallow-etag" target="_blank" rel="noopener noreferrer">Shallow ETag</a></li>\n<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#filters-cors" target="_blank" rel="noopener noreferrer">CORS</a></li>\n</ul>',r:{minutes:3.26,words:979},t:"Spring MVC 之过滤器",y:"a"}}],["/pages/1d2954/",{loader:()=>t.e(1987).then(t.bind(t,70579)),meta:{d:1676579606e3,l:"2023年2月16日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","CORS"],e:'\n<p>Spring MVC 支持跨域处理（CORS）。</p>\n<h2>简介</h2>\n<p>出于安全原因，浏览器禁止对当前源之外的资源进行 AJAX 调用。例如，可以在一个选项卡中使用您的银行帐户，而在另一个选项卡中使用 <a href="http://evil.com" target="_blank" rel="noopener noreferrer">evil.com</a>。来自 <a href="http://evil.com" target="_blank" rel="noopener noreferrer">evil.com</a> 的脚本不应该能够使用您的凭据向您的银行 API 发出 AJAX 请求——例如从您的账户中取款！</p>',r:{minutes:4.7,words:1409},t:"Spring MVC 之跨域",y:"a"}}],["/pages/251e31/",{loader:()=>t.e(8345).then(t.bind(t,35580)),meta:{d:1676632885e3,l:"2023年2月17日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","Web","View"],e:'\n<p>Spring MVC 中视图技术的使用是可插拔的。无论决定使用 Thymeleaf、Groovy 等模板引擎、JSP 还是其他技术，都可以通过配置来更改。</p>\n<p>Spring MVC 的视图位于该应用程序的内部信任边界内。 视图可以访问应用程序上下文的所有 bean。 因此，不建议在模板可由外部源编辑的应用程序中使用 Spring MVC 的模板支持，因为这可能会产生安全隐患。</p>\n<h2>Thymeleaf</h2>\n<p><a href="https://www.thymeleaf.org/" target="_blank" rel="noopener noreferrer">Thymeleaf</a> 是一个现代服务器端 Java 模板引擎，它强调自然的 HTML 模板，可以通过双击在浏览器中预览，而无需运行服务器，这对于 UI 模板的独立工作（例如，由设计师）非常有帮助。</p>',r:{minutes:19.63,words:5888},t:"Spring MVC 之视图技术",y:"a"}}],["/pages/ad0516/",{loader:()=>t.e(3599).then(t.bind(t,42854)),meta:{d:1546967974e3,l:"2019年1月8日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","SpringBoot","Web"],e:"\n<blockquote>\n<p>EasyUI 是一个简单的用户界面组件的集合。由于 EasyUI 已经封装好大部分 UI 基本功能，能帮用户减少大量的 js 和 css 代码。所以，EasyUI 非常适合用于开发简单的系统或原型系统。</p>\n<p>本文示例使用技术点：</p>\n<ul>\n<li>Spring Boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa</li>\n<li>EasyUI：按需加载，并没有引入所有的 EasyUI 特性</li>\n<li>数据库：为了测试方便，使用 H2</li>\n</ul>\n</blockquote>",r:{minutes:4.71,words:1413},t:"SpringBoot 之应用 EasyUI",y:"a"}}],["/pages/e2586a/",{loader:()=>t.e(6929).then(t.bind(t,80247)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","SpringWeb"],g:["Java","框架","Spring","SpringBoot","Web"],e:'\n<blockquote>\n<p>章节主要针对：Spring 在 web 领域的应用。如：Spring MVC、WebSocket 等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/01.SpringWeb%E7%BB%BC%E8%BF%B0.html" target="_blank">SpringWeb 综述</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/02.SpringWeb%E5%BA%94%E7%94%A8.html" target="_blank">SpringWeb 应用</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/03.DispatcherServlet.html" target="_blank">DispatcherServlet</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/04.Spring%E8%BF%87%E6%BB%A4%E5%99%A8.html" target="_blank">Spring 过滤器</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/05.Spring%E8%B7%A8%E5%9F%9F.html" target="_blank">Spring 跨域</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/06.Spring%E8%A7%86%E5%9B%BE.html" target="_blank">Spring 视图</a></li>\n<li><a href="/blog/posts/java/spring/03-SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html" target="_blank">SpringBoot 之应用 EasyUI</a></li>\n</ul>',r:{minutes:.6,words:179},t:"Spring Web",y:"a"}}],["/pages/92add2/",{loader:()=>t.e(8610).then(t.bind(t,82199)),meta:{d:1574088901e3,l:"2019年11月18日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","异步"],e:'\n<h2><code>@EnableAsync</code> 注解</h2>\n<p>要使用 <code>@Async</code>，首先需要使用 <code>@EnableAsync</code> 注解开启 Spring Boot 中的异步特性。</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">Configuration</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B">EnableAsync</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:3,words:899},t:"spring-boot-async",y:"a"}}],["/pages/676725/",{loader:()=>t.e(8323).then(t.bind(t,35749)),meta:{d:1546208656e3,l:"2018年12月30日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","JSON"],e:"\n<h2>简介</h2>\n<h3>Spring Boot 支持的 Json 库</h3>\n<p>Spring Boot 支持三种 Json 库：</p>\n<ul>\n<li>Gson</li>\n<li>Jackson</li>\n<li>JSON-B</li>\n</ul>\n<p><strong>Jackson 是 Spring Boot 官方推荐的默认库。</strong></p>\n<p>Spring Boot 提供了 Jackson 的自动配置，Jackson 是 <code>spring-boot-starter-json</code> 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。</p>",r:{minutes:5.75,words:1726},t:"SpringBoot 之集成 Json",y:"a"}}],["/pages/2586f1/",{loader:()=>t.e(3568).then(t.bind(t,67723)),meta:{d:1574263244e3,l:"2019年11月20日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","邮件"],e:'\n<h2>简介</h2>\n<p>Spring Boot 收发邮件最简便方式是通过 <code>spring-boot-starter-mail</code>。</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-mail&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.96,words:889},t:"SpringBoot 之发送邮件",y:"a"}}],["/pages/56581b/",{loader:()=>t.e(83).then(t.bind(t,32110)),meta:{d:166350084e4,l:"2022年9月18日",c:["Java","框架","Spring","SpringIO"],g:["Java","框架","Spring","SpringBoot","IO"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/04-SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html" target="_blank">SpringBoot 之异步请求</a></li>\n<li><a href="/blog/posts/java/spring/04-SpringIO/02.SpringBoot%E4%B9%8BJson.html" target="_blank">SpringBoot 之 Json</a></li>\n<li><a href="/blog/posts/java/spring/04-SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html" target="_blank">SpringBoot 之邮件</a></li>\n</ul>',r:{minutes:.46,words:139},t:"Spring IO",y:"a"}}],["/pages/a311cb/",{loader:()=>t.e(7289).then(t.bind(t,87073)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","缓存"],e:'\n<blockquote>\n<p>Spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。</p>\n</blockquote>\n<h2>缓存接口</h2>\n<p>Spring 的缓存 API 以注解方式提供。</p>\n<h3>开启注解</h3>\n<p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。<br>\n你有两个选择：<br>\n(1) 在 xml 中声明<br>\n像上一节 spring-ehcache.xml 中的做法一样，使用<code>&lt;cache:annotation-driven/&gt;</code></p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">cache:annotation-driven</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66"> cache-manager</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">"cacheManager"</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">/&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div></div></div>',r:{minutes:4.08,words:1223},t:"Spring集成缓存",y:"a"}}],["/pages/a187f0/",{loader:()=>t.e(3591).then(t.bind(t,634)),meta:{d:1510160007e3,l:"2017年11月8日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","调度器"],e:'\n<h2>概述</h2>\n<p>如果想在 Spring 中使用任务调度功能，除了集成调度框架 Quartz 这种方式，也可以使用 Spring 自己的调度任务框架。<br>\n使用 Spring 的调度框架，优点是：支持注解<code>@Scheduler</code>，可以省去大量的配置。</p>\n<h2>实时触发调度任务</h2>\n<h3>TaskScheduler 接口</h3>\n<p>Spring3 引入了<code>TaskScheduler</code>接口，这个接口定义了调度任务的抽象方法。<br>\nTaskScheduler 接口的声明：</p>\n<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> TaskScheduler</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> schedule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Trigger</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> trigger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> schedule</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleAtFixedRate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> period</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleAtFixedRate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> period</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleWithFixedDelay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Date</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> startTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> delay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">    ScheduledFuture</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> scheduleWithFixedDelay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B">Runnable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic"> delay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:6.67,words:2002},t:"Spring 集成调度器",y:"a"}}],["/pages/274fd7/",{loader:()=>t.e(4334).then(t.bind(t,83988)),meta:{d:1509125441e3,l:"2017年10月27日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","集成","Dubbo"],e:'\n<h2>ZooKeeper</h2>\n<p>ZooKeeper 可以作为 Dubbo 的注册中心。</p>\n<p>Dubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。</p>\n<p><strong>安装</strong></p>\n<p>在 <a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener noreferrer">ZooKeeper 发布中心</a> 选择需要的版本，下载后解压到本地。</p>',r:{minutes:3.64,words:1091},t:"Spring集成Dubbo",y:"a"}}],["/pages/d6025b/",{loader:()=>t.e(8049).then(t.bind(t,79442)),meta:{d:1582760867e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring集成"],g:["Java","框架","Spring","SpringBoot","集成"],e:'\n<blockquote>\n<p>章节主要针对：Spring 与第三方框架、库集成。如：Cache、Scheduling、JMS、JMX 等。</p>\n</blockquote>\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html" target="_blank">Spring 集成缓存中间件</a></li>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html" target="_blank">Spring 集成定时任务中间件</a></li>\n<li><a href="/blog/posts/java/spring/05-Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html" target="_blank">Spring 集成 Dubbo</a></li>\n</ul>',r:{minutes:.59,words:177},t:"Spring 集成",y:"a"}}],["/pages/568352/",{loader:()=>t.e(2871).then(t.bind(t,15712)),meta:{d:1620930116e3,l:"2021年5月13日",c:["Java","框架","Spring","Spring安全"],g:["Java","框架","Spring","SpringBoot","安全"],e:'\n<h2>QuickStart</h2>\n<p>（1）添加依赖</p>\n<div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-web&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t\t&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;spring-boot-starter-security&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">\t\t&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">&gt;</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:.46,words:138},t:"SpringBoot 之安全快速入门",y:"a"}}],["/pages/752c6a/",{loader:()=>t.e(8768).then(t.bind(t,38339)),meta:{d:1513350632e3,l:"2017年12月15日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring"],e:"\n<h2>前言</h2>\n<p>最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 JDK8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。</p>\n<p>总之，这是个费劲的活啊。</p>\n<p>本文小结一下升级 Spring4 的连锁问题。</p>\n<h2>为什么升级 spring4</h2>\n<p>升级 Spring4 的原因是：Spring 4 以前的版本不兼容 JDK8。当你的项目同时使用 Spring3 和 JDK8，如果代码中有使用 JDK8 字节码或 Lambada 表达式，那么会出问题。</p>",r:{minutes:7.37,words:2210},t:"Spring 4 升级踩雷指南",y:"a"}}],["/pages/bac2ce/",{loader:()=>t.e(8242).then(t.bind(t,12395)),meta:{d:1545434564e3,l:"2018年12月21日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>简介</h2>\n<p>Spring Boot 启动时默认会显示以下 LOGO：</p>\n<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  .   ____          _            __ _ _</span></span>\n<span class="line"><span> /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</span></span>\n<span class="line"><span>( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\</span></span>\n<span class="line"><span> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span></span>\n<span class="line"><span>  \'  |____| .__|_| |_|_| |_\\__, | / / / /</span></span>\n<span class="line"><span> =========|_|==============|___/=/_/_/_/</span></span>\n<span class="line"><span> :: Spring Boot ::        (v2.1.1.RELEASE)</span></span></code></pre>\n<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',r:{minutes:2.42,words:727},t:"SpringBoot 之 banner 定制",y:"a"}}],["/pages/c013cc/",{loader:()=>t.e(6251).then(t.bind(t,41863)),meta:{d:1655239882e3,l:"2022年6月14日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.7.0/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener noreferrer"><code>spring-boot-actuator</code></a> 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 <code>spring-boot-starter-actuator</code> 依赖。</p>\n<p>如果是 Maven 项目，添加以下依赖：</p>',r:{minutes:9.96,words:2988},t:"SpringBoot Actuator 快速入门",y:"a"}}],["/pages/6bb8c1/",{loader:()=>t.e(8288).then(t.bind(t,86304)),meta:{d:1582760886e3,l:"2020年2月26日",c:["Java","框架","Spring","Spring其他"],g:["Java","框架","Spring","SpringBoot"],e:'\n<h2>📖 内容</h2>\n<ul>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html" target="_blank">Spring4 升级</a></li>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html" target="_blank">SpringBoot 之 banner</a></li>\n<li><a href="/blog/posts/java/spring/99-Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html" target="_blank">SpringBoot 之 Actuator</a></li>\n</ul>',r:{minutes:.44,words:133},t:"Spring 其他",y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html",{loader:()=>t.e(8805).then(t.bind(t,47631)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>日志</p>\n",r:{minutes:1.91,words:573},t:"日志",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",{loader:()=>t.e(4198).then(t.bind(t,72581)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>类加载器</p>\n",r:{minutes:4.07,words:1220},t:"类加载器",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html",{loader:()=>t.e(6679).then(t.bind(t,54101)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>xml</p>\n",r:{minutes:9.68,words:2905},t:"xml",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",{loader:()=>t.e(1148).then(t.bind(t,77365)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>单元测试Junit</p>\n",r:{minutes:4.05,words:1216},t:"单元测试Junit",i:"pen-to-square",O:1,y:"a"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html",{loader:()=>t.e(5825).then(t.bind(t,12741)),meta:{a:[{name:"xuyong"},{name:"黑马程序员"}],d:16771968e5,l:"2023年2月24日",c:["java"],g:["java-basic"],e:"<p>注解</p>\n",r:{minutes:3.29,words:988},t:"注解",i:"pen-to-square",O:1,y:"a"}}],["/404.html",{loader:()=>t.e(7490).then(t.bind(t,81489)),meta:{t:""}}],["/posts/",{loader:()=>t.e(8666).then(t.bind(t,18063)),meta:{t:"Posts"}}],["/posts/linux/",{loader:()=>t.e(1343).then(t.bind(t,29772)),meta:{t:"Linux"}}],["/posts/idea/",{loader:()=>t.e(9824).then(t.bind(t,21838)),meta:{t:"Idea"}}],["/posts/mysql/",{loader:()=>t.e(3191).then(t.bind(t,25626)),meta:{t:"Mysql"}}],["/posts/network/",{loader:()=>t.e(183).then(t.bind(t,45998)),meta:{t:"Network"}}],["/posts/redis/",{loader:()=>t.e(2110).then(t.bind(t,58243)),meta:{t:"Redis"}}],["/posts/shell/",{loader:()=>t.e(5443).then(t.bind(t,95748)),meta:{t:"Shell"}}],["/posts/windows/",{loader:()=>t.e(2912).then(t.bind(t,72190)),meta:{t:"Windows"}}],["/posts/java/basic/",{loader:()=>t.e(3086).then(t.bind(t,33465)),meta:{t:"Basic"}}],["/posts/java/",{loader:()=>t.e(4895).then(t.bind(t,31919)),meta:{t:"Java"}}],["/posts/java/bug/",{loader:()=>t.e(5489).then(t.bind(t,89461)),meta:{t:"Bug"}}],["/posts/java/dependence/",{loader:()=>t.e(1133).then(t.bind(t,28682)),meta:{t:"Dependence"}}],["/posts/java/netty/",{loader:()=>t.e(584).then(t.bind(t,21103)),meta:{t:"Netty"}}],["/posts/java/spring/",{loader:()=>t.e(9385).then(t.bind(t,85793)),meta:{t:"Spring"}}],["/posts/java/springboot/",{loader:()=>t.e(861).then(t.bind(t,29432)),meta:{t:"Springboot"}}],["/posts/java/web/",{loader:()=>t.e(8458).then(t.bind(t,83749)),meta:{t:"Web"}}],["/posts/python/django/",{loader:()=>t.e(3521).then(t.bind(t,12691)),meta:{t:"Django"}}],["/posts/python/",{loader:()=>t.e(1285).then(t.bind(t,65169)),meta:{t:"Python"}}],["/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/",{loader:()=>t.e(6350).then(t.bind(t,731)),meta:{t:"01 Java入门"}}],["/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/",{loader:()=>t.e(451).then(t.bind(t,84459)),meta:{t:"02 Java基础概念"}}],["/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/",{loader:()=>t.e(4970).then(t.bind(t,36991)),meta:{t:"03 Java运算符"}}],["/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/",{loader:()=>t.e(7060).then(t.bind(t,75751)),meta:{t:"04 判断和循环"}}],["/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/",{loader:()=>t.e(9143).then(t.bind(t,20219)),meta:{t:"05 循环高级和数组"}}],["/posts/java/basic/06-%E6%96%B9%E6%B3%95/",{loader:()=>t.e(9794).then(t.bind(t,39713)),meta:{t:"06 方法"}}],["/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/",{loader:()=>t.e(5622).then(t.bind(t,267)),meta:{t:"07 综合练习"}}],["/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",{loader:()=>t.e(5345).then(t.bind(t,66304)),meta:{t:"08 面向对象"}}],["/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/",{loader:()=>t.e(6752).then(t.bind(t,36934)),meta:{t:"09 面向对象综合训练"}}],["/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/",{loader:()=>t.e(6658).then(t.bind(t,9578)),meta:{t:"10 字符串"}}],["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",{loader:()=>t.e(3113).then(t.bind(t,24305)),meta:{t:"11 集合 学生管理系统"}}],["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/",{loader:()=>t.e(3992).then(t.bind(t,20591)),meta:{t:"13 面向对象进阶（static 继承）"}}],["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/",{loader:()=>t.e(7694).then(t.bind(t,26475)),meta:{t:"14 面向对象进阶（多态 包 Final 权限修饰符 代码块）"}}],["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/",{loader:()=>t.e(5522).then(t.bind(t,56902)),meta:{t:"15 面向对象进阶（抽象类 接口 内部类）"}}],["/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/",{loader:()=>t.e(7048).then(t.bind(t,62421)),meta:{t:"16 面向对象综合练习（上）"}}],["/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/",{loader:()=>t.e(122).then(t.bind(t,71342)),meta:{t:"17 面向对象综合练习（下）"}}],["/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/",{loader:()=>t.e(1340).then(t.bind(t,83657)),meta:{t:"18 API（常见 API，对象克隆）"}}],["/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/",{loader:()=>t.e(250).then(t.bind(t,43069)),meta:{t:"19 API（正则表达式）"}}],["/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",{loader:()=>t.e(1239).then(t.bind(t,68503)),meta:{t:"20 API（时间，包装类，练习）"}}],["/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",{loader:()=>t.e(5710).then(t.bind(t,30001)),meta:{t:"21 API（算法，lambda，练习）"}}],["/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/",{loader:()=>t.e(637).then(t.bind(t,56887)),meta:{t:"22 集合（ List集合）"}}],["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/",{loader:()=>t.e(4377).then(t.bind(t,20898)),meta:{t:"23 集合（泛型 Set 数据结构）"}}],["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/",{loader:()=>t.e(9283).then(t.bind(t,60465)),meta:{t:"24 集合（ Map 可变参数 集合工具类）"}}],["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/",{loader:()=>t.e(6905).then(t.bind(t,7784)),meta:{t:"25 阶段项目（综合练习 Doudizhu游戏）"}}],["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/",{loader:()=>t.e(5746).then(t.bind(t,97715)),meta:{t:"26 集合（ Stream流 方法引用）"}}],["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/",{loader:()=>t.e(5437).then(t.bind(t,46019)),meta:{t:"27 IO(异常 File 综合案例）"}}],["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/",{loader:()=>t.e(1158).then(t.bind(t,62624)),meta:{t:"28 IO（字节流 字符流）"}}],["/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/",{loader:()=>t.e(8613).then(t.bind(t,12925)),meta:{t:"29 IO（其他流）"}}],["/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/",{loader:()=>t.e(1181).then(t.bind(t,3318)),meta:{t:"30 多线程"}}],["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/",{loader:()=>t.e(1843).then(t.bind(t,63030)),meta:{t:"31 多线程 Juc"}}],["/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",{loader:()=>t.e(4787).then(t.bind(t,97379)),meta:{t:"32 网络编程"}}],["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/",{loader:()=>t.e(524).then(t.bind(t,56350)),meta:{t:"33 基础加强（反射，动态代理）"}}],["/pages/",{loader:()=>t.e(3713).then(t.bind(t,80510)),meta:{t:"Pages"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/",{loader:()=>t.e(8295).then(t.bind(t,26139)),meta:{t:"01 Log日志"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/",{loader:()=>t.e(7870).then(t.bind(t,44715)),meta:{t:"34 基础加强（日志，类加载器，单元测试，xml，注解）"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",{loader:()=>t.e(8990).then(t.bind(t,69814)),meta:{t:"02 类加载器"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/",{loader:()=>t.e(4726).then(t.bind(t,42302)),meta:{t:"03 Xml"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",{loader:()=>t.e(754).then(t.bind(t,34689)),meta:{t:"04 单元测试"}}],["/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/",{loader:()=>t.e(4854).then(t.bind(t,12472)),meta:{t:"05 注解"}}],["/category/",{loader:()=>t.e(3583).then(t.bind(t,3233)),meta:{t:"分类",I:!1}}],["/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>t.e(4021).then(t.bind(t,37062)),meta:{t:"使用指南 分类",I:!1}}],["/category/linux/",{loader:()=>t.e(8654).then(t.bind(t,70332)),meta:{t:"linux 分类",I:!1}}],["/category/idea/",{loader:()=>t.e(739).then(t.bind(t,64336)),meta:{t:"idea 分类",I:!1}}],["/category/mysql/",{loader:()=>t.e(1006).then(t.bind(t,37667)),meta:{t:"mysql 分类",I:!1}}],["/category/java/",{loader:()=>t.e(8236).then(t.bind(t,1730)),meta:{t:"java 分类",I:!1}}],["/category/network/",{loader:()=>t.e(150).then(t.bind(t,3942)),meta:{t:"network 分类",I:!1}}],["/category/redis/",{loader:()=>t.e(7).then(t.bind(t,21902)),meta:{t:"redis 分类",I:!1}}],["/category/windows/",{loader:()=>t.e(433).then(t.bind(t,93729)),meta:{t:"windows 分类",I:!1}}],["/category/dependence/",{loader:()=>t.e(7053).then(t.bind(t,32087)),meta:{t:"dependence 分类",I:!1}}],["/category/spring/",{loader:()=>t.e(9097).then(t.bind(t,97494)),meta:{t:"spring 分类",I:!1}}],["/category/python/",{loader:()=>t.e(1034).then(t.bind(t,99983)),meta:{t:"python 分类",I:!1}}],["/category/java/",{loader:()=>t.e(8236).then(t.bind(t,1730)),meta:{t:"Java 分类",I:!1}}],["/category/%E6%A1%86%E6%9E%B6/",{loader:()=>t.e(168).then(t.bind(t,18056)),meta:{t:"框架 分类",I:!1}}],["/category/spring/",{loader:()=>t.e(9097).then(t.bind(t,97494)),meta:{t:"Spring 分类",I:!1}}],["/category/spring%E7%BB%BC%E5%90%88/",{loader:()=>t.e(797).then(t.bind(t,48482)),meta:{t:"Spring综合 分类",I:!1}}],["/category/spring%E6%A0%B8%E5%BF%83/",{loader:()=>t.e(5164).then(t.bind(t,2936)),meta:{t:"Spring核心 分类",I:!1}}],["/category/spring%E6%95%B0%E6%8D%AE/",{loader:()=>t.e(6815).then(t.bind(t,33068)),meta:{t:"Spring数据 分类",I:!1}}],["/category/springweb/",{loader:()=>t.e(6729).then(t.bind(t,81638)),meta:{t:"SpringWeb 分类",I:!1}}],["/category/springio/",{loader:()=>t.e(7345).then(t.bind(t,50976)),meta:{t:"SpringIO 分类",I:!1}}],["/category/spring%E9%9B%86%E6%88%90/",{loader:()=>t.e(7975).then(t.bind(t,61837)),meta:{t:"Spring集成 分类",I:!1}}],["/category/spring%E5%AE%89%E5%85%A8/",{loader:()=>t.e(3912).then(t.bind(t,25392)),meta:{t:"Spring安全 分类",I:!1}}],["/category/spring%E5%85%B6%E4%BB%96/",{loader:()=>t.e(769).then(t.bind(t,71118)),meta:{t:"Spring其他 分类",I:!1}}],["/tag/",{loader:()=>t.e(1797).then(t.bind(t,60951)),meta:{t:"标签",I:!1}}],["/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",{loader:()=>t.e(602).then(t.bind(t,99462)),meta:{t:"标签: 页面配置",I:!1}}],["/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{loader:()=>t.e(1431).then(t.bind(t,8210)),meta:{t:"标签: 使用指南",I:!1}}],["/tag/linux/",{loader:()=>t.e(4316).then(t.bind(t,45922)),meta:{t:"标签: linux",I:!1}}],["/tag/tomcat/",{loader:()=>t.e(1986).then(t.bind(t,75925)),meta:{t:"标签: tomcat",I:!1}}],["/tag/shell/",{loader:()=>t.e(472).then(t.bind(t,42614)),meta:{t:"标签: shell",I:!1}}],["/tag/sql/",{loader:()=>t.e(5374).then(t.bind(t,60071)),meta:{t:"标签: sql",I:!1}}],["/tag/bug/",{loader:()=>t.e(6504).then(t.bind(t,12914)),meta:{t:"标签: bug",I:!1}}],["/tag/internet/",{loader:()=>t.e(9375).then(t.bind(t,74062)),meta:{t:"标签: internet",I:!1}}],["/tag/java/",{loader:()=>t.e(7869).then(t.bind(t,53691)),meta:{t:"标签: java",I:!1}}],["/tag/spring/",{loader:()=>t.e(6847).then(t.bind(t,40551)),meta:{t:"标签: spring",I:!1}}],["/tag/springboot/",{loader:()=>t.e(1159).then(t.bind(t,73821)),meta:{t:"标签: springboot",I:!1}}],["/tag/redis/",{loader:()=>t.e(8857).then(t.bind(t,41774)),meta:{t:"标签: redis",I:!1}}],["/tag/script/",{loader:()=>t.e(9969).then(t.bind(t,80696)),meta:{t:"标签: script",I:!1}}],["/tag/java-basic/",{loader:()=>t.e(4101).then(t.bind(t,23337)),meta:{t:"标签: java-basic",I:!1}}],["/tag/logback/",{loader:()=>t.e(2931).then(t.bind(t,93858)),meta:{t:"标签: logback",I:!1}}],["/tag/maven/",{loader:()=>t.e(9405).then(t.bind(t,88321)),meta:{t:"标签: maven",I:!1}}],["/tag/mybatis/",{loader:()=>t.e(3223).then(t.bind(t,95115)),meta:{t:"标签: mybatis",I:!1}}],["/tag/netty/",{loader:()=>t.e(70).then(t.bind(t,21707)),meta:{t:"标签: netty",I:!1}}],["/tag/nio/",{loader:()=>t.e(7936).then(t.bind(t,27565)),meta:{t:"标签: nio",I:!1}}],["/tag/javaweb/",{loader:()=>t.e(4172).then(t.bind(t,64741)),meta:{t:"标签: javaweb",I:!1}}],["/tag/http/",{loader:()=>t.e(4226).then(t.bind(t,83428)),meta:{t:"标签: http",I:!1}}],["/tag/servlet/",{loader:()=>t.e(6611).then(t.bind(t,32189)),meta:{t:"标签: servlet",I:!1}}],["/tag/request/",{loader:()=>t.e(7435).then(t.bind(t,78061)),meta:{t:"标签: Request",I:!1}}],["/tag/response/",{loader:()=>t.e(3301).then(t.bind(t,11006)),meta:{t:"标签: Response",I:!1}}],["/tag/jdbc/",{loader:()=>t.e(2703).then(t.bind(t,28650)),meta:{t:"标签: jdbc",I:!1}}],["/tag/djgango/",{loader:()=>t.e(8048).then(t.bind(t,9529)),meta:{t:"标签: djgango",I:!1}}],["/tag/java/",{loader:()=>t.e(7869).then(t.bind(t,53691)),meta:{t:"标签: Java",I:!1}}],["/tag/%E6%A1%86%E6%9E%B6/",{loader:()=>t.e(6606).then(t.bind(t,6807)),meta:{t:"标签: 框架",I:!1}}],["/tag/spring/",{loader:()=>t.e(6847).then(t.bind(t,40551)),meta:{t:"标签: Spring",I:!1}}],["/tag/springboot/",{loader:()=>t.e(1159).then(t.bind(t,73821)),meta:{t:"标签: SpringBoot",I:!1}}],["/tag/%E9%9D%A2%E8%AF%95/",{loader:()=>t.e(243).then(t.bind(t,856)),meta:{t:"标签: 面试",I:!1}}],["/tag/bean/",{loader:()=>t.e(9976).then(t.bind(t,22343)),meta:{t:"标签: Bean",I:!1}}],["/tag/beandefinition/",{loader:()=>t.e(8865).then(t.bind(t,5839)),meta:{t:"标签: BeanDefinition",I:!1}}],["/tag/ioc/",{loader:()=>t.e(5551).then(t.bind(t,67005)),meta:{t:"标签: IOC",I:!1}}],["/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",{loader:()=>t.e(2422).then(t.bind(t,83770)),meta:{t:"标签: 依赖查找",I:!1}}],["/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",{loader:()=>t.e(6).then(t.bind(t,96461)),meta:{t:"标签: 依赖注入",I:!1}}],["/tag/aop/",{loader:()=>t.e(6830).then(t.bind(t,85731)),meta:{t:"标签: AOP",I:!1}}],["/tag/resource/",{loader:()=>t.e(4742).then(t.bind(t,81272)),meta:{t:"标签: Resource",I:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",{loader:()=>t.e(8507).then(t.bind(t,16797)),meta:{t:"标签: 数据绑定",I:!1}}],["/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",{loader:()=>t.e(4817).then(t.bind(t,12875)),meta:{t:"标签: 数据库",I:!1}}],["/tag/datasource/",{loader:()=>t.e(23).then(t.bind(t,36861)),meta:{t:"标签: DataSource",I:!1}}],["/tag/jdbc/",{loader:()=>t.e(2703).then(t.bind(t,28650)),meta:{t:"标签: JDBC",I:!1}}],["/tag/jdbctemplate/",{loader:()=>t.e(6809).then(t.bind(t,62927)),meta:{t:"标签: JdbcTemplate",I:!1}}],["/tag/%E4%BA%8B%E5%8A%A1/",{loader:()=>t.e(5426).then(t.bind(t,33347)),meta:{t:"标签: 事务",I:!1}}],["/tag/jpa/",{loader:()=>t.e(7419).then(t.bind(t,52266)),meta:{t:"标签: JPA",I:!1}}],["/tag/mybatis/",{loader:()=>t.e(3223).then(t.bind(t,95115)),meta:{t:"标签: MyBatis",I:!1}}],["/tag/pagehelper/",{loader:()=>t.e(8285).then(t.bind(t,22160)),meta:{t:"标签: PageHelper",I:!1}}],["/tag/mapper/",{loader:()=>t.e(1943).then(t.bind(t,26230)),meta:{t:"标签: Mapper",I:!1}}],["/tag/redis/",{loader:()=>t.e(8857).then(t.bind(t,41774)),meta:{t:"标签: Redis",I:!1}}],["/tag/mongodb/",{loader:()=>t.e(9416).then(t.bind(t,75579)),meta:{t:"标签: MongoDB",I:!1}}],["/tag/elasticsearch/",{loader:()=>t.e(8361).then(t.bind(t,37511)),meta:{t:"标签: Elasticsearch",I:!1}}],["/tag/web/",{loader:()=>t.e(2660).then(t.bind(t,57940)),meta:{t:"标签: Web",I:!1}}],["/tag/controller/",{loader:()=>t.e(7010).then(t.bind(t,55167)),meta:{t:"标签: Controller",I:!1}}],["/tag/dispatcherservlet/",{loader:()=>t.e(7212).then(t.bind(t,19670)),meta:{t:"标签: DispatcherServlet",I:!1}}],["/tag/filter/",{loader:()=>t.e(8088).then(t.bind(t,50466)),meta:{t:"标签: Filter",I:!1}}],["/tag/cors/",{loader:()=>t.e(2707).then(t.bind(t,74776)),meta:{t:"标签: CORS",I:!1}}],["/tag/view/",{loader:()=>t.e(8632).then(t.bind(t,20409)),meta:{t:"标签: View",I:!1}}],["/tag/%E5%BC%82%E6%AD%A5/",{loader:()=>t.e(6339).then(t.bind(t,28527)),meta:{t:"标签: 异步",I:!1}}],["/tag/json/",{loader:()=>t.e(40).then(t.bind(t,28229)),meta:{t:"标签: JSON",I:!1}}],["/tag/%E9%82%AE%E4%BB%B6/",{loader:()=>t.e(214).then(t.bind(t,40234)),meta:{t:"标签: 邮件",I:!1}}],["/tag/io/",{loader:()=>t.e(4086).then(t.bind(t,90795)),meta:{t:"标签: IO",I:!1}}],["/tag/%E9%9B%86%E6%88%90/",{loader:()=>t.e(9236).then(t.bind(t,6607)),meta:{t:"标签: 集成",I:!1}}],["/tag/%E7%BC%93%E5%AD%98/",{loader:()=>t.e(6822).then(t.bind(t,1694)),meta:{t:"标签: 缓存",I:!1}}],["/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",{loader:()=>t.e(7765).then(t.bind(t,55302)),meta:{t:"标签: 调度器",I:!1}}],["/tag/dubbo/",{loader:()=>t.e(4894).then(t.bind(t,65853)),meta:{t:"标签: Dubbo",I:!1}}],["/tag/%E5%AE%89%E5%85%A8/",{loader:()=>t.e(6123).then(t.bind(t,64610)),meta:{t:"标签: 安全",I:!1}}],["/article/",{loader:()=>t.e(7511).then(t.bind(t,2772)),meta:{t:"文章",I:!1}}],["/star/",{loader:()=>t.e(7199).then(t.bind(t,70353)),meta:{t:"星标",I:!1}}],["/timeline/",{loader:()=>t.e(5464).then(t.bind(t,14695)),meta:{t:"时间轴",I:!1}}]])},35124:(n,e,t)=>{t.d(e,{o:()=>i});const i=[{title:"主页",headers:[],path:"/",pathLocale:"/",extraFields:[]},{title:"介绍页",headers:[],path:"/intro.html",pathLocale:"/",extraFields:[]},{title:"主要功能与配置演示",headers:[],path:"/demo/",pathLocale:"/",extraFields:[]},{title:"布局与功能禁用",headers:[],path:"/demo/disable.html",pathLocale:"/",extraFields:[]},{title:"布局",headers:[],path:"/demo/layout.html",pathLocale:"/",extraFields:[]},{title:"Markdown 展示",headers:[{level:2,title:"Markdown 介绍",slug:"markdown-介绍",link:"#markdown-介绍",children:[]},{level:2,title:"Markdown 配置",slug:"markdown-配置",link:"#markdown-配置",children:[]},{level:2,title:"Markdown 扩展",slug:"markdown-扩展",link:"#markdown-扩展",children:[{level:3,title:"VuePress 扩展",slug:"vuepress-扩展",link:"#vuepress-扩展",children:[]},{level:3,title:"主题扩展",slug:"主题扩展",link:"#主题扩展",children:[]},{level:3,title:"图片增强",slug:"图片增强",link:"#图片增强",children:[]}]}],path:"/demo/markdown.html",pathLocale:"/",extraFields:["component VPCard\ntitle: Mr.Hope\ndesc: Where there is light, there is hope\nlogo: https://mister-hope.com/logo.svg\nlink: https://mister-hope.com\nbackground: rgba(253, 230, 138, 0.15)","js\nconst a = 1;","bash\npnpm add -D vuepress-theme-hope","bash\nyarn add -D vuepress-theme-hope","bash\nnpm i -D vuepress-theme-hope"]},{title:"页面配置使用说明",headers:[{level:2,title:"页面标题",slug:"页面标题",link:"#页面标题",children:[]},{level:2,title:"页面信息",slug:"页面信息",link:"#页面信息",children:[]},{level:2,title:"页面内容",slug:"页面内容",link:"#页面内容",children:[]},{level:2,title:"组件",slug:"组件",link:"#组件",children:[]},{level:2,title:"表格",slug:"表格",link:"#表格",children:[]}],path:"/demo/page.html",pathLocale:"/",extraFields:["md\n---\ntitle: 页面标题\n---","component VPCard\n  title: Mr.Hope\n  desc: Where there is light, there is hope\n  logo: https://mister-hope.com/logo.svg\n  link: https://mister-hope.com\n  background: rgba(253, 230, 138, 0.15)"]},{title:"页面配置使用说明",headers:[{level:2,title:"组件引用实例",slug:"组件引用实例",link:"#组件引用实例",children:[]},{level:2,title:"页面标题",slug:"页面标题",link:"#页面标题",children:[]},{level:2,title:"页面信息",slug:"页面信息",link:"#页面信息",children:[]},{level:2,title:"页面内容",slug:"页面内容",link:"#页面内容",children:[]},{level:2,title:"组件",slug:"组件",link:"#组件",children:[]},{level:2,title:"表格",slug:"表格",link:"#表格",children:[]}],path:"/posts/markdown.html",pathLocale:"/",extraFields:["md\n---\ntitle: 页面标题\n---","component VPCard\n  title: Mr.Hope\n  desc: Where there is light, there is hope\n  logo: https://mister-hope.com/logo.svg\n  link: https://mister-hope.com\n  background: rgba(253, 230, 138, 0.15)"]},{title:"linux 命令集",headers:[{level:2,title:"1.基本命令",slug:"_1-基本命令",link:"#_1-基本命令",children:[]},{level:2,title:"2.关机",slug:"_2-关机",link:"#_2-关机",children:[]},{level:2,title:"3.文件和目录",slug:"_3-文件和目录",link:"#_3-文件和目录",children:[]},{level:2,title:"4.文件搜索",slug:"_4-文件搜索",link:"#_4-文件搜索",children:[]},{level:2,title:"5.挂载一个文件系统",slug:"_5-挂载一个文件系统",link:"#_5-挂载一个文件系统",children:[]},{level:2,title:"6.磁盘空间",slug:"_6-磁盘空间",link:"#_6-磁盘空间",children:[]},{level:2,title:"7.用户和群组",slug:"_7-用户和群组",link:"#_7-用户和群组",children:[]},{level:2,title:"8.文件的权限，使用“+”设置权限，使用“-”用于取消",slug:"_8-文件的权限-使用-设置权限-使用-用于取消",link:"#_8-文件的权限-使用-设置权限-使用-用于取消",children:[]},{level:2,title:"9.文件的特殊属性",slug:"_9-文件的特殊属性",link:"#_9-文件的特殊属性",children:[]},{level:2,title:"10.打包和压缩文件",slug:"_10-打包和压缩文件",link:"#_10-打包和压缩文件",children:[]},{level:2,title:"11.RPM 包",slug:"_11-rpm-包",link:"#_11-rpm-包",children:[]},{level:2,title:"12.YUM 软件包升级器",slug:"_12-yum-软件包升级器",link:"#_12-yum-软件包升级器",children:[]},{level:2,title:"13.deb 包",slug:"_13-deb-包",link:"#_13-deb-包",children:[]},{level:2,title:"14.查看文件内容",slug:"_14-查看文件内容",link:"#_14-查看文件内容",children:[]},{level:2,title:"15.文本处理",slug:"_15-文本处理",link:"#_15-文本处理",children:[]},{level:2,title:"16.字符设置和文件格式转换",slug:"_16-字符设置和文件格式转换",link:"#_16-字符设置和文件格式转换",children:[]},{level:2,title:"17.文件系统分析",slug:"_17-文件系统分析",link:"#_17-文件系统分析",children:[]},{level:2,title:"18.初始化一个文件系统",slug:"_18-初始化一个文件系统",link:"#_18-初始化一个文件系统",children:[]},{level:2,title:"19. SWAP文件系统",slug:"_19-swap文件系统",link:"#_19-swap文件系统",children:[]},{level:2,title:"20.备份",slug:"_20-备份",link:"#_20-备份",children:[]},{level:2,title:"21.光盘",slug:"_21-光盘",link:"#_21-光盘",children:[]},{level:2,title:"22.网络（以太网和WIFI无线）",slug:"_22-网络-以太网和wifi无线",link:"#_22-网络-以太网和wifi无线",children:[]},{level:2,title:"23.列出目录内容",slug:"_23-列出目录内容",link:"#_23-列出目录内容",children:[]},{level:2,title:"24.查看文件的类型",slug:"_24-查看文件的类型",link:"#_24-查看文件的类型",children:[]},{level:2,title:"25.复制文件目录",slug:"_25-复制文件目录",link:"#_25-复制文件目录",children:[]},{level:2,title:"26.系统常用命令",slug:"_26-系统常用命令",link:"#_26-系统常用命令",children:[]},{level:2,title:"27.VIM",slug:"_27-vim",link:"#_27-vim",children:[]},{level:2,title:"28.Windows 连接Linux",slug:"_28-windows-连接linux",link:"#_28-windows-连接linux",children:[]}],path:"/posts/linux/linux.html",pathLocale:"/",extraFields:["shell\nps -ef | grep Name 查找进程\nkill Name 结束进程\nuname -m 显示机器的处理器架构\nuname -r 显示正在使用的内核版本\ndmidecode -q 显示硬件系统部件\n(SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性\nhdparm -tT /dev/sda 在磁盘上执行测试性读取操作系统信息\narch 显示机器的处理器架构\nuname -m 显示机器的处理器架构\nuname -r 显示正在使用的内核版本\ndmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)\nhdparm -i /dev/hda 罗列一个磁盘的架构特性\nhdparm -tT /dev/sda 在磁盘上执行测试性读取操作\ncat /proc/cpuinfo 显示CPU info的信息\ncat /proc/interrupts 显示中断\ncat /proc/meminfo 校验内存使用\ncat /proc/swaps 显示哪些swap被使用\ncat /proc/version 显示内核的版本\ncat /proc/net/dev 显示网络适配器及统计\ncat /proc/mounts 显示已加载的文件系统\nlspci -tv 罗列 PCI 设备\nlsusb -tv 显示 USB 设备\ndate 显示系统日期\ncal 2007 显示2007年的日历表\ndate 041217002007.00 设置日期和时间 - 月日时分年.秒\nclock -w 将时间修改保存到 BIOS","shell\nshutdown -h now 关闭系统(1)\ninit 0 关闭系统(2)\ntelinit 0 关闭系统(3)\nshutdown -h hours:minutes & 按预定时间关闭系统\nshutdown -c 取消按预定时间关闭系统\nshutdown -r now 重启(1)\nreboot 重启(2)\nlogout 注销","shell\ncd /home 进入 '/ home' 目录'\ncd .. 返回上一级目录\ncd ../.. 返回上两级目录\ncd 进入个人的主目录\ncd ~user1 进入个人的主目录\ncd - 返回上次所在的目录\npwd 显示工作路径\nls 查看目录中的文件\nls -F 查看目录中的文件\nls -l 显示文件和目录的详细资料\nls -a 显示隐藏文件\nls *[0-9]* 显示包含数字的文件名和目录名\ntree 显示文件和目录由根目录开始的树形结构(1)\nlstree 显示文件和目录由根目录开始的树形结构(2)\nmkdir dir1 创建一个叫做 'dir1' 的目录'\nmkdir dir1 dir2 同时创建两个目录\nmkdir -p /tmp/dir1/dir2 创建一个目录树\nrm -f file1 删除一个叫做 'file1' 的文件'\nrmdir dir1 删除一个叫做 'dir1' 的目录'\nrm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容\nrm -rf dir1 dir2 同时删除两个目录及它们的内容\nmv dir1 new_dir 重命名/移动 一个目录\ncp file1 file2 复制一个文件\ncp dir/* . 复制一个目录下的所有文件到当前工作目录\ncp -a /tmp/dir1 . 复制一个目录到当前工作目录\ncp -a dir1 dir2 复制一个目录\nln -s file1 lnk1 创建一个指向文件或目录的软链接\nln file1 lnk1 创建一个指向文件或目录的物理链接\ntouch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)\nfile file1 outputs the mime type of the file as text\niconv -l 列出已知的编码\niconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.\nfind . -maxdepth 1 -name *.jpg -print -exec convert \"{}\" -resize 80x60 \"thumbs/{}\" \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)","shell\nfind / -name file1 从 '/' 开始进入根文件系统搜索文件和目录\nfind / -user user1 搜索属于用户 'user1' 的文件和目录\nfind /home/user1 -name \\*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件\nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件\nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件\nfind / -name \\*.rpm -exec chmod 755 '{}' \\; 搜索以 '.rpm' 结尾的文件并定义其权限\nfind / -xdev -name \\*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备\nlocate \\*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令\nwhereis halt 显示一个二进制文件、源码或man的位置\nwhich halt 显示一个二进制文件或可执行文件的完整路径","shell\nmount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在\numount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出\nfuser -km /mnt/hda2 当设备繁忙时强制卸载\numount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用\nmount /dev/fd0 /mnt/floppy 挂载一个软盘\nmount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom\nmount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom\nmount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件\nmount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统\nmount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享","shell\ndf -h 显示已经挂载的分区列表\nls -lSr |more 以尺寸大小排列文件和目录\ndu -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'\ndu -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小\nrpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)\ndpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)","shell\ngroupadd group_name 创建一个新用户组\ngroupdel group_name 删除一个用户组\ngroupmod -n new_group_name old_group_name 重命名一个用户组\nuseradd -c \"Name Surname \" -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 \"admin\" 用户组的用户\nuseradd user1 创建一个新用户\nuserdel -r user1 删除一个用户 ( '-r' 排除主目录)\nusermod -c \"User FTP\" -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性\npasswd 修改口令\npasswd user1 修改一个用户的口令 (只允许root执行)\nchage -E 2005-12-31 user1 设置用户口令的失效期限\npwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户\ngrpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组\nnewgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组","shell\nls -lh 显示权限\nls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示\nchmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限\nchmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限\nchown user1 file1 改变一个文件的所有人属性\nchown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性\nchgrp group1 file1 改变文件的群组\nchown user1:group1 file1 改变一个文件的所有人和群组属性\nfind / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件\nchmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限\nchmod u-s /bin/file1 禁用一个二进制文件的 SUID位\nchmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的\nchmod g-s /home/public 禁用一个目录的 SGID 位\nchmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件\nchmod o-t /home/public 禁用一个目录的 STIKY 位\nchmod +x 文件路径 为所有者、所属组和其他用户添加执行的权限\nchmod -x 文件路径 为所有者、所属组和其他用户删除执行的权限\nchmod u+x 文件路径 为所有者添加执行的权限\nchmod g+x 文件路径 为所属组添加执行的权限\nchmod o+x 文件路径 为其他用户添加执行的权限\nchmod ug+x 文件路径 为所有者、所属组添加执行的权限\nchmod =wx 文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限\nchmod ug=wx 文件路径 为所有者、所属组添加写、执行的权限，取消读权限","shell\nchattr +a file1 只允许以追加方式读写文件\nchattr +c file1 允许这个文件能被内核自动压缩/解压\nchattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件\nchattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接\nchattr +s file1 允许一个文件被安全地删除\nchattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\nchattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件\nlsattr 显示特殊的属性","shell\nbunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件\nbzip2 file1 压缩一个叫做 'file1' 的文件\ngunzip file1.gz 解压一个叫做 'file1.gz'的文件\ngzip file1 压缩一个叫做 'file1'的文件\ngzip -9 file1 最大程度压缩\nrar a file1.rar test_file 创建一个叫做 'file1.rar' 的包\nrar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1'\nrar x file1.rar 解压rar包\nunrar x file1.rar 解压rar包\ntar -cvf archive.tar file1 创建一个非压缩的 tarball\ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件\ntar -tf archive.tar 显示一个包中的内容\ntar -xvf archive.tar 释放一个包\ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下\ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包\ntar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包\ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包\ntar -xvfz archive.tar.gz 解压一个gzip格式的压缩包\nzip file1.zip file1 创建一个zip格式的压缩包\nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包\nunzip file1.zip 解压一个zip格式压缩包",'shell\nrpm -ivh package.rpm 安装一个rpm包\nrpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告\nrpm -U package.rpm 更新一个rpm包但不改变其配置文件\nrpm -F package.rpm 更新一个确定已经安装的rpm包\nrpm -e package_name.rpm 删除一个rpm包\nrpm -qa 显示系统中所有已经安装的rpm包\nrpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包\nrpm -qi package_name 获取一个已安装包的特殊信息\nrpm -qg "System Environment/Daemons" 显示一个组件的rpm包\nrpm -ql package_name 显示一个已经安装的rpm包提供的文件列表\nrpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表\nrpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表\nrpm -q package_name --whatprovides 显示一个rpm包所占的体积\nrpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l\nrpm -q package_name --changelog 显示一个rpm包的修改历史\nrpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供\nrpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表\nrpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书\nrpm --checksig package.rpm 确认一个rpm包的完整性\nrpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性\nrpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间\nrpm -Va 检查系统中所有已安装的rpm包- 小心使用\nrpm -Vp package.rpm 确认一个rpm包还未安装\nrpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件\nrpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包\nrpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包',"shell\nyum install package_name 下载并安装一个rpm包\nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系\nyum update package_name.rpm 更新当前系统中所有安装的rpm包\nyum update package_name 更新一个rpm包\nyum remove package_name 删除一个rpm包\nyum list 列出当前系统中安装的所有包\nyum search package_name 在rpm仓库中搜寻软件包\nyum clean packages 清理rpm缓存删除下载的包\nyum clean headers 删除所有头文件\nyum clean all 删除所有缓存的包和头文件",'shell\ndpkg -i package.deb 安装/更新一个 deb 包\ndpkg -r package_name 从系统删除一个 deb 包\ndpkg -l 显示系统中所有已经安装的 deb 包\ndpkg -l | grep httpd 显示所有名称中包含 "httpd" 字样的deb包\ndpkg -s package_name 获得已经安装在系统中一个特殊包的信息\ndpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表\ndpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表\ndpkg -S /bin/ping 确认所给的文件由哪个deb包提供\nAPT 软件工具 (Debian, Ubuntu 以及类似系统)\napt-get install package_name 安装/更新一个 deb 包\napt-cdrom install package_name 从光盘安装/更新一个 deb 包\napt-get update 升级列表中的软件包\napt-get upgrade 升级所有已安装的软件\napt-get remove package_name 从系统删除一个deb包\napt-get check 确认依赖的软件仓库正确\napt-get clean 从下载的软件包中清理缓存\napt-cache search searched-package 返回包含所要搜索字符串的软件包名称',"shell\ncat file1 从第一个字节开始正向查看文件的内容\ntac file1 从最后一行开始反向查看一个文件的内容\nmore file1 查看一个长文件的内容\nless file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作\nhead -2 file1 查看一个文件的前两行\ntail -2 file1 查看一个文件的最后两行\ntail -f /var/log/messages 实时查看被添加到一个文件中的内容","shell\ncat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT\ncat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中\ncat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中\ngrep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词\"Aug\"\ngrep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇\ngrep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行\ngrep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\"\nsed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\"\nsed '/^$/d' example.txt 从example.txt文件中删除所有空白行\nsed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行\necho 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容\nsed -e '1d' result.txt 从文件example.txt 中排除第一行\nsed -n '/stringa1/p' 查看只包含词汇 \"string1\"的行\nsed -e 's/ *$//' example.txt 删除每一行最后的空白字符\nsed -e 's/stringa1//g' example.txt 从文档中只删除词汇 \"string1\" 并保留剩余全部\nsed -n '1,5p;5q' example.txt 查看从第一行到第5行内容\nsed -n '5p;5q' example.txt 查看第5行\nsed -e 's/00*/0/g' example.txt 用单个零替换多个零\ncat -n file1 标示文件的行数\ncat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行\necho a b c | awk '{print $1}' 查看一行第一栏\necho a b c | awk '{print $1,$3}' 查看一行的第一和第三栏\npaste file1 file2 合并两个文件或两栏的内容\npaste -d '+' file1 file2 合并两个文件或两栏的内容，中间用\"+\"区分\nsort file1 file2 排序两个文件的内容\nsort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)\nsort file1 file2 | uniq -u 删除交集，留下其他的行\nsort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)\ncomm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容\ncomm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容\ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分","shell\ndos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX\nunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS\nrecode ..HTML < page.txt > page.html 将一个文本文件转换成html\nrecode -l | more 显示所有允许的转换格式","shell\nbadblocks -v /dev/hda1 检查磁盘hda1上的坏磁块\nfsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性\nfsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性\ne2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性\ne2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性\nfsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性\nfsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性\nfsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性\ndosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性","shell\nmkfs /dev/hda1 在hda1分区创建一个文件系统\nmke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统\nmke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统\nmkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统\nfdformat -n /dev/fd0 格式化一个软盘\nmkswap /dev/hda3 创建一个swap文件系统","shell\nmkswap /dev/hda3 创建一个swap文件系统\nswapon /dev/hda3 启用一个新的swap文件系统\nswapon /dev/hda2 /dev/hdb3 启用两个swap分区","shell\ndump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份\ndump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份\nrestore -if /tmp/home0.bak 还原一个交互式备份\nrsync -rogpav --delete /home /tmp 同步两边的目录\nrsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync\nrsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录\nrsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录\ndd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作\ndd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件\ntar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作\n( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p' 通过ssh在远程目录中复制一个目录内容\n( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' 通过ssh在远程目录中复制一个本地目录\ntar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接\nfind /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录\nfind /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包\ndd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作\ndd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容",'shell\ncdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容\nmkisofs /dev/cdrom > cd.iso 在磁盘上创建一个光盘的iso镜像文件\nmkisofs /dev/cdrom | gzip > cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件\nmkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件\ncdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件\ngzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件\nmount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件\ncd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中\ncd-paranoia -- "-3" 从一个CD光盘转录音轨到 wav 文件中（参数-3）\ncdrecord --scanbus 扫描总线以识别scsi通道\ndd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD',"shell\nifconfig eth0 显示一个以太网卡的配置\nifup eth0 启用一个 'eth0' 网络设备\nifdown eth0 禁用一个 'eth0' 网络设备\nifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址\nifconfig eth0 promisc 设置 'eth0' 成混杂模式以嗅探数据包 (sniffing)\ndhclient eth0 以dhcp模式启用 'eth0'\nroute -n show routing table\nroute add -net 0/0 gw IP_Gateway configura default gateway\nroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network '192.168.0.0/16'\nroute del 0/0 gw IP_gateway remove static route\necho \"1\" > /proc/sys/net/ipv4/ip_forward activate ip routing\nhostname show hostname of system\nhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)\nip link show show link status of all interfaces\nmii-tool eth0 show link status of 'eth0'\nethtool eth0 show statistics of network card 'eth0'\nnetstat -tup show all active network connections and their PID\nnetstat -tupl show all network services listening on the system and their PID\ntcpdump tcp port 80 show all HTTP traffic\niwlist scan show wireless networks\niwconfig eth1 show configuration of a wireless network card\nhostname show hostname\nhost www.example.com lookup hostname to resolve name to ip address and viceversa\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa\nwhois www.example.com lookup on Whois database","ls -a：显示所有文件（包括隐藏文件）；\nls -l：显示详细信息；\nls -R：递归显示子目录结构；\nls -ld：显示目录和链接信息；\nctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；\nLinux中以.开头的文件是隐藏文件；\npwd:显示当前目录","shell\nssh @root ip"]},{title:"在工作中遇到的有关Linux的问题",headers:[{level:2,title:"linux 查找文件",slug:"linux-查找文件",link:"#linux-查找文件",children:[]},{level:2,title:"java linux 启动和关闭脚本",slug:"java-linux-启动和关闭脚本",link:"#java-linux-启动和关闭脚本",children:[]}],path:"/posts/linux/linuxWork.html",pathLocale:"/",extraFields:["shell\ncrontab -e\n# 在其中添加 下面这行代码（startup.sh 自行更好，只有一行时 & 不要） 保存\nreboot sudo -u root /home/debian/tomcat9/bin/startup.sh start &","shell\n#!/bin/bash\nnohup java -server -jar XXX.jar > /dev/null 2>&1 &\n#nohup 确保即使用户退出登录，Java进程也会继续运行。\n#java -server -jar XXX.jar 启动指定的JAR文件。\n#-server 是一个JVM选项，表示以服务器模式运行JVM。服务器模式下的JVM通常会进行更多的优化，适合长时间运行的应用程序。\n#> /dev/null 将标准输出（控制台输出）丢弃。\n#2>&1 将标准错误（错误信息）也丢弃。\n#& 将整个命令放在后台执行。","shell\ncd /etc/rc.d\ncat rc.local","shell\nsleep 60\ncd /myApp/test\nsh /myApp/test/startup.sh\n \n#第一句为进入你项目所在的目录，我这里把项目放在/myApp/test下\n#第二句执行该目录下的sh文件\n \n##说明\n#如果不提前进入所在目录，直接执行第二句，也会开机自启动，但是日志文件会在根目录下的log文件中。只有先进入，再执行，项目的日志文件才会在test文件夹下\n \n##test文件中有jar包、startup.sh、以及jar包的日志文件logs","shell\nchmod +x /etc/rc.d/rc.local\nchmod +x /myApp/test/startup.sh",'bash\nfind /path/to/search -name "filename"',"shell\n#!/usr/bin/env sh\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nAPP_HOME=$(cd $(dirname $0)/../;pwd)                    # shell脚本必须指定，因为脚本不会自动加载环境变量，不写的话导致出现此错误\napp=$APP_HOME'/app.jar'    #jar包的决定路径\nargs='-server -Xms4096m -Xmx4096m -XX:PermSize=512m -XX:SurvivorRatio=2 -XX:+UseParallelGC'  #java程序启动参数，可不写\nargs1='--spring.config.location='$APP_HOME'/config/application.properties --logging.config='$APP_HOME'/config/logback-spring.xml --db.file='$APP_HOME'/config/config.db --logging.file.path='$APP_HOME'/logs/'\nLOGS_FILE=/dev/null                           # 把打印的日志扔进垃圾桶\n\ncmd=$1                                        #获取执行脚本的时候带的参数\npid=`ps -ef|grep java|grep $app|awk '{print $2}'`                # 抓取对应的java进程\n\n\n\nstartup(){\n  aa=`nohup java -jar $args $app $args1 >> $LOGS_FILE 2>&1 &`\n  echo \"nohup java -jar $args $app $args1 >> $LOGS_FILE 2>&1 &\"\n}\n\nif [ ! $cmd ]; then\n  echo \"Please specify args 'start|restart|stop'\"\n  exit\nfi\n\nif [ $cmd = 'start' ]; then\n  if [ ! $pid ]; then\n    startup\n  else\n    echo \"$app is running! pid=$pid\"\n  fi\nfi\n\nif [ $cmd = 'restart' ]; then\n  if [ $pid ]\n    then\n      echo \"$pid will be killed after 3 seconds!\"\n      sleep 3\n      kill -9 $pid\n  fi\n  startup\nfi\n\nif [ $cmd = 'stop' ]; then\n  if [ $pid ]; then\n    echo \"$pid will be killed after 3 seconds!\"\n    sleep 3\n    kill -9 $pid\n  fi\n  echo \"$app is stopped\"\nfi"]},{title:"idea 使用方便记录",headers:[{level:2,title:"springboot的yml文件没有小叶子",slug:"springboot的yml文件没有小叶子",link:"#springboot的yml文件没有小叶子",children:[]},{level:2,title:"好用的插件",slug:"好用的插件",link:"#好用的插件",children:[]},{level:2,title:"快捷键",slug:"快捷键",link:"#快捷键",children:[]},{level:2,title:"使用过程中遇到的问题",slug:"使用过程中遇到的问题",link:"#使用过程中遇到的问题",children:[{level:3,title:"启动报错 windows defender might impact performance",slug:"启动报错-windows-defender-might-impact-performance",link:"#启动报错-windows-defender-might-impact-performance",children:[]}]}],path:"/posts/idea/idea.html",pathLocale:"/",extraFields:["shell\n格式化文档：Ctrl+Shift+Alt+L\n文件内替换：Ctrl+R\n进入方法体：Ctrl+B\n提交git的commit：Ctrl+K\n快速折叠if/else语句：Ctrl+Shift+。\ntry-catch-finally:Ctrl+Alt+T","shell\nwindows defender might impact performance\n\nexclude IDE and project directories from antivirus scans:\n\n*****\n\n*****\n\nAlternatively, add the IDE process as an exclusion\n\nExclude directories    Don't show again"]},{title:"DDL常用命令，操作数据库和表结构",headers:[{level:2,title:"操作数据库",slug:"操作数据库",link:"#操作数据库",children:[]},{level:2,title:"修改数据库密码",slug:"修改数据库密码",link:"#修改数据库密码",children:[]},{level:2,title:"修改数据库连接权限",slug:"修改数据库连接权限",link:"#修改数据库连接权限",children:[]},{level:2,title:"查看当前数据库的连接数",slug:"查看当前数据库的连接数",link:"#查看当前数据库的连接数",children:[]},{level:2,title:"操作表",slug:"操作表",link:"#操作表",children:[]}],path:"/posts/mysql/DDL.html",pathLocale:"/",extraFields:["shell\nSHOW DATABASES;--查询所有数据库\nCREATE DATABASE 数据库名称;--创建数据库\nCREATE DATABASE IF NOT EXISTS 数据库名称;--创建数据库(判断，如果不存在则创建)\nDROP DATABASE 数据库名称;--删除数据库\nDROP DATABASE IF EXISTS 数据库名称;--删除数据库(判断，如果存在则删除)\nUSE 数据库名称;--切换到当前数据库\nSELECT DATABASE();--查看当前使用的数据库",'shell\nmysql> use mysq;\n-- 查询主机用户名密码：5.7版本之前的\nmysql> select host,user,plugin,password from user;\n-- 查询主机用户名密码：5.7版本之后的，包括5.7\nmysql> select host,user,plugin,authentication_string from user;\nmysql> select host,user,plugin,authentication_string from user\\G;\nmysql> select host,user,plugin,authentication_string from mysql.user;\n-- 修改密码，刷新权限\nmysql> update user set password=password("新密码") where user="root";\nmysql> flush privileges;\nmysql> quit\n-- 上面修改密码是在5.7版本之前的。若是5.7版本之后的（包括5.7），没有password这个字段了，则修改方法如下：\nmysql> alter user "root"@"localhost" identified by "新密码";  -- 方法1\nmysql> update user set authentication_string=password("新密码") where user="root";  -- 方法2\nmysql> flush privileges;\nmysql> quit',"shell\nupdate user set host='%' where user='root';","shell\nshow status like 'Threads%';","shell\nSHOW TABLES;--查询当前数据库下所有表名称\nDESC 表名称;--查询表结构\n--创建表\nCREATE TABLE 表名 (\n\t字段名1  数据类型1,\n\t字段名2  数据类型2,\n\t…\n\t字段名n  数据类型n\n);\nDROP TABLE 表名;--删除表\nDROP TABLE IF EXISTS 表名;--删除表时判断表是否存在\nALTER TABLE 表名 RENAME TO 新的表名;--修改表名\nALTER TABLE 表名 ADD 列名 数据类型;--添加一列\nALTER TABLE 表名 MODIFY 列名 新数据类型;--修改数据类型\nALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;--修改列名和数据类型\nALTER TABLE 表名 DROP 列名;--删除列"]},{title:"DML和DQL常用命令，操作表数据",headers:[{level:2,title:"DML（Data Manipulation Language）",slug:"dml-data-manipulation-language",link:"#dml-data-manipulation-language",children:[]},{level:2,title:"DQL（data query language）",slug:"dql-data-query-language",link:"#dql-data-query-language",children:[{level:3,title:"排序查询",slug:"排序查询",link:"#排序查询",children:[]},{level:3,title:"聚合函数",slug:"聚合函数",link:"#聚合函数",children:[]},{level:3,title:"分组查询",slug:"分组查询",link:"#分组查询",children:[]}]}],path:"/posts/mysql/DML_DQL.html",pathLocale:"/",extraFields:["shell\nINSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);--给指定列添加数据\nINSERT INTO 表名 VALUES(值1,值2,…);--给全部列添加数据\n--批量添加数据\nNSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\nINSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\n\nUPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;--修改表数据\nDELETE FROM 表名 [WHERE 条件] ;--删除数据","shell\nSELECT 字段列表 FROM 表名;\nSELECT * FROM 表名; -- 查询所有数据\nSELECT DISTINCT 字段列表 FROM 表名;--去除重复记录\n--起别名，AS: AS 也可以省略\n\nSELECT 字段列表 FROM 表名 WHERE 条件列表;--条件查询\nSELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;--分页查询\nselect * from stu where name like '_%';--模糊查询，（1）_ : 代表单个任意字符，（2）% : 代表任意个数字符","sql\n    SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;","sql\nSELECT 聚合函数名(列名) FROM 表;","sql\nSELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];"]},{title:"mysql使用中遇到的问题记录",headers:[{level:2,title:"Packet for query is too large错误",slug:"packet-for-query-is-too-large错误",link:"#packet-for-query-is-too-large错误",children:[]},{level:2,title:"索引失效",slug:"索引失效",link:"#索引失效",children:[]}],path:"/posts/mysql/mysqlBug.html",pathLocale:"/",extraFields:["txt\n在mysql安装目录中找到my.ini配置文件\n在最后添加 max_allowed_packet=10485760","shell\nSELECT * FROM user WHERE age = '20';"]},{title:"mysql 存储过程",headers:[{level:2,title:"什么是存储过程",slug:"什么是存储过程",link:"#什么是存储过程",children:[]},{level:2,title:"存储过程的作用（优点）",slug:"存储过程的作用-优点",link:"#存储过程的作用-优点",children:[]},{level:2,title:"存储过程的缺点",slug:"存储过程的缺点",link:"#存储过程的缺点",children:[]},{level:2,title:"创建存储过程",slug:"创建存储过程",link:"#创建存储过程",children:[{level:3,title:"1.具体语法详解",slug:"_1-具体语法详解",link:"#_1-具体语法详解",children:[]}]}],path:"/posts/mysql/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html",pathLocale:"/",extraFields:["shell\nCREATE PROCEDURE sp_name ([proc_parameter])\n[characteristice ...] routine_body"]},{title:"mysql 安装",headers:[{level:2,title:"下载",slug:"下载",link:"#下载",children:[]},{level:2,title:"配置环境变量",slug:"配置环境变量",link:"#配置环境变量",children:[]},{level:2,title:"创建 my.ini配置文件",slug:"创建-my-ini配置文件",link:"#创建-my-ini配置文件",children:[]},{level:2,title:"cmd 到bin目录",slug:"cmd-到bin目录",link:"#cmd-到bin目录",children:[]},{level:2,title:"执行 sc delete mysql",slug:"执行-sc-delete-mysql",link:"#执行-sc-delete-mysql",children:[]},{level:2,title:"执行 mysqld --install",slug:"执行-mysqld-install",link:"#执行-mysqld-install",children:[]}],path:"/posts/mysql/mysql%E5%AE%89%E8%A3%85.html",pathLocale:"/",extraFields:["shell\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld]\n# 设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir = D:\\\\mysql\\\\mysql-8.0.17-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir = D:\\\\mysql\\\\mysql-8.0.17-winx64\\\\data\n# 允许最大连接数\nmax_connections=20\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 创建模式\nsql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES","shell\nmysqld --initialize"]},{title:"mysql 数据格式",headers:[],path:"/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html",pathLocale:"/",extraFields:[]},{title:"mysql约束",headers:[{level:2,title:"1，约束",slug:"_1-约束",link:"#_1-约束",children:[{level:3,title:"1.1  概念",slug:"_1-1-概念",link:"#_1-1-概念",children:[]},{level:3,title:"1.2  分类",slug:"_1-2-分类",link:"#_1-2-分类",children:[]},{level:3,title:"1.3  非空约束",slug:"_1-3-非空约束",link:"#_1-3-非空约束",children:[]},{level:3,title:"1.4  唯一约束",slug:"_1-4-唯一约束",link:"#_1-4-唯一约束",children:[]},{level:3,title:"1.5  主键约束",slug:"_1-5-主键约束",link:"#_1-5-主键约束",children:[]},{level:3,title:"1.6  默认约束",slug:"_1-6-默认约束",link:"#_1-6-默认约束",children:[]},{level:3,title:"1.7  约束练习",slug:"_1-7-约束练习",link:"#_1-7-约束练习",children:[]},{level:3,title:"1.8  外键约束",slug:"_1-8-外键约束",link:"#_1-8-外键约束",children:[]}]}],path:"/posts/mysql/mysql%E7%BA%A6%E6%9D%9F.html",pathLocale:"/",extraFields:["sql\n    -- 创建表时添加非空约束\n    CREATE TABLE 表名(\n       列名 数据类型 NOT NULL,\n       …\n    );","sql\n    -- 建完表后添加非空约束\n    ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;","sql\n    ALTER TABLE 表名 MODIFY 字段名 数据类型;","sql\n    -- 创建表时添加唯一约束\n    CREATE TABLE 表名(\n       列名 数据类型 UNIQUE [AUTO_INCREMENT],\n       -- AUTO_INCREMENT: 当不指定值时自动增长\n       …\n    ); \n    CREATE TABLE 表名(\n       列名 数据类型,\n       …\n       [CONSTRAINT] [约束名称] UNIQUE(列名)\n    );","sql\n    -- 建完表后添加唯一约束\n    ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;","sql\n    ALTER TABLE 表名 DROP INDEX 字段名;","sql\n    -- 创建表时添加主键约束\n    CREATE TABLE 表名(\n       列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],\n       …\n    ); \n    CREATE TABLE 表名(\n       列名 数据类型,\n       [CONSTRAINT] [约束名称] PRIMARY KEY(列名)\n    );","sql\n    -- 建完表后添加主键约束\n    ALTER TABLE 表名 ADD PRIMARY KEY(字段名);","sql\n    ALTER TABLE 表名 DROP PRIMARY KEY;","sql\n    -- 创建表时添加默认约束\n    CREATE TABLE 表名(\n       列名 数据类型 DEFAULT 默认值,\n       …\n    );","sql\n    -- 建完表后添加默认约束\n    ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;","sql\n    ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;","sql\n-- 员工表\nCREATE TABLE emp (\n\tid INT,  -- 员工id，主键且自增长\n    ename VARCHAR(50), -- 员工姓名，非空且唯一\n    joindate DATE,  -- 入职日期，非空\n    salary DOUBLE(7,2),  -- 工资，非空\n    bonus DOUBLE(7,2)  -- 奖金，如果没有将近默认为0\n);","sql\nDROP TABLE IF EXISTS emp;\n\n-- 员工表\nCREATE TABLE emp (\n  id INT PRIMARY KEY, -- 员工id，主键且自增长\n  ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一\n  joindate DATE NOT NULL , -- 入职日期，非空\n  salary DOUBLE(7,2) NOT NULL , -- 工资，非空\n  bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0\n);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'张三','1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'张三','1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'张三','1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(2,'李四','1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(3,null,'1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(3,'李四','1999-11-11',8800,5000);","sql\nINSERT INTO emp(id,ename,joindate,salary) values(3,'王五','1999-11-11',8800);","sql\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(4,'赵六','1999-11-11',8800,null);","sql\n-- 员工表\nCREATE TABLE emp (\n  id INT PRIMARY KEY auto_increment, -- 员工id，主键且自增长\n  ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一\n  joindate DATE NOT NULL , -- 入职日期，非空\n  salary DOUBLE(7,2) NOT NULL , -- 工资，非空\n  bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0\n);","sql\nINSERT INTO emp(ename,joindate,salary,bonus) values('赵六','1999-11-11',8800,null);\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'赵六2','1999-11-11',8800,null);\nINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'赵六3','1999-11-11',8800,null);","sql\n-- 创建表时添加外键约束\nCREATE TABLE 表名(\n   列名 数据类型,\n   …\n   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) \n);","sql\n-- 建完表后添加外键约束\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);","sql\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;","sql\n-- 删除表\nDROP TABLE IF EXISTS emp;\nDROP TABLE IF EXISTS dept;\n\n-- 部门表\nCREATE TABLE dept(\n\tid int primary key auto_increment,\n\tdep_name varchar(20),\n\taddr varchar(20)\n);\n-- 员工表 \nCREATE TABLE emp(\n\tid int primary key auto_increment,\n\tname varchar(20),\n\tage int,\n\tdep_id int,\n\n\t-- 添加外键 dep_id,关联 dept 表的id主键\n\tCONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id)\t\n);","sql\n-- 添加 2 个部门\ninsert into dept(dep_name,addr) values\n('研发部','广州'),('销售部', '深圳');\n\n-- 添加员工,dep_id 表示员工所在的部门\nINSERT INTO emp (NAME, age, dep_id) VALUES \n('张三', 20, 1),\n('李四', 20, 1),\n('王五', 20, 1),\n('赵六', 20, 2),\n('孙七', 22, 2),\n('周八', 18, 2);","sql\nalter table emp drop FOREIGN key fk_emp_dept;","sql\nalter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);"]},{title:"mysql自定义函数",headers:[{level:2,title:"建库函数",slug:"建库函数",link:"#建库函数",children:[]},{level:2,title:"建表函数",slug:"建表函数",link:"#建表函数",children:[]},{level:2,title:"加字段函数",slug:"加字段函数",link:"#加字段函数",children:[]},{level:2,title:"自定义函数中调用其他函数做循环",slug:"自定义函数中调用其他函数做循环",link:"#自定义函数中调用其他函数做循环",children:[]}],path:"/posts/mysql/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html",pathLocale:"/",extraFields:["sql\nCREATE DEFINER=`root`@`%` PROCEDURE `createdatabases`()\nBEGIN\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant where TENANTCODE<>'incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET Done = 1;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\t#CREATE DATABASE str CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\tSET @strsql = CONCAT('CREATE DATABASE  if not exists ',str,' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci');\n    ## 预处理需要执行的动态SQL,其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\nEND","sql\nCREATE DEFINER=`root`@`%` PROCEDURE `addtable`()\nBEGIN\n\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant WHERE TENANTCODE!='incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR 1243 SET Done = 0;\nDECLARE CONTINUE HANDLER FOR 1146 SET Done = 0;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\tSET @strsql = CONCAT(\"CREATE TABLE  IF NOT EXISTS \" ,str,\".`sys_module_operation_record` (\n  `ID` varchar(36) NOT NULL COMMENT '主键',\n  `CODE` varchar(100) DEFAULT NULL COMMENT '编号',\n  `EVENTTIME` datetime DEFAULT NULL COMMENT '事件时间',\n  `OPERATIONUSERID` varchar(36) DEFAULT NULL COMMENT '操作用户ID',\n  `OPERATIONUSERNAME` varchar(50) DEFAULT NULL COMMENT '操作用户名称',\n  `EVENTTYPE` varchar(50) DEFAULT NULL COMMENT '事件类型',\n  `EVENTTYPENAME` varchar(50) DEFAULT NULL COMMENT '事件类型名称',\n  `EVENTDESCRIBE` varchar(300) DEFAULT '' COMMENT '事件描述',\n  `TABLENAME` varchar(100) DEFAULT NULL COMMENT '关联主表',\n  `IP` varchar(50) DEFAULT NULL COMMENT 'IP',\n  `OPURL` varchar(200) DEFAULT NULL COMMENT 'URL',\n  `CLIENTINFO` varchar(200) DEFAULT NULL COMMENT '客户端',\n  `ISMOBILE` varchar(20) DEFAULT NULL COMMENT '是否移动端',\n  `ROPTION` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '扩展json格式配置',\n  `DELETED` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '0' COMMENT '是否删除Y/N',\n  `REMARK` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '备注',\n  `CREATEDATE` datetime DEFAULT NULL COMMENT '创建时间',\n  `CREATEUSERID` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建用户ID',\n  `MODIFYDATE` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改日期',\n  `MODIFYUSERID` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改用户ID',\n  `CREATEUSERNAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建人名称',\n  `MODIFYUSERNAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改人名称',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='日志记录';\");\n    ## 预处理需要执行的动态SQL，其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\n\nEND","sql\nCREATE DEFINER=`root`@`%` PROCEDURE `adddatabaseclumn`()\nBEGIN\nDECLARE str varchar(40);\nDECLARE Done INT DEFAULT 0;\nDECLARE rs CURSOR FOR SELECT TENANTCODE FROM sys_tenant WHERE TENANTCODE!='incontrol';\n/* 异常处理 */\nDECLARE CONTINUE HANDLER FOR 1243 SET Done = 0;\nDECLARE CONTINUE HANDLER FOR 1146 SET Done = 0;\n/* 打开游标 */\nOPEN rs;\n/* 逐个取出当前记录userId字段的值*/\nFETCH NEXT FROM rs INTO str;\n/* 遍历数据表 */\nREPEAT\n\t#alter table wf_run_task add COLUMN AUDITTIMELIMIT datetime COMMENT '审批时限';\n\tSET @strsql = CONCAT('alter table ',str,'.wf_run_task add COLUMN AUDITTIMELIMIT datetime COMMENT \\'审批时限\\'');\n    ## 预处理需要执行的动态SQL,其中stmt是一个变量\n    PREPARE stmt FROM @strsql;  \n    ## 执行SQL语句\n    EXECUTE stmt;  \n    ## 释放掉预处理段\n    deallocate prepare stmt;\nFETCH NEXT FROM rs INTO str;\nUNTIL Done END REPEAT;\n/* 关闭游标 */\nCLOSE rs;\nEND","sql\nCREATE DEFINER=`root`@`%` PROCEDURE `createAllBlades`()\nBEGIN\n\t#Routine body goes here...\n\n\tDECLARE macId VARCHAR(64) ;   -- 自定义变量tableName\n\tDECLARE done INT DEFAULT FALSE;\n  declare runsql varchar(1000);\n\n\t-- 定义游标并输入结果集\n\tDECLARE cur_account CURSOR FOR select machine_id from qacs2000_config_2010.c_machine;\n\n\t-- 将结束标志绑定到游标，游标循环结束自动转true\n\tDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n\n\t-- 打开游标\n\tOPEN  cur_account;\n\t-- 开始循环，read_loop为自定义循环名,结束循环时用到\n\t  read_loop: LOOP\n\n\t\t-- 取值 将游标当前读取行的数据顺序赋予自定义变量\n\t\tFETCH cur_account INTO macId;\n\n\t\t-- 判断是否继续循环\n\t\tIF done THEN\n\t\t\tLEAVE read_loop; -- 结束循环\n\t\tEND IF;\n\n    set @sqlStr= concat('call dgm2000_1_2010.createtables(', macId, ')');\n    PREPARE stmt from @sqlStr;\n    EXECUTE stmt;\n    deallocate prepare stmt;\n\n\tEND LOOP read_loop;\n\n\tCLOSE cur_account; -- 关闭游标\n\nEND"]},{title:"触发器",headers:[{level:2,title:"触发器",slug:"触发器",link:"#触发器",children:[]}],path:"/posts/mysql/mysql%E8%A7%A6%E5%8F%91%E5%99%A8.html",pathLocale:"/",extraFields:["shell\nCREATE TRIGGER trigger_name\n{BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON table_name\nFOR EACH ROW\nBEGIN\n    -- 触发器主体\n    -- 你的SQL语句\nEND;","shell\nCREATE TABLE orders (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product VARCHAR(255),\n    quantity INT,\n    order_date DATE\n);","shell\nCREATE TABLE orders (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    product VARCHAR(255),\n    quantity INT,\n    order_date DATE\n);","shell\nDELIMITER $$\n\nCREATE TRIGGER after_insert_order\nAFTER INSERT ON orders\nFOR EACH ROW\nBEGIN\n    UPDATE order_summary SET total_orders = total_orders + 1;\nEND$$\nDELIMITER ;","shell\n-- 插入几条订单记录\nINSERT INTO orders (product, quantity, order_date) VALUES ('Apple', 10, '2024-11-28');\nINSERT INTO orders (product, quantity, order_date) VALUES ('Banana', 5, '2024-11-28');\n\n-- 查看当前的总订单数\nSELECT * FROM order_summary;"]},{title:"ftp",headers:[{level:2,title:"概述",slug:"概述",link:"#概述",children:[]},{level:2,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:2,title:"Server Reply: SSH-2.0-OpenSSH_7.4 报错",slug:"server-reply-ssh-2-0-openssh-7-4-报错",link:"#server-reply-ssh-2-0-openssh-7-4-报错",children:[]},{level:2,title:"老是连接超时",slug:"老是连接超时",link:"#老是连接超时",children:[]},{level:2,title:"getReplyCode() 返回530",slug:"getreplycode-返回530",link:"#getreplycode-返回530",children:[]},{level:2,title:"sortFile 连接超时",slug:"sortfile-连接超时",link:"#sortfile-连接超时",children:[]}],path:"/posts/network/ftp.html",pathLocale:"/",extraFields:["xml\n <dependency>\n    <groupId>commons-net</groupId>\n    <artifactId>commons-net</artifactId>\n    <version>3.3</version>\n</dependency>","java\n ftpClient.enterLocalPassiveMode();//开启被动模式"]},{title:"计算机网络",headers:[{level:2,title:"1.计算机网络概述",slug:"_1-计算机网络概述",link:"#_1-计算机网络概述",children:[{level:3,title:"1.1.互联网的构成",slug:"_1-1-互联网的构成",link:"#_1-1-互联网的构成",children:[]},{level:3,title:"1.2.网络分类",slug:"_1-2-网络分类",link:"#_1-2-网络分类",children:[]},{level:3,title:"1.3.接入网",slug:"_1-3-接入网",link:"#_1-3-接入网",children:[]},{level:3,title:"1.4.网络核心的两大功能",slug:"_1-4-网络核心的两大功能",link:"#_1-4-网络核心的两大功能",children:[]},{level:3,title:"1.5.网络分层",slug:"_1-5-网络分层",link:"#_1-5-网络分层",children:[]},{level:3,title:"1.6.三种交换方式",slug:"_1-6-三种交换方式",link:"#_1-6-三种交换方式",children:[]},{level:3,title:"1.7.计算机网络的性能指标",slug:"_1-7-计算机网络的性能指标",link:"#_1-7-计算机网络的性能指标",children:[]},{level:3,title:"1.8.计算机网络体系结构",slug:"_1-8-计算机网络体系结构",link:"#_1-8-计算机网络体系结构",children:[]}]}],path:"/posts/network/internet.html",pathLocale:"/",extraFields:["tex\n100001111[头部]","tex\n10001111[头部]……1110011[头部]","tex\n10001111……1110011"]},{title:"redis 学习笔记之实战篇",headers:[{level:2,title:"1.短信登陆",slug:"_1-短信登陆",link:"#_1-短信登陆",children:[{level:3,title:"1.1实现发送短信验证码功能",slug:"_1-1实现发送短信验证码功能",link:"#_1-1实现发送短信验证码功能",children:[]},{level:3,title:"1.2.实现登陆拦截功能",slug:"_1-2-实现登陆拦截功能",link:"#_1-2-实现登陆拦截功能",children:[]},{level:3,title:"1.3.session共享问题",slug:"_1-3-session共享问题",link:"#_1-3-session共享问题",children:[]},{level:3,title:"1.4.Redis代替session的业务流程",slug:"_1-4-redis代替session的业务流程",link:"#_1-4-redis代替session的业务流程",children:[]},{level:3,title:"1.5.用Redis代替session存储短信验证码",slug:"_1-5-用redis代替session存储短信验证码",link:"#_1-5-用redis代替session存储短信验证码",children:[]},{level:3,title:"1.6.基于Redis实现短信登陆",slug:"_1-6-基于redis实现短信登陆",link:"#_1-6-基于redis实现短信登陆",children:[]},{level:3,title:"1.7.修改优化拦截器",slug:"_1-7-修改优化拦截器",link:"#_1-7-修改优化拦截器",children:[]}]},{level:2,title:"2.商户查询缓存",slug:"_2-商户查询缓存",link:"#_2-商户查询缓存",children:[{level:3,title:"2.1.什么是缓存",slug:"_2-1-什么是缓存",link:"#_2-1-什么是缓存",children:[]},{level:3,title:"2.2.添加商户缓存",slug:"_2-2-添加商户缓存",link:"#_2-2-添加商户缓存",children:[]},{level:3,title:"2.3.缓存更新策略",slug:"_2-3-缓存更新策略",link:"#_2-3-缓存更新策略",children:[]},{level:3,title:"2.4.实现商铺和缓存与数据库双写一致",slug:"_2-4-实现商铺和缓存与数据库双写一致",link:"#_2-4-实现商铺和缓存与数据库双写一致",children:[]},{level:3,title:"2.5.缓存穿透问题的解决思路",slug:"_2-5-缓存穿透问题的解决思路",link:"#_2-5-缓存穿透问题的解决思路",children:[]},{level:3,title:"2.6.编码解决商品查询的缓存穿透问题：",slug:"_2-6-编码解决商品查询的缓存穿透问题",link:"#_2-6-编码解决商品查询的缓存穿透问题",children:[]},{level:3,title:"2.7.缓存雪崩问题及解决思路",slug:"_2-7-缓存雪崩问题及解决思路",link:"#_2-7-缓存雪崩问题及解决思路",children:[]},{level:3,title:"2.8.缓存击穿问题及解决思路",slug:"_2-8-缓存击穿问题及解决思路",link:"#_2-8-缓存击穿问题及解决思路",children:[]},{level:3,title:"2.9.封装Redis工具类",slug:"_2-9-封装redis工具类",link:"#_2-9-封装redis工具类",children:[]}]},{level:2,title:"3.优惠券秒杀",slug:"_3-优惠券秒杀",link:"#_3-优惠券秒杀",children:[{level:3,title:"3.1.全局唯一ID",slug:"_3-1-全局唯一id",link:"#_3-1-全局唯一id",children:[]},{level:3,title:"3.2.Redis实现全局唯一Id",slug:"_3-2-redis实现全局唯一id",link:"#_3-2-redis实现全局唯一id",children:[]},{level:3,title:"3.3.添加优惠券",slug:"_3-3-添加优惠券",link:"#_3-3-添加优惠券",children:[]},{level:3,title:"3.4.实现秒杀下单(基础逻辑）",slug:"_3-4-实现秒杀下单-基础逻辑",link:"#_3-4-实现秒杀下单-基础逻辑",children:[]},{level:3,title:"3.5.库存超卖问题分析",slug:"_3-5-库存超卖问题分析",link:"#_3-5-库存超卖问题分析",children:[]},{level:3,title:"3.6.乐观锁解决超卖问题",slug:"_3-6-乐观锁解决超卖问题",link:"#_3-6-乐观锁解决超卖问题",children:[]},{level:3,title:"3.7.优惠券秒杀-一人一单",slug:"_3-7-优惠券秒杀-一人一单",link:"#_3-7-优惠券秒杀-一人一单",children:[]},{level:3,title:"3.8.集群环境下的并发问题",slug:"_3-8-集群环境下的并发问题",link:"#_3-8-集群环境下的并发问题",children:[]}]},{level:2,title:"4.分布式锁",slug:"_4-分布式锁",link:"#_4-分布式锁",children:[{level:3,title:"4.1.基本原理和实现方式对比",slug:"_4-1-基本原理和实现方式对比",link:"#_4-1-基本原理和实现方式对比",children:[]},{level:3,title:"4.2.Redis分布式锁的实现核心思路",slug:"_4-2-redis分布式锁的实现核心思路",link:"#_4-2-redis分布式锁的实现核心思路",children:[]},{level:3,title:"4.3.实现分布式锁版本一",slug:"_4-3-实现分布式锁版本一",link:"#_4-3-实现分布式锁版本一",children:[]}]}],path:"/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%9E%E6%88%98%E7%AF%87.html",pathLocale:"/",extraFields:['java\n public Result sendCode(String phone, HttpSession session) {\n        // 1.校验手机号\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.符合，生成验证码\n        String code = RandomUtil.randomNumbers(6);\n\n        // 4.保存验证码到 session\n        session.setAttribute("code",code);\n        // 5.发送验证码\n        System.out.println("code:"+code);\n        // 返回ok\n        return Result.ok();\n    }','java\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n        // 1.校验手机号\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.校验验证码\n        Object cacheCode = session.getAttribute("code");\n        String code = loginForm.getCode();\n        if(cacheCode == null || !cacheCode.toString().equals(code)){\n            //3.不一致，报错\n            return Result.fail("验证码错误");\n        }\n        //一致，根据手机号查询用户\n        Student stu = StudentList.findByPhone(phone);\n        //5.判断用户是否存在\n        if(stu == null){\n            //不存在，则创建\n            stu =  createUserWithPhone(phone);\n        }\n        //7.保存用户信息到session中\n        session.setAttribute("stu", BeanUtil.copyProperties(stu, StudentDTO.class));\n\n        return Result.ok();\n    }','json\n{\n"phone":"XXXXXXX",\n"code":"前面获取的，是后台打印"\n}','java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        //1.获取session\n        HttpSession session = request.getSession();\n        //2.获取session中的用户\n        Object stu = session.getAttribute("stu");\n        //3.判断用户是否存在\n        if(stu == null){\n            //4.不存在，拦截，返回401状态码\n            response.setStatus(401);\n            return false;\n        }\n        //5.存在，保存用户信息到Threadlocal\n        StudentHolder.saveStudent((StudentDTO) stu);\n        //6.放行\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        // 移除用户\n        StudentHolder.removeStudent();\n\n    }\n}','java\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        "/student/code",\n                        "/student/login"\n                );\n    }\n}','java\n//session.setAttribute("code",code);\n// set key value ex 120\nstringRedisTemplate.opsForValue().set("login:code"+phone,code,2,TimeUnit.MINUTES);','java\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n        // 1.校验手机号\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)) {\n            // 2.如果不符合，返回错误信息\n            return Result.fail("手机号格式错误！");\n        }\n        // 3.校验验证码,TODO 之后从redis中获取\n//        Object cacheCode = session.getAttribute("code");\n        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);\n        String code = loginForm.getCode();\n        if(cacheCode == null || !cacheCode.toString().equals(code)){\n            //3.不一致，报错\n            return Result.fail("验证码错误");\n        }\n        //一致，根据手机号查询用户\n        Student stu = StudentList.findByPhone(phone);\n        //5.判断用户是否存在\n        if(stu == null){\n            //不存在，则创建\n            stu =  createUserWithPhone(phone);\n        }\n        //7.保存用户信息到session中，TODO 之后用redis代替\n//        session.setAttribute("stu", BeanUtil.copyProperties(stu, StudentDTO.class));\n        // TODO 7.1.随机生成token，作为登录令牌\n        String token = UUID.randomUUID().toString(true);\n        //TODO 7.2.将User对象转为HashMap存储\n        StudentDTO stuDTO = BeanUtil.copyProperties(stu, StudentDTO.class);\n        Map<String, Object> stuMap = BeanUtil.beanToMap(stuDTO, new HashMap<>(),\n                CopyOptions.create() // 数据拷贝是的选项\n                        .setIgnoreNullValue(true) //忽略空的值\n                        .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));//修改字段，将long的id转为String\n        //TODO 7.3.存储\n        String tokenKey = LOGIN_STU_KEY + token;\n        stringRedisTemplate.opsForHash().putAll(tokenKey, stuMap);\n        // TODO 7.4.设置token有效期\n        stringRedisTemplate.expire(tokenKey, LOGIN_STU_TTL, TimeUnit.MINUTES);\n//        return Result.ok();\n        return Result.ok(token);//TODO 返回token\n    }','java\npublic class RefreshTokenInterceptor implements HandlerInterceptor {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            // 1.获取请求头中的token\n            String token = request.getHeader("authorization");\n            if (StrUtil.isBlank(token)) {\n                return true;\n            }\n            // 2.基于TOKEN获取redis中的用户\n            String key  = LOGIN_STU_KEY + token;\n            Map<Object, Object> stuMap = stringRedisTemplate.opsForHash().entries(key);\n            // 3.判断用户是否存在\n            if (stuMap.isEmpty()) {\n                return true;\n            }\n            // 5.将查询到的hash数据转为stuDTO\n            StudentDTO studentDTO = BeanUtil.fillBeanWithMap(stuMap, new StudentDTO(), false);\n            // 6.存在，保存用户信息到 ThreadLocal\n            StudentHolder.saveStudent(studentDTO);\n            // 7.刷新token有效期\n            stringRedisTemplate.expire(key, LOGIN_STU_TTL, TimeUnit.MINUTES);\n            // 8.放行\n            return true;\n        }\n\n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            // 移除用户\n            StudentHolder.removeStudent();\n        }\n    }',"java\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 1.判断是否需要拦截（ThreadLocal中是否有用户）\n        if (StudentHolder.getStudent() == null) {\n            // 没有，需要拦截，设置状态码\n            response.setStatus(401);\n            // 拦截\n            return false;\n        }\n        // 有用户，则放行\n        return true;\n    }",'java\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 登录拦截器\n        registry.addInterceptor(new LoginInterceptor())\n                .excludePathPatterns(\n                        "/student/code",\n                        "/student/login"\n                ).order(1);// order(1) 后执行，值越小，执行等级越高\n        // token刷新的拦截器\n        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns("/**").order(0);// order(0) 先执行\n    }',"java\n例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发\n\n例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存\n\n例3:Static final Map<K,V> map =  new HashMap(); 本地缓存",'java\n@GetMapping("/{id}")\npublic Result queryShopById(@PathVariable("id") Long id) {\n    //这里是直接查询数据库\n    return shopService.queryById(id);\n}','java\n    public Result queryById(Long id) {\n\n        String key = "cache:shop:" + id;\n        // 1. Mredis查询商铺缓存\n         String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            Shop shop = JSONUtil.toBean(shopJson, Shop.class);\n            return Result.ok(shop);\n\n        }\n        //4.不存在，根据id查询数据库\n        Shop shop = getById(id);\n        //5.不存在，返回错误\n        if (shop == null) {\n            return Result.fail("店铺不存在!");\n        }\n        //6.存在，写入\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));\n        //7.返回\n        return Result.ok(shop);\n        }',"java\nstringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),30L, TimeUnit.MINUTES);",'java\n @Transactional\n    public Result updateById(Shop shop){\n        Long id = shop.getId();\n        if(id == null){\n            return Result.fail("店铺id不能为空");\n        }\n        // 1.更新数据库\n        ShopList.updateById(shop);\n        // 2.删除缓存\n        stringRedisTemplate.delete(CACHE_SHOP_KEY + id);\n        return Result.ok();\n    }','json\n{\n"id":2,\n"name":"你看我名字变了吧",\n"address":"你看我地址也变了吧"\n}','java\n    private boolean tryLock(String key) {\n        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);//setnx\n        return BooleanUtil.isTrue(flag);//帮助拆箱，如果封装类是null会包空指针异常\n    }\n\n    private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n    }','java\n public Shop queryWithMutex(Long id){\n        String key = CACHE_SHOP_KEY + id;\n        // 1. Mredis查询商铺缓存\n        String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            return JSONUtil.toBean(shopJson, Shop.class);\n\n        }\n        //判断命中的是不是空值，缓存空对象，解决缓存穿透的策略\n        if(shopJson != null){\n            //返回一个错误信息\n            return null;\n        }\n        //4.实现缓存重建\n        //4.1获取互斥锁\n        String lockKey = "lock:shop:" + id;\n        Shop shop = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            //4.2判断是否获取成功\n            if (!isLock){\n                //4.3失败，则休眠或者重试\n                Thread.sleep(50);\n                return queryWithMutex(id);\n            }\n            //4.4成功，根据id查询数据库\n\n            //4.不存在，根据id查询数据库\n            shop = ShopList.findById(id);\n            // 模拟重建的延迟\n            Thread.sleep(200);\n            //5.不存在，返回错误\n            if (shop == null) {\n                //缓存空对象，解决缓存穿透\n                stringRedisTemplate.opsForValue().set(key, "",CACHE_NULL_TTL, TimeUnit.MINUTES);\n                return null;\n            }\n            //6.存在，写入\n            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            //7.释放锁\n            unlock(lockKey);\n        }\n        //8.返回\n        return shop;\n    }',"@Data\npublic class RedisData {\n    private LocalDateTime expireTime;\n    private Object data;\n}","java\n    public void saveShop2Redis(Long id,Long expireSeconds) throws InterruptedException {\n        Thread.sleep(200);\n        //1.查询店铺数据\n        Shop shop = ShopList.findById(id);\n        //2.封装逻辑过期时间\n        RedisData redisData = new RedisData();\n        redisData.setData(shop);\n        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));\n        //3.写入redis\n        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id ,JSONUtil.toJsonStr(redisData));\n    }","java\n@Test\n    public void testSaveShop() throws InterruptedException {\n        shopService.saveShop2Redis(2l,10l);\n    }","java\n// 创建一个线程池\n    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);\n    public Shop queryWithLogicalExpire(Long id){\n        String key = CACHE_SHOP_KEY + id;\n        // 1. Mredis查询商铺缓存\n        String shopJson  = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n//            3.存在，直接返回\n            return null;\n\n        }\n        //4.命中，需要先把JSON序列化为对象\n        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);\n        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        //5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return shop;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock){\n            CACHE_REBUILD_EXECUTOR.submit( ()->{\n\n                try{\n                    //重建缓存\n                    this.saveShop2Redis(id,20L);\n                }catch (Exception e){\n                    throw new RuntimeException(e);\n                }finally {\n                    unlock(lockKey);\n                }\n            });\n        }\n        //7.返回\n        return shop;\n\n\n    }",'java\n\n@Slf4j\n@Component\npublic class CacheClient {\n\n    private final StringRedisTemplate stringRedisTemplate;\n\n    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);//创建线程池\n\n    public CacheClient(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    /**\n     * 序列化java对象\n     * @param key 键\n     * @param value 被序列化的对象\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return void\n     * @author xuy\n     * @date 2022/12/27 17:20\n     */\n    public void set(String key, Object value, Long time, TimeUnit unit) {\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);\n    }\n\n    /**\n     * 逻辑过期 缓存重建\n     * @param key 键\n     * @param value java 对象\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return void\n     * @author xuy\n     * @date 2022/12/27 17:19\n     */\n    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {\n        // 设置逻辑过期\n        RedisData redisData = new RedisData();\n        redisData.setData(value);\n        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));\n        // 写入Redis\n        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));\n    }\n\n    /**\n     * 缓存穿透 用缓存空对象解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:24\n     */\n    public <R,ID> R queryWithPassThrough(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit){\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(json)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(json, type);\n        }\n        // 判断命中的是否是空值\n        if (json != null) {\n            // 返回一个错误信息\n            return null;\n        }\n\n        // 4.不存在，根据id查询数据库\n        R r = dbFallback.apply(id);\n        // 5.不存在，返回错误\n        if (r == null) {\n            // 将空值写入redis\n            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);\n            // 返回错误信息\n            return null;\n        }\n        // 6.存在，写入redis\n        this.set(key, r, time, unit);\n        return r;\n    }\n\n    /**\n     * 缓存击穿 逻辑过期解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:27\n     */\n    public <R, ID> R queryWithLogicalExpire(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isBlank(json)) {\n            // 3.存在，直接返回\n            return null;\n        }\n        // 4.命中，需要先把json反序列化为对象\n        RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n        LocalDateTime expireTime = redisData.getExpireTime();\n        // 5.判断是否过期\n        if(expireTime.isAfter(LocalDateTime.now())) {\n            // 5.1.未过期，直接返回店铺信息\n            return r;\n        }\n        // 5.2.已过期，需要缓存重建\n        // 6.缓存重建\n        // 6.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功\n        if (isLock){\n            // 6.3.成功，开启独立线程，实现缓存重建\n            CACHE_REBUILD_EXECUTOR.submit(() -> {\n                try {\n                    // 查询数据库\n                    R newR = dbFallback.apply(id);\n                    // 重建缓存\n                    this.setWithLogicalExpire(key, newR, time, unit);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }finally {\n                    // 释放锁\n                    unlock(lockKey);\n                }\n            });\n        }\n        // 6.4.返回过期的商铺信息\n        return r;\n    }\n\n    /**\n     * 缓存击穿 互斥锁解决\n     * @param keyPrefix key的前缀\n     * @param id 查询的id\n     * @param type 返回值类型\n     * @param dbFallback 有参有返回值的函数\n     * @param time 过期时间\n     * @param unit 时间单位\n     * @return R\n     * @author xuy\n     * @date 2022/12/27 17:38\n     */\n    public <R, ID> R queryWithMutex(\n            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n        String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n        String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n        if (StrUtil.isNotBlank(shopJson)) {\n            // 3.存在，直接返回\n            return JSONUtil.toBean(shopJson, type);\n        }\n        // 判断命中的是否是空值\n        if (shopJson != null) {\n            // 返回一个错误信息\n            return null;\n        }\n\n        // 4.实现缓存重建\n        // 4.1.获取互斥锁\n        String lockKey = LOCK_SHOP_KEY + id;\n        R r = null;\n        try {\n            boolean isLock = tryLock(lockKey);\n            // 4.2.判断是否获取成功\n            if (!isLock) {\n                // 4.3.获取锁失败，休眠并重试\n                Thread.sleep(50);\n                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n            }\n            // 4.4.获取锁成功，根据id查询数据库\n            r = dbFallback.apply(id);\n            // 5.不存在，返回错误\n            if (r == null) {\n                // 将空值写入redis\n                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);\n                // 返回错误信息\n                return null;\n            }\n            // 6.存在，写入redis\n            this.set(key, r, time, unit);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }finally {\n            // 7.释放锁\n            unlock(lockKey);\n        }\n        // 8.返回\n        return r;\n    }\n\n    private boolean tryLock(String key) {\n        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);//setnx\n        return BooleanUtil.isTrue(flag);//帮助拆箱，如果封装类是null会包空指针异常\n    }\n\n    private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n    }\n}','java\n  @Resource\n    private CacheClient cacheClient;//封装之后的工具类\n\n    public Result queryById(Long id) {\n        //解决缓存穿透\n        //Shop shop = queryWithPassThrough(id);\n        Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        //互斥锁解决缓存击穿\n        // Shop shop = queryWithMutex(id);\n//        Shop shop = cacheClient.queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        //逻辑过期解决缓存击穿\n        // Shop shop = queryWithLogicalExpire(id);\n//        Shop shop = cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, shopId -> ShopList.findById(shopId), CACHE_SHOP_TTL, TimeUnit.MINUTES);//封装之后的写法\n        if (shop == null) {\n            return Result.fail("店铺不存在！");\n        }\n        return Result.ok(shop);','java\n@Component\npublic class RedisIdWorker {\n    /**\n     * 开始时间戳\n     */\n    private static final long BEGIN_TIMESTAMP = 1640995200L;\n    /**\n     * 序列号的位数\n     */\n    private static final int COUNT_BITS = 32;\n\n    private StringRedisTemplate stringRedisTemplate;\n\n    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    public long nextId(String keyPrefix) {\n        // 1.生成时间戳\n        LocalDateTime now = LocalDateTime.now();\n        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);\n        long timestamp = nowSecond - BEGIN_TIMESTAMP;\n\n        // 2.生成序列号\n        // 2.1.获取当前日期，精确到天\n        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));\n        // 2.2.自增长\n        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);\n\n        // 3.拼接并返回\n        return timestamp << COUNT_BITS | count;//时间戳左移32位。或运算填充序列号\n    }\n}','java\n @Test\n    public void testRedisIdWorker() throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(300);\n        Runnable task = ()->{\n            for (int i = 0; i < 100; i++) {\n                System.out.println("id:"+redisIdWorker.nextId("order"));\n            }\n            latch.countDown();\n        };\n        long begin = System.currentTimeMillis();\n        for (int i = 0; i < 300; i++) {\n            es.submit(task);//线程池是异步的，得借助CountDownLatch\n        }\n        latch.await();//等待所有countdown结束\n        long end = System.currentTimeMillis();\n        System.out.println("time:"+(end - begin));\n    }',"java\n @PostMapping\n    public Result addVoucher(@RequestBody Voucher voucher) {\n        VoucherList.add(voucher);\n        return Result.ok(voucher.getId());\n    }",'java\n@PostMapping("seckill")\n    public Result addSeckillVoucher(@RequestBody Voucher voucher) {\n        voucherService.addSeckillVoucher(voucher);\n        return Result.ok(voucher.getId());\n    }',"java\n    //@Transactional\n    public void addSeckillVoucher(Voucher voucher) {\n        // 保存优惠券\n        VoucherList.add(voucher);\n        // 保存秒杀信息\n        SeckillVoucher seckillVoucher = new SeckillVoucher();\n        seckillVoucher.setVoucherId(voucher.getId());\n        seckillVoucher.setStock(voucher.getStock());\n        seckillVoucher.setBeginTime(voucher.getBeginTime());\n        seckillVoucher.setEndTime(voucher.getEndTime());\n        SeckillVoucherList.add(seckillVoucher);\n        // 保存秒杀库存到Redis中\n        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());\n    }",'json\n{\n"id": 2,\n"shopId": 2,\n"titile": "一百元代金券",\n"subTitle": "周一至周日均可以使用",\n"rules": "全场通用\\\\n无需预约\\\\n可无限叠加",\n"payValue": 8000,\n"actualValue": 10000,\n"type": 1,\n"stock": 100,\n"beginTime": "2022-12-26T10:09:17",\n"endTime": "2023-12-26T10:09:17"\n}','java\n public Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        //5，扣减库存\n        voucher.setStock(voucher.getStock()-1);\n        Boolean success = SeckillVoucherList.updateById(voucher);\n        if (!success) {\n            //扣减库存\n            return Result.fail("库存不足！");\n        }\n        //6.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 6.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 6.2.用户id\n        Long stuId = StudentHolder.getStudent().getId();\n        voucherOrder.setUserId(stuId);\n        // 6.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        //        创建优惠券订单\n        VoucherOrderList.add(voucherOrder);\n        return Result.ok(orderId);\n    }','java\n // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        //5，扣减库存\n        voucher.setStock(voucher.getStock()-1);\n        Boolean success = SeckillVoucherList.updateById(voucher);\n        if (!success) {\n            //扣减库存\n            return Result.fail("库存不足！");\n        }',"java\nint var5;\ndo {\n    var5 = this.getIntVolatile(var1, var2);\n} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\nreturn var5;","sql\nupdate table set stock = stock -1 where id = ？ and stock = ?","sql\nupdate table set stock = stock -1 where id = ？ and stock > 0",'java\n    @Transactional\npublic Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        Long stuId = StudentHolder.getStudent().getId();\n        // TODO 判断用户是否获取过优惠券\n        VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n        if (order != null){\n            // 用户已经购买过了\n            return Result.fail("用户已经购买过一次！");\n        }\n        //5，扣减库存\n        if(voucher.getStock() > 0){\n            voucher.setStock(voucher.getStock()-1);\n            Boolean success = SeckillVoucherList.updateById(voucher);\n            if (!success) {\n                //扣减库存\n                return Result.fail("库存不足！");\n            }\n        }\n        //6.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 6.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 6.2.用户id\n        voucherOrder.setUserId(stuId);\n        // 6.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n//        创建优惠券订单\n        VoucherOrderList.add(voucherOrder);\n        System.out.println(SeckillVoucherList.findById(voucherId));//剩下的订单\n        return Result.ok(orderId);\n    }','java\n    @Transactional\npublic synchronized Result createVoucherOrder(Long voucherId) {\n        // 5.1.查询订单\n        Long stuId = StudentHolder.getStudent().getId();\n        VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n        // 5.2.判断是否存在\n        if (order != null ) {\n            // 用户已经购买过了\n            return Result.fail("用户已经购买过一次！");\n        }\n        // 6.扣减库存\n        SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n        if(voucher.getStock() > 0){\n            voucher.setStock(voucher.getStock()-1);\n            Boolean success = SeckillVoucherList.updateById(voucher);\n            if (!success) {\n                // 扣减失败\n                return Result.fail("库存不足！");\n            }\n        }\n        // 7.创建订单\n        VoucherOrder voucherOrder = new VoucherOrder();\n        // 7.1.订单id\n        long orderId = redisIdWorker.nextId("order");\n        voucherOrder.setId(orderId);\n        // 7.2.用户id\n        voucherOrder.setUserId(stuId);\n        // 7.3.代金券id\n        voucherOrder.setVoucherId(voucherId);\n        VoucherOrderList.add(voucherOrder);\n        // 7.返回订单id\n        return Result.ok(orderId);\n    }','java\n    @Transactional\n    public Result createVoucherOrder(Long voucherId) {\n        Long stuId = StudentHolder.getStudent().getId();\n        synchronized (stuId.toString().intern()){\n            // 5.1.查询订单\n            VoucherOrder order = VoucherOrderList.findById(voucherId, stuId);\n            // 5.2.判断是否存在\n            if (order != null ) {\n                // 用户已经购买过了\n                return Result.fail("用户已经购买过一次！");\n            }\n            // 6.扣减库存\n            SeckillVoucher voucher = SeckillVoucherList.findById(voucherId);\n            if(voucher.getStock() > 0){\n                voucher.setStock(voucher.getStock()-1);\n                Boolean success = SeckillVoucherList.updateById(voucher);\n                if (!success) {\n                    // 扣减失败\n                    return Result.fail("库存不足！");\n                }\n            }\n            // 7.创建订单\n            VoucherOrder voucherOrder = new VoucherOrder();\n            // 7.1.订单id\n            long orderId = redisIdWorker.nextId("order");\n            voucherOrder.setId(orderId);\n            // 7.2.用户id\n            voucherOrder.setUserId(stuId);\n            // 7.3.代金券id\n            voucherOrder.setVoucherId(voucherId);\n            VoucherOrderList.add(voucherOrder);\n            // 7.返回订单id\n            return Result.ok(orderId);\n        }\n    }',"java\nsynchronized (stuId.toString().intern()) {\n            return this.createVoucherOrder(voucherId);\n        }","java\n        synchronized (stuId.toString().intern()) {\n            //获取代理对象(事务)\n            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();\n            return proxy.createVoucherOrder(voucherId);\n        }","java\npublic interface ILock {\n    /**\n     * 尝试获取锁\n     * @param timeoutSec 锁持有的超时时间，过期后自动释放\n     * @return true代表获取锁成功; false代表获取锁失败\n     */\n    boolean tryLock(long timeoutSec);\n\n    /**\n     * 释放锁\n     */\n    void unlock();\n}",'java\nprivate static final String KEY_PREFIX="lock:";\n@Override\npublic boolean tryLock(long timeoutSec) {\n    // 获取线程标示\n    String threadId = Thread.currentThread().getId();\n    // 获取锁\n    Boolean success = stringRedisTemplate.opsForValue()\n            .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS);\n    return Boolean.TRUE.equals(success);\n}',"java\npublic void unlock() {\n    //通过del删除锁\n    stringRedisTemplate.delete(KEY_PREFIX + name);\n}",'java\n  @Override\n    public Result seckillVoucher(Long voucherId) {\n        // 1.查询优惠券\n        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);\n        // 2.判断秒杀是否开始\n        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀尚未开始！");\n        }\n        // 3.判断秒杀是否已经结束\n        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {\n            // 尚未开始\n            return Result.fail("秒杀已经结束！");\n        }\n        // 4.判断库存是否充足\n        if (voucher.getStock() < 1) {\n            // 库存不足\n            return Result.fail("库存不足！");\n        }\n        Long userId = UserHolder.getUser().getId();\n        //创建锁对象(新增代码)\n        SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);\n        //获取锁对象\n        boolean isLock = lock.tryLock(1200);\n\t\t//加锁失败\n        if (!isLock) {\n            return Result.fail("不允许重复下单");\n        }\n        try {\n            //获取代理对象(事务)\n            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();\n            return proxy.createVoucherOrder(voucherId);\n        } finally {\n            //释放锁\n            lock.unlock();\n        }\n    }']},{title:"redis 学习笔记之快速入门",headers:[{level:2,title:"1.初识Redis",slug:"_1-初识redis",link:"#_1-初识redis",children:[{level:3,title:"1.1.认识Nosql",slug:"_1-1-认识nosql",link:"#_1-1-认识nosql",children:[]},{level:3,title:"1.2.认识redis",slug:"_1-2-认识redis",link:"#_1-2-认识redis",children:[]},{level:3,title:"1.3.安装redis",slug:"_1-3-安装redis",link:"#_1-3-安装redis",children:[]},{level:3,title:"1.4.Redis桌面客户端",slug:"_1-4-redis桌面客户端",link:"#_1-4-redis桌面客户端",children:[]}]},{level:2,title:"2.Redis常用命令",slug:"_2-redis常用命令",link:"#_2-redis常用命令",children:[{level:3,title:"2.1.Redis通用命令",slug:"_2-1-redis通用命令",link:"#_2-1-redis通用命令",children:[]},{level:3,title:"2.2.String类型",slug:"_2-2-string类型",link:"#_2-2-string类型",children:[]},{level:3,title:"2.2.1.String常用命令",slug:"_2-2-1-string常用命令",link:"#_2-2-1-string常用命令",children:[]},{level:3,title:"2.2.2.Key结构",slug:"_2-2-2-key结构",link:"#_2-2-2-key结构",children:[]},{level:3,title:"2.3.Hash类型",slug:"_2-3-hash类型",link:"#_2-3-hash类型",children:[]},{level:3,title:"2.4.List类型",slug:"_2-4-list类型",link:"#_2-4-list类型",children:[]},{level:3,title:"2.5.Set类型",slug:"_2-5-set类型",link:"#_2-5-set类型",children:[]},{level:3,title:"2.6.SortedSet类型",slug:"_2-6-sortedset类型",link:"#_2-6-sortedset类型",children:[]}]},{level:2,title:"3.1.Redis客户端",slug:"_3-1-redis客户端",link:"#_3-1-redis客户端",children:[{level:3,title:"3.1.1.快速入门",slug:"_3-1-1-快速入门",link:"#_3-1-1-快速入门",children:[]},{level:3,title:"3.1.2.连接池",slug:"_3-1-2-连接池",link:"#_3-1-2-连接池",children:[]}]},{level:2,title:"3.2.SpringDataRedis客户端",slug:"_3-2-springdataredis客户端",link:"#_3-2-springdataredis客户端",children:[{level:3,title:"3.2.1.快速入门",slug:"_3-2-1-快速入门",link:"#_3-2-1-快速入门",children:[]}]},{level:2,title:"3.2.2.自定义序列化",slug:"_3-2-2-自定义序列化",link:"#_3-2-2-自定义序列化",children:[{level:3,title:"3.2.3.StringRedisTemplate",slug:"_3-2-3-stringredistemplate",link:"#_3-2-3-stringredistemplate",children:[]}]}],path:"/posts/redis/redis%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",pathLocale:"/",extraFields:['json\n{\n  id: 1,\n  name: "张三",\n  orders: [\n    {\n       id: 1,\n       item: {\n\t id: 10, title: "荣耀6", price: 4999\n       }\n    },\n    {\n       id: 2,\n       item: {\n\t id: 20, title: "小米11", price: 3999\n       }\n    }\n  ]\n}',"sql\n# 关系型 SQL \nselect * from t_user where id = 1;\n# 非关系型 Redis\nget user:1\n# 非关系型 MongoDB\n`db.users.find({_id:1})`\n# 非关系型 elasticsearch\nGET http://localhost:9200/users/1","cmd\n# 默认启动\nredis-server","properties\n# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0\nbind 0.0.0.0\n# 守护进程，修改为yes后即可后台运行\ndaemonize yes \n# 密码，设置后访问Redis必须输入密码\nrequirepass 123321",'properties\n# 监听的端口\nport 6379\n# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录\ndir .\n# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15\ndatabases 1\n# 设置redis能够使用的最大内存\nmaxmemory 512mb\n# 日志文件，默认为空，不记录日志，可以指定日志文件名\nlogfile "redis.log"',"sh\n# 进入redis安装目录 \ncd /usr/local/src/redis-6.2.6\n# 启动\nredis-server redis.conf","sh\nredis-server.exe redis.windows.conf\n# 进入命令行\nredis-cli.exe","sh\n# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，\n# 因为之前配置了密码，因此需要通过 -u 来指定密码\nredis-cli -u 123321 shutdown","sh\nvi /etc/systemd/system/redis.service","shell\n[Unit]\nDescription=redis-server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target","sh\nsystemctl daemon-reload","sh\n# 启动\nsystemctl start redis\n# 停止\nsystemctl stop redis\n# 重启\nsystemctl restart redis\n# 查看状态\nsystemctl status redis","sh\nsystemctl enable redis","sh\nredis-cli [options] [commonds]","sh\n# 查看keys命令的帮助信息：\n127.0.0.1:6379> help keys\n\nKEYS pattern\nsummary: Find all keys matching the given pattern\nsince: 1.0.0\ngroup: generic","xml\n\x3c!--jedis--\x3e\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.7.0</version>\n</dependency>\n\x3c!--单元测试--\x3e\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter</artifactId>\n    <version>5.7.0</version>\n    <scope>test</scope>\n</dependency>",'java\nprivate Jedis jedis;\n\n@BeforeEach\nvoid setUp() {\n    // 1.建立连接\n    jedis = new Jedis("192.168.150.101", 6379);\n    //jedis = JedisConnectionFactory.getJedis();\n    // 2.设置密码\n    jedis.auth("123321");\n    // 3.选择库\n    jedis.select(0);\n}','java\n@Test\nvoid testString() {\n    // 存入数据\n    String result = jedis.set("name", "虎哥");\n    System.out.println("result = " + result);\n    // 获取数据\n    String name = jedis.get("name");\n    System.out.println("name = " + name);\n}\n\n@Test\nvoid testHash() {\n    // 插入hash数据\n    jedis.hset("user:1", "name", "Jack");\n    jedis.hset("user:1", "age", "21");\n\n    // 获取\n    Map<String, String> map = jedis.hgetAll("user:1");\n    System.out.println(map);\n}',"java\n@AfterEach\nvoid tearDown() {\n    if (jedis != null) {\n        jedis.close();\n    }\n}",'java\npackage com.heima.jedis.util;\n\nimport redis.clients.jedis.*;\n\npublic class JedisConnectionFactory {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 配置连接池\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(8);//设置总共的连接的最大数量\n        poolConfig.setMaxIdle(8);//最大空闲连接数, 默认8个\n        poolConfig.setMinIdle(0);//最小空闲连接数, 默认0\n        poolConfig.setMaxWaitMillis(1000);//超时时间\n        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码\n        jedisPool = new JedisPool(poolConfig, "192.168.150.101", 6379, 1000, "123321");\n    }\n\n    public static Jedis getJedis(){\n        return jedisPool.getResource();\n    }\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.7</version>\n        <relativePath/> \x3c!-- lookup parent from repository --\x3e\n    </parent>\n    <groupId>com.heima</groupId>\n    <artifactId>redis-demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>redis-demo</name>\n    <description>Demo project for Spring Boot</description>\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n    <dependencies>\n        \x3c!--redis依赖--\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        \x3c!--common-pool--\x3e\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-pool2</artifactId>\n        </dependency>\n        \x3c!--Jackson依赖--\x3e\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>',"shell\nspring:\n  redis:\n    host: 192.168.150.101\n    port: 6379\n    password: 123321\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        min-idle: 0\n        max-wait: 100ms","java\n@SpringBootTest\nclass RedisStringTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n}",'java\n@SpringBootTest\nclass RedisStringTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    void testString() {\n        // 写入一条String数据\n        redisTemplate.opsForValue().set("name", "虎哥");\n        // 获取string数据\n        Object name = stringRedisTemplate.opsForValue().get("name");\n        System.out.println("name = " + name);\n    }\n}',"java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){\n        // 创建RedisTemplate对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n        // 创建JSON序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer = \n            \t\t\t\t\t\t\tnew GenericJackson2JsonRedisSerializer();\n        // 设置Key的序列化\n        template.setKeySerializer(RedisSerializer.string());\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置Value的序列化\n        template.setValueSerializer(jsonRedisSerializer);\n        template.setHashValueSerializer(jsonRedisSerializer);\n        // 返回\n        return template;\n    }\n}",'json\n{\n    "@class": "com.heima.redis.pojo.User",\n    "name": "虎哥",\n    "age": 21\n}','java\n@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n// JSON序列化工具\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\n@Test\nvoid testSaveUser() throws JsonProcessingException {\n    // 创建对象\n    User user = new User("虎哥", 21);\n    // 手动序列化\n    String json = mapper.writeValueAsString(user);\n    // 写入数据\n    stringRedisTemplate.opsForValue().set("user:200", json);\n\n    // 获取数据\n    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");\n    // 手动反序列化\n    User user1 = mapper.readValue(jsonUser, User.class);\n    System.out.println("user1 = " + user1);\n}']},{title:"redis 使用过程中的bug记录",headers:[{level:2,title:"Windows环境",slug:"windows环境",link:"#windows环境",children:[]},{level:2,title:"MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.",slug:"misconf-redis-is-configured-to-save-rdb-snapshots-but-it-is-currently-not-able-to-persist-on-disk-commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-rdb-snapshotting-fails-stop-writes-on-bgsave-error-option-please-check-the-redis-logs-for-details-about-the-rdb-error",link:"#misconf-redis-is-configured-to-save-rdb-snapshots-but-it-is-currently-not-able-to-persist-on-disk-commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-rdb-snapshotting-fails-stop-writes-on-bgsave-error-option-please-check-the-redis-logs-for-details-about-the-rdb-error",children:[]}],path:"/posts/redis/redisBUG.html",pathLocale:"/",extraFields:["shell\nD:\\Redis-x64-5.0.14.1>redis-server.exe redis.windows.conf\n[7948] 29 Jan 10:06:50.399 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n[7948] 29 Jan 10:06:50.399 # Redis version=5.0.14.1, bits=64, commit=ec77f72d, modified=0, pid=7948, just started\n[7948] 29 Jan 10:06:50.400 # Configuration loaded\n[7948] 29 Jan 10:06:50.402 # Could not create server TCP listening socket 127.0.0.1:6379: bind: 操作成功完成。","shell\nredis-cli.exe      # 进入客户端\nshutdown  # 关闭该redis服务\nexit       # 退出\nredis-server.exe redis.windows.conf  # 重新启动reids 服务","shell\n127.0.0.1:6379> config set stop-writes-on-bgsave-error no"]},{title:"shell 基础知识",headers:[{level:2,title:"1、@echo off",slug:"_1、-echo-off",link:"#_1、-echo-off",children:[]},{level:2,title:"2、%0 %1——给批处理脚本传递参数",slug:"_2、-0-1——给批处理脚本传递参数",link:"#_2、-0-1——给批处理脚本传递参数",children:[]},{level:2,title:"3、变量声明、设置、拼接、截取",slug:"_3、变量声明、设置、拼接、截取",link:"#_3、变量声明、设置、拼接、截取",children:[]},{level:2,title:"4、路径相关%cd%和%~dp0的区别",slug:"_4、路径相关-cd-和-dp0的区别",link:"#_4、路径相关-cd-和-dp0的区别",children:[]},{level:2,title:"5、遍历指定目录下资源文件并更新",slug:"_5、遍历指定目录下资源文件并更新",link:"#_5、遍历指定目录下资源文件并更新",children:[]},{level:2,title:"6、替换字符串中匹配的子串",slug:"_6、替换字符串中匹配的子串",link:"#_6、替换字符串中匹配的子串",children:[]},{level:2,title:"7、各种形式的变量%0、%i、%%i、var、%var%、!var!的含义和区别",slug:"_7、各种形式的变量-0、-i、-i、var、-var-、-var-的含义和区别",link:"#_7、各种形式的变量-0、-i、-i、var、-var-、-var-的含义和区别",children:[{level:3,title:"7.1、%0",slug:"_7-1、-0",link:"#_7-1、-0",children:[]},{level:3,title:"7.2、%i",slug:"_7-2、-i",link:"#_7-2、-i",children:[]},{level:3,title:"7.3、%%i",slug:"_7-3、-i",link:"#_7-3、-i",children:[]},{level:3,title:"7.4、var,%var%",slug:"_7-4、var-var",link:"#_7-4、var-var",children:[]},{level:3,title:"7.5、!var!",slug:"_7-5、-var",link:"#_7-5、-var",children:[]}]},{level:2,title:"8、替换带有等号=的字符串的子串",slug:"_8、替换带有等号-的字符串的子串",link:"#_8、替换带有等号-的字符串的子串",children:[]},{level:2,title:"9、从路径字符串中截取盘符、文件名、后缀名等信息",slug:"_9、从路径字符串中截取盘符、文件名、后缀名等信息",link:"#_9、从路径字符串中截取盘符、文件名、后缀名等信息",children:[]},{level:2,title:"10、替换字符串中包含百分号%的子串",slug:"_10、替换字符串中包含百分号-的子串",link:"#_10、替换字符串中包含百分号-的子串",children:[]},{level:2,title:"来源",slug:"来源",link:"#来源",children:[]}],path:"/posts/shell/shell.html",pathLocale:"/",extraFields:["shell\n@echo off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause","shell \necho off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause","shell\n::echo off\n\necho 这是测试内容的第1行\necho 这是测试内容的第2行\necho 这是测试内容的第3行\necho end\n\npause","shell\n@echo off\n\necho param[0] = %0\necho param[1] = %1\necho param[2] = %2\necho param[3] = %3\necho param[4] = %4\necho param[5] = %5\necho ...\npause","shell\n@echo off\n\n::设置变量\nSET Sender1=%1\nSET Sender2=%2\nSET Receiver=%3\nSET Content=%4\n\n::字符串拼接(等号前面不能有空格)\nSET Sender=%Sender1%, %Sender2% \n::字符串截取\nSET RealContent=%Content:~1,-1%\n\necho Sender = %Sender%\necho ---------------------------------/\necho Receiver = %Receiver%\necho ---------------------------------/\necho Content = %Content%\necho ---------------------------------/\necho RealContent = %RealContent%\necho ---------------------------------/\n\npause","shell\n@echo off\n\n::对比%cd%和%~dp0的不同\necho %%cd%% = %cd%     \necho %%~dp0 = %~dp0","cmd\nF:\\batTool>test_dir.bat\n%cd% = F:\\batTool\n%~dp0 = F:\\batTool\\\n\nF:\\batTool>cd /d E:\n\nE:>F:\\batTool\\test_dir.bat\n%cd% = E:\\\n%~dp0 = F:\\batTool\\\n\nE:>cd /d D:\n\nD:>F:\\batTool\\test_dir.bat\n%cd% = D:\\\n%~dp0 = F:\\batTool\\","shell\nroot:[E:/dirZ]\n+--aaa.txt\n+--bbb.txt\n+--ccc.txt\n+--ddd.txt\n+--eee.txt\n+--extra.c\n+--extra.h\n+--fff.txt\n+--ggg.txt","shell\nroot:[E:/dirA]\n+--aaa.txt\n+--bbb.txt\n+--dirB\n|    +--ccc.txt\n|    +--extra.c\n|    +--extra.h\n+--dirC\n|    +--ddd.txt\n|    +--dirD\n|    |    +--eee.txt\n+--dirE\n|    +--dirF\n|    |    +--fff.txt\n|    |    +--ggg.txt",'shell\n@echo off\n\nrem 启用延迟环境变量扩展\nsetlocal enabledelayedexpansion\n\nrem 定义不需要更新的文件\nSET EXCEPT_FILE=ggg.txt\n\nrem 定义工作目录和资源目录\nSET WORK_PATH=E:\\dirA\\\nSET RESO_PATH=E:\\dirZ\\\n\nrem 简单输出查看一下\necho WORK_PATH is %WORK_PATH%\necho RESO_PATH is %RESO_PATH%\necho ------------------------\n\nrem for循环递归遍历WORK_PATH目录中的.txt文件，文件的全路径放在变量f中\nfor /R %WORK_PATH% %%f in (*.txt) do (\n rem 使用TARGET_FILE变量记录绝对文件名，注意延迟变量的使用\n SET TARGET_FILE=%%f\n echo !TARGET_FILE!\n\n rem 去掉路径，只保留文件名及扩展名\n SET "FILE_PATH_NO_EXT=%%~nxf"\n rem 利用资源路径和文件名，拼接出资源的绝对全路径\n SET SOURCE_FILE=%RESO_PATH%!FILE_PATH_NO_EXT!\n echo !SOURCE_FILE!\n\n rem 条件判断是否是不需要更新的文件\n if NOT !FILE_PATH_NO_EXT!==%EXCEPT_FILE% (\n     copy !SOURCE_FILE! !TARGET_FILE!\n )\n)\npause',"shell\nWORK_PATH is E:\\dirA\\\nRESO_PATH is E:\\dirZ\\\n<hr />\n\nE:\\dirA\\aaa.txt\nE:\\dirZ\\aaa.txt\n已复制         1 个文件。\nE:\\dirA\\bbb.txt\nE:\\dirZ\\bbb.txt\n已复制         1 个文件。\nE:\\dirA\\dirB\\ccc.txt\nE:\\dirZ\\ccc.txt\n已复制         1 个文件。\nE:\\dirA\\dirC\\ddd.txt\nE:\\dirZ\\ddd.txt\n已复制         1 个文件。\nE:\\dirA\\dirC\\dirD\\eee.txt\nE:\\dirZ\\eee.txt\n已复制         1 个文件。\nE:\\dirA\\dirE\\dirF\\fff.txt\nE:\\dirZ\\fff.txt\n已复制         1 个文件。\nE:\\dirA\\dirE\\dirF\\ggg.txt\nE:\\dirZ\\ggg.txt\n请按任意键继续. . .",'shell\nECHO off\nSETlOCAL enabledelayedexpansion\n\nSET FIND_DIR=E:\\dirA\\dirC\\dirD\n\nfor /R %FIND_DIR% %%f in (*.txt) do (\n    SET FULL_PATH=%%f\n    ECHO 完整的路径: !FULL_PATH!\n\n    SET FILE_DIR=%%~dpf\n    ECHO 所在的目录: !FILE_DIR!\n\n    SET FILE_NAME=%%~nf\n    ECHO 无后缀文件: !FILE_NAME!\n\n    SET FILE_EXT=%%~xf\n    ECHO 文件名后缀: !FILE_EXT!\n\n    SET "FILE_NAME_NOT_PATH=%%~nxf"\n    ECHO 无路径文件: !FILE_NAME_NOT_PATH!\n\n    SET "FULL_PATH_NOT_EXT=%%~dpnf"\n    ECHO 无后缀全名: !FULL_PATH_NOT_EXT!\n)\npause',"shell\n完整的路径: E:\\dirA\\dirC\\dirD\\eee.txt\n所在的目录: E:\\dirA\\dirC\\dirD\\\n无后缀文件: eee\n文件名后缀: .txt\n无路径文件: eee.txt\n无后缀全名: E:\\dirA\\dirC\\dirD\\eee","shell\n@echo off\n\nSET INPUT_PARAM=%1\n\nrem 替换输入变量中的world为China\necho source string is %INPUT_PARAM%\necho ===   China replace world   ===\necho replace result is %INPUT_PARAM:world=China%\n\necho.\n\nrem 将路径中的反斜杠替换成斜杠\nSET IMAGE_PATH=C:\\NVIDIA\\AndroidWorks\\001\necho source string is %IMAGE_PATH%\necho ===   \\ replace /   ===\necho replace result is %IMAGE_PATH:\\=/%\n\necho.\n\necho ABCD:A=a\n\npause",'shell\nE:\\batTool>Replace.bat "Hello wolrd, All over the world!"\nsource string is "Hello wolrd, All over the world!"\n===   China replace world   ===\nreplace result is "Hello wolrd, All over the China!"\n\nsource string is C:\\NVIDIA\\AndroidWorks\\001\n===   \\ replace /   ===\nreplace result is C:/NVIDIA/AndroidWorks/001\n\nABCD:A=a\n请按任意键继续. . .',"shell\n@echo off\n\necho param0=%0\necho param0=%1\necho param0=%2","shell\nC:\\Users\\Administrator\\Downloads>testparams.bat “hello world”\nparam0=testparams.bat\nparam1=“hello world”\nparam2=","shell\nC:\\Users\\Administrator\\Downloads>for %i in (1,3,5,8) do echo %i\nC:\\Users\\Administrator\\Downloads>echo 1\n1\nC:\\Users\\Administrator\\Downloads>echo 3\n3\nC:\\Users\\Administrator\\Downloads>echo 5\n5\nC:\\Users\\Administrator\\Downloads>echo 8\n8","shell\nC:\\Users\\Administrator\\Downloads>for %%i in (1,3,5,8) do echo %%i\n此时不应有 %%i。","shell\nfor %%i in (1,3,5,8) do echo %%i","shell\nD:\\test\\battest>testPrecent.bat\nD:\\test\\battest>for %i in (1 3 5 8) do echo %i\nD:\\test\\battest>echo 1\n1\nD:\\test\\battest>echo 3\n3\nD:\\test\\battest>echo 5\n5\nD:\\test\\battest>echo 8\n8","shell\nfor %i in (1,3,5,8) do echo %i","shell\nC:\\Users\\Administrator\\Downloads>testfor.bat\n此时不应有 i。","shell\n@echo off\n\nset var1=1\nset /a var2=var1+1\n\necho var1\necho var2","shell\nC:\\Users\\Administrator\\Downloads>normalVar.bat\nvar1\nvar2","shell\n@echo off\n\nset var1=1\nset /a var2=var1+1\n\nset var3=%var2%\n\necho %var1%\necho %var2%\necho %var3%","shell\nC:\\Users\\Administrator\\Downloads>normalVar.bat\n1\n2\n2","shell\n@echo off\n\nset var1=110\nset var1=120&echo %var1%","shell\nC:\\Users\\Administrator\\Downloads>extVar.bat\n110","shell\n@echo off\n\nsetlocal enabledelayedexpansion\nset var1=110\nset var1=120&echo !var1!","shell\nset STR=abcdo=ocar12a=ajdjko=ot","shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset RESULT=%STR:o=o=A%\n\necho %RESULT%\npause > nul","shell\nabcdo=A=o=Acar12a=ajdjko=A=o=At","shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset RESULT=%STR:o^=o=A%\n\necho %RESULT%\npause > nul","shell\nabcdo=ocar12a=ajdjko=ot",'shell\n@echo off\n\nset STR=abcdo=ocar12a=ajdjko=ot\nset CURSTR=%STR%\nset RESULT=\n\n:next\nif "%CURSTR%" equ "" goto end\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT=%RESULT%#) else (set RESULT=%RESULT%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next\n\n:end\necho source string is %STR%\necho result string is %RESULT%\npause > nul',"shell\nsource string is abcdo=ocar12a=ajdjko=ot\nresult string is abcdo#ocar12a#ajdjko#ot",'@echo off\n\nrem 第一步\nset CORESTR=###i#am#happy###\nset STR=abcdo=ocar12a=ajdjko=ot\nset CURSTR=%STR%\nset RESULT1=\n\n:next1\nif "%CURSTR%" equ "" goto end1\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT1=%RESULT1%%CORESTR%) else (set RESULT1=%RESULT1%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next1\n\n:end1\necho source1 string is %STR%\necho result1 string is %RESULT1%\npause > nul\n\n\nrem 第 2 步\nset CORESTR=###i#am#happy###\nset STR=o=o\nset CURSTR=%STR%\nset RESULT2=\n\n:next2\nif "%CURSTR%" equ "" goto end2\nset a=%CURSTR:~0,1%\n\nif "%a%" equ "=" (set RESULT2=%RESULT2%%CORESTR%) else (set RESULT2=%RESULT2%%a%)\nset CURSTR=%CURSTR:~1%\ngoto next2\n\n:end2\necho source2 string is %STR%\necho result2 string is %RESULT2%\npause > nul\n\n\nrem 第3步，需要开启延迟变量\nsetlocal ENABLEDELAYEDEXPANSION\nset RESULT3=!RESULT1:%RESULT2%=A!\necho result3 string is %RESULT3%\npause > nul\n\n\nrem 第4步\nset RESULT4=!RESULT3:%CORESTR%==!\n\necho finally result is %RESULT4%',"shell\nsource1 string is abcdo=ocar12a=ajdjko=ot\nresult1 string is abcdo###i#am#happy###ocar12a###i#am#happy###ajdjko###i#am#happy###ot\nsource2 string is o=o\nresult2 string is o###i#am#happy###o\nresult3 string is abcdAcar12a###i#am#happy###ajdjkAt\nfinally result is abcdAcar12a=ajdjkAt",'shell\nAlbert at home-pc in D:\\data\\bat [0:03:25]\n% Get-Content showparams.bat\n@echo off\n\necho %0\necho %1\n\nAlbert at home-pc in D:\\data\\bat [0:03:31]\n% ./showparams.bat good\n"D:\\data\\bat\\showparams.bat"\ngood','shell\nAlbert at home-pc in D:\\data\\bat [0:26:17]\n% Get-Content showparams.bat\n@echo off\n\necho %0\necho %~0\necho %~f0\necho %~d0\necho %~p0\necho %~n0\necho %~x0\necho %~s0\necho %~a0\necho %~t0\necho %~z0\necho %~dp0\necho %~nx0\nAlbert at home-pc in D:\\data\\bat [0:26:28]\n% .\\showparams.bat\n"D:\\data\\bat\\showparams.bat"\nD:\\data\\bat\\showparams.bat\nD:\\data\\bat\\showparams.bat\nD:\n\\data\\bat\\\nshowparams\n.bat\nD:\\data\\bat\\showparams.bat\n--a--------\n2021/10/17 00:26\n156\nD:\\data\\bat\\\nshowparams.bat','Albert at home-pc in D:\\data\\bat [17:37:54]\n% Get-Content extract1.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\necho %OriginStr%\n\ncall :extract %OriginStr%\ngoto :eof\n\n:extract\nrem 获取到文件路径\necho %~dp1\nrem 获取到文件盘符\necho %~d1\nrem 获取到文件名称\necho %~n1\nrem 获取到文件后缀\necho %~x1\n\nAlbert at home-pc in D:\\data\\bat [17:41:25]\n% .\\extract1.bat\n"C:/Demo/myproject/example.txt"\nC:\\Demo\\myproject\\\nC:\nexample\n.txt','Albert at home-pc in D:\\data\\bat [17:46:29]\n% Get-Content extract2.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\n\nfor %%I in (%OriginStr%) do echo %%I\n\nAlbert at home-pc in D:\\data\\bat [17:46:57]\n% .\\extract2.bat\n"C:/Demo/myproject/example.txt"','Albert at home-pc in D:\\data\\bat [17:53:53]\n\n% Get-Content extract2.bat\n@echo off\n\nset OriginStr="C:/Demo/myproject/example.txt"\n\nfor %%I in (%OriginStr%) do echo %%I\n\nrem 获取到文件路径\nfor %%I in (%OriginStr%) do echo %%~dpI\nrem 获取到文件盘符\nfor %%I in (%OriginStr%) do echo %%~dI\nrem 获取到文件名称\nfor %%I in (%OriginStr%) do echo %%~nI\nrem 获取到文件后缀\nfor %%I in (%OriginStr%) do echo %%~xI\n\nAlbert at home-pc in D:\\data\\bat [17:54:01]\n\n% .\\extract2.bat\n"C:/Demo/myproject/example.txt"\nC:\\Demo\\myproject\\\nC:\nexample\n.txt',"shell\n将字符串 https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925 中的 %3c 替换成字母 e","@echo off\nrem 将输入字符串中的%3c替换成字母e\n\nSET INPUT_PARAM=%1\nsetlocal EnableDelayedExpansion\n\necho -\necho replace result is !INPUT_PARAM:%%3c=e!\necho -\n\npause","D:\\data\\bat>replace%.bat https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925\n-\nreplace result is https://blog.csdn.net/albertsh/article/details/124760925\n-\n请按任意键继续. . .","shell\n批处理脚本中的替换语法不仅可以写成 %a:b=c%，还可以写成 !a:b=c!的形式\n批处理脚本执行机制是会按行执行，在执行之前会先预处理\n开启延迟环境变量扩展setlocal enabledelayedexpansion，变量会在用到时再估值，不会预处理了"]},{title:"工作中遇到的 shell",headers:[{level:2,title:"1、脚本启动停止jar包，并生成日志文件",slug:"_1、脚本启动停止jar包-并生成日志文件",link:"#_1、脚本启动停止jar包-并生成日志文件",children:[]},{level:2,title:"2、上面的变种",slug:"_2、上面的变种",link:"#_2、上面的变种",children:[]}],path:"/posts/shell/shellWork.html",pathLocale:"/",extraFields:['shell\n@echo off\n%1 mshta vbscript:CreateObject("WScript.Shell").Run("%~s0 ::",0,FALSE)(window.close)&&exit\njava -jar 包名.jar >StartupLog.log  2>&1 &\nexit','shell\n@echo off\nset port=程序端口号\nfor /f "tokens=1-5" %%i in (\'netstat -ano^|findstr ":%port%"\') do taskkill /f /pid %%m',"shell\nset JAVA_HOME=./jdk\n \nset CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n \nset Path=%JAVA_HOME%\\bin;\n \njava -jar DMS_DEMO-1.0-SNAPSHOT.jar",'shell\n@echo off\n# 项目启动后，会占用的端口\nset port=9021\nfor /f "tokens=1-5" %%i in (\'netstat -ano^|findstr ":%port%"\') do (\n    echo kill the process %%m who use the port %port%\n    # 根据 进程id pid 信息，杀掉进程\n    taskkill /f /pid %%m\n)']},{title:"Windows 工作中遇到的问题",headers:[{level:2,title:"windows 端口占用",slug:"windows-端口占用",link:"#windows-端口占用",children:[]},{level:2,title:"windows 启动 jar包",slug:"windows-启动-jar包",link:"#windows-启动-jar包",children:[]},{level:2,title:"windows 停止 jar包",slug:"windows-停止-jar包",link:"#windows-停止-jar包",children:[]}],path:"/posts/windows/workcondition.html",pathLocale:"/",extraFields:['sh\n# 查找端口号，监听的程序id\nnetstat -aon|findstr "9011"\n# 通过程序id，找到程序\ntasklist|findstr "24548"\n# 通过程序id，杀死这个程序\ntaskkill -pid 24548 -f','shell\n@echo off\nsetlocal\n\nREM 改变当前工作目录到 JAR 文件所在目录, /d 参数允许同时更改驱动器和目录\ncd /d D:\\transferData\\\n\nREM 指定Java应用程序和参数\nset "JAVA_PATH=D:\\transferData\\jdk1.8.0_351\\jre\\bin\\java"\nset "JAR_FILE=datatransport-0.0.1-SNAPSHOT.jar"\n\nREM 启动Java应用程序\n"%JAVA_PATH%" -jar "%JAR_FILE%" --server.port=10086\nendlocal\nPAUSE',"shell\n@echo off\nREM 确保在批处理脚本中对环境变量所做的更改只在该脚本内部有效，不会影响到批处理脚本外部的环境变量\nsetlocal\n\nREM 设置要查找和停止的端口号\nset PORT=10086\n\nREM 查找并终止监听指定端口的Java进程\nfor /f \"tokens=5\" %%i in ('netstat -ano ^| findstr :%PORT%') do (\n    taskkill /F /PID %%i\n)\n\necho Attempted to stop Java process listening on port %PORT%.\n\nendlocal\nPAUSE",'shell\n@echo off\nsetlocal\n\nREM 设置要查找和停止的端口号\nset PORT=10086\n\nREM 初始化变量用于存储唯一PID\nset UNIQUE_PIDS=\n\nREM 查找并终止监听指定端口的Java进程，同时去重\nfor /f "tokens=5" %%i in (\'netstat -ano ^| findstr :%PORT%\') do (\n    set NEW_PID=%%i\n    set found=\n    for /f "tokens=*" %%j in (\'set pid_%%i 2^>nul\') do set found=true\n    if not defined found (\n        echo Process ID listening on port %PORT% is %%i\n        taskkill /F /PID %%i\n        if errorlevel 1 (\n            echo Failed to stop the process with PID %%i.\n        ) else (\n            echo Successfully stopped the Java process with PID %%i.\n            set pid_%%i=1\n        )\n    )\n)\n\nif "%UNIQUE_PIDS%"=="" (\n    echo No process found listening on port %PORT%.\n) else (\n    echo All matching processes have been processed.\n)\n\nendlocal\nPAUSE','shell\n@echo off\nsetlocal\n\nREM 设置JDK路径和JAR文件路径\nset "jdkPath=D:\\transferData\\jdk1.8.0_351"\nset "jarFileName=datatransport-0.0.1-SNAPSHOT.jar"\n\nREM 保存当前的JAVA_HOME和PATH\nset "original_JAVA_HOME=%JAVA_HOME%"\nset "original_PATH=%PATH%"\n\nREM 设置新的JAVA_HOME环境变量\nset "JAVA_HOME=%jdkPath%"\n\nREM 添加JDK的bin目录到PATH环境变量\nset "PATH=%JAVA_HOME%\\bin;%PATH%"\n\nREM 打印当前设置的JAVA_HOME和PATH\necho JAVA_HOME is set to: %JAVA_HOME%\necho PATH is set to: %PATH%\n\nREM 检查jps是否存在\nwhere jps >nul 2>&1\nif errorlevel 1 (\n    echo Error: jps not found in PATH.\n    goto end\n)\n\nREM 获取正在运行的Java进程列表，并查找包含指定JAR文件名的进程\necho Searching for Java processes...\nfor /f "tokens=1,2 delims= " %%p in (\'jps -l\') do (\n    if "%%q"=="%jarFileName%" (\n        echo Found process with PID %%p running %jarFileName%\n        echo Killing process with PID %%p\n        taskkill /PID %%p /F\n        if errorlevel 1 (\n            echo Failed to kill process with PID %%p\n        ) else (\n            echo Successfully killed process with PID %%p\n        )\n    ) else (\n        REM 检查命令行参数是否包含JAR文件路径\n        for /f "tokens=*" %%a in (\'wmic process where processid^=%%p get commandline ^| findstr /i "%jarFileName%"\') do (\n            if not "%%a"=="" (\n                echo Found process with PID %%p running %jarFileName%\n                echo Killing process with PID %%p\n                taskkill /PID %%p /F\n                if errorlevel 1 (\n                    echo Failed to kill process with PID %%p\n                ) else (\n                    echo Successfully killed process with PID %%p\n                )\n            )\n        )\n    )\n)\n\nREM 如果没有找到任何进程\nif \'%errorlevel%\'==\'0\' (\n    echo No matching Java processes found.\n)\n\n:end\nREM 恢复原来的JAVA_HOME和PATH\nset "JAVA_HOME=%original_JAVA_HOME%"\nset "PATH=%original_PATH%"\n\necho Restored original JAVA_HOME and PATH.\n\nendlocal\npause']},{title:"什么是面向对象编程",headers:[{level:2,title:"1.什么是面向过程？",slug:"_1-什么是面向过程",link:"#_1-什么是面向过程",children:[{level:3,title:"1.1.关键特点",slug:"_1-1-关键特点",link:"#_1-1-关键特点",children:[]}]},{level:2,title:"2.什么是面向对象编程 (OOP)？",slug:"_2-什么是面向对象编程-oop",link:"#_2-什么是面向对象编程-oop",children:[{level:3,title:"2.1.面向对象编程的核心概念",slug:"_2-1-面向对象编程的核心概念",link:"#_2-1-面向对象编程的核心概念",children:[]},{level:3,title:"2.2.面向对象编程的优势",slug:"_2-2-面向对象编程的优势",link:"#_2-2-面向对象编程的优势",children:[]}]},{level:2,title:"3.面向对象和面向过程的总结",slug:"_3-面向对象和面向过程的总结",link:"#_3-面向对象和面向过程的总结",children:[]},{level:2,title:"4.面向对象的三大基本特征",slug:"_4-面向对象的三大基本特征",link:"#_4-面向对象的三大基本特征",children:[{level:3,title:"4.1. 封装 (Encapsulation)",slug:"_4-1-封装-encapsulation",link:"#_4-1-封装-encapsulation",children:[]},{level:3,title:"4.2. 继承 (Inheritance)",slug:"_4-2-继承-inheritance",link:"#_4-2-继承-inheritance",children:[]},{level:3,title:"4.3. 多态 (Polymorphism)",slug:"_4-3-多态-polymorphism",link:"#_4-3-多态-polymorphism",children:[]}]},{level:2,title:"5.面向对象的五大基本原则 (SOLID)",slug:"_5-面向对象的五大基本原则-solid",link:"#_5-面向对象的五大基本原则-solid",children:[{level:3,title:"5.1. 单一职责原则 (Single Responsibility Principle, SRP)",slug:"_5-1-单一职责原则-single-responsibility-principle-srp",link:"#_5-1-单一职责原则-single-responsibility-principle-srp",children:[]},{level:3,title:"5.2. 开闭原则 (Open/Closed Principle, OCP)",slug:"_5-2-开闭原则-open-closed-principle-ocp",link:"#_5-2-开闭原则-open-closed-principle-ocp",children:[]},{level:3,title:"5.3. 里氏替换原则 (Liskov Substitution Principle, LSP)",slug:"_5-3-里氏替换原则-liskov-substitution-principle-lsp",link:"#_5-3-里氏替换原则-liskov-substitution-principle-lsp",children:[]},{level:3,title:"5.4. 接口隔离原则 (Interface Segregation Principle, ISP)",slug:"_5-4-接口隔离原则-interface-segregation-principle-isp",link:"#_5-4-接口隔离原则-interface-segregation-principle-isp",children:[]},{level:3,title:"5.5. 依赖倒置原则 (Dependency Inversion Principle, DIP)",slug:"_5-5-依赖倒置原则-dependency-inversion-principle-dip",link:"#_5-5-依赖倒置原则-dependency-inversion-principle-dip",children:[]},{level:3,title:"5.6.总结",slug:"_5-6-总结",link:"#_5-6-总结",children:[]}]}],path:"/posts/java/basic/1.object-oriented-programming.html",pathLocale:"/",extraFields:["java\n// 错误做法：多个职责\nclass User {\n    public void register() { /* 注册逻辑 */ }\n    public void sendEmail() { /* 发送邮件逻辑 */ }\n}\n\n// 正确做法：单一职责\nclass UserService {\n    public void register() { /* 注册逻辑 */ }\n}\n\nclass EmailService {\n    public void sendEmail() { /* 发送邮件逻辑 */ }\n}",'java\n// 错误做法：违反开闭原则\nclass DiscountCalculator {\n    public double calculateDiscount(String userType, double amount) {\n        if ("VIP".equals(userType)) {\n            return amount * 0.8;\n        } else {\n            return amount;\n        }\n    }\n}\n\n// 正确做法：遵循开闭原则\ninterface DiscountStrategy {\n    double apply(double amount);\n}\n\nclass VIPDiscount implements DiscountStrategy {\n    @Override\n    public double apply(double amount) {\n        return amount * 0.8;\n    }\n}\n\nclass DiscountCalculator {\n    private DiscountStrategy strategy;\n\n    public DiscountCalculator(DiscountStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public double calculateDiscount(double amount) {\n        return strategy.apply(amount);\n    }\n}',"java\n// 错误做法：违反里氏替换原则\nclass Rectangle {\n    protected int width, height;\n\n    public void setWidth(int w) { width = w; }\n    public void setHeight(int h) { height = h; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int w) {\n        super.setWidth(w);\n        super.setHeight(w); // 违反了LSP，因为Square改变了Rectangle的行为\n    }\n\n    @Override\n    public void setHeight(int h) {\n        super.setHeight(h);\n        super.setWidth(h);\n    }\n}\n\n// 正确做法：遵循里氏替换原则\ninterface Shape {\n    double area();\n}\n\nclass Rectangle implements Shape {\n    private final int width, height;\n\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        return width * height;\n    }\n}\n\nclass Square implements Shape {\n    private final int side;\n\n    public Square(int side) {\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        return side * side;\n    }\n}",'java\n// 错误做法：大而全的接口\ninterface Worker {\n    void work();\n    void eat();\n}\n\nclass HumanWorker implements Worker {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { /* 吃饭 */ }\n}\n\nclass RobotWorker implements Worker {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { throw new UnsupportedOperationException("Robots don\'t eat!"); }\n}\n\n// 正确做法：分离接口\ninterface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\nclass HumanWorker implements Workable, Eatable {\n    @Override\n    public void work() { /* 工作 */ }\n    @Override\n    public void eat() { /* 吃饭 */ }\n}\n\nclass RobotWorker implements Workable {\n    @Override\n    public void work() { /* 工作 */ }\n}',"java\n// 错误做法：高层次依赖于低层次\nclass LightBulb {\n    public void turnOn() { /* 打开电灯 */ }\n}\n\nclass Switch {\n    private LightBulb lightBulb;\n\n    public Switch(LightBulb bulb) {\n        this.lightBulb = bulb;\n    }\n\n    public void operate() {\n        lightBulb.turnOn();\n    }\n}\n\n// 正确做法：依赖于抽象\ninterface Switchable {\n    void turnOn();\n}\n\nclass LightBulb implements Switchable {\n    @Override\n    public void turnOn() { /* 打开电灯 */ }\n}\n\nclass Switch {\n    private Switchable device;\n\n    public Switch(Switchable device) {\n        this.device = device;\n    }\n\n    public void operate() {\n        device.turnOn();\n    }\n}"]},{title:"面向对象的三大基本特征",headers:[{level:2,title:"1.Java 的封装 (Encapsulation)",slug:"_1-java-的封装-encapsulation",link:"#_1-java-的封装-encapsulation",children:[{level:3,title:"1.1.定义",slug:"_1-1-定义",link:"#_1-1-定义",children:[]},{level:3,title:"1.2.目标",slug:"_1-2-目标",link:"#_1-2-目标",children:[]},{level:3,title:"1.3.实现方式",slug:"_1-3-实现方式",link:"#_1-3-实现方式",children:[]},{level:3,title:"1.4.示例代码",slug:"_1-4-示例代码",link:"#_1-4-示例代码",children:[]},{level:3,title:"1.5.总结",slug:"_1-5-总结",link:"#_1-5-总结",children:[]}]},{level:2,title:"2.继承 (Inheritance)",slug:"_2-继承-inheritance",link:"#_2-继承-inheritance",children:[{level:3,title:"2.1.示例",slug:"_2-1-示例",link:"#_2-1-示例",children:[]},{level:3,title:"2.2.方法重写 (Method Overriding)详细说明",slug:"_2-2-方法重写-method-overriding-详细说明",link:"#_2-2-方法重写-method-overriding-详细说明",children:[]}]},{level:2,title:"3.多态 (Polymorphism)",slug:"_3-多态-polymorphism",link:"#_3-多态-polymorphism",children:[{level:3,title:"3.1.示例",slug:"_3-1-示例",link:"#_3-1-示例",children:[]},{level:3,title:"3.2.方法重载 (Method Overloading)细节说明",slug:"_3-2-方法重载-method-overloading-细节说明",link:"#_3-2-方法重载-method-overloading-细节说明",children:[]}]},{level:2,title:"4.构造函数 (Constructor)",slug:"_4-构造函数-constructor",link:"#_4-构造函数-constructor",children:[{level:3,title:"4.1.示例",slug:"_4-1-示例",link:"#_4-1-示例",children:[]},{level:3,title:"4.2.默认构造函数 (Default Constructor)",slug:"_4-2-默认构造函数-default-constructor",link:"#_4-2-默认构造函数-default-constructor",children:[]}]},{level:2,title:"5.类变量 (Class Variables) 和 成员变量 (Instance Variables)",slug:"_5-类变量-class-variables-和-成员变量-instance-variables",link:"#_5-类变量-class-variables-和-成员变量-instance-variables",children:[{level:3,title:"5.1示例",slug:"_5-1示例",link:"#_5-1示例",children:[]}]},{level:2,title:"6.局部变量 (Local Variables)",slug:"_6-局部变量-local-variables",link:"#_6-局部变量-local-variables",children:[{level:3,title:"6.1.示例",slug:"_6-1-示例",link:"#_6-1-示例",children:[]}]},{level:2,title:"7.成员变量和方法的作用域 (Scope of Instance Variables and Methods)",slug:"_7-成员变量和方法的作用域-scope-of-instance-variables-and-methods",link:"#_7-成员变量和方法的作用域-scope-of-instance-variables-and-methods",children:[{level:3,title:"7.1示例",slug:"_7-1示例",link:"#_7-1示例",children:[]}]},{level:2,title:"8.平台无关性 (Platform Independence)",slug:"_8-平台无关性-platform-independence",link:"#_8-平台无关性-platform-independence",children:[]},{level:2,title:"9.值传递 (Pass by Value)",slug:"_9-值传递-pass-by-value",link:"#_9-值传递-pass-by-value",children:[{level:3,title:"9.1.示例",slug:"_9-1-示例",link:"#_9-1-示例",children:[]}]}],path:"/posts/java/basic/2.three-features.html",pathLocale:"/",extraFields:['java\npublic class Person {\n    // 私有属性，外界无法直接访问\n    private String name;\n    private int age;\n\n    // 默认构造函数\n    public Person() {}\n\n    // 带参数的构造函数\n    public Person(String name, int age) {\n        this.name = name;\n        setAge(age); // 使用setter进行验证\n    }\n\n    // Getter 方法\n    public String getName() {\n        return name;\n    }\n\n    // Setter 方法，包含验证逻辑\n    public void setName(String name) {\n        if (name != null && !name.isEmpty()) {\n            this.name = name;\n        } else {\n            System.out.println("Name cannot be empty.");\n        }\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        if (age > 0 && age < 120) {\n            this.age = age;\n        } else {\n            System.out.println("Invalid age value.");\n        }\n    }\n}','java\nclass Animal {\n    void eat() {\n        System.out.println("This animal eats.");\n    }\n}\n\nclass Dog extends Animal {\n    // 方法重写\n    @Override\n    void eat() {\n        System.out.println("The dog eats dog food.");\n    }\n\n    // 新增方法\n    void bark() {\n        System.out.println("Woof!");\n    }\n}','java\nclass Animal {\n    void sound() {\n        System.out.println("Some generic animal sound.");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void sound() {\n        System.out.println("Woof!");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    void sound() {\n        System.out.println("Meow!");\n    }\n}\n\npublic class OverridingExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n\n        myDog.sound(); // 输出: Woof!\n        myCat.sound(); // 输出: Meow!\n    }\n}',"java\n// 假设我们有上述定义的Animal和Dog类\npublic class PolymorphismExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog(); // 父类引用指向子类对象\n        myDog.eat(); // 输出: The dog eats dog food.\n        \n        // 下面这行代码会报错，因为myDog是Animal类型的引用，\n        // 它不知道Dog特有的bark()方法\n        // myDog.bark();\n    }\n}","java\nclass Calculator {\n    // 加法：两个整数相加\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    // 加法：三个整数相加\n    int add(int a, int b, int c) {\n        return a + b + c;\n    }\n\n    // 加法：两个浮点数相加\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n\npublic class OverloadingExample {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        System.out.println(calc.add(1, 2));       // 输出: 3\n        System.out.println(calc.add(1, 2, 3));    // 输出: 6\n        System.out.println(calc.add(1.5, 2.5));   // 输出: 4.0\n    }\n}",'java\nclass Person {\n    String name;\n    int age;\n\n    // 默认构造函数\n    public Person() {\n        this.name = "Unknown";\n        this.age = 0;\n    }\n\n    // 带参数的构造函数\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}',"java\nclass Counter {\n    static int count = 0; // 类变量\n    int instanceCount = 0; // 成员变量\n\n    Counter() {\n        count++;\n        instanceCount++;\n    }\n}","java\npublic class Example {\n    void methodWithLocalVariable() {\n        int localVariable = 10; // 局部变量\n        System.out.println(localVariable);\n    }\n}",'java\nclass ScopeExample {\n    private String memberVariable = "I\'m a member variable"; // 私有成员变量\n\n    public void printMemberVariable() {\n        System.out.println(memberVariable); // 在类的方法中访问成员变量\n    }\n\n    public void anotherMethod() {\n        printMemberVariable(); // 在另一个方法中调用公共方法\n    }\n}','java\npublic class PassByValueExample {\n\n    // 对于基本数据类型，传递的是值的副本\n    public static void changePrimitive(int x) {\n        x = 100;\n    }\n\n    // 对于引用类型，传递的是引用的副本，但是引用指向的对象是相同的\n    public static void changeObject(Builder builder) {\n        builder.setName("Changed Name");\n    }\n\n    public static void main(String[] args) {\n        int num = 5;\n        changePrimitive(num);\n        System.out.println(num); // 输出: 5，因为传递的是值的副本\n\n        Builder myBuilder = new Builder("Original Name");\n        changeObject(myBuilder);\n        System.out.println(myBuilder.getName()); // 输出: Changed Name，因为修改了对象的状态\n    }\n}\n\nclass Builder {\n    private String name;\n\n    public Builder(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}']},{title:"java 基础知识",headers:[{level:2,title:"1. Java基本数据类型",slug:"_1-java基本数据类型",link:"#_1-java基本数据类型",children:[{level:3,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:3,title:"1.2 详细分类",slug:"_1-2-详细分类",link:"#_1-2-详细分类",children:[]},{level:3,title:"1.3 自动拆装箱",slug:"_1-3-自动拆装箱",link:"#_1-3-自动拆装箱",children:[]},{level:3,title:"1.4 浮点数与金额问题",slug:"_1-4-浮点数与金额问题",link:"#_1-4-浮点数与金额问题",children:[]}]},{level:2,title:"2. String类型",slug:"_2-string类型",link:"#_2-string类型",children:[{level:3,title:"2.1.不可变性的实现",slug:"_2-1-不可变性的实现",link:"#_2-1-不可变性的实现",children:[]},{level:3,title:"2.2.不可变性的优点",slug:"_2-2-不可变性的优点",link:"#_2-2-不可变性的优点",children:[]},{level:3,title:"2.3.示例代码",slug:"_2-3-示例代码",link:"#_2-3-示例代码",children:[]},{level:3,title:"2.4. 常用方法",slug:"_2-4-常用方法",link:"#_2-4-常用方法",children:[]},{level:3,title:"2.5. 使用选择",slug:"_2-5-使用选择",link:"#_2-5-使用选择",children:[]},{level:3,title:"2.6. 字符串池、常量池概念",slug:"_2-6-字符串池、常量池概念",link:"#_2-6-字符串池、常量池概念",children:[]},{level:3,title:"2.7. intern方法",slug:"_2-7-intern方法",link:"#_2-7-intern方法",children:[]},{level:3,title:"2.8. String长度限制",slug:"_2-8-string长度限制",link:"#_2-8-string长度限制",children:[]}]},{level:2,title:"3. Java关键字",slug:"_3-java关键字",link:"#_3-java关键字",children:[{level:3,title:"3.1. 访问控制",slug:"_3-1-访问控制",link:"#_3-1-访问控制",children:[]},{level:3,title:"3.2. 类、接口、抽象相关",slug:"_3-2-类、接口、抽象相关",link:"#_3-2-类、接口、抽象相关",children:[]},{level:3,title:"3.3. 修饰符",slug:"_3-3-修饰符",link:"#_3-3-修饰符",children:[]},{level:3,title:"3.4. 流程控制",slug:"_3-4-流程控制",link:"#_3-4-流程控制",children:[]},{level:3,title:"3.5. 异常处理",slug:"_3-5-异常处理",link:"#_3-5-异常处理",children:[]},{level:3,title:"3.6. 其他",slug:"_3-6-其他",link:"#_3-6-其他",children:[]}]}],path:"/posts/java/basic/3.java-basic.html",pathLocale:"/",extraFields:["java\ndouble amount1 = 0.1;\ndouble amount2 = 0.2;\ndouble sum = amount1 + amount2; \n// 此时 sum 可能不是精确的 0.3，而接近 0.30000000000000004",'java\nString s1 = "Hello";\nString s2 = s1.concat(" World"); // 这不会改变s1，而是返回一个新的String对象给s2\nSystem.out.println(s1); // 输出: Hello\nSystem.out.println(s2); // 输出: Hello World','java\nStringBuilder sb = new StringBuilder();\nsb.append("Hello");\nsb.append(" Java");\nString result = sb.toString();','java\nString s1 = new String("world").intern();\nString s2 = "world";\nSystem.out.println(s1 == s2); // true',"java\nabstract class Vehicle {\n    abstract void move();\n}","java\nfinal class FinalClass {}\nclass AnotherClass {\n    final void finalMethod() {}\n    final int CONSTANT = 10;\n}","java\nclass Utility {\n    static int count;\n    static void increment() { count++; }\n}","java\nclass SharedResource {\n    synchronized void access() {}\n}","java\nswitch (var) {\n    case 1: break;\n    case 2: break;\n    default: break;\n}","java\nwhile (condition) {}\ndo {} while (condition);","java\ntry {\n    // 可能抛异常代码\n} catch (Exception e) {\n    // 处理异常\n} finally {\n    // 必执行，清理资源\n}","java\nclass Person {\n    private int age;\n    public Person(int age) {\n        this.age = age;\n    }\n}","java\nclass Child extends Parent {\n    public Child() {\n        super();\n    }\n    void parentMethod() {\n        super.method();\n    }\n}"]},{title:"java 集合",headers:[{level:2,title:"1. 集合框架概述",slug:"_1-集合框架概述",link:"#_1-集合框架概述",children:[]},{level:2,title:"2. Collection 接口",slug:"_2-collection-接口",link:"#_2-collection-接口",children:[{level:3,title:"2.1. 特点",slug:"_2-1-特点",link:"#_2-1-特点",children:[]},{level:3,title:"2.2. 常用方法",slug:"_2-2-常用方法",link:"#_2-2-常用方法",children:[]}]},{level:2,title:"3. List 接口及实现类",slug:"_3-list-接口及实现类",link:"#_3-list-接口及实现类",children:[{level:3,title:"3.1. 特点",slug:"_3-1-特点",link:"#_3-1-特点",children:[]},{level:3,title:"3.2. 常用实现类",slug:"_3-2-常用实现类",link:"#_3-2-常用实现类",children:[]}]},{level:2,title:"4. Set 接口及实现类",slug:"_4-set-接口及实现类",link:"#_4-set-接口及实现类",children:[{level:3,title:"4.1. 特点",slug:"_4-1-特点",link:"#_4-1-特点",children:[]},{level:3,title:"4.2. 常用实现类",slug:"_4-2-常用实现类",link:"#_4-2-常用实现类",children:[]}]},{level:2,title:"5. Map 接口及实现类",slug:"_5-map-接口及实现类",link:"#_5-map-接口及实现类",children:[{level:3,title:"5.1. 特点",slug:"_5-1-特点",link:"#_5-1-特点",children:[]},{level:3,title:"5.2. 常用实现类",slug:"_5-2-常用实现类",link:"#_5-2-常用实现类",children:[]}]},{level:2,title:"6. 迭代器（Iterator）",slug:"_6-迭代器-iterator",link:"#_6-迭代器-iterator",children:[]},{level:2,title:"7. 面试题",slug:"_7-面试题",link:"#_7-面试题",children:[{level:3,title:"7.1. ArrayList 和 LinkedList 的区别？",slug:"_7-1-arraylist-和-linkedlist-的区别",link:"#_7-1-arraylist-和-linkedlist-的区别",children:[]},{level:3,title:"7.2. HashSet 如何保证元素唯一性？",slug:"_7-2-hashset-如何保证元素唯一性",link:"#_7-2-hashset-如何保证元素唯一性",children:[]},{level:3,title:"7.3. HashMap 的底层原理是什么？",slug:"_7-3-hashmap-的底层原理是什么",link:"#_7-3-hashmap-的底层原理是什么",children:[]},{level:3,title:"7.4. 如何实现一个自定义类作为 HashMap 的键？",slug:"_7-4-如何实现一个自定义类作为-hashmap-的键",link:"#_7-4-如何实现一个自定义类作为-hashmap-的键",children:[]}]}],path:"/posts/java/basic/4.collection.html",pathLocale:"/",extraFields:["java\nboolean add(E e); // 向集合中添加元素，成功返回 true，若集合不允许添加重复元素且已存在相同元素则返回 false\nboolean remove(Object o); // 从集合中移除指定元素，若元素存在并移除成功返回 true，否则返回 false\nboolean contains(Object o); // 判断集合是否包含指定元素，包含返回 true，否则返回 false\nint size(); // 返回集合中元素的个数\nboolean isEmpty(); // 判断集合是否为空，为空返回 true，否则返回 false\nIterator<E> iterator(); // 返回一个迭代器，用于遍历集合中的元素",'java\nArrayList<String> arrayList = new ArrayList<>();\narrayList.add("apple");\narrayList.add("banana");\nString element = arrayList.get(0); // 获取索引为 0 的元素，即 "apple"',"java\nLinkedList<Integer> linkedList = new LinkedList<>();\nlinkedList.add(1);\nlinkedList.add(2);\nlinkedList.addFirst(0); // 在链表头部添加元素 0","java\nHashSet<Character> hashSet = new HashSet<>();\nhashSet.add('a');\nhashSet.add('b');\nhashSet.add('a'); // 重复元素，不会被添加","java\nTreeSet<Integer> treeSet = new TreeSet<>();\ntreeSet.add(3);\ntreeSet.add(1);\ntreeSet.add(2); \n// 元素按升序排列，遍历结果为 1, 2, 3",'java\nHashMap<String, Integer> hashMap = new HashMap<>();\nhashMap.put("apple", 1);\nhashMap.put("banana", 2);\nInteger value = hashMap.get("apple"); // 获取键 "apple" 对应的值 1','java\nTreeMap<String, Double> treeMap = new TreeMap<>();\ntreeMap.put("orange", 3.5);\ntreeMap.put("grape", 2.0);\n// 按键升序遍历，输出顺序与键的排序一致','java\nCollection<String> collection = new ArrayList<>();\ncollection.add("one");\ncollection.add("two");\nIterator<String> iterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    String element = iterator.next();\n    System.out.println(element);\n}',"java\nclass MyKey {\n    private int id;\n    private String name;\n\n    public MyKey(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass()!= o.getClass()) return false;\n        MyKey myKey = (MyKey) o;\n        return id == myKey.id && Objects.equals(name, myKey.name);\n    }\n}"]},{title:"comparator 基本使用",headers:[{level:2,title:"3.1 实现 Comparator 接口",slug:"_3-1-实现-comparator-接口",link:"#_3-1-实现-comparator-接口",children:[]},{level:2,title:"3.2 匿名内部类",slug:"_3-2-匿名内部类",link:"#_3-2-匿名内部类",children:[]},{level:2,title:"3.3 Lambda 表达式",slug:"_3-3-lambda-表达式",link:"#_3-3-lambda-表达式",children:[]},{level:2,title:"3.4 链接多个 Comparator",slug:"_3-4-链接多个-comparator",link:"#_3-4-链接多个-comparator",children:[]},{level:2,title:"3.5 Comparator 工具方法",slug:"_3-5-comparator-工具方法",link:"#_3-5-comparator-工具方法",children:[]}],path:"/posts/java/basic/comparator.html",pathLocale:"/",extraFields:["java\nimport java.util.Comparator;\n\nclass AgeComparator implements Comparator<Person> {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return Integer.compare(p1.getAge(), p2.getAge());\n    }\n}",'java\nList<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25));\npeople.sort(new Comparator<Person>() {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return p1.getName().compareTo(p2.getName());\n    }\n});',"java\npeople.sort((p1, p2) -> p1.getName().compareTo(p2.getName()));\n// 或者更简洁的形式\npeople.sort(Comparator.comparing(Person::getName));","java\npeople.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName));",'java\nimport java.util.*;\n\nclass Person {\n    private String name;\n    private int age;\n\n    // 构造函数、getter 和 setter 方法省略\n\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n            new Person("Alice", 30),\n            new Person("Bob", 25),\n            new Person("Charlie", 35)\n        );\n\n        // 按年龄升序排序，若年龄相同则按名字排序\n        people.sort(Comparator.comparingInt(Person::getAge).thenComparing(Person::getName));\n\n        // 输出排序后的列表\n        people.forEach(person -> System.out.println(person.getName() + " (" + person.getAge() + ")"));\n    }\n}']},{title:"io 流的基本使用",headers:[{level:2,title:"InputStream ,ByteArrayInputStream",slug:"inputstream-bytearrayinputstream",link:"#inputstream-bytearrayinputstream",children:[]},{level:2,title:"DataInputStream",slug:"datainputstream",link:"#datainputstream",children:[]}],path:"/posts/java/basic/ioStream.html",pathLocale:"/",extraFields:["java\nbyte[] bb = new byte[]{49,50,51};\nInputStream in = new ByteArrayInputStream(bb);\nDataInputStream dis = new DataInputStream(in);"]},{title:"java8 stream",headers:[{level:2,title:"00.不可变集合",slug:"_00-不可变集合",link:"#_00-不可变集合",children:[]},{level:2,title:"01.Stream流的思想和获取Stream流",slug:"_01-stream流的思想和获取stream流",link:"#_01-stream流的思想和获取stream流",children:[]},{level:2,title:"02.Stream流的中间方法",slug:"_02-stream流的中间方法",link:"#_02-stream流的中间方法",children:[]},{level:2,title:"03.Stream流的终结方法",slug:"_03-stream流的终结方法",link:"#_03-stream流的终结方法",children:[]},{level:2,title:"0.前置",slug:"_0-前置",link:"#_0-前置",children:[]},{level:2,title:"1.Stream初相识",slug:"_1-stream初相识",link:"#_1-stream初相识",children:[]},{level:2,title:"2.Stream方法使用",slug:"_2-stream方法使用",link:"#_2-stream方法使用",children:[{level:3,title:"2.1.map与flatMap",slug:"_2-1-map与flatmap",link:"#_2-1-map与flatmap",children:[]},{level:3,title:"2.2.peek和foreach",slug:"_2-2-peek和foreach",link:"#_2-2-peek和foreach",children:[]},{level:3,title:"2.3.filter、sorted、distinct、limit",slug:"_2-3-filter、sorted、distinct、limit",link:"#_2-3-filter、sorted、distinct、limit",children:[]},{level:3,title:"2.4.简单结果终止方法",slug:"_2-4-简单结果终止方法",link:"#_2-4-简单结果终止方法",children:[]}]},{level:2,title:"3.避坑提醒",slug:"_3-避坑提醒",link:"#_3-避坑提醒",children:[]},{level:2,title:"4.结果收集终止方法",slug:"_4-结果收集终止方法",link:"#_4-结果收集终止方法",children:[{level:3,title:"4.1.生成集合",slug:"_4-1-生成集合",link:"#_4-1-生成集合",children:[]},{level:3,title:"4.2.生成拼接字符串",slug:"_4-2-生成拼接字符串",link:"#_4-2-生成拼接字符串",children:[]},{level:3,title:"4.3.数据批量数学运算",slug:"_4-3-数据批量数学运算",link:"#_4-3-数据批量数学运算",children:[]}]},{level:2,title:"5.并行Stream",slug:"_5-并行stream",link:"#_5-并行stream",children:[{level:3,title:"5.1.机制说明",slug:"_5-1-机制说明",link:"#_5-1-机制说明",children:[]},{level:3,title:"5.2.约束与限制",slug:"_5-2-约束与限制",link:"#_5-2-约束与限制",children:[]}]},{level:2,title:"6.回答最初的问题",slug:"_6-回答最初的问题",link:"#_6-回答最初的问题",children:[]}],path:"/posts/java/basic/java8Stream.html",pathLocale:"/",extraFields:['java\n// 创建不可变的list集合，只能进行查询操作，这是要jdk9\nList.of("1","2","3");\nSet.of(……);\n//Map的of方法，参数有上限，最多20个，就是10个键值对。\n//因为of方法没有可变参数的设置。key不能重复。\n//专属ofEntries()方法。超过10个键值对使用。\n//更简单的还是 copyOf，要jdk10.\nMap.of("key1","val1","key2","val2");','java\nArrayListcstring> list1 = new ArrayList<>(];\nlist1.add("张无忌");\nlist1.add("周芷若");\nlist1.add("赵敏");\nlist1.add("张濒");\nlistl.add("张三丰");\nlist1.stream().filter(name->name.startsWith("张")).filter(name->name.length()== 3).forEach(name -> System.out.println(name));','java\n//1.单列集合获取stream流\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list,  "a","b", "c", "d", "e");//获取到一条流水线，并把集合中的数据放到流水线上\nList<String> list = new ArrayList<>();\nlist.stream().forEach(s-> System.out.println(s));','java\n//1.创建双列集合\nHashMap<String, Integer> hm = new HashMap<>();//2.添加数据\nhm.put("aaa", 111);\nhm.put("b66", 222);\nhm.put("ccc", 333);\nhm.put("ddd", 444);\n//3.第一种获收stream流\n//hm.keySet().stream().forEach(s -> System.out.println(s));\n//4.第二种获取stream流\nhm.entrySet().stream().forEach(s -> System.out.println(s));','java\n//1.创建数组\nint[] arr1 = {1,2,3,4,5,6,7,8,9,103};String[] arr2 = {"a","b","c"};\n//2.获取stream流\nArrays.stream(arr1).forEach(s-> System.out.println(s));\nSystem.out.println("=================");\nArrays.stream(arr2).forEach(s-> System.out.println(s));','java\n//注意:\n//stream接口中静态方法of的细节\n//方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组\n//但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。\nStream.of(1,2,3,4,5).forEach(s-> System.out.println(s));\nStream.of(" ","b","c","d","e").forEach(s-> System.out.println(s));','java\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list,"水品-15","花养-14","赵镇-13","张-20","张二卡-100","张柴山-40","张良-35","王二嘛子-2");\n//需求:只获取里面的年龄并进行打印\n//String->int\n//第一个类型：流中原本你的数据类型\n//第二个类型：要转成之后的类型。\n\n//apply的形参s：依次表示流里面的每一个数据\n//返回值：表示转换之后的数据\n\n//当map方法执行完毕之后，流上的数据就变成了整数。\n//所以在下面的forEach当中，s一次表示流里面的每一个数据，这个数据现在就是整数了。\nlist.stream().map(new Function<String, Integer>(){\n    @Override\n    public Integer apply(String s) {\n        String[] arr = s.split("-");\n        String ageString = arr[1];\n        int age = Integer.parseInt(ageString);\n        return age;\n    }\n}).forEach(s-> System.out.println(s));\n\n//Lambda表达式写法\nlist.stream().map(s -> Integer.parseInt(s.split("-")[1])).forEach(s -> System.out.println(s));','java\nArrayList<String> list = new ArrayList<>();\nCollections.addAll(list, "水品-15", "花养-14", "赵镇-13", "张-20", "张二卡-100", "张柴山-40", "张良-35", "王二嘛子-2");\n// toArray()\n// 收集流中的数据，放到数组中\n//Object[] arr1 = list.stream().toArray();//system.out.printIn(Arrays .tostring(arr1));\n//IntFunction的泛型:具体类型的数组\n//apply的形参:流中数据的个数，要跟数组的长度保持一致\n//apply的返回值:具体类型的数组\n//方法体:就是创建数组\n//toArray方法的参数的作用: 负责创建一个指定类型的数组\n// toArray方法的底层，会依次得到流里面的每一个数据，并把数据放到数组当中\n// toArray方法的返回值: 是一个装着流里面所有数据的致组\nString[] arr = list.stream().toArray(new IntFunction<String[]>() {\n    @Override\n    public String[] apply(int value) {\n        return new String[value];\n    }\n});\n\n//Lambda 表达式写法\nString[] arr2 = list.stream().toArray(value -> new String[value]);\nSystem.out.println(Arrays.toString(arr2));',"java",'java\n/**\n * 【常规方式】\n * 从给定句子中返回单词长度大于5的单词列表，按长度倒序输出，最多返回3个\n *\n * @param sentence 给定的句子，约定非空，且单词之间仅由一个空格分隔\n * @return 倒序输出符合条件的单词列表\n */\npublic List<String> sortGetTop3LongWords(@NotNull String sentence) {\n    // 先切割句子，获取具体的单词信息\n    String[] words = sentence.split(" ");\n    List<String> wordList = new ArrayList<>();\n    // 循环判断单词的长度，先过滤出符合长度要求的单词\n    for (String word : words) {\n        if (word.length() > 5) {\n            wordList.add(word);\n        }\n    }\n    // 对符合条件的列表按照长度进行排序\n    wordList.sort((o1, o2) -> o2.length() - o1.length());\n    // 判断list结果长度，如果大于3则截取前三个数据的子list返回\n    if (wordList.size() > 3) {\n        wordList = wordList.subList(0, 3);\n    }\n    return wordList;\n}','java\n\n/**\n * 【Stream方式】\n * 从给定句子中返回单词长度大于5的单词列表，按长度倒序输出，最多返回3个\n *\n * @param sentence 给定的句子，约定非空，且单词之间仅由一个空格分隔\n * @return 倒序输出符合条件的单词列表\n */\npublic List<String> sortGetTop3LongWordsByStream(@NotNull String sentence) {\n    return Arrays.stream(sentence.split(" "))\n            .filter(word -> word.length() > 5)\n            .sorted((o1, o2) -> o2.length() - o1.length())\n            .limit(3)\n            .collect(Collectors.toList());\n}','java\n/**\n * 演示map的用途：一对一转换\n */\npublic void stringToIntMap() {\n    List<String> ids = Arrays.asList("205", "105", "308", "469", "627", "193", "111");\n    // 使用流操作\n    List<User> results = ids.stream()\n            .map(id -> {\n                User user = new User();\n                user.setId(id);\n                return user;\n            })\n            .collect(Collectors.toList());\n    System.out.println(results);\n}',"java\n[User{id='205'}, \n User{id='105'},\n User{id='308'}, \n User{id='469'}, \n User{id='627'}, \n User{id='193'}, \n User{id='111'}]",'java\n\npublic void stringToIntFlatmap() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 使用流操作\n    List<String> results = sentences.stream()\n            .flatMap(sentence -> Arrays.stream(sentence.split(" ")))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}',"java\n[hello, world, Jia, Gou, Wu, Dao]",'java\npublic void testPeekAndforeach() {\n    List<String> sentences = Arrays.asList("hello world","Jia Gou Wu Dao");\n    // 演示点1： 仅peek操作，最终不会执行\n    System.out.println("----before peek----");\n    sentences.stream().peek(sentence -> System.out.println(sentence));\n    System.out.println("----after peek----");\n    // 演示点2： 仅foreach操作，最终会执行\n    System.out.println("----before foreach----");\n    sentences.stream().forEach(sentence -> System.out.println(sentence));\n    System.out.println("----after foreach----");\n    // 演示点3： peek操作后面增加终止操作，peek会执行\n    System.out.println("----before peek and count----");\n    sentences.stream().peek(sentence -> System.out.println(sentence)).count();\n    System.out.println("----after peek and count----");\n}',"java\n----before peek----\n----after peek----\n----before foreach----\nhello world\nJia Gou Wu Dao\n----after foreach----\n----before peek and count----\nhello world\nJia Gou Wu Dao\n----after peek and count----",'java\npublic void testGetTargetUsers() {\n    List<String> ids = Arrays.asList("205","10","308","49","627","193","111", "193");\n    // 使用流操作\n    List<Dept> results = ids.stream()\n            .filter(s -> s.length() > 2)\n            .distinct()\n            .map(Integer::valueOf)\n            .sorted(Comparator.comparingInt(o -> o))\n            .limit(3)\n            .map(id -> new Dept(id))\n            .collect(Collectors.toList());\n    System.out.println(results);\n}',"java\n[Dept{id=111},  Dept{id=193},  Dept{id=205}]",'java\npublic void testSimpleStopOptions() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    // 统计stream操作后剩余的元素个数\n    System.out.println(ids.stream().filter(s -> s.length() > 2).count());\n    // 判断是否有元素值等于205\n    System.out.println(ids.stream().filter(s -> s.length() > 2).anyMatch("205"::equals));\n    // findFirst操作\n    ids.stream().filter(s -> s.length() > 2)\n            .findFirst()\n            .ifPresent(s -> System.out.println("findFirst:" + s));\n}',"java\n6\ntrue\nfindFirst:205",'java\npublic void testHandleStreamAfterClosed() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    Stream<String> stream = ids.stream().filter(s -> s.length() > 2);\n    // 统计stream操作后剩余的元素个数\n    System.out.println(stream.count());\n    System.out.println("-----下面会报错-----");\n    // 判断是否有元素值等于205\n    try {\n        System.out.println(stream.anyMatch("205"::equals));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println("-----上面会报错-----");\n}',"java\n\n6\n-----下面会报错-----\njava.lang.IllegalStateException: stream has already been operated upon or closed\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)\n\tat java.util.stream.ReferencePipeline.anyMatch(ReferencePipeline.java:449)\n\tat com.veezean.skills.stream.StreamService.testHandleStreamAfterClosed(StreamService.java:153)\n\tat com.veezean.skills.stream.StreamService.main(StreamService.java:176)\n-----上面会报错-----",'java\npublic void testCollectStopOptions() {\n    List<Dept> ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));\n    // collect成list\n    List<Dept> collectList = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toList());\n    System.out.println("collectList:" + collectList);\n    // collect成Set\n    Set<Dept> collectSet = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toSet());\n    System.out.println("collectSet:" + collectSet);\n    // collect成HashMap，key为id，value为Dept对象\n    Map<Integer, Dept> collectMap = ids.stream().filter(dept -> dept.getId() > 20)\n            .collect(Collectors.toMap(Dept::getId, dept -> dept));\n    System.out.println("collectMap:" + collectMap);\n}',"java\ncollectList:[Dept{id=22}, Dept{id=23}]\ncollectSet:[Dept{id=23}, Dept{id=22}]\ncollectMap:{22=Dept{id=22}, 23=Dept{id=23}}",'java\npublic void testForJoinStrings() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    StringBuilder builder = new StringBuilder();\n    for (String id : ids) {\n        builder.append(id).append(\',\');\n    }\n    // 去掉末尾多拼接的逗号\n    builder.deleteCharAt(builder.length() - 1);\n    System.out.println("拼接后：" + builder.toString());\n}','java\npublic void testCollectJoinStrings() {\n    List<String> ids = Arrays.asList("205", "10", "308", "49", "627", "193", "111", "193");\n    String joinResult = ids.stream().collect(Collectors.joining(","));\n    System.out.println("拼接后：" + joinResult);\n}',"java\n拼接后：205,10,308,49,627,193,111,193",'java\npublic void testNumberCalculate() {\n    List<Integer> ids = Arrays.asList(10, 20, 30, 40, 50);\n    // 计算平均值\n    Double average = ids.stream().collect(Collectors.averagingInt(value -> value));\n    System.out.println("平均值：" + average);\n    // 数据统计信息\n    IntSummaryStatistics summary = ids.stream().collect(Collectors.summarizingInt(value -> value));\n    System.out.println("数据统计信息： " + summary);\n}',"java\n平均值：30.0\n总和： IntSummaryStatistics{count=5, sum=150, min=10, average=30.000000, max=50}"]},{title:"java 零碎知识点",headers:[{level:2,title:"去除科学计数法",slug:"去除科学计数法",link:"#去除科学计数法",children:[]},{level:2,title:"时间戳转为日期格式",slug:"时间戳转为日期格式",link:"#时间戳转为日期格式",children:[]},{level:2,title:"判断一个字符串是否能转为数字",slug:"判断一个字符串是否能转为数字",link:"#判断一个字符串是否能转为数字",children:[]},{level:2,title:"Byte 高位/低位（大端格式/小端格式）",slug:"byte-高位-低位-大端格式-小端格式",link:"#byte-高位-低位-大端格式-小端格式",children:[{level:3,title:"大端格式（Big-Endian）",slug:"大端格式-big-endian",link:"#大端格式-big-endian",children:[]},{level:3,title:"小端格式（Little-Endian）",slug:"小端格式-little-endian",link:"#小端格式-little-endian",children:[]},{level:3,title:"网络字节序",slug:"网络字节序",link:"#网络字节序",children:[]}]}],path:"/posts/java/basic/jottings.html",pathLocale:"/",extraFields:['java\nBigDecimal bg=new BigDecimal(val+"");//去除科学计数法','java\n public static String timeStamp2Date(String time) {\n        Long timeLong = Long.parseLong(time);\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//要转换的时间格式\n        Date date;\n        try {\n        date = sdf.parse(sdf.format(timeLong));\n        return sdf.format(date);\n        } catch (ParseException e) {\n        e.printStackTrace();\n        return null;\n        }\n}',"Memory Address:  0x00    0x01\nContents:        0x12    0x34","Memory Address:  0x00    0x01\nContents:        0x34    0x12"]},{title:"多线程基础",headers:[{level:2,title:"继承 Thread 类",slug:"继承-thread-类",link:"#继承-thread-类",children:[]},{level:2,title:"实现 Runnable 接口",slug:"实现-runnable-接口",link:"#实现-runnable-接口",children:[]},{level:2,title:"实现 Callable 接口 （JDK5.0 新增）",slug:"实现-callable-接口-jdk5-0-新增",link:"#实现-callable-接口-jdk5-0-新增",children:[]},{level:2,title:"线程池",slug:"线程池",link:"#线程池",children:[]},{level:2,title:"synchronized",slug:"synchronized",link:"#synchronized",children:[]},{level:2,title:"Lock 接口：JDK5.0新增",slug:"lock-接口-jdk5-0新增",link:"#lock-接口-jdk5-0新增",children:[]},{level:2,title:"死锁产生的原因",slug:"死锁产生的原因",link:"#死锁产生的原因",children:[]},{level:2,title:"死锁产生的四个必要条件？",slug:"死锁产生的四个必要条件",link:"#死锁产生的四个必要条件",children:[]},{level:2,title:"如何防止死锁？",slug:"如何防止死锁",link:"#如何防止死锁",children:[]},{level:2,title:"sleep() 和 wait()的异同？",slug:"sleep-和-wait-的异同",link:"#sleep-和-wait-的异同",children:[]},{level:2,title:"synchronized 与 Lock的异同？",slug:"synchronized-与-lock的异同",link:"#synchronized-与-lock的异同",children:[]}],path:"/posts/java/basic/multithreading.html",pathLocale:"/",extraFields:["java\n// ①\npublic class Test extends Thread{\n\t@Override\n\tpublic void run(){\n       ......\n\t}\n}\n// ②\nclass Main{\n\tpublic static void main(String[] args){\n\t\tTest test = new Test();\n\t\ttest.start();//只能调用start 方法 ，不能调用run，直接调用run()方法是和主线程一起共用一个线程，并没有开启一个线程。\n\t}\n}","java\npublic class Test implements Runnable {\n\t@Override\n\tpublic void run(){\n\t\t……\n\t}\n}\nclass Main {\n\tpublic static void main(String[] args){\n\t\tTest test = new Test();\n\t\tnew Thread(test).start();\n\t}\n}","java\npublic class Test implements Callable{\n\t@Override\n\tpublic Object call() thorws Exception {\n\t\t……\n\t\treturn Object;\n\t}\n}\nclass Main{\n\tpublic static void main(String[] args){\n\t\tTest test= new Test();\n\t\tFutureTask futureTask = new FutureTask(test);\n\t\tnew Thread(futureTask).start();\n\t\t\n\t\ttry{\n\t\t\tObject obj = futureTast.get();//获取返回值的方式\n\t\t}catch(ExecutionException e ){\n\t\t\te.printStackTrace();\n\t\t}","java\nclass Test implements Runnable {// 也可以用 Callable\n\t@Override\n\tpublic void run(){\n\t\t……\n\t}\n}\nclass Main {\n\tpublic static void main(String[] args){\n\t\tExecutorService servie = Executors.newFixedThreadPool(10);//参数表示 线程的最大数量 \n\t\tThreadPoolExecutor service1 = (ThreadPoolExecutor) servie;\n\t\tservice.execute(new Test());// 适用于 Runnable\n\t\tservice.submit(Callable callable);// 适用于 Callable\n\t\tservice.shutdown();// 关闭连接池\n\t}\n}","java\n 测试Thread中的常用方法：\n1. start():启动当前线程；调用当前线程的run()\n2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中\n3. currentThread():静态方法，返回执行当前代码的线程\n4. getName():获取当前线程的名字\n5. setName():设置当前线程的名字\n6. yield():释放当前cpu的执行权，执行机会让给相同或者更高优先级的线程。\n7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才\n          结束阻塞状态。\n8. stop():已过时。当执行此方法时，强制结束当前线程。\n9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前\n                         线程是阻塞状态，不释放锁。\n10. isAlive():判断当前线程是否存活\n\n线程的优先级：\n1.\nMAX_PRIORITY：10\n MIN _PRIORITY：1\nNORM_PRIORITY：5  --\x3e默认优先级\n2.如何获取和设置当前线程的优先级：\n  getPriority():获取线程的优先级\n  setPriority(int p):设置线程的优先级\n  说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下\n  被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。",'java\nclass Window implements Runnable{\n\tprivate int ticket = 100;//卖一百张票；不要想把这里改为 static 会有用，两个线程同时操作一张票（此时没有加 synchronized）是指，线程一 还没有执行到 ticket--，线程二已经到了输出语句。\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tsynchronized(this){//此时的 this 是唯一的 Window 对象（加锁）；也可以用其他对象\n\t\t\t\tif(ticket > 0){\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);\n\t\t\t\t\tticket--;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tWindow w = new Window();\n\t\tThread t1 = new Thread(w);\n\t\tThread t2 = new Thread(w);\n\t\tt1.setName("窗口1");\n\t\tt2.setName("窗口2");\n\t\tt1.start();\n\t\tt2.start();\n\t}',"java\nclass Window implements Runnable{\n//局部 run()\n\tpublic void run(){while(true){show();}}\n//同步方法\n\tprivate synchronized void show(){//此时锁的对象是调用 show() 的 对象，也就是 Window\n\t\tif(ticket > 0)……\n\t}\n}",'java\nclass Window implements Runnable{\n\tprivate int ticket = 100;\n\tprivate ReentrantLock lock = new ReentrantLock();\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\ttry{\n\t\t\t\tlock.lock();\n\t\t\t\tif(ticket > 0){\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + "：售票，票号为：" + ticket);\n\t\t\t\t\tticket--;\n\t\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}finally{\n\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\t}\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tWindow w = new Window();\n\t\tThread t1 = new Thread(w);\n\t\tThread t2 = new Thread(w);\n\t\tt1.setName("窗口1");\n\t\tt2.setName("窗口2");\n\t\tt1.start();\n\t\tt2.start();\n   \t\t}\n   \t}','java \npublic class DeadLock{\n\tpublic static void main(String[] args){\n\t\tStringBuffer s1 = new StringBuffer();// 拿来当锁用\n\t\tStringBuffer s2 = new StringBuffer();// 拿来当锁用\n\t\tnew Thread(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tsynchronized(s1){\n\t\t\t\t\ts1.append("a");\n\t\t\t\t\ts2.append("1");\n\t\t\t\t\tsynchronized(s2){// 执行到这里时，s2 已经被 下面一个线程 占用\n\t\t\t\t\t\ts1.append("b");\n\t\t\t\t\t\ts2.append("2");\n\t\t\t\t\t\tSystem.out.println(s1);\n                        System.out.println(s2);\n                    }\n               }\n           }\n       }.start();\n       \n       new Thread(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tsynchronized(s2){\n\t\t\t\t\ts1.append("c");\n\t\t\t\t\ts2.append("3");\n\t\t\t\t\tsynchronized(s1){// 这里又被上面 线程 占用，僵持了\n\t\t\t\t\t\ts1.append("d");\n\t\t\t\t\t\ts2.append("4");\n\t\t\t\t\t\tSystem.out.println(s1);\n                        System.out.println(s2);\n                    }\n               }\n           }\n       }.start();\n       }\n  }',"java\nwait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器（锁）。\nnotify()：一旦执行此方法，就会唤醒被 wait 的线程。如果有多个线程被 wait ，就换醒优先级最高的那个。\nnotifyAll()：一旦执行此方法，就会唤醒所有被 wait 的线程。\n说明：\n这三个方法是定义在 java.lang.Object 类中；\n必须使用在同步代码块或同步方法中；\n它们的调用者必须是同步代码块或同步方法中的同步监视器。",'java\npublic class Main {\n    public static void main(String[] args) {\n        Number number = new Number();\n        Thread t1 = new Thread(number);\n        Thread t2 = new Thread(number);\n        t1.setName("线程一");\n        t2.setName("线程二");\n        t1.start();\n        t2.start();\n    }\n\n    static class Number implements Runnable {\n        private int num = 1;\n        private Object obj = new Object();// 拿来当锁\n\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (obj) {\n                    obj.notify();\n                    if (num <= 100) {\n                        System.out.println(Thread.currentThread().getName() + ":" + num++);\n                        try {\n                            obj.wait();//线程一 num++ 后 必须刹一脚； 上面线程二 进来又唤醒 线程一。\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}','java\nclass Clerk{// 共享数据（店员/产品）\n\n    private int productCount = 0;\n    //生产产品\n    public synchronized void produceProduct() {\n\n        if(productCount < 20){\n            productCount++;\n            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");\n\n            notify();\n\n        }else{\n            //等待\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n    //消费产品\n    public synchronized void consumeProduct() {\n        if(productCount > 0){\n            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");\n            productCount--;\n\n            notify();\n        }else{\n            //等待\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\nclass Producer extends Thread{//生产者\n\n    private Clerk clerk;\n\n    public Producer(Clerk clerk) {\n        this.clerk = clerk;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(getName() + ":开始生产产品.....");\n\n        while(true){\n\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            clerk.produceProduct();\n        }\n\n    }\n}\n\nclass Consumer extends Thread{//消费者\n    private Clerk clerk;\n\n    public Consumer(Clerk clerk) {\n        this.clerk = clerk;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(getName() + ":开始消费产品.....");\n\n        while(true){\n\n            try {\n                Thread.sleep(20);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            clerk.consumeProduct();\n        }\n    }\n}\n\npublic class ProductTest {\n\n    public static void main(String[] args) {\n        Clerk clerk = new Clerk();\n\n        Producer p1 = new Producer(clerk);\n        p1.setName("生产者1");\n\n        Consumer c1 = new Consumer(clerk);\n        c1.setName("消费者1");\n        Consumer c2 = new Consumer(clerk);\n        c2.setName("消费者2");\n\n        p1.start();\n        c1.start();\n        c2.start();\n\n    }\n}']},{title:"java 使用正则表达式",headers:[{level:2,title:"1.1 Java 正则表达式使用指南",slug:"_1-1-java-正则表达式使用指南",link:"#_1-1-java-正则表达式使用指南",children:[]},{level:2,title:"1.2 Pattern 类",slug:"_1-2-pattern-类",link:"#_1-2-pattern-类",children:[]},{level:2,title:"1.3 创建 Pattern 对象",slug:"_1-3-创建-pattern-对象",link:"#_1-3-创建-pattern-对象",children:[]},{level:2,title:"2.1 常用方法",slug:"_2-1-常用方法",link:"#_2-1-常用方法",children:[]},{level:2,title:"3.1 检查字符串是否为有效的电子邮件地址",slug:"_3-1-检查字符串是否为有效的电子邮件地址",link:"#_3-1-检查字符串是否为有效的电子邮件地址",children:[]},{level:2,title:"3.2 提取所有的数字",slug:"_3-2-提取所有的数字",link:"#_3-2-提取所有的数字",children:[]},{level:2,title:"3.3 替换所有非字母字符为空格",slug:"_3-3-替换所有非字母字符为空格",link:"#_3-3-替换所有非字母字符为空格",children:[]},{level:2,title:"3.4 特殊字符和转义",slug:"_3-4-特殊字符和转义",link:"#_3-4-特殊字符和转义",children:[]},{level:2,title:"3.5 分组和捕获",slug:"_3-5-分组和捕获",link:"#_3-5-分组和捕获",children:[]},{level:2,title:"3.6. 总结",slug:"_3-6-总结",link:"#_3-6-总结",children:[]},{level:2,title:"4.1 基本字符匹配",slug:"_4-1-基本字符匹配",link:"#_4-1-基本字符匹配",children:[]},{level:2,title:"4.2 定量符（Quantifiers）",slug:"_4-2-定量符-quantifiers",link:"#_4-2-定量符-quantifiers",children:[]},{level:2,title:"4.3 字符类（Character Classes）",slug:"_4-3-字符类-character-classes",link:"#_4-3-字符类-character-classes",children:[]},{level:2,title:"4.4 预定义字符类",slug:"_4-4-预定义字符类",link:"#_4-4-预定义字符类",children:[]},{level:2,title:"4.5 锚点（Anchors）",slug:"_4-5-锚点-anchors",link:"#_4-5-锚点-anchors",children:[]},{level:2,title:"4.6 分组与捕获（Grouping and Capturing）",slug:"_4-6-分组与捕获-grouping-and-capturing",link:"#_4-6-分组与捕获-grouping-and-capturing",children:[]},{level:2,title:"4.7 替代（Alternation）",slug:"_4-7-替代-alternation",link:"#_4-7-替代-alternation",children:[]},{level:2,title:"4.8 向后引用（Backreferences）",slug:"_4-8-向后引用-backreferences",link:"#_4-8-向后引用-backreferences",children:[]},{level:2,title:"4.9 注释",slug:"_4-9-注释",link:"#_4-9-注释",children:[]},{level:2,title:"4.10 标志（Flags/Modifiers）",slug:"_4-10-标志-flags-modifiers",link:"#_4-10-标志-flags-modifiers",children:[]}],path:"/posts/java/basic/regularExpression.html",pathLocale:"/",extraFields:['java\nPattern pattern = Pattern.compile("your_regex_here");','java\nMatcher matcher = pattern.matcher("input_string_to_match");','java\nString emailRegex = "^[\\\\w.-]+@[\\\\w.-]+\\\\.[a-zA-Z]{2,}$";\nPattern pattern = Pattern.compile(emailRegex);\nMatcher matcher = pattern.matcher("example@example.com");\nboolean isValidEmail = matcher.matches();','java\nString content = "The price is 100 dollars and the tax is 5%";\nPattern pattern = Pattern.compile("\\\\d+");\nMatcher matcher = pattern.matcher(content);\n\nwhile (matcher.find()) {\n    System.out.println(matcher.group());\n}','java\nString text = "Hello, world! 123";\nString cleanedText = text.replaceAll("[^a-zA-Z]", " ");\nSystem.out.println(cleanedText);','java\nString specialCharRegex = "\\\\."; // 匹配实际的点号','java\nString datePattern = "(\\\\d{4})-(\\\\d{2})-(\\\\d{2})"; // 年-月-日格式\nPattern pattern = Pattern.compile(datePattern);\nMatcher matcher = pattern.matcher("2023-04-01");\n\nif (matcher.matches()) {\n    String year = matcher.group(1);\n    String month = matcher.group(2);\n    String day = matcher.group(3);\n}']},{title:"java bug 合集",headers:[{level:2,title:"解決BufferedReader读取中文乱码问题",slug:"解決bufferedreader读取中文乱码问题",link:"#解決bufferedreader读取中文乱码问题",children:[]}],path:"/posts/java/bug/bug.html",pathLocale:"/",extraFields:['java\nInputStream in=new FileInputStream("D:\\\\temp\\\\user2.txt");\nSystem.out.println(stream2String(in));\n\n//stream2String方法的主要代码:\n\nsb = new StringBuffer();\n//bfReader = new BufferedReader(new InputStreamReader(in));  //会出乱码\nbfReader = new BufferedReader(new InputStreamReader(in, "UTF-8"));\n\nString line = bfReader.readLine();']},{title:"docx4j 基本使用",headers:[{level:2,title:"1.快速入门",slug:"_1-快速入门",link:"#_1-快速入门",children:[{level:3,title:"1.1.引入依赖",slug:"_1-1-引入依赖",link:"#_1-1-引入依赖",children:[]},{level:3,title:"1.2.用一些文本创建文档",slug:"_1-2-用一些文本创建文档",link:"#_1-2-用一些文本创建文档",children:[]},{level:3,title:"1.3.添加带样式的文本",slug:"_1-3-添加带样式的文本",link:"#_1-3-添加带样式的文本",children:[]},{level:3,title:"1.4.添加表格",slug:"_1-4-添加表格",link:"#_1-4-添加表格",children:[]},{level:3,title:"1.5.给表格添加边框",slug:"_1-5-给表格添加边框",link:"#_1-5-给表格添加边框",children:[]},{level:3,title:"1.6.给表格添加其他样式",slug:"_1-6-给表格添加其他样式",link:"#_1-6-给表格添加其他样式",children:[]}]},{level:2,title:"2.加载已有的word修改其表格中的值",slug:"_2-加载已有的word修改其表格中的值",link:"#_2-加载已有的word修改其表格中的值",children:[]},{level:2,title:"3.实际问题",slug:"_3-实际问题",link:"#_3-实际问题",children:[]}],path:"/posts/java/dependence/docx4j.html",pathLocale:"/",extraFields:["shell\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.docx4j</groupId>\n\t\t<artifactId>docx4j-core</artifactId>\n\t\t<version>8.2.6</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.docx4j</groupId>\n\t\t<artifactId>docx4j-JAXB-ReferenceImpl</artifactId>\n\t\t<version>8.2.6</version>\n\t</dependency>\n    <dependency>\n        <groupId>org.docx4j</groupId>\n        <artifactId>docx4j</artifactId>\n        <version>6.1.2</version>\n    </dependency>\n</dependencies>",'java\n @Test\n    public void test1() throws Docx4JException {\n        WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();//创建一个空白word\n        wordMLPackage.getMainDocumentPart().addParagraphOfText("Hello Word!");//添加一个文本段落\n        wordMLPackage.save(new java.io.File("HelloWord1.docx"));\n    }','java\n @Test\n    public void test2() throws Docx4JException {\n        WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();\n        wordMLPackage.getMainDocumentPart().addStyledParagraphOfText("Title", "Hello Word!");\n        wordMLPackage.getMainDocumentPart().addStyledParagraphOfText("Subtitle","This is a subtitle!");\n        wordMLPackage.save(new java.io.File("HelloWord2.docx"));\n    }','java\n public void test3() throws Docx4JException {\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl table = factory.createTbl();//创建表格\n        Tr tableRow = factory.createTr();//创建一行\n\n        Tc tableCell_1 = factory.createTc();//创建单元格\n        tableCell_1.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 1"));//设置单元格内容\n        tableRow.getContent().add(tableCell_1);//添加单元格到row中\n\n        Tc tableCell_2 = factory.createTc();\n        tableCell_1.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 2"));\n        tableRow.getContent().add(tableCell_2);\n\n\n        table.getContent().add(tableRow);//将row添加到表格中\n\n        wordMlPackage.getMainDocumentPart().addObject(table);//将表格添加到word中\n        wordMlPackage.save(new File("HelloWord4.docx"));//保存\n    }','java\n//给表格添加边框\n    @Test\n    public void test4() throws Docx4JException {\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl table = factory.createTbl();\n        Tr tableRow = factory.createTr();\n        Tc tableCell = factory.createTc();//创建单元格\n        tableCell.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Field 1"));//设置单元格内容\n        tableRow.getContent().add(tableCell);//添加单元格到row中\n        table.getContent().add(tableRow);//将row添加到表格中\n\n        addBorders(table);\n\n        wordMlPackage.getMainDocumentPart().addObject(table);//将表格添加到word中\n        wordMlPackage.save(new File("HelloWord5.docx"));//保存\n    }\n    //加边框\n    void addBorders(Tbl table) {\n        table.setTblPr(new TblPr());\n        CTBorder border = new CTBorder();\n        border.setColor("auto");\n        border.setSz(new BigInteger("4"));\n        border.setSpace(new BigInteger("0"));\n        border.setVal(STBorder.SINGLE);\n\n        TblBorders borders = new TblBorders();\n        borders.setBottom(border);\n        borders.setLeft(border);\n        borders.setRight(border);\n        borders.setTop(border);\n        borders.setInsideH(border);\n        borders.setInsideV(border);\n        table.getTblPr().setTblBorders(borders);\n    }','java\n//给表格添加样式\n    @Test\n    public void test6() throws Docx4JException{\n        WordprocessingMLPackage wordMlPackage = WordprocessingMLPackage.createPackage();\n        ObjectFactory factory = Context.getWmlObjectFactory();//工厂\n        Tbl tab = factory.createTbl();\n        Tr row = factory.createTr();\n        Tc tc = factory.createTc();\n        //第一个单元格\n        tc.getContent().add(wordMlPackage.getMainDocumentPart().createParagraphOfText("Normal text"));\n        row.getContent().add(tc);\n        //第二个单元格\n        Tc tc2 = factory.createTc();\n        P paragraph = factory.createP();//创建段落\n        Text text = factory.createText();//文本对象\n        text.setValue("Bold text");\n\n        R run = factory.createR();//创建运行块对象,它是一块或多块拥有共同属性的文本的容器\n        run.getContent().add(text);//将文本对象添加到其中.\n\n        paragraph.getContent().add(run);//运行块R添加到段落内容中.\n\n        RPr runProperties = factory.createRPr();//运行属性\n\n        BooleanDefaultTrue b = new BooleanDefaultTrue();//默认为true\n        b.setVal(true);\n\n        runProperties.setB(b);//将运行块属性添加为粗体属性\n\n        HpsMeasure size = new HpsMeasure();//字体大小属性\n        size.setVal(new BigInteger("40"));//这个属性规定是半个点(half-point)大小, 因此字体大小需要是你想在Word中显示大小的两倍,\n\n        runProperties.setSz(size);//猜测是整体大小\n        runProperties.setSzCs(size);//猜测为单元格大小\n\n        run.setRPr(runProperties);//将样式添加进去\n\n        tc2.getContent().add(paragraph);\n        row.getContent().add(tc2);\n\n\n        tab.getContent().add(row);\n        addBorders(tab);\n\n        wordMlPackage.getMainDocumentPart().addObject(tab);\n        wordMlPackage.save(new File("helloWord6.docx"));\n    }','java\n  @Test\n    public void test9(){\n        WordprocessingMLPackage wordMlPackage = null;\n        try {\n            wordMlPackage = WordprocessingMLPackage.load(new File("helloWord6.docx"));\n        } catch (Docx4JException e) {\n            log.error("文件加载失败");\n            e.printStackTrace();\n        }\n        MainDocumentPart mainDocPart = wordMlPackage.getMainDocumentPart();\n        List<Object> children = ((ContentAccessor) mainDocPart).getContent();\n        JAXBElement jaxbElement = (JAXBElement) children.get(0);\n        Tbl tbl = (Tbl) jaxbElement.getValue();\n        List<Object> trList = tbl.getContent();\n        Tr tr = (Tr) trList.get(0);\n\n        JAXBElement jax_tc = (JAXBElement) tr.getContent().get(0);\n        Tc tc = (Tc) jax_tc.getValue();\n        P p = (P) tc.getContent().get(0);//段落\n        R r = (R) p.getContent().get(0);//行\n        JAXBElement jax = (JAXBElement) r.getContent().get(0);\n        Text text = (Text) jax.getValue();\n        String value = text.getValue();\n        log.error("获取到表格中第一列第一行的值为：" + value);\n        text.setValue("我成功啦");\n        try {\n            wordMlPackage.save(new File("helloWord6.docx"));\n        } catch (Docx4JException e) {\n            log.error("保存文件失败");\n            e.printStackTrace();\n        }\n    }',"shell\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.24</version> \x3c!-- 请检查最新版本 --\x3e\n</dependency>\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j</artifactId>\n    <version>6.1.2</version>\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n        \x3c!-- https://mvnrepository.com/artifact/org.docx4j/docx4j-export-fo --\x3e\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j-export-fo</artifactId>\n    <version>6.1.0</version>\n</dependency>",'java\n\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.docx4j.Docx4J;\nimport org.docx4j.openpackaging.packages.WordprocessingMLPackage;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class PdfPageCounter {\n    public static void main(String[] args) {\n        String pdfPath = getPdf(HmiproApplication.getPath(), "mingyang.docx");\n        int pdfCount = getPdfCount(pdfPath);\n        System.out.println(pdfCount);\n    }\n\n    public static String getPdf(String filePath,String fileName) {\n        try {\n            // 设置输入输出文件路径\n            File inputFile = new File(filePath + fileName);\n            String res = filePath+ File.separator + fileName + "pdf.pdf";\n            File outputFile = new File(res);\n\n            // 加载 DOCX 文件\n            WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.load(inputFile);\n\n            // 执行转换\n            Docx4J.toPDF(wordMLPackage, new FileOutputStream(outputFile));\n            return res;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static int getPdfCount(String pdfPath){\n        File file = new File(pdfPath);\n        try (PDDocument document = PDDocument.load(file)) {\n            int numberOfPages = document.getNumberOfPages();\n            document.close();\n            file.deleteOnExit();\n            return numberOfPages;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n}',"shell\n\n<dependency>\n    <groupId>com.documents4j</groupId>\n    <artifactId>documents4j-local</artifactId>\n    <version>1.0.3</version>\n</dependency>\n<dependency>\n    <groupId>com.documents4j</groupId>\n    <artifactId>documents4j-transformer-msoffice-word</artifactId>\n    <version>1.0.3</version>\n</dependency>\n\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.24</version> \x3c!-- 请检查最新版本 --\x3e\n</dependency>\n\n <dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j</artifactId>\n    <version>6.1.2</version>\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.docx4j</groupId>\n    <artifactId>docx4j-export-fo</artifactId>\n    <version>6.1.0</version>\n</dependency>",'java\nimport com.documents4j.api.DocumentType;\nimport com.documents4j.api.IConverter;\nimport com.documents4j.job.LocalConverter;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.docx4j.openpackaging.exceptions.Docx4JException;\n\nimport java.io.*;\n\npublic class PdfPageCounter {\n    public static void main(String[] args) throws Docx4JException {\n        String fileName = "demo.docx";\n        String path = "E:\\\\资料\\\\诊断报告";\n        String targetFile = path + File.separator + fileName;\n        String pdfPath = getPdf(path, fileName);\n        int pdfCount = getPdfCount(pdfPath);\n        System.out.println(pdfCount);\n    }\n    \n\n    public static int getPdfCount(String pdfPath){\n        File file = new File(pdfPath);\n        try (PDDocument document = PDDocument.load(file)) {\n            int numberOfPages = document.getNumberOfPages();\n            document.close();\n            file.deleteOnExit();\n            return numberOfPages;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return -1;\n    }\n\n    public static String getPdf(String path,String fileName) {\n        File inputWord = new File(path + File.separator + fileName);\n        String resPath = path + File.separator + fileName.replace(".docx",".pdf");\n        File outputFile = new File(resPath);\n        try  {\n            InputStream docxInputStream = new FileInputStream(inputWord);\n            OutputStream outputStream = new FileOutputStream(outputFile);\n            IConverter converter = LocalConverter.builder().build();\n            converter.convert(docxInputStream).as(DocumentType.DOCX).to(outputStream).as(DocumentType.PDF).execute();\n            outputStream.close();\n            System.out.println("success");\n            return resPath;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}']},{title:"Java 有关log的第三方依赖的使用",headers:[{level:2,title:'Failed to load class "org.slf4j.impl.StaticLoggerBinder"',slug:"failed-to-load-class-org-slf4j-impl-staticloggerbinder",link:"#failed-to-load-class-org-slf4j-impl-staticloggerbinder",children:[]},{level:2,title:"WARN No appenders could be found for logger",slug:"warn-no-appenders-could-be-found-for-logger",link:"#warn-no-appenders-could-be-found-for-logger",children:[]},{level:2,title:"Class path contains multiple SLF4J bindings.",slug:"class-path-contains-multiple-slf4j-bindings",link:"#class-path-contains-multiple-slf4j-bindings",children:[]}],path:"/posts/java/dependence/log.html",pathLocale:"/",extraFields:["shell\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.16</version>\n</dependency>\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-api</artifactId>\n    <version>1.7.30</version>\n</dependency>",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n\x3c!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\x3e\n\x3c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\x3e\n\x3c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。\n                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration  scan="true" scanPeriod="10 seconds">\n    <contextName>logback-spring</contextName>\n\n    \x3c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\x3e\n    <property name="logging.path" value="./logs" />\n\n    \x3c!--0. 日志格式和颜色渲染 --\x3e\n    \x3c!-- 彩色日志依赖的渲染类 --\x3e\n    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />\n    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />\n    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />\n    \x3c!-- 彩色日志格式 --\x3e\n    <property name="CONSOLE_LOG_PATTERN" value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>\n\n    \x3c!--1. 输出到控制台--\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>debug</level>\n        </filter>\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            \x3c!-- 设置字符集 --\x3e\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--2. 输出到文档--\x3e\n    \x3c!-- 2.1 level为 DEBUG 日志，时间滚动输出  --\x3e\n    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_debug.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 日志归档 --\x3e\n            <fileNamePattern>${logging.path}/web-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录debug级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>debug</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.2 level为 INFO 日志，时间滚动输出  --\x3e\n    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_info.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 每天日志归档路径以及格式 --\x3e\n            <fileNamePattern>${logging.path}/web-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录info级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>info</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.3 level为 WARN 日志，时间滚动输出  --\x3e\n    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_warn.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录warn级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>warn</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.4 level为 ERROR 日志，时间滚动输出  --\x3e\n    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_error.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录ERROR级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>ERROR</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!--\n        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n        以及指定<appender>。<logger>仅有一个name属性，\n        一个可选的level和一个可选的addtivity属性。\n        name:用来指定受此logger约束的某一个包或者具体的某一个类。\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n              如果未设置此属性，那么当前logger将会继承上级的级别。\n        addtivity:是否向上级logger传递打印信息。默认是true。\n        <logger name="org.springframework.web" level="info"/>\n        <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!--过滤掉spring和mybatis的一些无用的DEBUG信息--\x3e\n    <logger name="org.springframework" level="INFO" />\n    <logger name="org.mybatis" level="INFO" />\n    <logger name="org.apache.zookeeper" level="INFO" />\n\n    \x3c!-- 4. 最终的策略 --\x3e\n    \x3c!-- 4.1 开发环境:打印控制台--\x3e\n    <springProfile name="dev">\n        <logger name="com.example.datatransport" level="debug"/>\x3c!-- 修改此处扫描包名 --\x3e\n    </springProfile>\n\n    <root level="info">\n        <appender-ref ref="CONSOLE" />\n        <appender-ref ref="DEBUG_FILE" />\n        <appender-ref ref="INFO_FILE" />\n        <appender-ref ref="WARN_FILE" />\n        <appender-ref ref="ERROR_FILE" />\n    </root>\n\n\x3c!--    4.2 生产环境:输出到文档--\x3e\n    <springProfile name="pro">\n        <root level="info">\n            <appender-ref ref="CONSOLE" />\n            <appender-ref ref="DEBUG_FILE" />\n\x3c!--            <appender-ref ref="INFO_FILE" />--\x3e\n            <appender-ref ref="ERROR_FILE" />\n            <appender-ref ref="WARN_FILE" />\n        </root>\n    </springProfile>\n</configuration>',"xml\n<dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-log4j12</artifactId>\n      <version>1.7.5</version>\n</dependency>","properties\nlog4j.rootLogger=DEBUG, stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n"]},{title:"有关maven的使用",headers:[{level:2,title:"Maven&MyBatis",slug:"maven-mybatis",link:"#maven-mybatis",children:[]},{level:2,title:"1，Maven",slug:"_1-maven",link:"#_1-maven",children:[{level:3,title:"1.1  Maven简介",slug:"_1-1-maven简介",link:"#_1-1-maven简介",children:[]},{level:3,title:"1.2  Maven安装配置",slug:"_1-2-maven安装配置",link:"#_1-2-maven安装配置",children:[]},{level:3,title:"1.3  Maven基本使用",slug:"_1-3-maven基本使用",link:"#_1-3-maven基本使用",children:[]},{level:3,title:"1.4  IDEA使用Maven",slug:"_1-4-idea使用maven",link:"#_1-4-idea使用maven",children:[]},{level:3,title:"1.5  依赖管理",slug:"_1-5-依赖管理",link:"#_1-5-依赖管理",children:[]}]},{level:2,title:"1.6 maven命令行安装",slug:"_1-6-maven命令行安装",link:"#_1-6-maven命令行安装",children:[]},{level:2,title:"maven 相关的bug",slug:"maven-相关的bug",link:"#maven-相关的bug",children:[{level:3,title:"Could not transfer artifact",slug:"could-not-transfer-artifact",link:"#could-not-transfer-artifact",children:[]},{level:3,title:"the trustAnchors parameter must be non-empty",slug:"the-trustanchors-parameter-must-be-non-empty",link:"#the-trustanchors-parameter-must-be-non-empty",children:[]},{level:3,title:"Failure to transfer……from",slug:"failure-to-transfer-from",link:"#failure-to-transfer-from",children:[]}]}],path:"/posts/java/dependence/maven.html",pathLocale:"/",extraFields:["xml\n  <mirror>  \n      <id>alimaven</id>  \n      <name>aliyun maven</name>  \n      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n      <mirrorOf>central</mirrorOf>          \n  </mirror>","java\ncompile ：编译","mvn clean","mvn package","mvn test","mvn install"]},{title:"mybatis 的基础知识",headers:[{level:2,title:"2，Mybatis",slug:"_2-mybatis",link:"#_2-mybatis",children:[{level:3,title:"2.1  Mybatis概述",slug:"_2-1-mybatis概述",link:"#_2-1-mybatis概述",children:[]},{level:3,title:"2.2  Mybatis快速入门",slug:"_2-2-mybatis快速入门",link:"#_2-2-mybatis快速入门",children:[]},{level:3,title:"2.3  Mapper代理开发",slug:"_2-3-mapper代理开发",link:"#_2-3-mapper代理开发",children:[]},{level:3,title:"2.4  核心配置文件",slug:"_2-4-核心配置文件",link:"#_2-4-核心配置文件",children:[]}]},{level:2,title:"3.CRUD相关",slug:"_3-crud相关",link:"#_3-crud相关",children:[{level:3,title:"3.1 数据库字段和实体字段对不上",slug:"_3-1-数据库字段和实体字段对不上",link:"#_3-1-数据库字段和实体字段对不上",children:[]},{level:3,title:"3.2.参数暂位符",slug:"_3-2-参数暂位符",link:"#_3-2-参数暂位符",children:[]},{level:3,title:"3.3.parameterType使用",slug:"_3-3-parametertype使用",link:"#_3-3-parametertype使用",children:[]},{level:3,title:"3.4.SQL语句中特殊字段处理",slug:"_3-4-sql语句中特殊字段处理",link:"#_3-4-sql语句中特殊字段处理",children:[]},{level:3,title:"3.5.多条件查询",slug:"_3-5-多条件查询",link:"#_3-5-多条件查询",children:[]},{level:3,title:"4.Mybatis参数传递",slug:"_4-mybatis参数传递",link:"#_4-mybatis参数传递",children:[]},{level:3,title:"5.注解实现CRUD",slug:"_5-注解实现crud",link:"#_5-注解实现crud",children:[]}]},{level:2,title:"mybatis 注解相关",slug:"mybatis-注解相关",link:"#mybatis-注解相关",children:[{level:3,title:"日志",slug:"日志",link:"#日志",children:[]},{level:3,title:"@Mapper注解：",slug:"mapper注解",link:"#mapper注解",children:[]},{level:3,title:"@MapperScan",slug:"mapperscan",link:"#mapperscan",children:[]},{level:3,title:"使用@MapperScan注解多个包",slug:"使用-mapperscan注解多个包",link:"#使用-mapperscan注解多个包",children:[]},{level:3,title:"如果dao接口类没有在Spring Boot主程序可以扫描的包或者子包下面，可以使用如下方式进行配置：",slug:"如果dao接口类没有在spring-boot主程序可以扫描的包或者子包下面-可以使用如下方式进行配置",link:"#如果dao接口类没有在spring-boot主程序可以扫描的包或者子包下面-可以使用如下方式进行配置",children:[]},{level:3,title:"SqlSessionTemplate",slug:"sqlsessiontemplate",link:"#sqlsessiontemplate",children:[]}]},{level:2,title:"mybatis 遇到的相关bug",slug:"mybatis-遇到的相关bug",link:"#mybatis-遇到的相关bug",children:[]}],path:"/posts/java/dependence/mybatis.html",pathLocale:"/",extraFields:["sql\n  create database mybatis;\n  use mybatis;\n  \n  drop table if exists tb_user;\n  \n  create table tb_user(\n  \tid int primary key auto_increment,\n  \tusername varchar(20),\n  \tpassword varchar(20),\n  \tgender char(1),\n  \taddr varchar(30)\n  );\n  \n  INSERT INTO tb_user VALUES (1, 'zhangsan', '123', '男', '北京');\n  INSERT INTO tb_user VALUES (2, '李四', '234', '女', '天津');\n  INSERT INTO tb_user VALUES (3, '王五', '11', '男', '西安');","xml\n  <dependencies>\n      \x3c!--mybatis 依赖--\x3e\n      <dependency>\n          <groupId>org.mybatis</groupId>\n          <artifactId>mybatis</artifactId>\n          <version>3.5.5</version>\n      </dependency>\n  \n      \x3c!--mysql 驱动--\x3e\n      <dependency>\n          <groupId>mysql</groupId>\n          <artifactId>mysql-connector-java</artifactId>\n          <version>5.1.46</version>\n      </dependency>\n  \n      \x3c!--junit 单元测试--\x3e\n      <dependency>\n          <groupId>junit</groupId>\n          <artifactId>junit</artifactId>\n          <version>4.13</version>\n          <scope>test</scope>\n      </dependency>\n  \n      \x3c!-- 添加slf4j日志api --\x3e\n      <dependency>\n          <groupId>org.slf4j</groupId>\n          <artifactId>slf4j-api</artifactId>\n          <version>1.7.20</version>\n      </dependency>\n      \x3c!-- 添加logback-classic依赖 --\x3e\n      <dependency>\n          <groupId>ch.qos.logback</groupId>\n          <artifactId>logback-classic</artifactId>\n          <version>1.2.3</version>\n      </dependency>\n      \x3c!-- 添加logback-core依赖 --\x3e\n      <dependency>\n          <groupId>ch.qos.logback</groupId>\n          <artifactId>logback-core</artifactId>\n          <version>1.2.3</version>\n      </dependency>\n  </dependencies>",'xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <!DOCTYPE configuration\n          PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n          "http://mybatis.org/dtd/mybatis-3-config.dtd">\n  <configuration>\n  \n      <typeAliases>\n          <package name="com.itheima.pojo"/>\n      </typeAliases>\n      \n      \x3c!--\n      environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment\n      --\x3e\n      <environments default="development">\n          <environment id="development">\n              <transactionManager type="JDBC"/>\n              <dataSource type="POOLED">\n                  \x3c!--数据库连接信息--\x3e\n                  <property name="driver" value="com.mysql.jdbc.Driver"/>\n                  <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n                  <property name="username" value="root"/>\n                  <property name="password" value="1234"/>\n              </dataSource>\n          </environment>\n  \n          <environment id="test">\n              <transactionManager type="JDBC"/>\n              <dataSource type="POOLED">\n                  \x3c!--数据库连接信息--\x3e\n                  <property name="driver" value="com.mysql.jdbc.Driver"/>\n                  <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n                  <property name="username" value="root"/>\n                  <property name="password" value="1234"/>\n              </dataSource>\n          </environment>\n      </environments>\n      <mappers>\n         \x3c!--加载sql映射文件--\x3e\n         <mapper resource="UserMapper.xml"/>\n      </mappers>\n  </configuration>','xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n  <mapper namespace="test">\n      <select id="selectAll" resultType="com.itheima.pojo.User">\n          select * from tb_user;\n      </select>\n  </mapper>',"java\n      public class User {\n          private int id;\n          private String username;\n          private String password;\n          private String gender;\n          private String addr;\n          \n          //省略了 setter 和 getter\n      }",'java\n      public class MyBatisDemo {\n      \n          public static void main(String[] args) throws IOException {\n              //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory\n              String resource = "mybatis-config.xml";\n              InputStream inputStream = Resources.getResourceAsStream(resource);\n              SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n      \n              //2. 获取SqlSession对象，用它来执行sql\n              SqlSession sqlSession = sqlSessionFactory.openSession();\n              //3. 执行sql\n              List<User> users = sqlSession.selectList("test.selectAll"); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id\n              System.out.println(users);\n              //4. 释放资源\n              sqlSession.close();\n          }\n      }',"java\n  public interface UserMapper {\n      List<User> selectAll();\n      User selectById(int id);\n  }",'xml\n  \x3c!--\n      namespace:名称空间。必须是对应接口的全限定名\n  --\x3e\n  <mapper namespace="com.itheima.mapper.UserMapper">\n      <select id="selectAll" resultType="com.itheima.pojo.User">\n          select *\n          from tb_user;\n      </select>\n  </mapper>','java\n  /**\n   * Mybatis 代理开发\n   */\n  public class MyBatisDemo2 {\n  \n      public static void main(String[] args) throws IOException {\n  \n          //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory\n          String resource = "mybatis-config.xml";\n          InputStream inputStream = Resources.getResourceAsStream(resource);\n          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n  \n          //2. 获取SqlSession对象，用它来执行sql\n          SqlSession sqlSession = sqlSessionFactory.openSession();\n          //3. 执行sql\n          //3.1 获取UserMapper接口的代理对象\n          UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n          List<User> users = userMapper.selectAll();\n  \n          System.out.println(users);\n          //4. 释放资源\n          sqlSession.close();\n      }\n  }','xml\n<mappers>\n    \x3c!--加载sql映射文件--\x3e\n    \x3c!-- <mapper resource="com/itheima/mapper/UserMapper.xml"/>--\x3e\n    \x3c!--Mapper代理方式--\x3e\n    <package name="com.itheima.mapper"/>\n</mappers>','xml\n<environments default="development">\n    <environment id="development">\n        <transactionManager type="JDBC"/>\n        <dataSource type="POOLED">\n            \x3c!--数据库连接信息--\x3e\n            <property name="driver" value="com.mysql.jdbc.Driver"/>\n            <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n            <property name="username" value="root"/>\n            <property name="password" value="1234"/>\n        </dataSource>\n    </environment>\n\n    <environment id="test">\n        <transactionManager type="JDBC"/>\n        <dataSource type="POOLED">\n            \x3c!--数据库连接信息--\x3e\n            <property name="driver" value="com.mysql.jdbc.Driver"/>\n            <property name="url" value="jdbc:mysql:///mybatis?useSSL=false"/>\n            <property name="username" value="root"/>\n            <property name="password" value="1234"/>\n        </dataSource>\n    </environment>\n</environments>','xml\n<typeAliases>\n    \x3c!--name属性的值是实体类所在包--\x3e\n    <package name="com.itheima.pojo"/> \n</typeAliases>','xml\n<mapper namespace="com.itheima.mapper.UserMapper">\n    <select id="selectAll" resultType="user">\n        select * from tb_user;\n    </select>\n</mapper>','xml\n<select id="selectAll" resultType="brand">\n    select\n    id, brand_name as brandName, company_name as companyName, ordered, description, status\n    from tb_brand;\n</select>','xml\n  <sql id="brand_column">\n  \tid, brand_name as brandName, company_name as companyName, ordered, description, status\n  </sql>','xml\n  <select id="selectAll" resultType="brand">\n      select\n      <include refid="brand_column" />\n      from tb_brand;\n  </select>','xml\n  <resultMap id="brandResultMap" type="brand">\n      \x3c!--\n              id：完成主键字段的映射\n                  column：表的列名\n                  property：实体类的属性名\n              result：完成一般字段的映射\n                  column：表的列名\n                  property：实体类的属性名\n          --\x3e\n      <result column="brand_name" property="brandName"/>\n      <result column="company_name" property="companyName"/>\n  </resultMap>','xml\n  <select id="selectAll" resultMap="brandResultMap">\n      select *\n      from tb_brand;\n  </select>','xml\n  <select id="selectById"  resultMap="brandResultMap">\n      select *\n      from tb_brand where id = ${id};\n  </select>','xml\n<select id="selectById" parameterType="int" resultMap="brandResultMap">\n    select *\n    from tb_brand where id = ${id};\n</select>','java\n  List<Brand> selectByCondition(@Param("status") int status, @Param("companyName") String companyName,@Param("brandName") String brandName);',"java\n  List<Brand> selectByCondition(Brand brand);","List<Brand> selectByCondition(Map map);","sql\nselect * from tb_brand where status = #{status}","sql\nselect * from tb_brand where company_name like #{companName}","sql\nselect * from tb_brand where status = #{status} and company_name like #{companName}",'xml\n  <select id="selectByCondition" resultMap="brandResultMap">\n      select *\n      from tb_brand\n      where\n          <if test="status != null">\n              and status = #{status}\n          </if>\n          <if test="companyName != null and companyName != \'\' ">\n              and company_name like #{companyName}\n          </if>\n          <if test="brandName != null and brandName != \'\' ">\n              and brand_name like #{brandName}\n          </if>\n  </select>','java\n  Map map = new HashMap();\n  // map.put("status" , status);\n  map.put("companyName", companyName);\n  map.put("brandName" , brandName);',"sql\n  select * from tb_brand where and company_name like ? and brand_name like ?",'xml\n  <select id="selectByCondition" resultMap="brandResultMap">\n      select *\n      from tb_brand\n      <where>\n          <if test="status != null">\n              and status = #{status}\n          </if>\n          <if test="companyName != null and companyName != \'\' ">\n              and company_name like #{companyName}\n          </if>\n          <if test="brandName != null and brandName != \'\' ">\n              and brand_name like #{brandName}\n          </if>\n      </where>\n  </select>',"java\n/**\n  * 单条件动态查询\n  * @param brand\n  * @return\n  */\nList<Brand> selectByConditionSingle(Brand brand);",'xml\n<select id="selectByConditionSingle" resultMap="brandResultMap">\n    select *\n    from tb_brand\n    <where>\n        <choose>\x3c!--相当于switch--\x3e\n            <when test="status != null">\x3c!--相当于case--\x3e\n                status = #{status}\n            </when>\n            <when test="companyName != null and companyName != \'\' ">\x3c!--相当于case--\x3e\n                company_name like #{companyName}\n            </when>\n            <when test="brandName != null and brandName != \'\'">\x3c!--相当于case--\x3e\n                brand_name like #{brandName}\n            </when>\n        </choose>\n    </where>\n</select>','java\n@Test\npublic void testSelectByConditionSingle() throws IOException {\n    //接收参数\n    int status = 1;\n    String companyName = "华为";\n    String brandName = "华为";\n\n    // 处理参数\n    companyName = "%" + companyName + "%";\n    brandName = "%" + brandName + "%";\n\n    //封装对象\n    Brand brand = new Brand();\n    //brand.setStatus(status);\n    brand.setCompanyName(companyName);\n    //brand.setBrandName(brandName);\n\n    //1. 获取SqlSessionFactory\n    String resource = "mybatis-config.xml";\n    InputStream inputStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n    //2. 获取SqlSession对象\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    //3. 获取Mapper接口的代理对象\n    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);\n    //4. 执行方法\n    List<Brand> brands = brandMapper.selectByConditionSingle(brand);\n    System.out.println(brands);\n\n    //5. 释放资源\n    sqlSession.close();\n}','xml\n<insert id="add" useGeneratedKeys="true" keyProperty="id">\n    insert into tb_brand (brand_name, company_name, ordered, description, status)\n    values (#{brandName}, #{companyName}, #{ordered}, #{description}, #{status});\n</insert>','xml\n<update id="update">\n    update tb_brand\n    <set>\n        <if test="brandName != null and brandName != \'\'">\n            brand_name = #{brandName},\n        </if>\n        <if test="companyName != null and companyName != \'\'">\n            company_name = #{companyName},\n        </if>\n        <if test="ordered != null">\n            ordered = #{ordered},\n        </if>\n        <if test="description != null and description != \'\'">\n            description = #{description},\n        </if>\n        <if test="status != null">\n            status = #{status}\n        </if>\n    </set>\n    where id = #{id};\n</update>',"java\n/**\n  * 批量删除\n  */\nvoid deleteByIds(int[] ids);",'xml\n<delete id="deleteByIds">\n    delete from tb_brand where id\n    in\n    <foreach collection="array" item="id" separator="," open="(" close=")">\n        #{id}\n    </foreach>\n    ;\n</delete>',"sql\n> delete from tb_brand where id in (1,2,3);\n>",'java\n@Test\npublic void testDeleteByIds() throws IOException {\n    //接收参数\n    int[] ids = {5,7,8};\n\n    //1. 获取SqlSessionFactory\n    String resource = "mybatis-config.xml";\n    InputStream inputStream = Resources.getResourceAsStream(resource);\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n    //2. 获取SqlSession对象\n    SqlSession sqlSession = sqlSessionFactory.openSession();\n    //SqlSession sqlSession = sqlSessionFactory.openSession(true);\n    //3. 获取Mapper接口的代理对象\n    BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class);\n    //4. 执行方法\n    brandMapper.deleteByIds(ids);\n    //提交事务\n    sqlSession.commit();\n    //5. 释放资源\n    sqlSession.close();\n}','java\nUser select(@Param("username") String username,@Param("password") String password);','xml\n<select id="select" resultType="user">\n\tselect *\n    from tb_user\n    where \n    \tusername=#{username}\n    \tand password=#{password}\n</select>',"java\n  User select(String username,String password);",'xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{arg0}\n      \tand password=#{arg1}\n  </select>','xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{param1}\n      \tand password=#{param2}\n  </select>','java\n  User select(@Param("username") String username, String password);','xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{username}\n      \tand password=#{param2}\n  </select>','xml\n  <select id="select" resultType="user">\n  \tselect *\n      from tb_user\n      where \n      \tusername=#{arg0}\n      \tand password=#{param2}\n  </select>','java\n@Select(value = "select * from tb_user where id = #{id}")\npublic User select(int id);',"yaml\nlogging.level.路径=debug，eg：`logging.level.com.zzqa.amc.dao=debug`","java\n@Mapper\npublic interface UserDAO {\n//代码\n}",'java\n@SpringBootApplication\n@MapperScan("com.位置.dao")\npublic class SpringbootMybatisDemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootMybatisDemoApplication.class, args);\n    }\n}','java\n@SpringBootApplication\n@MapperScan({"com.h1.demo","com.h2.user"})\npublic class App {\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n}','java\n@Configuration//将想要的组件添加到容器中\n@MapperScan({"com.h1.*.mapper","org.h2.*.mapper"})\npublic class App {\n    // TODO 想要的操作\n}',"yaml\nmybatis:\n  mapper-locations: classpath:mapper/*.xml"]},{title:"netty 学习",headers:[{level:2,title:"基本使用",slug:"基本使用",link:"#基本使用",children:[]},{level:2,title:"不同 handler 的作用",slug:"不同-handler-的作用",link:"#不同-handler-的作用",children:[]}],path:"/posts/java/dependence/netty.html",pathLocale:"/",extraFields:["shell\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n</dependency>"]},{title:"NIO 基础",headers:[{level:2,title:"1. 三大组件",slug:"_1-三大组件",link:"#_1-三大组件",children:[{level:3,title:"1.1 Channel & Buffer",slug:"_1-1-channel-buffer",link:"#_1-1-channel-buffer",children:[]},{level:3,title:"1.2 Selector",slug:"_1-2-selector",link:"#_1-2-selector",children:[]}]},{level:2,title:"2. ByteBuffer",slug:"_2-bytebuffer",link:"#_2-bytebuffer",children:[{level:3,title:"2.1  ByteBuffer 正确使用姿势",slug:"_2-1-bytebuffer-正确使用姿势",link:"#_2-1-bytebuffer-正确使用姿势",children:[]},{level:3,title:"2.2 ByteBuffer 结构",slug:"_2-2-bytebuffer-结构",link:"#_2-2-bytebuffer-结构",children:[]},{level:3,title:"2.3 ByteBuffer 常见方法",slug:"_2-3-bytebuffer-常见方法",link:"#_2-3-bytebuffer-常见方法",children:[]},{level:3,title:"2.4 Scattering Reads",slug:"_2-4-scattering-reads",link:"#_2-4-scattering-reads",children:[]},{level:3,title:"2.5 Gathering Writes",slug:"_2-5-gathering-writes",link:"#_2-5-gathering-writes",children:[]},{level:3,title:"2.6 练习",slug:"_2-6-练习",link:"#_2-6-练习",children:[]}]},{level:2,title:"3. 文件编程",slug:"_3-文件编程",link:"#_3-文件编程",children:[{level:3,title:"3.1 FileChannel",slug:"_3-1-filechannel",link:"#_3-1-filechannel",children:[]},{level:3,title:"3.2 两个 Channel 传输数据",slug:"_3-2-两个-channel-传输数据",link:"#_3-2-两个-channel-传输数据",children:[]},{level:3,title:"3.3 Path",slug:"_3-3-path",link:"#_3-3-path",children:[]},{level:3,title:"3.4 Files",slug:"_3-4-files",link:"#_3-4-files",children:[]}]},{level:2,title:"4. 网络编程",slug:"_4-网络编程",link:"#_4-网络编程",children:[{level:3,title:"4.1 非阻塞 vs 阻塞",slug:"_4-1-非阻塞-vs-阻塞",link:"#_4-1-非阻塞-vs-阻塞",children:[]},{level:3,title:"4.2 Selector",slug:"_4-2-selector",link:"#_4-2-selector",children:[]},{level:3,title:"4.3 处理 accept 事件",slug:"_4-3-处理-accept-事件",link:"#_4-3-处理-accept-事件",children:[]},{level:3,title:"4.4 处理 read 事件",slug:"_4-4-处理-read-事件",link:"#_4-4-处理-read-事件",children:[]},{level:3,title:"4.5 处理 write 事件",slug:"_4-5-处理-write-事件",link:"#_4-5-处理-write-事件",children:[]},{level:3,title:"4.6 更进一步",slug:"_4-6-更进一步",link:"#_4-6-更进一步",children:[]},{level:3,title:"4.7 UDP",slug:"_4-7-udp",link:"#_4-7-udp",children:[]}]},{level:2,title:"5. NIO vs BIO",slug:"_5-nio-vs-bio",link:"#_5-nio-vs-bio",children:[{level:3,title:"5.1 stream vs channel",slug:"_5-1-stream-vs-channel",link:"#_5-1-stream-vs-channel",children:[]},{level:3,title:"5.2 IO 模型",slug:"_5-2-io-模型",link:"#_5-2-io-模型",children:[]},{level:3,title:"5.3 零拷贝",slug:"_5-3-零拷贝",link:"#_5-3-零拷贝",children:[]},{level:3,title:"5.3 AIO",slug:"_5-3-aio",link:"#_5-3-aio",children:[]}]}],path:"/posts/java/netty/Netty01-nio.html",pathLocale:"/",extraFields:["mermaid\ngraph LR\nchannel --\x3e buffer\nbuffer --\x3e channel","mermaid\ngraph TD\nsubgraph 多线程版\nt1(thread) --\x3e s1(socket1)\nt2(thread) --\x3e s2(socket2)\nt3(thread) --\x3e s3(socket3)\nend","mermaid\ngraph TD\nsubgraph 线程池版\nt4(thread) --\x3e s4(socket1)\nt5(thread) --\x3e s5(socket2)\nt4(thread) -.-> s6(socket3)\nt5(thread) -.-> s7(socket4)\nend","mermaid\ngraph TD\nsubgraph selector 版\nthread --\x3e selector\nselector --\x3e c1(channel)\nselector --\x3e c2(channel)\nselector --\x3e c3(channel)\nend","1234567890abcd",'java\n@Slf4j\npublic class ChannelDemo1 {\n    public static void main(String[] args) {\n        try (RandomAccessFile file = new RandomAccessFile("helloword/data.txt", "rw")) {\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(10);\n            do {\n                // 向 buffer 写入\n                int len = channel.read(buffer);\n                log.debug("读到字节数：{}", len);\n                if (len == -1) {\n                    break;\n                }\n                // 切换 buffer 读模式\n                buffer.flip();\n                while(buffer.hasRemaining()) {\n                    log.debug("{}", (char)buffer.get());\n                }\n                // 切换 buffer 写模式\n                buffer.clear();\n            } while (true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}',"10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1",'java\npublic class ByteBufferUtil {\n    private static final char[] BYTE2CHAR = new char[256];\n    private static final char[] HEXDUMP_TABLE = new char[256 * 4];\n    private static final String[] HEXPADDING = new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];\n    private static final String[] BYTE2HEX = new String[256];\n    private static final String[] BYTEPADDING = new String[16];\n\n    static {\n        final char[] DIGITS = "0123456789abcdef".toCharArray();\n        for (int i = 0; i < 256; i++) {\n            HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F];\n            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];\n        }\n\n        int i;\n\n        // Generate the lookup table for hex dump paddings\n        for (i = 0; i < HEXPADDING.length; i++) {\n            int padding = HEXPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding * 3);\n            for (int j = 0; j < padding; j++) {\n                buf.append("   ");\n            }\n            HEXPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) {\n            StringBuilder buf = new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, \'|\');\n            buf.append(\'|\');\n            HEXDUMP_ROWPREFIXES[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-hex-dump conversion\n        for (i = 0; i < BYTE2HEX.length; i++) {\n            BYTE2HEX[i] = \' \' + StringUtil.byteToHexStringPadded(i);\n        }\n\n        // Generate the lookup table for byte dump paddings\n        for (i = 0; i < BYTEPADDING.length; i++) {\n            int padding = BYTEPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding);\n            for (int j = 0; j < padding; j++) {\n                buf.append(\' \');\n            }\n            BYTEPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-char conversion\n        for (i = 0; i < BYTE2CHAR.length; i++) {\n            if (i <= 0x1f || i >= 0x7f) {\n                BYTE2CHAR[i] = \'.\';\n            } else {\n                BYTE2CHAR[i] = (char) i;\n            }\n        }\n    }\n\n    /**\n     * 打印所有内容\n     * @param buffer\n     */\n    public static void debugAll(ByteBuffer buffer) {\n        int oldlimit = buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin = new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println("+--------+-------------------- all ------------------------+----------------+");\n        System.out.printf("position: [%d], limit: [%d]\\n", buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    }\n\n    /**\n     * 打印可读取内容\n     * @param buffer\n     */\n    public static void debugRead(ByteBuffer buffer) {\n        StringBuilder builder = new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println("+--------+-------------------- read -----------------------+----------------+");\n        System.out.printf("position: [%d], limit: [%d]\\n", buffer.position(), buffer.limit());\n        System.out.println(builder);\n    }\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) {\n        if (isOutOfBounds(offset, length, buf.capacity())) {\n            throw new IndexOutOfBoundsException(\n                    "expected: " + "0 <= offset(" + offset + ") <= offset + length(" + length\n                            + ") <= " + "buf.capacity(" + buf.capacity() + \')\');\n        }\n        if (length == 0) {\n            return;\n        }\n        dump.append(\n                "         +-------------------------------------------------+" +\n                        NEWLINE + "         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |" +\n                        NEWLINE + "+--------+-------------------------------------------------+----------------+");\n\n        final int startIndex = offset;\n        final int fullRows = length >>> 4;\n        final int remainder = length & 0xF;\n\n        // Dump the rows which have 16 bytes.\n        for (int row = 0; row < fullRows; row++) {\n            int rowStartIndex = (row << 4) + startIndex;\n\n            // Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + 16;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(" |");\n\n            // ASCII dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(\'|\');\n        }\n\n        // Dump the last row which has less than 16 bytes.\n        if (remainder != 0) {\n            int rowStartIndex = (fullRows << 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + remainder;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(HEXPADDING[remainder]);\n            dump.append(" |");\n\n            // Ascii dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(BYTEPADDING[remainder]);\n            dump.append(\'|\');\n        }\n\n        dump.append(NEWLINE +\n                "+--------+-------------------------------------------------+----------------+");\n    }\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {\n        if (row < HEXDUMP_ROWPREFIXES.length) {\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        } else {\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, \'|\');\n            dump.append(\'|\');\n        }\n    }\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) {\n        return (short) (buffer.get(index) & 0xFF);\n    }\n}',"java\nBytebuffer buf = ByteBuffer.allocate(16);","java\nint readBytes = channel.read(buf);","java\nbuf.put((byte)127);","java\nint writeBytes = channel.write(buf);","java\nbyte b = buf.get();",'java\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode("你好");\nByteBuffer buffer2 = Charset.forName("utf-8").encode("你好");\n\ndebug(buffer1);\ndebug(buffer2);\n\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());\nSystem.out.println(buffer3.toString());',"+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好","onetwothree",'java\ntry (RandomAccessFile file = new RandomAccessFile("helloword/3parts.txt", "rw")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer a = ByteBuffer.allocate(3);\n    ByteBuffer b = ByteBuffer.allocate(3);\n    ByteBuffer c = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]{a, b, c});\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n} catch (IOException e) {\n    e.printStackTrace();\n}',"+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+","java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer d = ByteBuffer.allocate(4);\n    ByteBuffer e = ByteBuffer.allocate(4);\n    channel.position(11);\n\n    d.put(new byte[]{'f', 'o', 'u', 'r'});\n    e.put(new byte[]{'f', 'i', 'v', 'e'});\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]{d, e});\n} catch (IOException e) {\n    e.printStackTrace();\n}","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+","onetwothreefourfive",'java\npublic static void main(String[] args) {\n    ByteBuffer source = ByteBuffer.allocate(32);\n    //                     11            24\n    source.put("Hello,world\\nI\'m zhangsan\\nHo".getBytes());\n    split(source);\n\n    source.put("w are you?\\nhaha!\\n".getBytes());\n    split(source);\n}\n\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    int oldLimit = source.limit();\n    for (int i = 0; i < oldLimit; i++) {\n        if (source.get(i) == \'\\n\') {\n            System.out.println(i);\n            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());\n            // 0 ~ limit\n            source.limit(i + 1);\n            target.put(source); // 从source 读，向 target 写\n            debugAll(target);\n            source.limit(oldLimit);\n        }\n    }\n    source.compact();\n}',"java\nint readBytes = channel.read(buffer);","java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}","java\nlong pos = channel.position();","java\nlong newPos = ...;\nchannel.position(newPos);",'java\nString FROM = "helloword/data.txt";\nString TO = "helloword/to.txt";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println("transferTo 用时：" + (end - start) / 1000_000.0);',"transferTo 用时：8.2011",'java\npublic class TestFileChannelTransferTo {\n    public static void main(String[] args) {\n        try (\n                FileChannel from = new FileInputStream("data.txt").getChannel();\n                FileChannel to = new FileOutputStream("to.txt").getChannel();\n        ) {\n            // 效率高，底层会利用操作系统的零拷贝进行优化\n            long size = from.size();\n            // left 变量代表还剩余多少字节\n            for (long left = size; left > 0; ) {\n                System.out.println("position:" + (size - left) + " left:" + left);\n                left -= from.transferTo((size - left), left, to);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}',"position:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219",'java\nPath source = Paths.get("1.txt"); // 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source = Paths.get("d:\\\\1.txt"); // 绝对路径 代表了  d:\\1.txt\n\nPath source = Paths.get("d:/1.txt"); // 绝对路径 同样代表了  d:\\1.txt\n\nPath projects = Paths.get("d:\\\\data", "projects"); // 代表了  d:\\data\\projects',"d:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b",'java\nPath path = Paths.get("d:\\\\data\\\\projects\\\\a\\\\..\\\\b");\nSystem.out.println(path);\nSystem.out.println(path.normalize()); // 正常化路径',"d:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b",'java\nPath path = Paths.get("helloword/data.txt");\nSystem.out.println(Files.exists(path));','java\nPath path = Paths.get("helloword/d1");\nFiles.createDirectory(path);','java\nPath path = Paths.get("helloword/d1/d2");\nFiles.createDirectories(path);','java\nPath source = Paths.get("helloword/data.txt");\nPath target = Paths.get("helloword/target.txt");\n\nFiles.copy(source, target);',"java\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);",'java\nPath source = Paths.get("helloword/data.txt");\nPath target = Paths.get("helloword/data.txt");\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);','java\nPath target = Paths.get("helloword/target.txt");\n\nFiles.delete(target);','java\nPath target = Paths.get("helloword/d1");\n\nFiles.delete(target);','java\npublic static void main(String[] args) throws IOException {\n    Path path = Paths.get("C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91");\n    AtomicInteger dirCount = new AtomicInteger();\n    AtomicInteger fileCount = new AtomicInteger();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(dir);\n            dirCount.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(file);\n            fileCount.incrementAndGet();\n            return super.visitFile(file, attrs);\n        }\n    });\n    System.out.println(dirCount); // 133\n    System.out.println(fileCount); // 1479\n}','java\nPath path = Paths.get("C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91");\nAtomicInteger fileCount = new AtomicInteger();\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        if (file.toFile().getName().endsWith(".jar")) {\n            fileCount.incrementAndGet();\n        }\n        return super.visitFile(file, attrs);\n    }\n});\nSystem.out.println(fileCount); // 724','java\nPath path = Paths.get("d:\\\\a");\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        Files.delete(file);\n        return super.visitFile(file, attrs);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) \n        throws IOException {\n        Files.delete(dir);\n        return super.postVisitDirectory(dir, exc);\n    }\n});','java\nlong start = System.currentTimeMillis();\nString source = "D:\\\\Snipaste-1.16.2-x64";\nString target = "D:\\\\Snipaste-1.16.2-x64aaa";\n\nFiles.walk(Paths.get(source)).forEach(path -> {\n    try {\n        String targetName = path.toString().replace(source, target);\n        // 是目录\n        if (Files.isDirectory(path)) {\n            Files.createDirectory(Paths.get(targetName));\n        }\n        // 是普通文件\n        else if (Files.isRegularFile(path)) {\n            Files.copy(path, Paths.get(targetName));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlong end = System.currentTimeMillis();\nSystem.out.println(end - start);','java\n// 使用 nio 来理解阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\n\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug("connecting...");\n    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行\n    log.debug("connected... {}", sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        log.debug("before read... {}", channel);\n        channel.read(buffer); // 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug("after read...{}", channel);\n    }\n}','java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress("localhost", 8080));\nSystem.out.println("waiting...");','java\n// 使用 nio 来理解非阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false); // 非阻塞模式\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc != null) {\n        log.debug("connected... {}", sc);\n        sc.configureBlocking(false); // 非阻塞模式\n        channels.add(sc);\n    }\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read > 0) {\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug("after read...{}", channel);\n        }\n    }\n}',"mermaid\ngraph TD\nsubgraph selector 版\nthread --\x3e selector\nselector --\x3e c1(channel)\nselector --\x3e c2(channel)\nselector --\x3e c3(channel)\nend","java\nSelector selector = Selector.open();","java\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, 绑定事件);","java\nint count = selector.select();","java\nint count = selector.select(long timeout);","java\nint count = selector.selectNow();",'java\npublic class Client {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket("localhost", 8080)) {\n            System.out.println(socket);\n            socket.getOutputStream().write("world".getBytes());\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}','java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug("select count: {}", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        log.debug("{}", sc);\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}','java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug("select count: {}", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug("连接已建立: {}", sc);\n                    } else if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(128);\n                        int read = sc.read(buffer);\n                        if(read == -1) {\n                            key.cancel();\n                            sc.close();\n                        } else {\n                            buffer.flip();\n                            debug(buffer);\n                        }\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}',"sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+","java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss=new ServerSocket(9000);\n        while (true) {\n            Socket s = ss.accept();\n            InputStream in = s.getInputStream();\n            // 这里这么写，有没有问题\n            byte[] arr = new byte[4];\n            while(true) {\n                int read = in.read(arr);\n                // 这里这么写，有没有问题\n                if(read == -1) {\n                    break;\n                }\n                System.out.println(new String(arr, 0, read));\n            }\n        }\n    }\n}",'java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket max = new Socket("localhost", 9000);\n        OutputStream out = max.getOutputStream();\n        out.write("hello".getBytes());\n        out.write("world".getBytes());\n        out.write("你好".getBytes());\n        max.close();\n    }\n}',"hell\nowor\nld�\n�好","mermaid\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 ->> s: 发送 01234567890abcdef3333\\r\ns ->> b1: 第一次 read 存入 01234567890abcdef\ns ->> b2: 扩容\nb1 ->> b2: 拷贝 01234567890abcdef\ns ->> b2: 第二次 read 存入 3333\\r\nb2 ->> b2: 01234567890abcdef3333\\r",'java\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    for (int i = 0; i < source.limit(); i++) {\n        // 找到一条完整消息\n        if (source.get(i) == \'\\n\') {\n            int length = i + 1 - source.position();\n            // 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            // 从 source 读，向 target 写\n            for (int j = 0; j < length; j++) {\n                target.put(source.get());\n            }\n            debugAll(target);\n        }\n    }\n    source.compact(); // 0123456789abcdef  position 16 limit 16\n}\n\npublic static void main(String[] args) throws IOException {\n    // 1. 创建 selector, 管理多个 channel\n    Selector selector = Selector.open();\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    // 2. 建立 selector 和 channel 的联系（注册）\n    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    // key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug("sscKey:{}", sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) {\n        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug("key: {}", key);\n            // 5. 区分事件类型\n            if (key.isAcceptable()) { // 如果是 accept\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment\n                // 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug("{}", sc);\n                log.debug("scKey:{}", scKey);\n            } else if (key.isReadable()) { // 如果是 read\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel\n                    // 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1\n                    if(read == -1) {\n                        key.cancel();\n                    } else {\n                        split(buffer);\n                        // 需要扩容\n                        if (buffer.position() == buffer.limit()) {\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); // 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        }\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                }\n            }\n        }\n    }\n}','java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress("localhost", 8080));\nSocketAddress address = sc.getLocalAddress();\n// sc.write(Charset.defaultCharset().encode("hello\\nworld\\n"));\nsc.write(Charset.defaultCharset().encode("0123\\n456789abcdef"));\nsc.write(Charset.defaultCharset().encode("0123456789abcdef3333\\n"));\nSystem.in.read();','java\npublic class WriteServer {\n\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector = Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) {\n            selector.select();\n\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    SocketChannel sc = ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);\n                    // 1. 向客户端发送内容\n                    StringBuilder sb = new StringBuilder();\n                    for (int i = 0; i < 3000000; i++) {\n                        sb.append("a");\n                    }\n                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());\n                    int write = sc.write(buffer);\n                    // 3. write 表示实际写了多少字节\n                    System.out.println("实际写入字节:" + write);\n                    // 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) {\n                        // read 1  write 4\n                        // 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        // 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    }\n                } else if (key.isWritable()) {\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    int write = sc.write(buffer);\n                    System.out.println("实际写入字节:" + write);\n                    if (!buffer.hasRemaining()) { // 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    }\n                }\n            }\n        }\n    }\n}','java\npublic class WriteClient {\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        SocketChannel sc = SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress("localhost", 8080));\n        int count = 0;\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isConnectable()) {\n                    System.out.println(sc.finishConnect());\n                } else if (key.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);\n                    count += sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                }\n            }\n        }\n    }\n}','java\npublic class ChannelDemo7 {\n    public static void main(String[] args) throws IOException {\n        new BossEventLoop().register();\n    }\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable {\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start = false;\n        AtomicInteger index = new AtomicInteger();\n\n        public void register() throws IOException {\n            if (!start) {\n                ServerSocketChannel ssc = ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss = Selector.open();\n                SelectionKey ssckey = ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers = initEventLoops();\n                new Thread(this, "boss").start();\n                log.debug("boss start...");\n                start = true;\n            }\n        }\n\n        public WorkerEventLoop[] initEventLoops() {\n//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];\n            for (int i = 0; i < workerEventLoops.length; i++) {\n                workerEventLoops[i] = new WorkerEventLoop(i);\n            }\n            return workerEventLoops;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    boss.select();\n                    Iterator<SelectionKey> iter = boss.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                            SocketChannel sc = c.accept();\n                            sc.configureBlocking(false);\n                            log.debug("{} connected", sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable {\n        private Selector worker;\n        private volatile boolean start = false;\n        private int index;\n\n        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();\n\n        public WorkerEventLoop(int index) {\n            this.index = index;\n        }\n\n        public void register(SocketChannel sc) throws IOException {\n            if (!start) {\n                worker = Selector.open();\n                new Thread(this, "worker-" + index).start();\n                start = true;\n            }\n            tasks.add(() -> {\n                try {\n                    SelectionKey sckey = sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            worker.wakeup();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    worker.select();\n                    Runnable task = tasks.poll();\n                    if (task != null) {\n                        task.run();\n                    }\n                    Set<SelectionKey> keys = worker.selectedKeys();\n                    Iterator<SelectionKey> iter = keys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(128);\n                            try {\n                                int read = sc.read(buffer);\n                                if (read == -1) {\n                                    key.cancel();\n                                    sc.close();\n                                } else {\n                                    buffer.flip();\n                                    log.debug("{} message:", sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            }\n                        }\n                        iter.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}','java\npublic class UdpServer {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            channel.socket().bind(new InetSocketAddress(9999));\n            System.out.println("waiting...");\n            ByteBuffer buffer = ByteBuffer.allocate(32);\n            channel.receive(buffer);\n            buffer.flip();\n            debug(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}',"waiting...",'java\npublic class UdpClient {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            ByteBuffer buffer = StandardCharsets.UTF_8.encode("hello");\n            InetSocketAddress address = new InetSocketAddress("localhost", 9999);\n            channel.send(buffer, address);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}',"+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+",'java\nFile f = new File("helloword/data.txt");\nRandomAccessFile file = new RandomAccessFile(file, "r");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);','java\n@Slf4j\npublic class AioDemo1 {\n    public static void main(String[] args) throws IOException {\n        try{\n            AsynchronousFileChannel s = \n                AsynchronousFileChannel.open(\n                \tPaths.get("1.txt"), StandardOpenOption.READ);\n            ByteBuffer buffer = ByteBuffer.allocate(2);\n            log.debug("begin...");\n            s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    log.debug("read completed...{}", result);\n                    buffer.flip();\n                    debug(buffer);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    log.debug("read failed...");\n                }\n            });\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        log.debug("do other things...");\n        System.in.read();\n    }\n}',"13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+",'java\npublic class AioServer {\n    public static void main(String[] args) throws IOException {\n        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    }\n\n    private static void closeChannel(AsynchronousSocketChannel sc) {\n        try {\n            System.out.printf("[%s] %s close\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            try {\n                if (result == -1) {\n                    closeChannel(sc);\n                    return;\n                }\n                System.out.printf("[%s] %s read\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            closeChannel(sc);\n            exc.printStackTrace();\n        }\n    }\n\n    private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) {\n                sc.write(attachment);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n            closeChannel(sc);\n        }\n    }\n\n    private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> {\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) {\n            this.ssc = ssc;\n        }\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) {\n            try {\n                System.out.printf("[%s] %s connected\\n", Thread.currentThread().getName(), sc.getRemoteAddress());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            // 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            // 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode("server hello!"), ByteBuffer.allocate(16), new WriteHandler(sc));\n            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            exc.printStackTrace();\n        }\n    }\n}']},{title:"Netty 入门",headers:[{level:2,title:"1. 概述",slug:"_1-概述",link:"#_1-概述",children:[{level:3,title:"1.1 Netty 是什么？",slug:"_1-1-netty-是什么",link:"#_1-1-netty-是什么",children:[]},{level:3,title:"1.2 Netty 的作者",slug:"_1-2-netty-的作者",link:"#_1-2-netty-的作者",children:[]},{level:3,title:"1.3 Netty 的地位",slug:"_1-3-netty-的地位",link:"#_1-3-netty-的地位",children:[]},{level:3,title:"1.4 Netty 的优势",slug:"_1-4-netty-的优势",link:"#_1-4-netty-的优势",children:[]}]},{level:2,title:"2. Hello World",slug:"_2-hello-world",link:"#_2-hello-world",children:[{level:3,title:"2.1 目标",slug:"_2-1-目标",link:"#_2-1-目标",children:[]},{level:3,title:"2.2 服务器端",slug:"_2-2-服务器端",link:"#_2-2-服务器端",children:[]},{level:3,title:"2.3 客户端",slug:"_2-3-客户端",link:"#_2-3-客户端",children:[]},{level:3,title:"2.4 流程梳理",slug:"_2-4-流程梳理",link:"#_2-4-流程梳理",children:[]}]},{level:2,title:"3. 组件",slug:"_3-组件",link:"#_3-组件",children:[{level:3,title:"3.1 EventLoop",slug:"_3-1-eventloop",link:"#_3-1-eventloop",children:[]},{level:3,title:"3.2 Channel",slug:"_3-2-channel",link:"#_3-2-channel",children:[]},{level:3,title:"3.3 Future & Promise",slug:"_3-3-future-promise",link:"#_3-3-future-promise",children:[]},{level:3,title:"3.4 Handler & Pipeline",slug:"_3-4-handler-pipeline",link:"#_3-4-handler-pipeline",children:[]},{level:3,title:"3.5 ByteBuf",slug:"_3-5-bytebuf",link:"#_3-5-bytebuf",children:[]}]},{level:2,title:"4. 双向通信",slug:"_4-双向通信",link:"#_4-双向通信",children:[{level:3,title:"4.1 练习",slug:"_4-1-练习",link:"#_4-1-练习",children:[]},{level:3,title:"💡 读和写的误解",slug:"💡-读和写的误解",link:"#💡-读和写的误解",children:[]}]}],path:"/posts/java/netty/Netty02-%E5%85%A5%E9%97%A8.html",pathLocale:"/",extraFields:["Netty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers & clients.","xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.39.Final</version>\n</dependency>","java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioServerSocketChannel.class) // 2\n    .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new StringDecoder()); // 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                    System.out.println(msg);\n                }\n            });\n        }\n    })\n    .bind(8080); // 4",'java\nnew Bootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioSocketChannel.class) // 2\n    .handler(new ChannelInitializer<Channel>() { // 3\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder()); // 8\n        }\n    })\n    .connect("127.0.0.1", 8080) // 4\n    .sync() // 5\n    .channel() // 6\n    .writeAndFlush(new Date() + ": hello world!"); // 7',"java\n// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());","io.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98","java\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) {\n    System.out.println(eventLoop);\n}","io.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6","java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();",'java\npublic static void main(String[] args) throws InterruptedException {\n    Channel channel = new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer<NioSocketChannel>() {\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception {\n                    System.out.println("init...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                }\n            })\n            .channel(NioSocketChannel.class).connect("localhost", 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes("wangwu".getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes("wangwu".getBytes()));',"22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu",'java\nDefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch)  {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(normalWorkers,"myhandler",\n              new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();',"22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu",'java\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {\n    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);\n    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor = next.executor();\n    \n    // 是，直接调用\n    if (executor.inEventLoop()) {\n        next.invokeChannelRead(m);\n    } \n    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else {\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                next.invokeChannelRead(m);\n            }\n        });\n    }\n}','java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug("server start...");\nThread.sleep(2000);\nnioWorkers.execute(()->{\n    log.debug("normal task...");\n});',"22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...",'java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug("server start...");\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -> {\n    log.debug("running...");\n}, 0, 1, TimeUnit.SECONDS);',"22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...",'java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + ": hello world!");','java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080); // 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + ": hello world!");','java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080);\n\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.sync(); // 2\nSystem.out.println(channelFuture.channel()); // 3','java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080);\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.addListener((ChannelFutureListener) future -> {\n    System.out.println(future.channel()); // 2\n});','java\n@Slf4j\npublic class CloseFutureClient {\n    public static void main(String[] args) throws InterruptedException {\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture = new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override // 在连接建立后被调用\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                })\n                .connect(new InetSocketAddress("localhost", 8080));\n        Channel channel = channelFuture.sync().channel();\n        log.debug("{}", channel);\n        new Thread(()->{\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if ("q".equals(line)) {\n                    channel.close(); // close 异步操作 1s 之后\n//                    log.debug("处理关闭之后的操作"); // 不能在这里善后\n                    break;\n                }\n                channel.writeAndFlush(line);\n            }\n        }, "input").start();\n\n        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture = channel.closeFuture();\n        /*log.debug("waiting close...");\n        closeFuture.sync();\n        log.debug("处理关闭之后的操作");*/\n        closeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                log.debug("处理关闭之后的操作");\n                group.shutdownGracefully();\n            }\n        });\n    }\n}','java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug("set success, {}",10);\n    promise.setSuccess(10);\n});\n\nlog.debug("start...");\nlog.debug("{}",promise.getNow()); // 还没有结果\nlog.debug("{}",promise.get());',"11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10",'java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n// 设置回调，异步接收结果\npromise.addListener(future -> {\n    // 这里的 future 就是上面的 promise\n    log.debug("{}",future.getNow());\n});\n\n// 等待 1000 后设置成功结果\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug("set success, {}",10);\n    promise.setSuccess(10);\n});\n\nlog.debug("start...");',"11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10",'java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\n        DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n        eventExecutors.execute(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            RuntimeException e = new RuntimeException("error...");\n            log.debug("set failure, {}", e.toString());\n            promise.setFailure(e);\n        });\n\n        log.debug("start...");\n        log.debug("{}", promise.getNow());\n        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常','12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread "main" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)','java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException("error...");\n    log.debug("set failure, {}", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug("start...");\nlog.debug("{}", promise.getNow());\npromise.await(); // 与 sync 和 get 区别在于，不会抛异常\nlog.debug("result {}", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());',"12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...",'java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\npromise.addListener(future -> {\n    log.debug("result {}", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n});\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException("error...");\n    log.debug("set failure, {}", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug("start...");',"12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...",'java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.submit(()->{\n    System.out.println("1");\n    try {\n        promise.await();\n        // 注意不能仅捕获 InterruptedException 异常\n        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    } catch (Exception e) { \n        e.printStackTrace();\n    }\n    System.out.println("2");\n});\neventExecutors.submit(()->{\n    System.out.println("3");\n    try {\n        promise.await();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println("4");\n});',"1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)","java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); // 1\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); // 2\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(3);\n                    ctx.channel().write(msg); // 3\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(4);\n                    ctx.write(msg, promise); // 4\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(5);\n                    ctx.write(msg, promise); // 5\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(6);\n                    ctx.write(msg, promise); // 6\n                }\n            });\n        }\n    })\n    .bind(8080);",'java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect("127.0.0.1", 8080)\n    .addListener((ChannelFutureListener) future -> {\n        future.channel().writeAndFlush("hello,world");\n    });',"1\n2\n3\n6\n5\n4","java\nByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);","read index:0 write index:0 capacity:10",'java\nprivate static void log(ByteBuf buffer) {\n    int length = buffer.readableBytes();\n    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;\n    StringBuilder buf = new StringBuilder(rows * 80 * 2)\n        .append("read index:").append(buffer.readerIndex())\n        .append(" write index:").append(buffer.writerIndex())\n        .append(" capacity:").append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n}',"java\nByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);","java\nByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);","java\n-Dio.netty.allocator.type={unpooled|pooled}","java\nbuffer.writeBytes(new byte[]{1, 2, 3, 4});\nlog(buffer);","read index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+","java\nbuffer.writeInt(5);\nlog(buffer);","read index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+","java\nbuffer.writeInt(6);\nlog(buffer);","read index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+","java\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);","1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+","java\nbuffer.markReaderIndex();\nSystem.out.println(buffer.readInt());\nlog(buffer);","5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+","java\nbuffer.resetReaderIndex();\nlog(buffer);","read index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf buf = ...\ntry {\n    ...\n} finally {\n    buf.release();\n}",'java\n// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) {\n    try {\n        logger.debug(\n            "Discarded inbound message {} that reached at the tail of the pipeline. " +\n            "Please check your pipeline configuration.", msg);\n    } finally {\n        ReferenceCountUtil.release(msg);\n    }\n}',"java\n// io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) {\n    if (msg instanceof ReferenceCounted) {\n        return ((ReferenceCounted) msg).release();\n    }\n    return false;\n}","java\nByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]{1, 2, 3, 4});\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf slice = origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+","java\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+","java\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+","java\nslice.setByte(2, 5);\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+","System.out.println(ByteBufUtil.prettyHexDump(origin));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf buf3 = ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+","java\nCompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\n\n// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));","+-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+","java\nByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6});\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));","class io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+","java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response = ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    // 思考：需要释放 buffer 吗\n                    // 思考：需要释放 response 吗\n                }\n            });\n        }\n    }).bind(8080);",'java\nNioEventLoopGroup group = new NioEventLoopGroup();\nChannel channel = new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 思考：需要释放 buffer 吗\n                }\n            });\n        }\n    }).connect("127.0.0.1", 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -> {\n    group.shutdownGracefully();\n});\n\nnew Thread(() -> {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n        String line = scanner.nextLine();\n        if ("q".equals(line)) {\n            channel.close();\n            break;\n        }\n        channel.writeAndFlush(line);\n    }\n}).start();',"java\npublic class TestServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888);\n        Socket s = ss.accept();\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}",'java\npublic class TestClient {\n    public static void main(String[] args) throws IOException {\n        Socket s = new Socket("localhost", 8888);\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}']},{title:"Netty 进阶",headers:[{level:2,title:"1. 粘包与半包",slug:"_1-粘包与半包",link:"#_1-粘包与半包",children:[{level:3,title:"1.1 粘包现象",slug:"_1-1-粘包现象",link:"#_1-1-粘包现象",children:[]},{level:3,title:"1.2 半包现象",slug:"_1-2-半包现象",link:"#_1-2-半包现象",children:[]},{level:3,title:"1.3 现象分析",slug:"_1-3-现象分析",link:"#_1-3-现象分析",children:[]},{level:3,title:"1.4 解决方案",slug:"_1-4-解决方案",link:"#_1-4-解决方案",children:[]}]},{level:2,title:"2. 协议设计与解析",slug:"_2-协议设计与解析",link:"#_2-协议设计与解析",children:[{level:3,title:"2.1 为什么需要协议？",slug:"_2-1-为什么需要协议",link:"#_2-1-为什么需要协议",children:[]},{level:3,title:"2.2 redis 协议举例",slug:"_2-2-redis-协议举例",link:"#_2-2-redis-协议举例",children:[]},{level:3,title:"2.3 http 协议举例",slug:"_2-3-http-协议举例",link:"#_2-3-http-协议举例",children:[]},{level:3,title:"2.4 自定义协议要素",slug:"_2-4-自定义协议要素",link:"#_2-4-自定义协议要素",children:[]}]},{level:2,title:"3. 聊天室案例",slug:"_3-聊天室案例",link:"#_3-聊天室案例",children:[{level:3,title:"3.1 聊天室业务介绍",slug:"_3-1-聊天室业务介绍",link:"#_3-1-聊天室业务介绍",children:[]},{level:3,title:"3.2 聊天室业务-登录",slug:"_3-2-聊天室业务-登录",link:"#_3-2-聊天室业务-登录",children:[]},{level:3,title:"3.3 聊天室业务-单聊",slug:"_3-3-聊天室业务-单聊",link:"#_3-3-聊天室业务-单聊",children:[]},{level:3,title:"3.4 聊天室业务-群聊",slug:"_3-4-聊天室业务-群聊",link:"#_3-4-聊天室业务-群聊",children:[]},{level:3,title:"3.5 聊天室业务-退出",slug:"_3-5-聊天室业务-退出",link:"#_3-5-聊天室业务-退出",children:[]},{level:3,title:"3.6 聊天室业务-空闲检测",slug:"_3-6-聊天室业务-空闲检测",link:"#_3-6-聊天室业务-空闲检测",children:[]}]}],path:"/posts/java/netty/Netty03-%E8%BF%9B%E9%98%B6.html",pathLocale:"/",extraFields:['java\npublic class HelloWorldServer {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("connected {}", ctx.channel());\n                            super.channelActive(ctx);\n                        }\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("disconnect {}", ctx.channel());\n                            super.channelInactive(ctx);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = serverBootstrap.bind(8080);\n            log.debug("{} binding...", channelFuture.channel());\n            channelFuture.sync();\n            log.debug("{} bound...", channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug("stoped");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HelloWorldServer().start();\n    }\n}','java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            for (int i = 0; i < 10; i++) {\n                                ByteBuf buffer = ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                                ctx.writeAndFlush(buffer);\n                            }\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}',"08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE","java\nByteBuf buffer = ctx.alloc().buffer();\nfor (int i = 0; i < 10; i++) {\n    buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n}\nctx.writeAndFlush(buffer);","java\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);","08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE",'java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        // 分 10 次发送\n        for (int i = 0; i < 10; i++) {\n            send();\n        }\n    }\n\n    private static void send() {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("conneted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                            ctx.writeAndFlush(buffer);\n                            // 发完即关\n                            ctx.close();\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("localhost", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}',"java\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));",'java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            // 发送内容随机的数据包\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte[] bytes = new byte[8];\n                                for (int j = 0; j < r.nextInt(8); j++) {\n                                    bytes[j] = (byte) c;\n                                }\n                                c++;\n                                buffer.writeBytes(bytes);\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}',"12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH","12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE","java\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));",'java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                for (int j = 1; j <= r.nextInt(16)+1; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                buffer.writeByte(10);\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}',"14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH","14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE","java\n// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));",'java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug("connetted...");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug("sending...");\n                            Random r = new Random();\n                            char c = \'a\';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte length = (byte) (r.nextInt(16) + 1);\n                                // 先写入长度\n                                buffer.writeByte(length);\n                                // 再\n                                for (int j = 1; j <= length; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect("192.168.0.103", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error("client error", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}',"14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH","14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE","下雨天留客天留我不留","下雨天留客，天留，我不留","下雨天，留客天，留我不？留","定长字节表示内容长度 + 实际内容","0f下雨天留客06天留09我不留",'java\nNioEventLoopGroup worker = new NioEventLoopGroup();\nbyte[] LINE = {13, 10};\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                // 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) {\n                    set(ctx);\n                    get(ctx);\n                }\n                private void get(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes("*2".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("get".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("aaa".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n                private void set(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes("*3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("set".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("aaa".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("$3".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes("bbb".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    ByteBuf buf = (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                }\n            });\n        }\n    });\n    ChannelFuture channelFuture = bootstrap.connect("localhost", 6379).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error("client error", e);\n} finally {\n    worker.shutdownGracefully();\n}','java\nNioEventLoopGroup boss = new NioEventLoopGroup();\nNioEventLoopGroup worker = new NioEventLoopGroup();\ntry {\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {\n                    // 获取请求\n                    log.debug(msg.uri());\n\n                    // 返回响应\n                    DefaultFullHttpResponse response =\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes = "<h1>Hello, world!</h1>".getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                    response.content().writeBytes(bytes);\n\n                    // 写回响应\n                    ctx.writeAndFlush(response);\n                }\n            });\n            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    log.debug("{}", msg.getClass());\n\n                    if (msg instanceof HttpRequest) { // 请求行，请求头\n\n                    } else if (msg instanceof HttpContent) { //请求体\n\n                    }\n                }\n            });*/\n        }\n    });\n    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error("server error", e);\n} finally {\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n}','java\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec<Message> {\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug("{}", message);\n        out.add(message);\n    }\n}','java\nEmbeddedChannel channel = new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n// encode\nLoginRequestMessage message = new LoginRequestMessage("zhangsan", "123", "张三");\n//        channel.writeOutbound(message);\n// decode\nByteBuf buf = ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 = buf.slice(0, 100);\nByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); // 引用计数 2\nchannel.writeInbound(s1); // release 1\nchannel.writeInbound(s2);','java\n@Slf4j\n@ChannelHandler.Sharable\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug("{}", message);\n        out.add(message);\n    }\n}',"java\n/**\n * 用户管理接口\n */\npublic interface UserService {\n\n    /**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     */\n    boolean login(String username, String password);\n}","java\n/**\n * 会话管理接口\n */\npublic interface Session {\n\n    /**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     */\n    void bind(Channel channel, String username);\n\n    /**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     */\n    void unbind(Channel channel);\n\n    /**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     */\n    Object getAttribute(Channel channel, String name);\n\n    /**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     */\n    void setAttribute(Channel channel, String name, Object value);\n\n    /**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     */\n    Channel getChannel(String username);\n}","java\n/**\n * 聊天组会话管理接口\n */\npublic interface GroupSession {\n\n    /**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     */\n    Group createGroup(String name, Set<String> members);\n\n    /**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group joinMember(String name, String member);\n\n    /**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeMember(String name, String member);\n\n    /**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeGroup(String name);\n\n    /**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     */\n    Set<String> getMembers(String name);\n\n    /**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     */\n    List<Channel> getMembersChannel(String name);\n}",'java\n@Slf4j\npublic class ChatServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n                            String username = msg.getUsername();\n                            String password = msg.getPassword();\n                            boolean login = UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) {\n                                message = new LoginResponseMessage(true, "登录成功");\n                            } else {\n                                message = new LoginResponseMessage(false, "用户名或密码不正确");\n                            }\n                            ctx.writeAndFlush(message);\n                        }\n                    });\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}','java\n@Slf4j\npublic class ChatClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);\n        AtomicBoolean LOGIN = new AtomicBoolean(false);\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n//                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast("client handler", new ChannelInboundHandlerAdapter() {\n                        // 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                            log.debug("msg: {}", msg);\n                            if ((msg instanceof LoginResponseMessage)) {\n                                LoginResponseMessage response = (LoginResponseMessage) msg;\n                                if (response.isSuccess()) {\n                                    // 如果登录成功\n                                    LOGIN.set(true);\n                                }\n                                // 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            }\n                        }\n\n                        // 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -> {\n                                Scanner scanner = new Scanner(System.in);\n                                System.out.println("请输入用户名:");\n                                String username = scanner.nextLine();\n                                System.out.println("请输入密码:");\n                                String password = scanner.nextLine();\n                                // 构造消息对象\n                                LoginRequestMessage message = new LoginRequestMessage(username, password);\n                                // 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println("等待后续操作...");\n                                try {\n                                    WAIT_FOR_LOGIN.await();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                                // 如果登录失败\n                                if (!LOGIN.get()) {\n                                    ctx.channel().close();\n                                    return;\n                                }\n                                while (true) {\n                                    System.out.println("==================================");\n                                    System.out.println("send [username] [content]");\n                                    System.out.println("gsend [group name] [content]");\n                                    System.out.println("gcreate [group name] [m1,m2,m3...]");\n                                    System.out.println("gmembers [group name]");\n                                    System.out.println("gjoin [group name]");\n                                    System.out.println("gquit [group name]");\n                                    System.out.println("quit");\n                                    System.out.println("==================================");\n                                    String command = scanner.nextLine();\n                                    String[] s = command.split(" ");\n                                    switch (s[0]){\n                                        case "send":\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case "gsend":\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case "gcreate":\n                                            Set<String> set = new HashSet<>(Arrays.asList(s[2].split(",")));\n                                            set.add(username); // 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case "gmembers":\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case "gjoin":\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case "gquit":\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case "quit":\n                                            ctx.channel().close();\n                                            return;\n                                    }\n                                }\n                            }, "system in").start();\n                        }\n                    });\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}','java\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n        String username = msg.getUsername();\n        String password = msg.getPassword();\n        boolean login = UserServiceFactory.getUserService().login(username, password);\n        LoginResponseMessage message;\n        if(login) {\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message = new LoginResponseMessage(true, "登录成功");\n        } else {\n            message = new LoginResponseMessage(false, "用户名或密码不正确");\n        }\n        ctx.writeAndFlush(message);\n    }\n}','java\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception {\n        String to = msg.getTo();\n        Channel channel = SessionFactory.getSession().getChannel(to);\n        // 在线\n        if(channel != null) {\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n        // 不在线\n        else {\n            ctx.writeAndFlush(new ChatResponseMessage(false, "对方用户不存在或者不在线"));\n        }\n    }\n}','java\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception {\n        String groupName = msg.getGroupName();\n        Set<String> members = msg.getMembers();\n        // 群管理器\n        GroupSession groupSession = GroupSessionFactory.getGroupSession();\n        Group group = groupSession.createGroup(groupName, members);\n        if (group == null) {\n            // 发生成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + "创建成功"));\n            // 发送拉群消息\n            List<Channel> channels = groupSession.getMembersChannel(groupName);\n            for (Channel channel : channels) {\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, "您已被拉入" + groupName));\n            }\n        } else {\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + "已经存在"));\n        }\n    }\n}',"java\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception {\n        List<Channel> channels = GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n    }\n}",'java\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群加入成功"));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群不存在"));\n        }\n    }\n}','java\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, "已退出群" + msg.getGroupName()));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + "群不存在"));\n        }\n    }\n}',"java\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception {\n        Set<String> members = GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    }\n}",'@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter {\n\n    // 当连接断开时触发 inactive 事件\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug("{} 已经断开", ctx.channel());\n    }\n\n\t// 当出现异常时触发\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug("{} 已经异常断开 异常是{}", ctx.channel(), cause.getMessage());\n    }\n}','java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了读空闲事件\n        if (event.state() == IdleState.READER_IDLE) {\n            log.debug("已经 5s 没有读到数据了");\n            ctx.channel().close();\n        }\n    }\n});','java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了写空闲事件\n        if (event.state() == IdleState.WRITER_IDLE) {\n            //                                log.debug("3s 没有写数据了，发送一个心跳包");\n            ctx.writeAndFlush(new PingMessage());\n        }\n    }\n});']},{title:"优化与源码",headers:[{level:2,title:"1. 优化",slug:"_1-优化",link:"#_1-优化",children:[{level:3,title:"1.1 扩展序列化算法",slug:"_1-1-扩展序列化算法",link:"#_1-1-扩展序列化算法",children:[]},{level:3,title:"1.2 参数调优",slug:"_1-2-参数调优",link:"#_1-2-参数调优",children:[]},{level:3,title:"1.3 RPC 框架",slug:"_1-3-rpc-框架",link:"#_1-3-rpc-框架",children:[]}]},{level:2,title:"2. 源码分析",slug:"_2-源码分析",link:"#_2-源码分析",children:[{level:3,title:"2.1 启动剖析",slug:"_2-1-启动剖析",link:"#_2-1-启动剖析",children:[]},{level:3,title:"2.2 NioEventLoop 剖析",slug:"_2-2-nioeventloop-剖析",link:"#_2-2-nioeventloop-剖析",children:[]},{level:3,title:"2.3 accept 剖析",slug:"_2-3-accept-剖析",link:"#_2-3-accept-剖析",children:[]},{level:3,title:"2.4 read 剖析",slug:"_2-4-read-剖析",link:"#_2-4-read-剖析",children:[]}]}],path:"/posts/java/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html",pathLocale:"/",extraFields:["java\n// 反序列化\nbyte[] body = new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message = (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n// 序列化\nByteArrayOutputStream out = new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes = out.toByteArray();","java\npublic interface Serializer {\n\n    // 反序列化方法\n    <T> T deserialize(Class<T> clazz, byte[] bytes);\n\n    // 序列化方法\n    <T> byte[] serialize(T object);\n\n}",'java\nenum SerializerAlgorithm implements Serializer {\n\t// Java 实现\n    Java {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            try {\n                ObjectInputStream in = \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object = in.readObject();\n                return (T) object;\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException("SerializerAlgorithm.Java 反序列化错误", e);\n            }\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            try {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            } catch (IOException e) {\n                throw new RuntimeException("SerializerAlgorithm.Java 序列化错误", e);\n            }\n        }\n    }, \n    // Json 实现(引入了 Gson 依赖)\n    Json {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);\n        }\n    };\n\n    // 需要从协议的字节中得到是哪种序列化算法\n    public static SerializerAlgorithm getByInt(int type) {\n        SerializerAlgorithm[] array = SerializerAlgorithm.values();\n        if (type < 0 || type > array.length - 1) {\n            throw new IllegalArgumentException("超过 SerializerAlgorithm 范围");\n        }\n        return array[type];\n    }\n}','java\npublic abstract class Config {\n    static Properties properties;\n    static {\n        try (InputStream in = Config.class.getResourceAsStream("/application.properties")) {\n            properties = new Properties();\n            properties.load(in);\n        } catch (IOException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    public static int getServerPort() {\n        String value = properties.getProperty("server.port");\n        if(value == null) {\n            return 8080;\n        } else {\n            return Integer.parseInt(value);\n        }\n    }\n    public static Serializer.Algorithm getSerializerAlgorithm() {\n        String value = properties.getProperty("serializer.algorithm");\n        if(value == null) {\n            return Serializer.Algorithm.Java;\n        } else {\n            return Serializer.Algorithm.valueOf(value);\n        }\n    }\n}',"properties\nserializer.algorithm=Json",'java\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerAlgorithm = in.readByte(); // 0 或 1\n        byte messageType = in.readByte(); // 0,1,2...\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n\n        // 找到反序列化算法\n        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];\n        // 确定具体消息类型\n        Class<? extends Message> messageClass = Message.getMessageClass(messageType);\n        Message message = algorithm.deserialize(messageClass, bytes);\n//        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);\n//        log.debug("{}", message);\n        out.add(message);\n    }\n}',"java\n@Data\npublic abstract class Message implements Serializable {\n\n    /**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     */\n    public static Class<? extends Message> getMessageClass(int messageType) {\n        return messageClasses.get(messageType);\n    }\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage = 0;\n    public static final int LoginResponseMessage = 1;\n    public static final int ChatRequestMessage = 2;\n    public static final int ChatResponseMessage = 3;\n    public static final int GroupCreateRequestMessage = 4;\n    public static final int GroupCreateResponseMessage = 5;\n    public static final int GroupJoinRequestMessage = 6;\n    public static final int GroupJoinResponseMessage = 7;\n    public static final int GroupQuitRequestMessage = 8;\n    public static final int GroupQuitResponseMessage = 9;\n    public static final int GroupChatRequestMessage = 10;\n    public static final int GroupChatResponseMessage = 11;\n    public static final int GroupMembersRequestMessage = 12;\n    public static final int GroupMembersResponseMessage = 13;\n    public static final int PingMessage = 14;\n    public static final int PongMessage = 15;\n    private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>();\n\n    static {\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    }\n}",'java\n@Slf4j\npublic class TestConnectionTimeout {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future = bootstrap.connect("127.0.0.1", 8080);\n            future.sync().channel().closeFuture().sync(); // 断点1\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.debug("timeout");\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}','java\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    // Schedule connect timeout.\n    int connectTimeoutMillis = config().getConnectTimeoutMillis();\n    if (connectTimeoutMillis > 0) {\n        connectTimeoutFuture = eventLoop().schedule(new Runnable() {\n            @Override\n            public void run() {                \n                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause =\n                    new ConnectTimeoutException("connection timed out: " + remoteAddress); // 断点2\n                if (connectPromise != null && connectPromise.tryFailure(cause)) {\n                    close(voidPromise());\n                }\n            }\n        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\t// ...\n}',"mermaid\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as syns queue\nparticipant aq as accept queue\n\ns ->> s : bind()\ns ->> s : listen()\nc ->> c : connect()\nc ->> s : 1. SYN\nNote left of c : SYN_SEND\ns ->> sq : put\nNote right of s : SYN_RCVD\ns ->> c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc ->> s : 3. ACK\nsq ->> aq : put\nNote right of s : ESTABLISHED\naq --\x3e> s : \ns ->> s : accept()","java\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig {\n\n    private volatile int backlog = NetUtil.SOMAXCONN;\n    // ...\n}","java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888, 2);\n        Socket accept = ss.accept();\n        System.out.println(accept);\n        System.in.read();\n    }\n}",'java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        try {\n            Socket s = new Socket();\n            System.out.println(new Date()+" connecting...");\n            s.connect(new InetSocketAddress("localhost", 8888),1000);\n            System.out.println(new Date()+" connected...");\n            s.getOutputStream().write(1);\n            System.in.read();\n        } catch (IOException e) {\n            System.out.println(new Date()+" connecting timeout...");\n            e.printStackTrace();\n        }\n    }\n}',"java\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...","Tue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out","java\n@Data\npublic abstract class Message implements Serializable {\n\n    // 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;\n\n    static {\n        // ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    }\n\n}","java\n@Getter\n@ToString(callSuper = true)\npublic class RpcRequestMessage extends Message {\n\n    /**\n     * 调用的接口全限定名，服务端根据它找到实现\n     */\n    private String interfaceName;\n    /**\n     * 调用接口中的方法名\n     */\n    private String methodName;\n    /**\n     * 方法返回类型\n     */\n    private Class<?> returnType;\n    /**\n     * 方法参数类型数组\n     */\n    private Class[] parameterTypes;\n    /**\n     * 方法参数值数组\n     */\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) {\n        super.setSequenceId(sequenceId);\n        this.interfaceName = interfaceName;\n        this.methodName = methodName;\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.parameterValue = parameterValue;\n    }\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_REQUEST;\n    }\n}","java\n@Data\n@ToString(callSuper = true)\npublic class RpcResponseMessage extends Message {\n    /**\n     * 返回值\n     */\n    private Object returnValue;\n    /**\n     * 异常值\n     */\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    }\n}",'java\n@Slf4j\npublic class RpcServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error("server error", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}','java\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}','java\npublic class ServicesFactory {\n\n    static Properties properties;\n    static Map<Class<?>, Object> map = new ConcurrentHashMap<>();\n\n    static {\n        try (InputStream in = Config.class.getResourceAsStream("/application.properties")) {\n            properties = new Properties();\n            properties.load(in);\n            Set<String> names = properties.stringPropertyNames();\n            for (String name : names) {\n                if (name.endsWith("Service")) {\n                    Class<?> interfaceClass = Class.forName(name);\n                    Class<?> instanceClass = Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                }\n            }\n        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    public static <T> T getService(Class<T> interfaceClass) {\n        return (T) map.get(interfaceClass);\n    }\n}',"serializer.algorithm=Json\ncn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl","java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> {\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) {\n        RpcResponseMessage response = new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());\n        try {\n            // 获取真正的实现对象\n            HelloService service = (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            // 获取要调用的方法\n            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            // 调用方法\n            Object invoke = method.invoke(service, message.getParameterValue());\n            // 调用成功\n            response.setReturnValue(invoke);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 调用异常\n            response.setExceptionValue(e);\n        }\n        // 返回结果\n        ctx.writeAndFlush(response);\n    }\n}",'java\n@Slf4j\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect("localhost", 8080).sync().channel();\n\n            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    "cn.itcast.server.service.HelloService",\n                    "sayHello",\n                    String.class,\n                    new Class[]{String.class},\n                    new Object[]{"张三"}\n            )).addListener(promise -> {\n                if (!promise.isSuccess()) {\n                    Throwable cause = promise.cause();\n                    log.error("error", cause);\n                }\n            });\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error("client error", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}','java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug("{}", msg);\n    }\n}','java\n@Slf4j\npublic class RpcClientManager {\n\n\n    public static void main(String[] args) {\n        HelloService service = getProxyService(HelloService.class);\n        System.out.println(service.sayHello("zhangsan"));\n//        System.out.println(service.sayHello("lisi"));\n//        System.out.println(service.sayHello("wangwu"));\n    }\n\n    // 创建代理类\n    public static <T> T getProxyService(Class<T> serviceClass) {\n        ClassLoader loader = serviceClass.getClassLoader();\n        Class<?>[] interfaces = new Class[]{serviceClass};\n        //                                                            sayHello  "张三"\n        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> {\n            // 1. 将方法调用转换为 消息对象\n            int sequenceId = SequenceIdGenerator.nextId();\n            RpcRequestMessage msg = new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            // 2. 将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程\n            DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop());\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n//            promise.addListener(future -> {\n//                // 线程\n//            });\n\n            // 4. 等待 promise 结果\n            promise.await();\n            if(promise.isSuccess()) {\n                // 调用正常\n                return promise.getNow();\n            } else {\n                // 调用失败\n                throw new RuntimeException(promise.cause());\n            }\n        });\n        return (T) o;\n    }\n\n    private static Channel channel = null;\n    private static final Object LOCK = new Object();\n\n    // 获取唯一的 channel 对象\n    public static Channel getChannel() {\n        if (channel != null) {\n            return channel;\n        }\n        synchronized (LOCK) { //  t2\n            if (channel != null) { // t1\n                return channel;\n            }\n            initChannel();\n            return channel;\n        }\n    }\n\n    // 初始化 channel 方法\n    private static void initChannel() {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            }\n        });\n        try {\n            channel = bootstrap.connect("localhost", 8080).sync().channel();\n            channel.closeFuture().addListener(future -> {\n                group.shutdownGracefully();\n            });\n        } catch (Exception e) {\n            log.error("client error", e);\n        }\n    }\n}','java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n\n    //                       序号      用来接收结果的 promise 对象\n    public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug("{}", msg);\n        // 拿到空的 promise\n        Promise<Object> promise = PROMISES.remove(msg.getSequenceId());\n        if (promise != null) {\n            Object returnValue = msg.getReturnValue();\n            Exception exceptionValue = msg.getExceptionValue();\n            if(exceptionValue != null) {\n                promise.setFailure(exceptionValue);\n            } else {\n                promise.setSuccess(returnValue);\n            }\n        }\n    }\n}',"java\n//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector = Selector.open(); \n\n//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment = new NioServerSocketChannel();\n\n//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n//4 启动 nio boss 线程执行接下来的操作\n\n//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);\n\n//6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor\n\n//7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n//8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);","java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n\t// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) {\n        return regFuture;\n    }\n\n    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    // 2.1 如果已经完成\n    if (regFuture.isDone()) {\n        ChannelPromise promise = channel.newPromise();\n        // 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    } \n    // 2.2 还没有完成\n    else {\n        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n        // 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                Throwable cause = future.cause();\n                if (cause != null) {\n                    // 处理异常...\n                    promise.setFailure(cause);\n                } else {\n                    promise.registered();\n\t\t\t\t\t// 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                }\n            }\n        });\n        return promise;\n    }\n}","java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    try {\n        channel = channelFactory.newChannel();\n        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    } catch (Throwable t) {\n        // 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    }\n\n    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) {\n        // 处理异常...\n    }\n    return regFuture;\n}",'java\n// 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception {\n    final Map<ChannelOption<?>, Object> options = options0();\n    synchronized (options) {\n        setChannelOptions(channel, options, logger);\n    }\n\n    final Map<AttributeKey<?>, Object> attrs = attrs0();\n    synchronized (attrs) {\n        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n            @SuppressWarnings("unchecked")\n            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n            channel.attr(key).set(e.getValue());\n        }\n    }\n\n    ChannelPipeline p = channel.pipeline();\n\n    final EventLoopGroup currentChildGroup = childGroup;\n    final ChannelHandler currentChildHandler = childHandler;\n    final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n    synchronized (childOptions) {\n        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));\n    }\n    synchronized (childAttrs) {\n        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));\n    }\n\t\n    // 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer<Channel>() {\n        @Override\n        public void initChannel(final Channel ch) throws Exception {\n            final ChannelPipeline pipeline = ch.pipeline();\n            ChannelHandler handler = config.handler();\n            if (handler != null) {\n                pipeline.addLast(handler);\n            }\n\n            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() {\n                @Override\n                public void run() {\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                }\n            });\n        }\n    });\n}',"java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行\n            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            // 这行代码完成的事实是 main -> nio boss 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}","java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\n        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        // 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) {\n            if (firstRegistration) {\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        // Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}","java\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n    if (initMap.add(ctx)) { // Guard against re-entrance.\n        try {\n            // 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        } catch (Throwable cause) {\n            exceptionCaught(ctx, cause);\n        } finally {\n            // 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline = ctx.pipeline();\n            if (pipeline.context(this) != null) {\n                pipeline.remove(this);\n            }\n        }\n        return true;\n    }\n    return false;\n}","java\n// 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) {\n\n    channel.eventLoop().execute(new Runnable() {\n        @Override\n        public void run() {\n            if (regFuture.isSuccess()) {\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                promise.setFailure(regFuture.cause());\n            }\n        }\n    });\n}","java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) {\n        return;\n    }\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&\n        localAddress instanceof InetSocketAddress &&\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&\n        !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {\n        // 记录日志...\n    }\n\n    boolean wasActive = isActive();\n    try {\n        // 3.3 执行端口绑定\n        doBind(localAddress);\n    } catch (Throwable t) {\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    }\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // 3.4 触发 active 事件\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n\n    safeSetSuccess(promise);\n}","java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}","java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();\n}","java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps & readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}",'java\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException("task");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) {\n        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) {\n            // 如果已经 shutdown，做拒绝逻辑，代码略...\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    }\n}',"java\n@Override\nprotected void wakeup(boolean inEventLoop) {\n    if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n        selector.wakeup();\n    }\n}",'java\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            // 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn("Unexpected exception from an event executor: ", t);\n            } finally {\n\t\t\t\t// 清理工作，代码略...\n            }\n        }\n    });\n}',"java\nprotected void run() {\n    for (;;) {\n        try {\n            try {\n                // calculateStrategy 的逻辑如下：\n                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        // 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp = wakenUp.getAndSet(false);\n                        \n                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        // 下面的 select 方法不会阻塞\n                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        // 才能执行，让 select 方法无谓阻塞\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                }\n            } catch (IOException e) {\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // ioRatio 默认是 50\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // ioRatio 为 100 时，总是运行完所有非 IO 任务\n                    runAllTasks();\n                }\n            } else {                \n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // 记录 io 事件处理耗时\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    // 运行非 IO 任务，一旦超时会退出 runAllTasks\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}","java\nprivate void select(boolean oldWakenUp) throws IOException {\n    Selector selector = this.selector;\n    try {\n        int selectCnt = 0;\n        long currentTimeNanos = System.nanoTime();\n        // 计算等待时间\n        // * 没有 scheduledTask，超时时间为 1s\n        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`\n        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) {\n            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;\n            // 如果超时，退出循环\n            if (timeoutMillis <= 0) {\n                if (selectCnt == 0) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                }\n                break;\n            }\n\n            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                selector.selectNow();\n                selectCnt = 1;\n                break;\n            }\n\n            // select 有限时阻塞\n            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%\n            int selectedKeys = selector.select(timeoutMillis);\n            // 计数加 1\n            selectCnt ++;\n\n            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环\n            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                break;\n            }\n            if (Thread.interrupted()) {\n               \t// 线程被打断，退出循环\n                // 记录日志\n                selectCnt = 1;\n                break;\n            }\n\n            long time = System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                // 如果超时，计数重置为 1，下次循环就会 break\n                selectCnt = 1;\n            } \n            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            // 这是为了解决 nio 空轮询 bug\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {\n                // 重建 selector\n                selector = selectRebuildSelector(selectCnt);\n                selectCnt = 1;\n                break;\n            }\n\n            currentTimeNanos = time;\n        }\n\n        if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) {\n            // 记录日志\n        }\n    } catch (CancelledKeyException e) {\n        // 记录日志\n    }\n}","java\nprivate void processSelectedKeys() {\n    if (selectedKeys != null) {\n        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();\n    } else {\n        processSelectedKeysPlain(selector.selectedKeys());\n    }\n}","java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n    // 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) {\n        // 无效时处理...\n        return;\n    }\n\n    try {\n        int readyOps = k.readyOps();\n        // 连接事件\n        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n            int ops = k.interestOps();\n            ops &= ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        }\n\n        // 可写事件\n        if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n            ch.unsafe().forceFlush();\n        }\n\n        // 可读或可接入事件\n        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();\n        }\n    } catch (CancelledKeyException ignored) {\n        unsafe.close(unsafe.voidPromise());\n    }\n}","java\n//1 阻塞直到事件发生\nselector.select();\n\nIterator<SelectionKey> iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) {    \n    //2 拿到一个事件\n    SelectionKey key = iter.next();\n    \n    //3 如果是 accept 事件\n    if (key.isAcceptable()) {\n        \n        //4 执行 accept\n        SocketChannel channel = serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        //5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n    // ...\n}","java\npublic void read() {\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config = config();\n    final ChannelPipeline pipeline = pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed = false;\n    Throwable exception = null;\n    try {\n        try {\n            do {\n\t\t\t\t// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf\n                // readBuf 是一个 ArrayList 用来缓存消息\n                int localRead = doReadMessages(readBuf);\n                if (localRead == 0) {\n                    break;\n                }\n                if (localRead < 0) {\n                    closed = true;\n                    break;\n                }\n\t\t\t\t// localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            } while (allocHandle.continueReading());\n        } catch (Throwable t) {\n            exception = t;\n        }\n\n        int size = readBuf.size();\n        for (int i = 0; i < size; i ++) {\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        }\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception != null) {\n            closed = closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        }\n\n        if (closed) {\n            inputShutdown = true;\n            if (isOpen()) {\n                close(voidPromise());\n            }\n        }\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}","java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // 这时的 msg 是 NioSocketChannel\n    final Channel child = (Channel) msg;\n\n    // NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    // 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n        child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n    }\n\n    try {\n        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}","java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 这行代码完成的事实是 nio boss -> nio worker 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}","java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\t\t\n        // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        // 执行后就是 head -> logging handler -> my handler -> tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) {\n            if (firstRegistration) {\n                // 触发 pipeline 上 active 事件\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}","java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n}","java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\t// 这时候 interestOps 是 0\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps & readInterestOp) == 0) {\n        // 关注 read 事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}","java\npublic final void read() {\n    final ChannelConfig config = config();\n    if (shouldBreakReadReady(config)) {\n        clearReadPending();\n        return;\n    }\n    final ChannelPipeline pipeline = pipeline();\n    // io.netty.allocator.type 决定 allocator 的实现\n    final ByteBufAllocator allocator = config.getAllocator();\n    // 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            // 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() <= 0) {\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() < 0;\n                if (close) {\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } \n        // 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        // 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}","java\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {\n    return \n           // 一般为 true\n           config.isAutoRead() &&\n           // respectMaybeMoreData 默认为 true\n           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&\n           // 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages < maxMessagePerRead &&\n           // 实际读到了数据\n           totalBytesRead > 0;\n}"]},{title:"spring 学习笔记",headers:[{level:2,title:"1.javaWeb的弊端",slug:"_1-javaweb的弊端",link:"#_1-javaweb的弊端",children:[]},{level:2,title:"2.IOC思想",slug:"_2-ioc思想",link:"#_2-ioc思想",children:[]},{level:2,title:"3.DI思想",slug:"_3-di思想",link:"#_3-di思想",children:[]},{level:2,title:"4.AOP 思想",slug:"_4-aop-思想",link:"#_4-aop-思想",children:[]},{level:2,title:"5.spring框架的诞生",slug:"_5-spring框架的诞生",link:"#_5-spring框架的诞生",children:[{level:3,title:"5.1.ApplicationContext快速入门",slug:"_5-1-applicationcontext快速入门",link:"#_5-1-applicationcontext快速入门",children:[]},{level:3,title:"5.2.BeanFactory与ApplicationContext的关系",slug:"_5-2-beanfactory与applicationcontext的关系",link:"#_5-2-beanfactory与applicationcontext的关系",children:[]}]},{level:2,title:"6.spring的配置详解",slug:"_6-spring的配置详解",link:"#_6-spring的配置详解",children:[{level:3,title:"6.1.Bean的基础配置",slug:"_6-1-bean的基础配置",link:"#_6-1-bean的基础配置",children:[]}]},{level:2,title:"web层解决方案-SpringMVC",slug:"web层解决方案-springmvc",link:"#web层解决方案-springmvc",children:[]}],path:"/posts/java/spring/spring.html",pathLocale:"/",extraFields:["text\n程序 -> BeanFactory -> 配置文件 -> UserServiceImpl 和 UserDaoImpl",'java\npublic static void main(String[]args){\n    BeanFactory beanFactory = new BeanFactory("beans.xml");//获取配置文件\n    UserServie userService = (UserService)beanFactory.getBean("userService");//获取userService的对象实例    \n}','xml\n\x3c!-- UserService配置 --\x3e\n<bean id="userService" class="com.study.UserServiceImpl"></bean>\n\x3c!-- UserDao配置 --\x3e\n<bean id="userDao" class="com.study.UserDaoImpl"></bean>','java\npublic static void main(String[]args){\n        //获取配置文件,创建工厂\n        BeanFactory beanFactory = new BeanFactory("beans.xml");\n        //获取userService的实例对象\n        UserServie userService = (UserService)beanFactory.getBean("userService");\n        //获得UserDao实例对象\n        UserDao userDao = (UserDao)beanFactroy.getBean("userDao");\n        //将UserDao设置给UserService\n        userService.setUserDao(userDao);\n}','xml\n\x3c!-- UserDao配置 --\x3e\n<bean id="userDao" class="com.study.UserDaoImpl"></bean>\n\x3c!-- UserService配置 --\x3e\n<bean id="userService" class="com.study.UserServiceImpl">\n    <property name="userDao" ref="userDao"></property>\n</bean>','java\n//创建ApplicationContext,加载配置文件，实例化容器\nApplicationContext applicationContext = new ClassPathxmlApplicationContext(“applicationContext.xml");\n//根据beanName获得容器中的Bean实例\nUserService userService = (UserService) applicationContext.getBean("userService");\nSystem.out.println(userService);','xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>','java\napplicationContext.getBean("userDao");','java\napplicationContext.getBean("com.itheima.dao.impl.UserDaoImpl");','xml\n<bean id="userDao" name="aaa,bbb" class="com.itheima.dao.impl.UserDaoImpl"/>','java\napplicationContext.getBean("userDao");\napplicationContext.getBean("aaa");\napplicationContext.getBean("bbb");','xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" scope="singleton"/>','java\nObject userDao = applicationContext.getBean("userDao");\nObject userDao2 = applicationContext.getBean("userDao");\nSystem.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@631330c\nSystem.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@631330c','xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" scope="prototype"/>','java\nObject userDao = applicationContext.getBean("userDao");\nObject userDao2 = applicationContext.getBean("userDao");\nSystem.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@4d50efb8\nSystem.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@7e2d773b','xml\n<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl" lazy-init="true"/>']},{title:"spring面试题",headers:[{level:2,title:"IoC 和 DI 的关系？",slug:"ioc-和-di-的关系",link:"#ioc-和-di-的关系",children:[]}],path:"/posts/java/spring/spring%E9%9D%A2%E8%AF%95%E9%A2%98.html",pathLocale:"/",extraFields:[]},{title:"springboot 工作中遇到的问题",headers:[{level:2,title:"pringboot的yml文件没有小叶子",slug:"pringboot的yml文件没有小叶子",link:"#pringboot的yml文件没有小叶子",children:[]},{level:2,title:"Failed to configure a DataSource: ‘url‘ attribute is not specified and no embedded datasource",slug:"failed-to-configure-a-datasource-url-attribute-is-not-specified-and-no-embedded-datasource",link:"#failed-to-configure-a-datasource-url-attribute-is-not-specified-and-no-embedded-datasource",children:[{level:3,title:"解决一：项目不需要连数据库",slug:"解决一-项目不需要连数据库",link:"#解决一-项目不需要连数据库",children:[]},{level:3,title:"解决二：项目需要连接数据库",slug:"解决二-项目需要连接数据库",link:"#解决二-项目需要连接数据库",children:[]},{level:3,title:"解决三：mysql版本问题",slug:"解决三-mysql版本问题",link:"#解决三-mysql版本问题",children:[]},{level:3,title:"解决四：项目没有加载到yml或者properties文件",slug:"解决四-项目没有加载到yml或者properties文件",link:"#解决四-项目没有加载到yml或者properties文件",children:[]},{level:3,title:"解决五：项目使用了springcloud+nacos系列",slug:"解决五-项目使用了springcloud-nacos系列",link:"#解决五-项目使用了springcloud-nacos系列",children:[]},{level:3,title:"test类dao层注册失败",slug:"test类dao层注册失败",link:"#test类dao层注册失败",children:[]},{level:3,title:"mybatis debug log startup",slug:"mybatis-debug-log-startup",link:"#mybatis-debug-log-startup",children:[]},{level:3,title:"@Autowired 和 @Resources 的区别",slug:"autowired-和-resources-的区别",link:"#autowired-和-resources-的区别",children:[]},{level:3,title:"logback 的使用",slug:"logback-的使用",link:"#logback-的使用",children:[]},{level:3,title:"logback-spring 这个只需要 引入lombok的依赖，@Slf4j的注解就能使用",slug:"logback-spring-这个只需要-引入lombok的依赖-slf4j的注解就能使用",link:"#logback-spring-这个只需要-引入lombok的依赖-slf4j的注解就能使用",children:[]},{level:3,title:"springboot 启动后 立即执行",slug:"springboot-启动后-立即执行",link:"#springboot-启动后-立即执行",children:[]}]},{level:2,title:"注解 @ConditionalOnProperty",slug:"注解-conditionalonproperty",link:"#注解-conditionalonproperty",children:[]},{level:2,title:"springboot jar端口号指定失效",slug:"springboot-jar端口号指定失效",link:"#springboot-jar端口号指定失效",children:[]},{level:2,title:"@ConfigurationProperties 注解",slug:"configurationproperties-注解",link:"#configurationproperties-注解",children:[{level:3,title:"前言",slug:"前言",link:"#前言",children:[]},{level:3,title:"概述",slug:"概述",link:"#概述",children:[]},{level:3,title:"源码解析",slug:"源码解析",link:"#源码解析",children:[]},{level:3,title:"案例分析",slug:"案例分析",link:"#案例分析",children:[]},{level:3,title:"使用DatabaseProperties",slug:"使用databaseproperties",link:"#使用databaseproperties",children:[]},{level:3,title:"应用场景案例",slug:"应用场景案例",link:"#应用场景案例",children:[]},{level:3,title:"核心类方法介绍",slug:"核心类方法介绍",link:"#核心类方法介绍",children:[]},{level:3,title:"测试用例",slug:"测试用例",link:"#测试用例",children:[]},{level:3,title:"ConfigPropertiesDemo类",slug:"configpropertiesdemo类",link:"#configpropertiesdemo类",children:[]},{level:3,title:"ConfigApp类",slug:"configapp类",link:"#configapp类",children:[]},{level:3,title:"DatabaseProperties类",slug:"databaseproperties类",link:"#databaseproperties类",children:[]},{level:3,title:"注意事项",slug:"注意事项",link:"#注意事项",children:[]},{level:3,title:"扩展",slug:"扩展",link:"#扩展",children:[]},{level:3,title:"小结",slug:"小结",link:"#小结",children:[]},{level:3,title:"总结",slug:"总结",link:"#总结",children:[]}]}],path:"/posts/java/springboot/workcondition.html",pathLocale:"/",extraFields:["shell\n***************************\nAPPLICATION FAILED TO START\n***************************\n \nDescription:\n \nFailed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.\n \nReason: Failed to determine a suitable driver class\n \n \nAction:\n \nConsider the following:\n    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).","shell\n@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})","shell\n#在application.properties/或者application.yml文件中没有添加数据库配置信息.\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF-8&useSSL=false\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.jdbc.Driver","<packaging>jar</packaging>","xml\n\x3c!--build放在</dependencies>标签的后面，主要加入的是resources标签 --\x3e\n\x3c!--resources标签可以告诉系统启动的时候能够读取到这些后缀的文件 --\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.yml</include>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.yml</include>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>lib</directory>\n            <includes>\n                <include>**/*.jar</include>\n            </includes>\n        </resource>\n    </resources>\n</build>","shell\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = '启动类'.class)","shell\n#在properties 文件中添加\nlogging.level.com.example.datatransport.dao=debug","shell\n@Autowired\n来源：@Autowired 是Spring框架提供的注解。\n工作方式：默认情况下，@Autowired 按照类型（byType）来装配。如果存在多个相同类型的bean，那么Spring会抛出异常，除非其中一个被标记为首选（使用@Primary注解）或通过@Qualifier指定具体的bean名称。\n使用场景：适用于需要根据类型匹配bean的情况，当有多个相同类型的bean时，可以结合@Qualifier使用以精确指定要装配的bean。\n@Resource\n来源：@Resource 是Java标准的一部分，由JSR-250规范定义，因此它不仅可以在Spring环境中使用，也可以在其他支持该规范的容器中使用。\n工作方式：默认情况下，@Resource 按照名称（byName）来装配。如果指定了名称，则会按照该名称查找bean；如果没有指定名称，那么会使用字段名作为默认名称来查找bean。如果找不到相应名称的bean，那么会退回到按类型装配。\n使用场景：适用于需要根据名称匹配bean的情况，或者希望代码更加独立于特定框架（如Spring），因为它是一个Java标准注解。\n总结\n如果你的项目严格遵循Spring框架，且主要关注类型安全，那么@Autowired可能是一个更好的选择。\n如果你需要跨不同Java容器的兼容性，或者更倾向于基于名称的装配，那么@Resource可能更适合你。\n在实际开发中，选择哪个注解取决于项目的具体需求和个人偏好。不过，通常推荐在一个项目中保持一致性，避免混合使用不同的注解风格，以减少潜在的混淆和维护成本。","shell\n \x3c!-- Logback Core --\x3e\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>1.2.11</version> \x3c!-- 选择合适的版本 --\x3e\n        </dependency>\n\n        \x3c!-- Logback Classic (用于替代 SLF4J 的实现) --\x3e\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.rxtx</groupId>\n            <artifactId>rxtx</artifactId>\n            <version>2.1.7</version>\n        </dependency>",'xml\n\n<configuration>\n\n\n    \x3c!-- 控制台日志输出 --\x3e\n    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5level) %white(-) %-15(%yellow([%10.20thread]))\n                %-55(%cyan(%.32logger{30}:%L)) %highlight(- %msg%n)\n            </pattern>\n        </encoder>\n    </appender>\n\n    \x3c!-- 普通应用日志文件输出 --\x3e\n    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        <file>logs/app.log</file>\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 按日期滚动日志文件 --\x3e\n            <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>\n            <maxHistory>30</maxHistory> \x3c!-- 保留30天的日志 --\x3e\n            <totalSizeCap>1GB</totalSizeCap>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5level) %white(-) %-15(%yellow([%10.20thread]))\n                %-55(%cyan(%.32logger{30}:%L)) %highlight(- %msg%n)\n            </pattern>\n        </encoder>\n    </appender>\n\n\n    \x3c!-- 定义全局的日志级别 --\x3e\n    <root level="INFO">\n        <appender-ref ref="STDOUT"/>\n        <appender-ref ref="FILE"/>\n    </root>\n\n</configuration>',"shell\n// 注意依赖引入错误会没有效果\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nprivate static final Logger log = LoggerFactory.getLogger(XXX.class);",'xml\n\x3c!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --\x3e\n\x3c!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --\x3e\n\x3c!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --\x3e\n\x3c!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --\x3e\n\x3c!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration scan="true" scanPeriod="60 seconds" debug="false">\n    \x3c!-- 动态日志级别 --\x3e\n    \x3c!--  <jmxConfigurator/>--\x3e\n    \x3c!-- 定义日志文件 输出位置 --\x3e\n\n    <springProperty scope="context" name="logPath" source="logging.file.path" defaultValue="./log"/>\n    <property name="log.path" value="${logPath}/log/"/>\n    \x3c!-- 日志最大的历史 30天 --\x3e\n    <property name="maxHistory" value="10"/>\n    \x3c!-- 设置日志输出格式 --\x3e\n    <property name="CONSOLE_LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-})  [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)"/>\n    <property name="LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] ${LOG_LEVEL_PATTERN:-%5p} ${PID:-}  [%thread] [%logger{50} - %method:%line] - %msg%n"/>\n\n    \x3c!-- ConsoleAppender 控制台输出日志 --\x3e\n    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>INFO</level>\n        </filter>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n\n    \x3c!-- INFO级别日志 appender --\x3e\n    <appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!--记录的日志文件的路径及文件名--\x3e\n        <file>${log.path}/info.log</file>\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>INFO</level>\n        </filter>\n        \x3c!--日志记录器的滚动策略，按日期，按大小记录--\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">\n            <fileNamePattern>${log.path}/%d{yyyy-MM,aux}/info.%d{yyyy-MM-dd}.%i.log.zip</fileNamePattern>\n            <maxFileSize>100MB</maxFileSize>\n            <totalSizeCap>1GB</totalSizeCap>\n            <maxHistory>10</maxHistory>\n            <cleanHistoryOnStart>true</cleanHistoryOnStart>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${LOG_PATTERN}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--\n      <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n      以及指定<appender>。<logger>仅有一个name属性，\n      一个可选的level和一个可选的addtivity属性。\n      name:用来指定受此logger约束的某一个包或者具体的某一个类。\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n            还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n            如果未设置此属性，那么当前logger将会继承上级的级别。\n      addtivity:是否向上级logger传递打印信息。默认是true。\n      <logger name="org.springframework.web" level="info"/>\n      <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!-- 4  最终的策略：\n                     基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)--\x3e\n    \x3c!-- root级别 DEBUG --\x3e\n    <root>\n        \x3c!-- 打印debug级别日志及以上级别日志 --\x3e\n        <level value="Info"/>\n        \x3c!-- 控制台输出 --\x3e\n        <appender-ref ref="console"/>\n        \x3c!-- 文件输出 --\x3e\n        <appender-ref ref="INFO"/>\n        \x3c!--    <appender-ref ref="DEBUG"/>--\x3e\n        \x3c!--    <appender-ref ref="TRACE"/>--\x3e\n    </root>\n    \x3c!--  &lt;!&ndash;不同业务打印到指定文件&ndash;&gt;--\x3e\n    \x3c!--  <logger name="byte" additivity="false" level="INFO">--\x3e\n    \x3c!--    <appender-ref ref="DELETE_INFO"/>--\x3e\n    \x3c!--  </logger>--\x3e\n    \x3c!--  &lt;!&ndash;  &lt;!&ndash;不同业务打印到指定文件&ndash;&gt;&ndash;&gt;--\x3e\n    \x3c!--  &lt;!&ndash; 生产环境, 指定某包日志为warn级 &ndash;&gt;--\x3e\n    \x3c!--  <logger name="org.springframework.jdbc.core.JdbcTemplate" level="info"/>--\x3e\n    \x3c!-- 特定某个类打印info日志, 比如application启动成功后的提示语 --\x3e\n</configuration>','xml\n<?xml version="1.0" encoding="UTF-8"?>\n\x3c!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\x3e\n\x3c!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --\x3e\n\x3c!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。\n                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\x3e\n\x3c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\x3e\n<configuration  scan="true" scanPeriod="10 seconds">\n    <contextName>logback-spring</contextName>\n\n    \x3c!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --\x3e\n    <property name="logging.path" value="./logs" />\n\n    \x3c!--0. 日志格式和颜色渲染 --\x3e\n    \x3c!-- 彩色日志依赖的渲染类 --\x3e\n    <conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" />\n    <conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" />\n    <conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" />\n    \x3c!-- 彩色日志格式 --\x3e\n\x3c!--    <property name="CONSOLE_LOG_PATTERN" value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(-&#45;&#45;){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>--\x3e\n    <property name="CONSOLE_LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-})  [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)"/>\n    <property name="LOG_PATTERN"\n              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{traceId}] ${LOG_LEVEL_PATTERN:-%5p} ${PID:-}  [%thread] [%logger{50} - %method:%line] - %msg%n"/>\n\n    \x3c!--1. 输出到控制台--\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\x3e\n        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">\n            <level>debug</level>\n        </filter>\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            \x3c!-- 设置字符集 --\x3e\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n\n    \x3c!--2. 输出到文档--\x3e\n    \x3c!-- 2.1 level为 DEBUG 日志，时间滚动输出  --\x3e\n    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_debug.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 日志归档 --\x3e\n            <fileNamePattern>${logging.path}/web-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录debug级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>debug</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.2 level为 INFO 日志，时间滚动输出  --\x3e\n    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_info.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            \x3c!-- 每天日志归档路径以及格式 --\x3e\n            <fileNamePattern>${logging.path}/web-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录info级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>info</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.3 level为 WARN 日志，时间滚动输出  --\x3e\n    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_warn.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录warn级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>warn</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!-- 2.4 level为 ERROR 日志，时间滚动输出  --\x3e\n    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        \x3c!-- 正在记录的日志文档的路径及文档名 --\x3e\n        <file>${logging.path}/web_error.log</file>\n        \x3c!--日志文档输出格式--\x3e\n        <encoder>\n            <Pattern>${LOG_PATTERN}</Pattern>\n            <charset>UTF-8</charset> \x3c!-- 此处设置字符集 --\x3e\n        </encoder>\n        \x3c!-- 日志记录器的滚动策略，按日期，按大小记录 --\x3e\n        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">\n            <fileNamePattern>${logging.path}/web-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">\n                <maxFileSize>100MB</maxFileSize>\n            </timeBasedFileNamingAndTriggeringPolicy>\n            \x3c!--日志文档保留天数--\x3e\n            <maxHistory>15</maxHistory>\n        </rollingPolicy>\n        \x3c!-- 此日志文档只记录ERROR级别的 --\x3e\n        <filter class="ch.qos.logback.classic.filter.LevelFilter">\n            <level>ERROR</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n    </appender>\n\n    \x3c!--\n        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n        以及指定<appender>。<logger>仅有一个name属性，\n        一个可选的level和一个可选的addtivity属性。\n        name:用来指定受此logger约束的某一个包或者具体的某一个类。\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n              如果未设置此属性，那么当前logger将会继承上级的级别。\n        addtivity:是否向上级logger传递打印信息。默认是true。\n        <logger name="org.springframework.web" level="info"/>\n        <logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>\n    --\x3e\n\n    \x3c!--\n        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n        第一种把<root level="info">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息\n        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n        【logging.level.org.mybatis=debug logging.level.dao=debug】\n     --\x3e\n\n    \x3c!--\n        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n        不能设置为INHERITED或者同义词NULL。默认是DEBUG\n        可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n    --\x3e\n    \x3c!--过滤掉spring和mybatis的一些无用的DEBUG信息--\x3e\n    <logger name="org.springframework" level="INFO"></logger>\n    <logger name="org.mybatis" level="INFO"></logger>\n    <logger name="org.apache.zookeeper" level="INFO"></logger>\n\n    \x3c!-- 4. 最终的策略 --\x3e\n    \x3c!-- 4.1 开发环境:打印控制台--\x3e\n    <springProfile name="dev">\n        <logger name="com.example.datatransport" level="debug"/>\x3c!-- 修改此处扫描包名 --\x3e\n    </springProfile>\n\n    <root level="info">\n        <appender-ref ref="CONSOLE" />\n        <appender-ref ref="DEBUG_FILE" />\n        <appender-ref ref="INFO_FILE" />\n        <appender-ref ref="WARN_FILE" />\n        <appender-ref ref="ERROR_FILE" />\n    </root>\n\n\x3c!--    4.2 生产环境:输出到文档--\x3e\n    <springProfile name="pro">\n        <root level="info">\n            <appender-ref ref="CONSOLE" />\n            <appender-ref ref="DEBUG_FILE" />\n\x3c!--            <appender-ref ref="INFO_FILE" />--\x3e\n            <appender-ref ref="ERROR_FILE" />\n            <appender-ref ref="WARN_FILE" />\n        </root>\n    </springProfile>\n</configuration>',"xml\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n </dependency>","properties\n# application.properties\ndatabase.url=jdbc:mysql://localhost:3306/mydb\ndatabase.username=root\ndatabase.password=secret",'java\n@Component\n@ConfigurationProperties(prefix = "database")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n\n    // getters and setters\n}',"java\n@Service\npublic class MyService {\n    private final DatabaseProperties databaseProperties;\n\n    @Autowired\n    public MyService(DatabaseProperties databaseProperties) {\n        this.databaseProperties = databaseProperties;\n    }\n\n    public void performDatabaseOperation() {\n        // 使用 databaseProperties.getUrl(), databaseProperties.getUsername(), databaseProperties.getPassword()\n    }\n}",'java\npublic class ConfigPropertiesDemo {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        context.register(ConfigApp.class);\n        context.refresh();\n\n        DatabaseProperties dbProps = context.getBean(DatabaseProperties.class);\n        System.out.println("Database URL: " + dbProps.getUrl());\n    }\n}\n\n@Configuration\n@PropertySource("classpath:db.properties")\npublic class ConfigApp {\n    @Bean\n    @ConfigurationProperties(prefix = "database")\n    public DatabaseProperties databaseProperties() {\n        return new DatabaseProperties();\n    }\n}\n\n@Component\n@ConfigurationProperties(prefix = "database")\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n\n    // getters and setters\n}']},{title:"HTTP tomcat Servlet 基础知识",headers:[{level:2,title:"1，Web概述",slug:"_1-web概述",link:"#_1-web概述",children:[{level:3,title:"1.1 Web和JavaWeb的概念",slug:"_1-1-web和javaweb的概念",link:"#_1-1-web和javaweb的概念",children:[]},{level:3,title:"1.2 JavaWeb技术栈",slug:"_1-2-javaweb技术栈",link:"#_1-2-javaweb技术栈",children:[]}]},{level:2,title:"2, HTTP",slug:"_2-http",link:"#_2-http",children:[{level:3,title:"2.1 简介",slug:"_2-1-简介",link:"#_2-1-简介",children:[]},{level:3,title:"2.2 请求数据格式",slug:"_2-2-请求数据格式",link:"#_2-2-请求数据格式",children:[]},{level:3,title:"2.3 响应数据格式",slug:"_2-3-响应数据格式",link:"#_2-3-响应数据格式",children:[]}]},{level:2,title:"3, Tomcat",slug:"_3-tomcat",link:"#_3-tomcat",children:[{level:3,title:"3.1 简介",slug:"_3-1-简介",link:"#_3-1-简介",children:[]},{level:3,title:"3.2 基本使用",slug:"_3-2-基本使用",link:"#_3-2-基本使用",children:[]},{level:3,title:"3.3 Maven创建Web项目",slug:"_3-3-maven创建web项目",link:"#_3-3-maven创建web项目",children:[]},{level:3,title:"3.4 IDEA使用Tomcat",slug:"_3-4-idea使用tomcat",link:"#_3-4-idea使用tomcat",children:[]}]},{level:2,title:"4， Servlet",slug:"_4-servlet",link:"#_4-servlet",children:[{level:3,title:"4.1 简介",slug:"_4-1-简介",link:"#_4-1-简介",children:[]},{level:3,title:"4.2 快速入门",slug:"_4-2-快速入门",link:"#_4-2-快速入门",children:[]},{level:3,title:"4.3 执行流程",slug:"_4-3-执行流程",link:"#_4-3-执行流程",children:[]},{level:3,title:"4.4 生命周期",slug:"_4-4-生命周期",link:"#_4-4-生命周期",children:[]},{level:3,title:"4.5 方法介绍",slug:"_4-5-方法介绍",link:"#_4-5-方法介绍",children:[]},{level:3,title:"4.6 体系结构",slug:"_4-6-体系结构",link:"#_4-6-体系结构",children:[]},{level:3,title:"4.7 urlPattern配置",slug:"_4-7-urlpattern配置",link:"#_4-7-urlpattern配置",children:[]}]}],path:"/posts/java/web/HTTP_Tomcat_Servlet.html",pathLocale:"/",extraFields:["Host: 表示请求的主机名\n  User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；\n  Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；\n  Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\n  Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。","Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；\n  Content-Length：表示该响应内容的长度（字节数）；\n  Content-Encoding：表示该响应压缩算法，例如gzip；\n  Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒",'java\npackage com.itheima;\n\nimport sun.misc.IOUtils;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\n/*\n    自定义服务器\n */\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8080); // 监听指定端口\n        System.out.println("server is running...");\n        while (true){\n            Socket sock = ss.accept();\n            System.out.println("connected from " + sock.getRemoteSocketAddress());\n            Thread t = new Handler(sock);\n            t.start();\n        }\n    }\n}\n\nclass Handler extends Thread {\n    Socket sock;\n\n    public Handler(Socket sock) {\n        this.sock = sock;\n    }\n\n    public void run() {\n        try (InputStream input = this.sock.getInputStream()) {\n            try (OutputStream output = this.sock.getOutputStream()) {\n                handle(input, output);\n            }\n        } catch (Exception e) {\n            try {\n                this.sock.close();\n            } catch (IOException ioe) {\n            }\n            System.out.println("client disconnected.");\n        }\n    }\n\n    private void handle(InputStream input, OutputStream output) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));\n        // 读取HTTP请求:\n        boolean requestOk = false;\n        String first = reader.readLine();\n        if (first.startsWith("GET / HTTP/1.")) {\n            requestOk = true;\n        }\n        for (;;) {\n            String header = reader.readLine();\n            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕\n                break;\n            }\n            System.out.println(header);\n        }\n        System.out.println(requestOk ? "Response OK" : "Response Error");\n        if (!requestOk) {\n            // 发送错误响应:\n            writer.write("HTTP/1.0 404 Not Found\\r\\n");\n            writer.write("Content-Length: 0\\r\\n");\n            writer.write("\\r\\n");\n            writer.flush();\n        } else {\n            // 发送成功响应:\n\n            //读取html文件，转换为字符串\n            BufferedReader br = new BufferedReader(new FileReader("http/html/a.html"));\n            StringBuilder data = new StringBuilder();\n            String line = null;\n            while ((line = br.readLine()) != null){\n                data.append(line);\n            }\n            br.close();\n            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;\n\n            writer.write("HTTP/1.1 200 OK\\r\\n");\n            writer.write("Connection: keep-alive\\r\\n");\n            writer.write("Content-Type: text/html\\r\\n");\n            writer.write("Content-Length: " + length + "\\r\\n");\n            writer.write("\\r\\n"); // 空行标识Header和Body的分隔\n            writer.write(data.toString());\n            writer.flush();\n        }\n    }\n}',"xml\n   <build>\n       <plugins>\n       \t\x3c!--Tomcat插件 --\x3e\n           <plugin>\n               <groupId>org.apache.tomcat.maven</groupId>\n               <artifactId>tomcat7-maven-plugin</artifactId>\n               <version>2.2</version>\n           </plugin>\n       </plugins>\n   </build>","xml\n<build>\n    <plugins>\n    \t\x3c!--Tomcat插件 --\x3e\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <version>2.2</version>\n            <configuration>\n            \t<port>80</port>\x3c!--访问端口号 --\x3e\n                \x3c!--项目访问路径\n\t\t\t\t\t未配置访问路径: http://localhost:80/tomcat-demo2/a.html\n\t\t\t\t\t配置/后访问路径: http://localhost:80/a.html\n\t\t\t\t\t如果配置成 /hello,访问路径会变成什么?\n\t\t\t\t\t\t答案: http://localhost:80/hello/a.html\n\t\t\t\t--\x3e\n                <path>/</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>","xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    \x3c!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --\x3e\n    <scope>provided</scope>\n</dependency>",'java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet {\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println("servlet hello world~");\n    }\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}','java\n@WebServlet("/demo1")',"http://localhost:8080/web-demo/demo1",'xml\n  默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n  \n  @WebServlet(urlPatterns = "/demo1",loadOnStartup = 1)\n  loadOnstartup的取值有两类情况\n  \t（1）负整数:第一次访问时创建Servlet对象\n  \t（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高','java\n  package com.itheima.web;\n  \n  import javax.servlet.*;\n  import javax.servlet.annotation.WebServlet;\n  import java.io.IOException;\n  /**\n  * Servlet生命周期方法\n  */\n  @WebServlet(urlPatterns = "/demo2",loadOnStartup = 1)\n  public class ServletDemo2 implements Servlet {\n  \n      /**\n       *  初始化方法\n       *  1.调用时机：默认情况下，Servlet被第一次访问时，调用\n       *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用\n       *  2.调用次数: 1次\n       * @param config\n       * @throws ServletException\n       */\n      public void init(ServletConfig config) throws ServletException {\n          System.out.println("init...");\n      }\n  \n      /**\n       * 提供服务\n       * 1.调用时机:每一次Servlet被访问时，调用\n       * 2.调用次数: 多次\n       * @param req\n       * @param res\n       * @throws ServletException\n       * @throws IOException\n       */\n      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n          System.out.println("servlet hello world~");\n      }\n  \n      /**\n       * 销毁方法\n       * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用\n       * 2.调用次数: 1次\n       */\n      public void destroy() {\n          System.out.println("destroy...");\n      }\n      public ServletConfig getServletConfig() {\n          return null;\n      }\n  \n      public String getServletInfo() {\n          return null;\n      }\n  \n  \n  }',"java\nvoid init(ServletConfig config)","java\nvoid service(ServletRequest req, ServletResponse res)","java\nvoid destroy()",'java\nString getServletInfo() \n//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() {\n    return "";\n}',"java\nServletConfig getServletConfig()",'java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n/**\n * Servlet方法介绍\n */\n@WebServlet(urlPatterns = "/demo3",loadOnStartup = 1)\npublic class ServletDemo3 implements Servlet {\n\n    private ServletConfig servletConfig;\n    /**\n     *  初始化方法\n     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用\n     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用\n     *  2.调用次数: 1次\n     * @param config\n     * @throws ServletException\n     */\n    public void init(ServletConfig config) throws ServletException {\n        this.servletConfig = config;\n        System.out.println("init...");\n    }\n    public ServletConfig getServletConfig() {\n        return servletConfig;\n    }\n    \n    /**\n     * 提供服务\n     * 1.调用时机:每一次Servlet被访问时，调用\n     * 2.调用次数: 多次\n     * @param req\n     * @param res\n     * @throws ServletException\n     * @throws IOException\n     */\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        System.out.println("servlet hello world~");\n    }\n\n    /**\n     * 销毁方法\n     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用\n     * 2.调用次数: 1次\n     */\n    public void destroy() {\n        System.out.println("destroy...");\n    }\n    \n    public String getServletInfo() {\n        return "";\n    }\n}','java\n@WebServlet("/demo4")\npublic class ServletDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //TODO GET 请求方式处理逻辑\n        System.out.println("get...");\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //TODO Post 请求方式处理逻辑\n        System.out.println("post...");\n    }\n}','html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n    <form action="/web-demo/demo4" method="post">\n        <input name="username"/><input type="submit"/>\n    </form>\n</body>\n</html>','java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n\n@WebServlet("/demo5")\npublic class ServletDemo5 implements Servlet {\n\n    public void init(ServletConfig config) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        //如何调用?\n        //获取请求方式，根据不同的请求方式进行不同的业务处理\n        HttpServletRequest request = (HttpServletRequest)req;\n       //1. 获取请求方式\n        String method = request.getMethod();\n        //2. 判断\n        if("GET".equals(method)){\n            // get方式的处理逻辑\n        }else if("POST".equals(method)){\n            // post方式的处理逻辑\n        }\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}','java\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class MyHttpServlet implements Servlet {\n    public void init(ServletConfig config) throws ServletException {\n\n    }\n\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        HttpServletRequest request = (HttpServletRequest)req;\n        //1. 获取请求方式\n        String method = request.getMethod();\n        //2. 判断\n        if("GET".equals(method)){\n            // get方式的处理逻辑\n            doGet(req,res);\n        }else if("POST".equals(method)){\n            // post方式的处理逻辑\n            doPost(req,res);\n        }\n    }\n\n    protected void doPost(ServletRequest req, ServletResponse res) {\n    }\n\n    protected void doGet(ServletRequest req, ServletResponse res) {\n    }\n\n    public String getServletInfo() {\n        return null;\n    }\n\n    public void destroy() {\n\n    }\n}','java\n@WebServlet("/demo5")\npublic class ServletDemo5 extends MyHttpServlet {\n\n    @Override\n    protected void doGet(ServletRequest req, ServletResponse res) {\n        System.out.println("get...");\n    }\n\n    @Override\n    protected void doPost(ServletRequest req, ServletResponse res) {\n        System.out.println("post...");\n    }\n}','java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException\n    {\n        String method = req.getMethod();\n\n        if (method.equals(METHOD_GET)) {\n            long lastModified = getLastModified(req);\n            if (lastModified == -1) {\n                // servlet doesn\'t support if-modified-since, no reason\n                // to go through further expensive logic\n                doGet(req, resp);\n            } else {\n                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n                if (ifModifiedSince < lastModified) {\n                    // If the servlet mod time is later, call doGet()\n                    // Round down to the nearest second for a proper compare\n                    // A ifModifiedSince of -1 will always be less\n                    maybeSetLastModified(resp, lastModified);\n                    doGet(req, resp);\n                } else {\n                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                }\n            }\n\n        } else if (method.equals(METHOD_HEAD)) {\n            long lastModified = getLastModified(req);\n            maybeSetLastModified(resp, lastModified);\n            doHead(req, resp);\n\n        } else if (method.equals(METHOD_POST)) {\n            doPost(req, resp);\n            \n        } else if (method.equals(METHOD_PUT)) {\n            doPut(req, resp);\n            \n        } else if (method.equals(METHOD_DELETE)) {\n            doDelete(req, resp);\n            \n        } else if (method.equals(METHOD_OPTIONS)) {\n            doOptions(req,resp);\n            \n        } else if (method.equals(METHOD_TRACE)) {\n            doTrace(req,resp);\n            \n        } else {\n            //\n            // Note that this means NO servlet supports whatever\n            // method was requested, anywhere on this server.\n            //\n\n            String errMsg = lStrings.getString("http.method_not_implemented");\n            Object[] errArgs = new Object[1];\n            errArgs[0] = method;\n            errMsg = MessageFormat.format(errMsg, errArgs);\n            \n            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n        }\n    }','java\npackage com.itheima.web;\n  \n  import javax.servlet.ServletRequest;\n  import javax.servlet.ServletResponse;\n  import javax.servlet.annotation.WebServlet;\n  \n  /**\n  * urlPattern: 一个Servlet可以配置多个访问路径\n  */\n  @WebServlet(urlPatterns = {"/demo7","/demo8"})\n  public class ServletDemo7 extends MyHttpServlet {\n  \n      @Override\n      protected void doGet(ServletRequest req, ServletResponse res) {\n          \n          System.out.println("demo7 get...");\n      }\n      @Override\n      protected void doPost(ServletRequest req, ServletResponse res) {\n      }\n  }','java\n    /**\n       * UrlPattern:\n       * * 精确匹配\n       */\n      @WebServlet(urlPatterns = "/user/select")\n      public class ServletDemo8 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo8 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }','java\n    package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 目录匹配: /user/*\n       */\n      @WebServlet(urlPatterns = "/user/*")\n      public class ServletDemo9 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo9 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }','java\n    package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 扩展名匹配: *.do\n       */\n      @WebServlet(urlPatterns = "*.do")\n      public class ServletDemo10 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo10 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }','java\n      package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 任意匹配： /\n       */\n      @WebServlet(urlPatterns = "/")\n      public class ServletDemo11 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo11 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }','java\n      package com.itheima.web;\n      \n      import javax.servlet.ServletRequest;\n      import javax.servlet.ServletResponse;\n      import javax.servlet.annotation.WebServlet;\n      \n      /**\n       * UrlPattern:\n       * * 任意匹配： /*\n       */\n      @WebServlet(urlPatterns = "/*")\n      public class ServletDemo12 extends MyHttpServlet {\n      \n          @Override\n          protected void doGet(ServletRequest req, ServletResponse res) {\n      \n              System.out.println("demo12 get...");\n          }\n          @Override\n          protected void doPost(ServletRequest req, ServletResponse res) {\n          }\n      }','java\npackage com.itheima.web;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebServlet;\n\npublic class ServletDemo13 extends MyHttpServlet {\n\n    @Override\n    protected void doGet(ServletRequest req, ServletResponse res) {\n\n        System.out.println("demo13 get...");\n    }\n    @Override\n    protected void doPost(ServletRequest req, ServletResponse res) {\n    }\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n    \n    \n    \n    \x3c!-- \n        Servlet 全类名\n    --\x3e\n    <servlet>\n        \x3c!-- servlet的名称，名字任意--\x3e\n        <servlet-name>demo13</servlet-name>\n        \x3c!--servlet的类全名--\x3e\n        <servlet-class>com.itheima.web.ServletDemo13</servlet-class>\n    </servlet>\n\n    \x3c!-- \n        Servlet 访问路径\n    --\x3e\n    <servlet-mapping>\n        \x3c!-- servlet的名称，要和上面的名称一致--\x3e\n        <servlet-name>demo13</servlet-name>\n        \x3c!-- servlet的访问路径--\x3e\n        <url-pattern>/demo13</url-pattern>\n    </servlet-mapping>\n</web-app>']},{title:"Request&Response 的基本使用",headers:[{level:2,title:"1，Request和Response的概述",slug:"_1-request和response的概述",link:"#_1-request和response的概述",children:[]},{level:2,title:"2，Request对象",slug:"_2-request对象",link:"#_2-request对象",children:[{level:3,title:"2.1 Request继承体系",slug:"_2-1-request继承体系",link:"#_2-1-request继承体系",children:[]},{level:3,title:"2.2 Request获取请求数据",slug:"_2-2-request获取请求数据",link:"#_2-2-request获取请求数据",children:[]},{level:3,title:"2.4 请求参数中文乱码问题",slug:"_2-4-请求参数中文乱码问题",link:"#_2-4-请求参数中文乱码问题",children:[]},{level:3,title:"2.5 Request请求转发",slug:"_2-5-request请求转发",link:"#_2-5-request请求转发",children:[]}]},{level:2,title:"3，Response对象",slug:"_3-response对象",link:"#_3-response对象",children:[{level:3,title:"3.1 Response设置响应数据功能介绍",slug:"_3-1-response设置响应数据功能介绍",link:"#_3-1-response设置响应数据功能介绍",children:[]},{level:3,title:"3.2 Respones请求重定向",slug:"_3-2-respones请求重定向",link:"#_3-2-respones请求重定向",children:[]},{level:3,title:"3.3 路径问题",slug:"_3-3-路径问题",link:"#_3-3-路径问题",children:[]},{level:3,title:"3.4 Response响应字符数据",slug:"_3-4-response响应字符数据",link:"#_3-4-response响应字符数据",children:[]},{level:3,title:"3.3 Response响应字节数据",slug:"_3-3-response响应字节数据",link:"#_3-3-response响应字节数据",children:[]}]},{level:2,title:"4，用户注册登录案例",slug:"_4-用户注册登录案例",link:"#_4-用户注册登录案例",children:[{level:3,title:"4.1 用户登录",slug:"_4-1-用户登录",link:"#_4-1-用户登录",children:[]},{level:3,title:"4.2 用户注册",slug:"_4-2-用户注册",link:"#_4-2-用户注册",children:[]},{level:3,title:"4.3 SqlSessionFactory工具类抽取",slug:"_4-3-sqlsessionfactory工具类抽取",link:"#_4-3-sqlsessionfactory工具类抽取",children:[]}]}],path:"/posts/java/web/Request_Response.html",pathLocale:"/",extraFields:['java\n@WebServlet("/demo3")\npublic class ServletDemo3 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //使用request对象 获取请求数据\n        String name = request.getParameter("name");//url?name=zhangsan\n\n        //使用response对象 设置响应数据\n        response.setHeader("content-type","text/html;charset=utf-8");\n        response.getWriter().write("<h1>"+name+",欢迎您！</h1>");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("Post...");\n    }\n}','java\n@WebServlet("/demo2")\npublic class ServletDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(request);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}',"String getMethod()","String getContextPath()","StringBuffer getRequestURL()","String getRequestURI()","String getQueryString()",'java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // String getMethod()：获取请求方式： GET\n        String method = req.getMethod();\n        System.out.println(method);//GET\n        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo\n        String contextPath = req.getContextPath();\n        System.out.println(contextPath);\n        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1\n        StringBuffer url = req.getRequestURL();\n        System.out.println(url.toString());\n        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1\n        String uri = req.getRequestURI();\n        System.out.println(uri);\n        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan\n        String queryString = req.getQueryString();\n        System.out.println(queryString);\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}',"xml\nuser-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.63","String getHeader(String name)",'java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求头: user-agent: 浏览器的版本信息\n        String agent = req.getHeader("user-agent");\n\t\tSystem.out.println(agent);\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}',"ServletInputStream getInputStream()\n该方法可以获取字节","BufferedReader getReader()",'html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n\x3c!-- \n    action:form表单提交的请求地址\n    method:请求方式，指定为post\n--\x3e\n<form action="/request-demo/req1" method="post">\n    <input type="text" name="username">\n    <input type="password" name="password">\n    <input type="submit">\n</form>\n</body>\n</html>','java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //在此处获取请求体中的数据\n    }\n}','java\n/**\n * request 获取请求数据\n */\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n         //获取post 请求体：请求参数\n        //1. 获取字符输入流\n        BufferedReader br = req.getReader();\n        //2. 读取数据\n        String line = br.readLine();\n        System.out.println(line);\n    }\n}',"String getQueryString()","BufferedReader getReader();",'java\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        String result = req.getQueryString();\n        System.out.println(result);\n\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        BufferedReader br = req.getReader();\n        String result = br.readLine();\n        System.out.println(result);\n    }\n}','java\n@WebServlet("/req1")\npublic class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //获取请求方式\n        String method = req.getMethod();\n        //获取请求参数\n        String params = "";\n        if("GET".equals(method)){\n            params = req.getQueryString();\n        }else if("POST".equals(method)){\n            BufferedReader reader = req.getReader();\n            params = reader.readLine();\n        }\n        //将请求参数进行打印控制台\n        System.out.println(params);\n      \n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doGet(req,resp);\n    }\n}',"Map<String,String[]> getParameterMap()","String[] getParameterValues(String name)","String getParameter(String name)",'html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/request-demo/req2" method="get">\n    <input type="text" name="username"><br>\n    <input type="password" name="password"><br>\n    <input type="checkbox" name="hobby" value="1"> 游泳\n    <input type="checkbox" name="hobby" value="2"> 爬山 <br>\n    <input type="submit">\n\n</form>\n</body>\n</html>','java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        System.out.println("get....");\n        //1. 获取所有参数的Map集合\n        Map<String, String[]> map = req.getParameterMap();\n        for (String key : map.keySet()) {\n            // username:zhangsan lisi\n            System.out.print(key+":");\n\n            //获取值\n            String[] values = map.get(key);\n            for (String value : values) {\n                System.out.print(value + " ");\n            }\n\n            System.out.println();\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}','java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        //...\n        System.out.println("------------");\n        String[] hobbies = req.getParameterValues("hobby");\n        for (String hobby : hobbies) {\n            System.out.println(hobby);\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}','java\n/**\n * request 通用方式获取请求参数\n */\n@WebServlet("/req2")\npublic class RequestDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //GET请求逻辑\n        //...\n        String username = req.getParameter("username");\n        String password = req.getParameter("password");\n        System.out.println(username);\n        System.out.println(password);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    }\n}',"public class RequestDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n       //采用request提供的获取请求参数的通用方式来获取请求参数\n       //编写其他的业务代码...\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doGet(req,resp);\n    }\n}",'html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/request-demo/req2" method="get">\n    <input type="text" name="username"><br>\n    <input type="password" name="password"><br>\n    <input type="checkbox" name="hobby" value="1"> 游泳\n    <input type="checkbox" name="hobby" value="2"> 爬山 <br>\n    <input type="submit">\n\n</form>\n</body>\n</html>','java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n       //1. 获取username\n       String username = request.getParameter("username");\n       System.out.println(username);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 解决乱码: POST getReader()\n        //设置字符输入流的编码，设置的字符集要和页面保持一致\n        request.setCharacterEncoding("UTF-8");\n       //2. 获取username\n       String username = request.getParameter("username");\n       System.out.println(username);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001",'java\njava.net.URLEncoder.encode("需要被编码的内容","字符集(UTF-8)")','java\njava.net.URLDecoder.decode("需要被解码的内容","字符集(UTF-8)")','public class URLDemo {\n\n  public static void main(String[] args) throws UnsupportedEncodingException {\n        String username = "张三";\n        //1. URL编码\n        String encode = URLEncoder.encode(username, "utf-8");\n        System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89\n\n       //2. URL解码\n       //String decode = URLDecoder.decode(encode, "utf-8");//打印:张三\n       String decode = URLDecoder.decode(encode, "ISO-8859-1");//打印:`å¼ ä¸ `\n       System.out.println(decode);\n    }\n}',"1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001",'public class URLDemo {\n\n  public static void main(String[] args) throws UnsupportedEncodingException {\n        String username = "张三";\n        //1. URL编码\n        String encode = URLEncoder.encode(username, "utf-8");\n        System.out.println(encode);\n        //2. URL解码\n        String decode = URLDecoder.decode(encode, "ISO-8859-1");\n\n        System.out.println(decode); //此处打印的是对应的乱码数据\n\n        //3. 转换为字节数据,编码\n        byte[] bytes = decode.getBytes("ISO-8859-1");\n        for (byte b : bytes) {\n            System.out.print(b + " ");\n        }\n\t\t//此处打印的是:-27 -68 -96 -28 -72 -119\n        //4. 将字节数组转为字符串，解码\n        String s = new String(bytes, "utf-8");\n        System.out.println(s); //此处打印的是张三\n    }\n}','java\n/**\n * 中文乱码问题解决方案\n */\n@WebServlet("/req4")\npublic class RequestDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 解决乱码：POST，getReader()\n        //request.setCharacterEncoding("UTF-8");//设置字符输入流的编码\n\n        //2. 获取username\n        String username = request.getParameter("username");\n        System.out.println("解决乱码前："+username);\n\n        //3. GET,获取参数的方式：getQueryString\n        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1\n       /* //3.1 先对乱码数据进行编码：转为字节数组\n        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);\n        //3.2 字节数组解码\n        username = new String(bytes, StandardCharsets.UTF_8);*/\n\n        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);\n\n        System.out.println("解决乱码后："+username);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','request.setCharacterEncoding("UTF-8");\n  注意:设置的字符集要和页面保持一致','new String(username.getBytes("ISO-8859-1"),"UTF-8");','URLEncoder.encode(str,"UTF-8");','URLDecoder.decode(s,"ISO-8859-1");','req.getRequestDispatcher("资源B路径").forward(req,resp);','java\n/**\n * 请求转发\n */\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n * 请求转发\n */\n@WebServlet("/req6")\npublic class RequestDemo6 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo6...");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n * 请求转发\n */\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n        //请求转发\n        request.getRequestDispatcher("/req6").forward(request,response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"void setAttribute(String name,Object o);","Object getAttribute(String name);","void removeAttribute(String name);",'java\n@WebServlet("/req5")\npublic class RequestDemo5 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo5...");\n        //存储数据\n        request.setAttribute("msg","hello");\n        //请求转发\n        request.getRequestDispatcher("/req6").forward(request,response);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n * 请求转发\n */\n@WebServlet("/req6")\npublic class RequestDemo6 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("demo6...");\n        //获取数据\n        Object msg = request.getAttribute("msg");\n        System.out.println(msg);\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"shell\ndemo5...\ndemo6...\nhello","void setStatus(int sc);","shell\ncontent-type: application/json","void setHeader(String name,String value);","PrintWriter getWriter();","ServletOutputStream getOutputStream();",'resp.setStatus(302);\nresp.setHeader("location","资源B的访问路径");','java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n@WebServlet("/resp2")\npublic class ResponseDemo2 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp2....");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n        //重定向\n        //1.设置响应状态码 302\n        response.setStatus(302);\n        //2. 设置响应头 Location\n        response.setHeader("Location","/request-demo/resp2");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','resposne.sendRedirect("/request-demo/resp2")','java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n        //重定向\n        resposne.sendRedirect("/request-demo/resp2")；\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"1.超链接，从浏览器发送，需要加\n2.表单，从浏览器发送，需要加\n3.转发，是从服务器内部跳转，不需要加\n4.重定向，是由浏览器进行跳转，需要加。",'java\n@WebServlet("/resp1")\npublic class ResponseDemo1 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println("resp1....");\n\n        //简化方式完成重定向\n        //动态获取虚拟目录\n        String contextPath = request.getContextPath();\n        response.sendRedirect(contextPath+"/resp2");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n * 响应字符数据：设置字符数据的响应体\n */\n@WebServlet("/resp3")\npublic class ResponseDemo3 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType("text/html;charset=utf-8");\n        //1. 获取字符输出流\n        PrintWriter writer = response.getWriter();\n\t\t writer.write("aaa");\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','PrintWriter writer = response.getWriter();\n//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签\nresponse.setHeader("content-type","text/html");\nwriter.write("<h1>aaa</h1>");','//设置响应的数据格式及数据的编码\nresponse.setContentType("text/html;charset=utf-8");\nwriter.write("你好");','java\n/**\n * 响应字节数据：设置字节数据的响应体\n */\n@WebServlet("/resp4")\npublic class ResponseDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 读取文件\n        FileInputStream fis = new FileInputStream("d://a.jpg");\n        //2. 获取response字节输出流\n        ServletOutputStream os = response.getOutputStream();\n        //3. 完成流的copy\n        byte[] buff = new byte[1024];\n        int len = 0;\n        while ((len = fis.read(buff))!= -1){\n            os.write(buff,0,len);\n        }\n        fis.close();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"xml\n<dependency>\n    <groupId>commons-io</groupId>\n    <artifactId>commons-io</artifactId>\n    <version>2.6</version>\n</dependency>","//fis:输入流\n//os:输出流\nIOUtils.copy(fis,os);",'java\n/**\n * 响应字节数据：设置字节数据的响应体\n */\n@WebServlet("/resp4")\npublic class ResponseDemo4 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 读取文件\n        FileInputStream fis = new FileInputStream("d://a.jpg");\n        //2. 获取response字节输出流\n        ServletOutputStream os = response.getOutputStream();\n        //3. 完成流的copy\n      \tIOUtils.copy(fis,os);\n        fis.close();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}',"xml\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.5.5</version>\n</dependency>\n\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.34</version>\n</dependency>",'xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n    \x3c!--起别名--\x3e\n    <typeAliases>\n        <package name="com.itheima.pojo"/>\n    </typeAliases>\n\n    <environments default="development">\n        <environment id="development">\n            <transactionManager type="JDBC"/>\n            <dataSource type="POOLED">\n                <property name="driver" value="com.mysql.jdbc.Driver"/>\n                \x3c!--\n                    useSSL:关闭SSL安全连接 性能更高\n                    useServerPrepStmts:开启预编译功能\n                    &amp; 等同于 & ,xml配置文件中不能直接写 &符号\n                --\x3e\n                <property name="url" value="jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true"/>\n                <property name="username" value="root"/>\n                <property name="password" value="1234"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        \x3c!--扫描mapper--\x3e\n        <package name="com.itheima.mapper"/>\n    </mappers>\n</configuration>',"java\npublic interface UserMapper {\n\n}",'java\n/**\n     * 根据用户名和密码查询用户对象\n     * @param username\n     * @param password\n     * @return\n     */\n    @Select("select * from tb_user where username = #{username} and password = #{password}")\n    User select(@Param("username") String username,@Param("password")  String password);','html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <title>login</title>\n    <link href="css/login.css" rel="stylesheet">\n</head>\n\n<body>\n<div id="loginDiv">\n    <form action="/request-demo/loginServlet" method="post" id="form">\n        <h1 id="loginMsg">LOGIN IN</h1>\n        <p>Username:<input id="username" name="username" type="text"></p>\n\n        <p>Password:<input id="password" name="password" type="password"></p>\n\n        <div id="subDiv">\n            <input type="submit" class="button" value="login up">\n            <input type="reset" class="button" value="reset">&nbsp;&nbsp;&nbsp;\n            <a href="register.html">没有账号？点击注册</a>\n        </div>\n    </form>\n</div>\n\n</body>\n</html>','java\n@WebServlet("/loginServlet")\npublic class LoginServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 接收用户名和密码\n        String username = request.getParameter("username");\n        String password = request.getParameter("password");\n\n        //2. 调用MyBatis完成查询\n        //2.1 获取SqlSessionFactory对象\n        String resource = "mybatis-config.xml";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        //2.2 获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //2.3 获取Mapper\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        //2.4 调用方法\n        User user = userMapper.select(username, password);\n        //2.5 释放资源\n        sqlSession.close();\n\n\n        //获取字符输出流，并设置content type\n        response.setContentType("text/html;charset=utf-8");\n        PrintWriter writer = response.getWriter();\n        //3. 判断user释放为null\n        if(user != null){\n            // 登陆成功\n            writer.write("登陆成功");\n        }else {\n            // 登陆失败\n            writer.write("登陆失败");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\n/**\n* 根据用户名查询用户对象\n* @param username\n* @return\n*/\n@Select("select * from tb_user where username = #{username}")\nUser selectByUsername(String username);\n\n/**\n* 添加用户\n* @param user\n*/\n@Insert("insert into tb_user values(null,#{username},#{password})")\nvoid add(User user);','html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>欢迎注册</title>\n    <link href="css/register.css" rel="stylesheet">\n</head>\n<body>\n\n<div class="form-div">\n    <div class="reg-content">\n        <h1>欢迎注册</h1>\n        <span>已有帐号？</span> <a href="login.html">登录</a>\n    </div>\n    <form id="reg-form" action="/request-demo/registerServlet" method="post">\n\n        <table>\n\n            <tr>\n                <td>用户名</td>\n                <td class="inputs">\n                    <input name="username" type="text" id="username">\n                    <br>\n                    <span id="username_err" class="err_msg" style="display: none">用户名不太受欢迎</span>\n                </td>\n\n            </tr>\n\n            <tr>\n                <td>密码</td>\n                <td class="inputs">\n                    <input name="password" type="password" id="password">\n                    <br>\n                    <span id="password_err" class="err_msg" style="display: none">密码格式有误</span>\n                </td>\n            </tr>\n\n        </table>\n\n        <div class="buttons">\n            <input value="注 册" type="submit" id="reg_btn">\n        </div>\n        <br class="clear">\n    </form>\n\n</div>\n</body>\n</html>','java\n@WebServlet("/registerServlet")\npublic class RegisterServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1. 接收用户数据\n        String username = request.getParameter("username");\n        String password = request.getParameter("password");\n\n        //封装用户对象\n        User user = new User();\n        user.setUsername(username);\n        user.setPassword(password);\n\n        //2. 调用mapper 根据用户名查询用户对象\n        //2.1 获取SqlSessionFactory对象\n        String resource = "mybatis-config.xml";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        //2.2 获取SqlSession对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //2.3 获取Mapper\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n\n        //2.4 调用方法\n        User u = userMapper.selectByUsername(username);\n\n        //3. 判断用户对象释放为null\n        if( u == null){\n            // 用户名不存在，添加用户\n            userMapper.add(user);\n\n            // 提交事务\n            sqlSession.commit();\n            // 释放资源\n            sqlSession.close();\n        }else {\n            // 用户名存在，给出提示信息\n            response.setContentType("text/html;charset=utf-8");\n            response.getWriter().write("用户名已存在");\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}','java\nString resource = "mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new \n\tSqlSessionFactoryBuilder().build(inputStream);','java\npublic class SqlSessionFactoryUtils {\n\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static {\n        //静态代码块会随着类的加载而自动执行，且只执行一次\n        try {\n            String resource = "mybatis-config.xml";\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static SqlSessionFactory getSqlSessionFactory(){\n        return sqlSessionFactory;\n    }\n}',"java\nSqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory();"]},{title:"jdbc 的基本使用",headers:[{level:2,title:"1，JDBC概述",slug:"_1-jdbc概述",link:"#_1-jdbc概述",children:[{level:3,title:"1.1  JDBC概念",slug:"_1-1-jdbc概念",link:"#_1-1-jdbc概念",children:[]},{level:3,title:"1.2  JDBC本质",slug:"_1-2-jdbc本质",link:"#_1-2-jdbc本质",children:[]},{level:3,title:"1.3  JDBC好处",slug:"_1-3-jdbc好处",link:"#_1-3-jdbc好处",children:[]}]},{level:2,title:"2，JDBC快速入门",slug:"_2-jdbc快速入门",link:"#_2-jdbc快速入门",children:[{level:3,title:"2.1  编写代码步骤",slug:"_2-1-编写代码步骤",link:"#_2-1-编写代码步骤",children:[]},{level:3,title:"2.2  具体操作",slug:"_2-2-具体操作",link:"#_2-2-具体操作",children:[]}]},{level:2,title:"3，JDBC API详解",slug:"_3-jdbc-api详解",link:"#_3-jdbc-api详解",children:[{level:3,title:"3.1  DriverManager",slug:"_3-1-drivermanager",link:"#_3-1-drivermanager",children:[]},{level:3,title:"3.2  Connection",slug:"_3-2-connection",link:"#_3-2-connection",children:[]},{level:3,title:"3.3  Statement",slug:"_3-3-statement",link:"#_3-3-statement",children:[]},{level:3,title:"3.4  ResultSet",slug:"_3-4-resultset",link:"#_3-4-resultset",children:[]},{level:3,title:"3.5  案例",slug:"_3-5-案例",link:"#_3-5-案例",children:[]},{level:3,title:"3.6  PreparedStatement",slug:"_3-6-preparedstatement",link:"#_3-6-preparedstatement",children:[]}]},{level:2,title:"4，数据库连接池",slug:"_4-数据库连接池",link:"#_4-数据库连接池",children:[{level:3,title:"4.1  数据库连接池简介",slug:"_4-1-数据库连接池简介",link:"#_4-1-数据库连接池简介",children:[]},{level:3,title:"4.2  数据库连接池实现",slug:"_4-2-数据库连接池实现",link:"#_4-2-数据库连接池实现",children:[]},{level:3,title:"4.3  Driud使用",slug:"_4-3-driud使用",link:"#_4-3-driud使用",children:[]}]}],path:"/posts/java/web/jdbc.html",pathLocale:"/",extraFields:['sql\n  Class.forName("com.mysql.jdbc.Driver");',"sql\n  Connection conn = DriverManager.getConnection(url, username, password);",'sql\n  String sql =  "update…" ;',"sql\n  Statement stmt = conn.createStatement();","sql\n  stmt.executeUpdate(sql);",'java\n/**\n * JDBC快速入门\n */\npublic class JDBCDemo {\n\n    public static void main(String[] args) throws Exception {\n        //1. 注册驱动\n        //Class.forName("com.mysql.jdbc.Driver");\n        //2. 获取连接\n        String url = "jdbc:mysql://127.0.0.1:3306/db1";\n        String username = "root";\n        String password = "1234";\n        Connection conn = DriverManager.getConnection(url, username, password);\n        //3. 定义sql\n        String sql = "update account set money = 2000 where id = 1";\n        //4. 获取执行sql的对象 Statement\n        Statement stmt = conn.createStatement();\n        //5. 执行sql\n        int count = stmt.executeUpdate(sql);//受影响的行数\n        //6. 处理结果\n        System.out.println(count);\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    }\n}',"java\n/*\n * 向驱动程序管理器注册给定的驱动程序。新加载的驱动程序类应调用方法 registerDriver，以使驱动程序管理器知道自身。\n * 如果驱动程序当前已注册，则不执行任何操作。参数：驱动程序 – 要注册到驱动程序管理器的新 JDBC 驱动程序\n * 抛出：SQLException – 如果发生数据库访问错误 空指针异常 – 如果驱动程序为空\n */\npublic static synchronized void registerDriver(java.sql.Driver driver)\n        throws SQLException {\n\n        registerDriver(driver, null);\n        }",'sql\n  Class.forName("com.mysql.jdbc.Driver");','java\nstatic {\n        try {\n            DriverManager.registerDriver(new Driver());\n        } catch (SQLException var1) {\n            throw new RuntimeException("Can\'t register driver!");\n        }\n    }','java\n @CallerSensitive\n    public static Connection getConnection(String url,\n        String user, String password) throws SQLException {\n        java.util.Properties info = new java.util.Properties();\n\n        if (user != null) {\n            info.put("user", user);\n        }\n        if (password != null) {\n            info.put("password", password);\n        }\n\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    }',"sql\n  Statement createStatement()","sql\n  PreparedStatement  prepareStatement(sql)","sql\n  CallableStatement prepareCall(sql)","java\n/*\n * 将此连接的自动提交模式设置为给定状态。如果连接处于自动提交模式，则其所有 SQL 语句将作为单个事务执行和提交。\n * 否则，其 SQL 语句将分组到通过调用方法提交或方法回滚而终止的事务中。\n * 默认情况下，新连接处于自动提交模式。提交在语句完成时发生。\n * 语句完成的时间取决于 SQL 语句的类型：对于 DML 语句（如插入、更新或删除）和 DDL 语句，语句在完成执行后立即完成。\n * 对于 Select 语句，当关联的结果集关闭时，该语句即为完成。\n * 对于 CallableStatement 对象或返回多个结果的语句，当所有关联的结果集都已关闭，并且已检索所有更新计数和输出参数时，该语句即为完成。\n * 注意：如果在事务期间调用此方法并且更改了自动提交模式，则会提交事务。如果调用了 setAutoCommit 并且未更改自动提交模式，则该调用为无操作。\n * 参数：自动提交 – true 以启用自动提交模式;假以禁用它 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用 setAutoCommit（true），或者在关闭的连接上调用此方法 另请参阅：getAutoCommit\n */\nvoid setAutoCommit(boolean autoCommit) throws SQLException;","java\n/*\n * 使自上次提交回滚以来所做的所有更改永久化，并释放此 Connection 对象当前持有的任何数据库锁。\n * 仅当禁用自动提交模式时，才应使用此方法。\n * 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用此方法，\n * 如果在关闭的连接上调用此方法或此连接对象处于自动提交模式 另请参阅：设置自动提交\n */\n void commit() throws SQLException;","java\n/*\n * 撤消在当前事务中所做的所有更改，并释放此 Connection 对象当前持有的任何数据库锁。\n * 仅当禁用自动提交模式时，才应使用此方法。\n * 抛出：SQLException – 如果发生数据库访问错误，则在参与分布式事务时调用此方法，在关闭的连接上调用此方法，或者此连接对象处于自动提交模式 另请参阅：setAutoCommit\n */\n void rollback() throws SQLException;",'java\n/**\n * JDBC API 详解：Connection\n */\npublic class JDBCDemo3_Connection {\n\n    public static void main(String[] args) throws Exception {\n        //1. 注册驱动\n        //Class.forName("com.mysql.jdbc.Driver");\n        //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url = "jdbc:mysql:///db1?useSSL=false";\n        String username = "root";\n        String password = "1234";\n        Connection conn = DriverManager.getConnection(url, username, password);\n        //3. 定义sql\n        String sql1 = "update account set money = 3000 where id = 1";\n        String sql2 = "update account set money = 3000 where id = 2";\n        //4. 获取执行sql的对象 Statement\n        Statement stmt = conn.createStatement();\n\n        try {\n            // ============开启事务==========\n            conn.setAutoCommit(false);\n            //5. 执行sql\n            int count1 = stmt.executeUpdate(sql1);//受影响的行数\n            //6. 处理结果\n            System.out.println(count1);\n            int i = 3/0;\n            //5. 执行sql\n            int count2 = stmt.executeUpdate(sql2);//受影响的行数\n            //6. 处理结果\n            System.out.println(count2);\n\n            // ============提交事务==========\n            //程序运行到此处，说明没有出现任何问题，则需求提交事务\n            conn.commit();\n        } catch (Exception e) {\n            // ============回滚事务==========\n            //程序在出现异常时会执行到这个地方，此时就需要回滚事务\n            conn.rollback();\n            e.printStackTrace();\n        }\n\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    }\n}',"java\n/*\n * 执行给定的 SQL 语句，该语句可以是 INSERT、UPDATE 或 DELETE 语句，也可以是不返回任何内容的 SQL 语句，例如 SQL DDL 语句。\n * 注意：此方法不能在 PreparedStatement 或 CallableStatement（已调用语句）上调用。\n * 参数：sql – SQL 数据操作语言 （DML） 语句，例如 INSERT、UPDATE 或 DELETE;或不返回任何内容的 SQL 语句，例如 DDL 语句。\n * 返回：（1） SQL 数据操作语言 （DML） 语句的行计数或 （2） 0 对于不返回任何内容的 SQL 语句 \n * 抛出：SQLTimeoutException – 当驱动程序确定已超出 setQueryTimeout 方法指定的超时值，\n * 并且至少尝试取消当前正在运行的语句 SQLException – 如果发生数据库访问错误， 此方法在闭合语句上调用，\n * 给定的 SQL 语句生成一个 ResultSet 对象，该方法在 PreparedStatement 或 CallableStatement 上调用\n */\nint executeUpdate(String sql) throws SQLException;","java\n/*\n * 执行给定的 SQL 语句，该语句返回单个结果集对象。\n * 注意：此方法不能在 PreparedStatement 或 CallableStatement（已调用语句）上调用。\n * 参数：sql – 要发送到数据库的 SQL 语句，通常是静态 SQL SELECT 语句 \n * 返回：一个 ResultSet 对象，其中包含给定查询生成的数据;\n * 永不空抛出： SQLTimeoutException – 当驱动程序确定已超出 setQueryTimeout 方法指定的超时值，并且至少尝试取消当前运行的语句 \n * SQLException – 如果发生数据库访问错误，则在关闭语句上调用此方法，给定的 SQL 语句生成除单个 ResultSet 对象以外的任何内容， \n * 该方法在 PreparedStatement 或 CallableStatement 上调用\n */\nResultSet executeQuery(String sql) throws SQLException;",'java\n  /**\n    * 执行DML语句\n    * @throws Exception\n    */\n  @Test\n  public void testDML() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n      //3. 定义sql\n      String sql = "update account set money = 3000 where id = 1";\n      //4. 获取执行sql的对象 Statement\n      Statement stmt = conn.createStatement();\n      //5. 执行sql\n      int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数\n      //6. 处理结果\n      //System.out.println(count);\n      if(count > 0){\n          System.out.println("修改成功~");\n      }else{\n          System.out.println("修改失败~");\n      }\n      //7. 释放资源\n      stmt.close();\n      conn.close();\n  }','java\n  /**\n    * 执行DDL语句\n    * @throws Exception\n    */\n  @Test\n  public void testDDL() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n      //3. 定义sql\n      String sql = "drop database db2";\n      //4. 获取执行sql的对象 Statement\n      Statement stmt = conn.createStatement();\n      //5. 执行sql\n      int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0\n      //6. 处理结果\n      System.out.println(count);\n  \n      //7. 释放资源\n      stmt.close();\n      conn.close();\n  }',"java\nResultSet  executeQuery(sql);//执行DQL 语句，返回 ResultSet 对象",'java\n/**\n  * 执行DQL\n  * @throws Exception\n  */\n@Test\npublic void testResultSet() throws  Exception {\n    //1. 注册驱动\n    //Class.forName("com.mysql.jdbc.Driver");\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n    //3. 定义sql\n    String sql = "select * from account";\n    //4. 获取statement对象\n    Statement stmt = conn.createStatement();\n    //5. 执行sql\n    ResultSet rs = stmt.executeQuery(sql);\n    //6. 处理结果， 遍历rs中的所有数据\n    /* // 6.1 光标向下移动一行，并且判断当前行是否有数据\n        while (rs.next()){\n            //6.2 获取数据  getXxx()\n            int id = rs.getInt(1);\n            String name = rs.getString(2);\n            double money = rs.getDouble(3);\n\n            System.out.println(id);\n            System.out.println(name);\n            System.out.println(money);\n\n            System.out.println("--------------");\n\n        }*/\n    // 6.1 光标向下移动一行，并且判断当前行是否有数据\n    while (rs.next()){\n        //6.2 获取数据  getXxx()\n        int id = rs.getInt("id");\n        String name = rs.getString("name");\n        double money = rs.getDouble("money");\n\n        System.out.println(id);\n        System.out.println(name);\n        System.out.println(money);\n\n        System.out.println("--------------");\n    }\n\n    //7. 释放资源\n    rs.close();\n    stmt.close();\n    conn.close();\n}','java\n  /**\n    * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中\n    * 1. 定义实体类Account\n    * 2. 查询数据，封装到Account对象中\n    * 3. 将Account对象存入ArrayList集合中\n    */\n  @Test\n  public void testResultSet2() throws  Exception {\n      //1. 注册驱动\n      //Class.forName("com.mysql.jdbc.Driver");\n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      String url = "jdbc:mysql:///db1?useSSL=false";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n  \n      //3. 定义sql\n      String sql = "select * from account";\n  \n      //4. 获取statement对象\n      Statement stmt = conn.createStatement();\n  \n      //5. 执行sql\n      ResultSet rs = stmt.executeQuery(sql);\n  \n      // 创建集合\n      List<Account> list = new ArrayList<>();\n     \n      // 6.1 光标向下移动一行，并且判断当前行是否有数据\n      while (rs.next()){\n          Account account = new Account();\n  \n          //6.2 获取数据  getXxx()\n          int id = rs.getInt("id");\n          String name = rs.getString("name");\n          double money = rs.getDouble("money");\n  \n          //赋值\n          account.setId(id);\n          account.setName(name);\n          account.setMoney(money);\n  \n          // 存入集合\n          list.add(account);\n      }\n  \n      System.out.println(list);\n  \n      //7. 释放资源\n      rs.close();\n      stmt.close();\n      conn.close();\n  }',"properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&useUnicode=true&characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=1234","sql\ncreate database test;","sql\nselect count() from t_user where name = 'name' and password = ''or'1' = '1';",'java\n@Test\npublic void testLogin() throws  Exception {\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    // 接收用户输入 用户名和密码\n    String name = "sjdljfld";\n    String pwd = "\' or \'1\' = \'1";\n    String sql = "select * from tb_user where username = \'"+name+"\' and password = \'"+pwd+"\'";\n    // 获取stmt对象\n    Statement stmt = conn.createStatement();\n    // 执行sql\n    ResultSet rs = stmt.executeQuery(sql);\n    // 判断登录是否成功\n    if(rs.next()){\n        System.out.println("登录成功~");\n    }else{\n        System.out.println("登录失败~");\n    }\n\n    //7. 释放资源\n    rs.close();\n    stmt.close();\n    conn.close();\n}',"sql\nselect * from tb_user where username = 'sjdljfld' and password = ''or '1' = '1'",'java\n  // SQL语句中的参数值，使用？占位符替代\n  String sql = "select * from user where username = ? and password = ?";\n  // 通过Connection对象获取，并传入对应的sql语句\n  PreparedStatement pstmt = conn.prepareStatement(sql);','java\n @Test\npublic void testPreparedStatement() throws  Exception {\n    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n    String url = "jdbc:mysql:///db1?useSSL=false";\n    String username = "root";\n    String password = "1234";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    // 接收用户输入 用户名和密码\n    String name = "zhangsan";\n    String pwd = "\' or \'1\' = \'1";\n\n    // 定义sql\n    String sql = "select * from tb_user where username = ? and password = ?";\n    // 获取pstmt对象\n    PreparedStatement pstmt = conn.prepareStatement(sql);\n    // 设置？的值\n    pstmt.setString(1,name);\n    pstmt.setString(2,pwd);\n    // 执行sql\n    ResultSet rs = pstmt.executeQuery();\n    // 判断登录是否成功\n    if(rs.next()){\n        System.out.println("登录成功~");\n    }else{\n        System.out.println("登录失败~");\n    }\n    //7. 释放资源\n    rs.close();\n    pstmt.close();\n    conn.close();\n}',"sql\nselect * from tb_user where username = 'sjdljfld' and password = '\\'or \\'1\\' = \\'1'","sql\n  useServerPrepStmts=true",'log-output=FILE\n  general-log=1\n  general_log_file="D:\\mysql.log"\n  slow-query-log=1\n  slow_query_log_file="D:\\mysql_slow.log"\n  long_query_time=2','java\n   /**\n     * PreparedStatement原理\n     * @throws Exception\n     */\n  @Test\n  public void testPreparedStatement2() throws  Exception {\n  \n      //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n      // useServerPrepStmts=true 参数开启预编译功能\n      String url = "jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true";\n      String username = "root";\n      String password = "1234";\n      Connection conn = DriverManager.getConnection(url, username, password);\n  \n      // 接收用户输入 用户名和密码\n      String name = "zhangsan";\n      String pwd = "\' or \'1\' = \'1";\n  \n      // 定义sql\n      String sql = "select * from tb_user where username = ? and password = ?";\n  \n      // 获取pstmt对象\n      PreparedStatement pstmt = conn.prepareStatement(sql);\n  \n      Thread.sleep(10000);\n      // 设置？的值\n      pstmt.setString(1,name);\n      pstmt.setString(2,pwd);\n      ResultSet rs = null;\n      // 执行sql\n      rs = pstmt.executeQuery();\n  \n      // 设置？的值\n      pstmt.setString(1,"aaa");\n      pstmt.setString(2,"bbb");\n      // 执行sql\n      rs = pstmt.executeQuery();\n  \n      // 判断登录是否成功\n      if(rs.next()){\n          System.out.println("登录成功~");\n      }else{\n          System.out.println("登录失败~");\n      }\n  \n      //7. 释放资源\n      rs.close();\n      pstmt.close();\n      conn.close();\n  }',"java\n  Connection getConnection()","properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true\nusername=root\npassword=1234\n# 初始化连接数量\ninitialSize=5\n# 最大连接数\nmaxActive=10\n# 最大等待时间\nmaxWait=3000",'java\n/**\n * Druid数据库连接池演示\n */\npublic class DruidDemo {\n\n    public static void main(String[] args) throws Exception {\n        //1.导入jar包\n        //2.定义配置文件\n        //3. 加载配置文件\n        Properties prop = new Properties();\n        prop.load(new FileInputStream("jdbc-demo/src/druid.properties"));\n        //4. 获取连接池对象\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n\n        //5. 获取数据库连接 Connection\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection); //获取到了连接后就可以继续做其他操作了\n\n        //System.out.println(System.getProperty("user.dir"));\n    }\n}']},{title:"django 使用过程中发生的问题",headers:[{level:2,title:"django  为何 只允许127.0.0.1 访问服务，电脑的实际ip确不行",slug:"django-为何-只允许127-0-0-1-访问服务-电脑的实际ip确不行",link:"#django-为何-只允许127-0-0-1-访问服务-电脑的实际ip确不行",children:[{level:3,title:"1. 修改ALLOWED_HOSTS设置：",slug:"_1-修改allowed-hosts设置",link:"#_1-修改allowed-hosts设置",children:[]},{level:3,title:"2. 运行Django服务时指定监听地址：",slug:"_2-运行django服务时指定监听地址",link:"#_2-运行django服务时指定监听地址",children:[]},{level:3,title:"3. 防火墙和网络设置：",slug:"_3-防火墙和网络设置",link:"#_3-防火墙和网络设置",children:[]},{level:3,title:"4. DNS和主机名：",slug:"_4-dns和主机名",link:"#_4-dns和主机名",children:[]}]}],path:"/posts/python/django/djangoWork.html",pathLocale:"/",extraFields:["python\nALLOWED_HOSTS = ['你的实际IP地址']  # 只允许指定IP访问  \n# 或者  \nALLOWED_HOSTS = ['*']  # 允许所有IP访问（不推荐用于生产环境）","bash\npython manage.py runserver 0.0.0.0:8000"]},{title:"Java入门",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",link:"#_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",link:"#_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",link:"#_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",link:"#_1-3-常用cmd命令",children:[]},{level:3,title:"1.4 CMD练习",slug:"_1-4-cmd练习",link:"#_1-4-cmd练习",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",link:"#_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",link:"#_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",link:"#_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",link:"#_1-2下载和安装",children:[]},{level:3,title:"1.3 HelloWorld小案例",slug:"_1-3-helloworld小案例",link:"#_1-3-helloworld小案例",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",link:"#_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",link:"#_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Notepad++",slug:"_1-6-notepad",link:"#_1-6-notepad",children:[]},{level:3,title:"1.7 Java语言的发展",slug:"_1-7-java语言的发展",link:"#_1-7-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",link:"#_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",link:"#_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",link:"#_1-10-jre和jdk",children:[]}]}],path:"/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/01-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",pathLocale:"/",extraFields:["java\n1,确定自己电脑上的QQ安装在哪里\n2,启动cmd\n3,进入到启动程序QQ.exe所在的路径。\n4,输出qq.exe加回车表示启动qq。",'java\npublic class HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("HelloWorld");\n\t}\n}','java\npublicclass HelloWorld{\n    public static void main(String[] args){\n        System.out.println("HelloWorld");\n    }\n}','java\npublic class HelloWorld{\n    public static void main(String[] args){\n        system.out.println("HelloWorld");\n    }\n}',"java\npublic class HelloWorld{\n    public static void main(String[] args){\n        System.out.println(HelloWorld);\n    }\n}",'java\npublic class HelloWorld{\n    public static void main(String[] args){\n        System.out.println("HelloWorld")；\n    }\n}']},{title:"Java基础概念",headers:[{level:2,title:"1. 注释",slug:"_1-注释",link:"#_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",link:"#使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",link:"#注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",link:"#_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",link:"#_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",link:"#_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",link:"#_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",link:"#区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",link:"#_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",link:"#_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",link:"#_4-2-变量的定义格式",children:[]},{level:3,title:"4.3 变量的练习",slug:"_4-3-变量的练习",link:"#_4-3-变量的练习",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",link:"#_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",link:"#_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",link:"#_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",link:"#_5-3-定义8种基本数据类型变量",children:[]},{level:3,title:"5.4 练习1",slug:"_5-4-练习1",link:"#_5-4-练习1",children:[]},{level:3,title:"5.5 练习2",slug:"_5-5-练习2",link:"#_5-5-练习2",children:[]},{level:3,title:"5.6 练习3",slug:"_5-6-练习3",link:"#_5-6-练习3",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",link:"#_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",link:"#_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",link:"#_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",link:"#_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",link:"#_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",link:"#阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",link:"#_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",link:"#_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",link:"#_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",link:"#_8-2-idea的下载和安装",children:[]},{level:3,title:"8.3 IDEA中层级结构介绍",slug:"_8-3-idea中层级结构介绍",link:"#_8-3-idea中层级结构介绍",children:[]},{level:3,title:"8.4 IDEA中的第一个代码",slug:"_8-4-idea中的第一个代码",link:"#_8-4-idea中的第一个代码",children:[]},{level:3,title:"8.5 IDEA中类的相关操作",slug:"_8-5-idea中类的相关操作",link:"#_8-5-idea中类的相关操作",children:[]},{level:3,title:"8.6 IDEA中模块的相关操作",slug:"_8-6-idea中模块的相关操作",link:"#_8-6-idea中模块的相关操作",children:[]},{level:3,title:"8.7 IDEA中项目的相关操作",slug:"_8-7-idea中项目的相关操作",link:"#_8-7-idea中项目的相关操作",children:[]}]}],path:"/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",pathLocale:"/",extraFields:["java\n/**\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/","java\npublic class HelloWorld{\n    \n   \n}","java\npublic class VariableDemo{\n\tpublic static void main(String[] args){\n\t\t//定义一个整数类型的变量\n\t\t//数据类型 变量名 = 数据值;\n\t\tint a = 16;\n\t\tSystem.out.println(a);//16\n\t\t\n\t\t//定义一个小数类型的变量\n\t\tdouble b = 10.1;\n\t\tSystem.out.println(b);//10.1\n\t}\n}","java\npublic class VariableDemo2{\n\tpublic static void main(String[] args){\n\t\t//1.变量名不允许重复\n\t\t//int a = 10;\n\t\t//int a = 20;\n\t\t//System.out.println(a);\n\t\t\n\t\t//2.一条语句可以定义多个变量\n\t\t//了解。\n\t\t//int a = 10, b = 20, c = 20,d = 20;\n\t\t//System.out.println(a);//?\n\t\t//System.out.println(b);//?\n\t\t\n\t\t\n\t\t//3.变量在使用之前必须要赋值\n\t\tint a = 30;\n\t\tSystem.out.println(a);\n\t}\n}","java\npublic class VariableTest1{\n\t//主入口\n\tpublic static void main(String[] args){\n\t\t//一开始没有乘客。\n\t\tint count = 0;\n\t\t//第一站：上去一位乘客\n\t\t//在原有的基础上 + 1\n\t\tcount = count + 1;\n\t\t//System.out.println(count);\n\t\t//第二站：上去两位乘客，下来一位乘客\n\t\tcount = count + 2 - 1; \n\t\t//第三站：上去两位乘客，下来一位乘客\n\t\tcount = count + 2 - 1;\n\t\t//第四站：下来一位乘客\n\t\tcount = count - 1;\n\t\t//第五站：上去一位乘客\n\t\tcount = count + 1;\n\t\t//请问：到了终点站，车上一共几位乘客。\n\t\tSystem.out.println(count);//3\n\t}\n}","java\npublic class VariableDemo3{\n    public static void main(String[] args){\n        //1.定义byte类型的变量\n        //数据类型 变量名 = 数据值;\n        byte a = 10;\n        System.out.println(a);\n\n        //2.定义short类型的变量\n        short b = 20;\n        System.out.println(b);\n\n        //3.定义int类型的变量\n        int c = 30;\n        System.out.println(c);\n\n        //4.定义long类型的变量\n        long d = 123456789123456789L;\n        System.out.println(d);\n\n        //5.定义float类型的变量\n        float e = 10.1F;\n        System.out.println(e);\n\n        //6.定义double类型的变量\n        double f = 20.3;\n        System.out.println(f);\n\n        //7.定义char类型的变量\n        char g = 'a';\n        System.out.println(g);\n\n        //8.定义boolean类型的变量\n        boolean h = true;\n        System.out.println(h);\n\n    }\n}","java\npublic class VariableTest1{\n\tpublic static void main(String[] args){\n\t\t//1.定义字符串类型的变量记录老师的姓名\n\t\tString name = \"黑马谢广坤\";\n\t\t//2.定义整数类型的变量记录老师的年龄\n\t\tint age = 18;\n\t\t//3.定义字符类型的变量记录老师的性别\n\t\tchar gender = '男';\n\t\t//4.定义小数类型的变量记录老师的身高\n\t\tdouble height = 180.1;\n\t\t//5.定义布尔类型的变量记录老师的婚姻状况\n\t\tboolean flag = true;\n\t\t\n\t\t//输出5个变量的值\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(age);\n\t\tSystem.out.println(gender);\n\t\tSystem.out.println(height);\n\t\tSystem.out.println(flag);\n\t\t\n\t}\n}",'java\npublic class VariableTest2{\n\tpublic static void main(String[] args){\n\t\t//1.定义字符串变量记录电影的名称\n\t\tString movie = "送初恋回家";\n\t\t//2.定义三个变量记录主演的名字\n\t\tString name1 = "刘鑫";\n\t\tString name2 = "张雨提";\n\t\tString name3 = "高媛";\n\t\t//3. 定义整数类型的变量记录年龄的年份\n\t\tint year = 2020;\n\t\t//4.定义小数类型的变量记录电影的评分\n\t\tdouble score = 9.0;\n\t\t\n\t\t//打印变量的信息\n\t\tSystem.out.println(movie);\n\t\tSystem.out.println(name1);\n\t\tSystem.out.println(name2);\n\t\tSystem.out.println(name3);\n\t\tSystem.out.println(year);\n\t\tSystem.out.println(score);\n\t\t\n\t}\n}','java\npublic class VariableTest3{\n\tpublic static void main(String[] args){\n\t\t//1.定义小数类型的变量记录手机的价格\n\t\tdouble price = 5299.0;\n\t\t\n\t\t//2.定义字符串类型的变量记录手机的品牌\n\t\tString brand = "华为";\n\t\t\n\t\t//输出变量记录的值\n\t\tSystem.out.println(price);\n\t\tSystem.out.println(brand);\n\t}\n}','java\n//导包，其实就是先找到Scanner这个类在哪\nimport java.util.Scanner;\npublic class ScannerDemo1{\n\tpublic static void main(String[] args){\n\t\t//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。\n\t\tScanner sc = new Scanner(System.in);\n\t\t//3.接收数据\n\t\t//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了\n\t\tSystem.out.println("请输入一个数字");\n\t\tint i = sc.nextInt();\n\t\tSystem.out.println(i);\n\t}\n}']},{title:"运算符和表达式",headers:[{level:2,title:"1.运算符和表达式概括",slug:"_1-运算符和表达式概括",link:"#_1-运算符和表达式概括",children:[{level:3,title:"运算符：",slug:"运算符",link:"#运算符",children:[]},{level:3,title:"表达式：",slug:"表达式",link:"#表达式",children:[]}]},{level:2,title:"2.算术运算符",slug:"_2-算术运算符",link:"#_2-算术运算符",children:[{level:3,title:"练习：数值拆分",slug:"练习-数值拆分",link:"#练习-数值拆分",children:[]}]},{level:2,title:"3.隐式转换",slug:"_3-隐式转换",link:"#_3-隐式转换",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]},{level:3,title:"简单记忆：",slug:"简单记忆",link:"#简单记忆",children:[]},{level:3,title:"两种提升规则：",slug:"两种提升规则",link:"#两种提升规则",children:[]},{level:3,title:"取值范围从小到大的关系：",slug:"取值范围从小到大的关系",link:"#取值范围从小到大的关系",children:[]}]},{level:2,title:"4.隐式转换的练习",slug:"_4-隐式转换的练习",link:"#_4-隐式转换的练习",children:[{level:3,title:"案例一：",slug:"案例一",link:"#案例一",children:[]},{level:3,title:"案例二：",slug:"案例二",link:"#案例二",children:[]},{level:3,title:"案例三：",slug:"案例三",link:"#案例三",children:[]},{level:3,title:"案例四：",slug:"案例四",link:"#案例四",children:[]},{level:3,title:"案例五：",slug:"案例五",link:"#案例五",children:[]},{level:3,title:"案例六：",slug:"案例六",link:"#案例六",children:[]}]},{level:2,title:"5.强制转换",slug:"_5-强制转换",link:"#_5-强制转换",children:[{level:3,title:"概念：",slug:"概念-1",link:"#概念-1",children:[]},{level:3,title:"书写格式：",slug:"书写格式",link:"#书写格式",children:[]}]},{level:2,title:"6.字符串的+操作",slug:"_6-字符串的-操作",link:"#_6-字符串的-操作",children:[{level:3,title:"核心技巧：",slug:"核心技巧",link:"#核心技巧",children:[]}]},{level:2,title:"7.字符串相加的练习：",slug:"_7-字符串相加的练习",link:"#_7-字符串相加的练习",children:[]},{level:2,title:"8.字符的+操作",slug:"_8-字符的-操作",link:"#_8-字符的-操作",children:[{level:3,title:"规则：",slug:"规则",link:"#规则",children:[]},{level:3,title:"案例：",slug:"案例",link:"#案例",children:[]}]},{level:2,title:"9.算术运算符的总结",slug:"_9-算术运算符的总结",link:"#_9-算术运算符的总结",children:[]},{level:2,title:"10.自增自减运算符",slug:"_10-自增自减运算符",link:"#_10-自增自减运算符",children:[{level:3,title:"分类：",slug:"分类",link:"#分类",children:[]},{level:3,title:"使用方式：",slug:"使用方式",link:"#使用方式",children:[]},{level:3,title:"注意点：",slug:"注意点",link:"#注意点",children:[]},{level:3,title:"案例：",slug:"案例-1",link:"#案例-1",children:[]},{level:3,title:"自增自减运算符的应用场景：",slug:"自增自减运算符的应用场景",link:"#自增自减运算符的应用场景",children:[]}]},{level:2,title:"11.赋值运算符",slug:"_11-赋值运算符",link:"#_11-赋值运算符",children:[]},{level:2,title:"12.扩展赋值运算符",slug:"_12-扩展赋值运算符",link:"#_12-扩展赋值运算符",children:[{level:3,title:"分类：",slug:"分类-1",link:"#分类-1",children:[]},{level:3,title:"运算规则：",slug:"运算规则",link:"#运算规则",children:[]},{level:3,title:"案例：",slug:"案例-2",link:"#案例-2",children:[]},{level:3,title:"注意点：",slug:"注意点-1",link:"#注意点-1",children:[]}]},{level:2,title:"13.关系运算符",slug:"_13-关系运算符",link:"#_13-关系运算符",children:[{level:3,title:"分类：",slug:"分类-2",link:"#分类-2",children:[]},{level:3,title:"注意点：",slug:"注意点-2",link:"#注意点-2",children:[]}]},{level:2,title:"14.逻辑运算符",slug:"_14-逻辑运算符",link:"#_14-逻辑运算符",children:[{level:3,title:"& 和 | 的使用：",slug:"和-的使用",link:"#和-的使用",children:[]},{level:3,title:"使用场景：",slug:"使用场景",link:"#使用场景",children:[]},{level:3,title:"^（异或）的使用：",slug:"异或-的使用",link:"#异或-的使用",children:[]},{level:3,title:"!（取反）的使用：",slug:"取反-的使用",link:"#取反-的使用",children:[]}]},{level:2,title:"15.短路逻辑运算符",slug:"_15-短路逻辑运算符",link:"#_15-短路逻辑运算符",children:[{level:3,title:"&&：",slug:"",link:"#",children:[]},{level:3,title:"||：",slug:"-1",link:"#-1",children:[]},{level:3,title:"逻辑核心：",slug:"逻辑核心",link:"#逻辑核心",children:[]},{level:3,title:"举例：",slug:"举例",link:"#举例",children:[]},{level:3,title:"总结：",slug:"总结",link:"#总结",children:[]},{level:3,title:"建议：",slug:"建议",link:"#建议",children:[]}]},{level:2,title:"16.三元运算符",slug:"_16-三元运算符",link:"#_16-三元运算符",children:[{level:3,title:"格式：",slug:"格式",link:"#格式",children:[]},{level:3,title:"计算规则：",slug:"计算规则",link:"#计算规则",children:[]},{level:3,title:"注意点：",slug:"注意点-3",link:"#注意点-3",children:[]},{level:3,title:"案例：",slug:"案例-3",link:"#案例-3",children:[]}]},{level:2,title:"17.练习1-两只老虎",slug:"_17-练习1-两只老虎",link:"#_17-练习1-两只老虎",children:[]},{level:2,title:"18.练习2-求三个数的最大值",slug:"_18-练习2-求三个数的最大值",link:"#_18-练习2-求三个数的最大值",children:[]},{level:2,title:"19.运算符的优先级",slug:"_19-运算符的优先级",link:"#_19-运算符的优先级",children:[]}],path:"/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/03%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:["java\n+ - * / %","java\n+ - * :跟小学数学中一模一样没有任何区别.","java\n/：\n1.整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。\n2.小数直接参与运算，得到的结果有可能是不精确的。\n案例：\nSystem.out.println( 10 / 3);//3\nSystem.out.println(10.0 / 3);//3.3333333333333335","java\n%：取模、取余。\n   他做的也是除法运算，只不过获取的是余数而已。\n案例：\nSystem.out.println(10 % 2);//0\nSystem.out.println(10 % 3);//1\n应用场景：\n//可以利用取模来判断一个数是奇数还是偶数\nSystem.out.println(15 % 2);//1  奇数",'java\n//1.键盘录入一个三位数\n//导包 --- 创建对象 --- 接收数据\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个三位数");\nint number = sc.nextInt();//123\n\n//2.获取这个三位数的个位、十位、百位并打印出来\n//公式：\n//针对于任意的一个数而言\n//个位： 数字 % 10\nint ones = number % 10;\n//十位： 数字 / 10 % 10\nint tens = number / 10 % 10;\n//百位： 数字 / 100 % 10\nint hundreds = number / 100  % 10;\n\n//输出结果\nSystem.out.println(ones);\nSystem.out.println(tens);\nSystem.out.println(hundreds);',"java\ndouble d = 10;\nSystem.out.println(d);//10.0","java\nbyte b = 100;\nint i = b;//可以成功赋值","java\nint i = 10;\nlong n = 20L;\n??? result = i + n;\n问变量result是什么类型的？","java\nint i = 10;\nlong n = 100L;\ndouble d = 20.0;\n??? result = i + n + d;\n问变量result是什么类型的？","java\nbyte b1 = 10;\nbyte b2 = 20;\n??? result = b1 + b2;//int\n问变量result是什么类型的？","java\nbyte b = 10;\nshort s = 20;\nlong n = 100L;\n??? result = b + s + n;\n问变量result是什么类型的？long","java\npublic class OperatorDemo2 {\n    public static void main(String[] args) {\n        double a = 12.3;\n        int b = (int) a;\n        System.out.println(b);//12\n    }\n}",'java\n1 + "abc" + 1','java\n1 + 2 + "abc" + 2 + 1','java\nString name = "黑默丁格";\nSystem.out.println("我的名字是" + name);',"java\nchar c = 'a';\nint result = c + 0;\nSystem.out.println(result);//97","java\n+ - * / %  这些操作跟小学数学几乎是一模一样的。","java\n++  自增运算符\n--  自减运算符","java\n//++\nint a = 10;\na++;//就是让变量a里面的值 + 1\nSystem.out.println(a);//11\n++a;//就是让变量a里面的值 + 1\nSystem.out.println(a);//12","java\npublic class OperatorDemo6 {\n    public static void main(String[] args) {\n        //1.最为简单的赋值运算符用法\n        int a = 10;//就是把10赋值给变量a\n        System.out.println(a);\n\n        //2.如果等号右边需要进行计算。\n        int b = 20;\n        int c = a + b;//先计算等号右边的，把计算的结果赋值给左边的变量\n        System.out.println(c);\n\n        //3.特殊的用法\n        a = a + 10;//先计算等号右边的，把计算的结果赋值给左边的变量\n        System.out.println(a);//20\n    }\n}","java\npublic class OperatorDemo7 {\n    public static void main(String[] args) {\n        //扩展赋值运算符\n        int a = 10;\n        int b = 20;\n        a += b;//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响\n        // 相当于 a = a + b;\n        System.out.println(a);//30\n        System.out.println(b);//20\n    }\n}","java\npublic class OperatorDemo8 {\n    public static void main(String[] args) {\n        byte a = 10;\n        byte b = 20;\n        //a += b;\n        a = (byte)(a + b);\n        System.out.println(a);//30\n    }\n}",'java\n// &  //两边都是真，结果才是真。\nSystem.out.println(true & true);//true\nSystem.out.println(false & false);//false\nSystem.out.println(true & false);//false\nSystem.out.println(false & true);//false\n\nSystem.out.println("===================================");\n\n// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。\nSystem.out.println(true | true);//true\nSystem.out.println(false | false);//false\nSystem.out.println(true | false);//true\nSystem.out.println(false | true);//true',"java\n//^   //左右不相同，结果才是true，左右相同结果就是false\nSystem.out.println(true ^ true);//false\nSystem.out.println(false ^ false);//false\nSystem.out.println(true ^ false);//true\nSystem.out.println(false ^ true);//true","java\nSystem.out.println(!false);//true\nSystem.out.println(!true);//false\n\nSystem.out.println(!!false);//注意点：取反最多只用一个。","java\npublic class OperatorDemo12 {\n    public static void main(String[] args) {\n        //需求：求两个数的较大值\n        int a = 10;\n        int b = 20;\n\n        //格式：关系表达式 ？ 表达式1 ： 表达式2 ；\n        //注意点：\n        //三元运算符的最终结果一定要被使用。\n        //要么赋值给一个变量，要么直接输出。\n       int max =  a > b ? a : b ;\n        System.out.println(max);\n\n\n        System.out.println(a > b ? a : b);\n    }\n}",'java\n//1.获取两只老虎的体重\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入第一只老虎的体重");\nint weight1 = sc.nextInt();\nSystem.out.println("请输入第二只老虎的体重");\nint weight2 = sc.nextInt();\n\n//2.利用三元运算符求出最终结果\nString result = weight1 == weight2 ? "相同" : "不相同";\nSystem.out.println(result);',"java\n//1.定义三个变量记录和尚的身高\nint height1 = 150;\nint height2 = 210;\nint height3 = 165;\n\n//2.利用三元运算符求出两个数中的较大值。\nint temp = height1 > height2 ? height1 : height2;\n\n//3.求出最终的结果\nint max = temp > height3 ? temp : height3;\n\nSystem.out.println(max);"]},{title:"流程控制语句",headers:[{level:2,title:"第一章 流程控制语句",slug:"第一章-流程控制语句",link:"#第一章-流程控制语句",children:[{level:3,title:"1.1 流程控制语句分类",slug:"_1-1-流程控制语句分类",link:"#_1-1-流程控制语句分类",children:[]},{level:3,title:"1.2 顺序结构",slug:"_1-2-顺序结构",link:"#_1-2-顺序结构",children:[]}]},{level:2,title:"第二章 判断语句：if语句",slug:"第二章-判断语句-if语句",link:"#第二章-判断语句-if语句",children:[{level:3,title:"2.1 if语句格式1",slug:"_2-1-if语句格式1",link:"#_2-1-if语句格式1",children:[]},{level:3,title:"2.2 if语句格式2",slug:"_2-2-if语句格式2",link:"#_2-2-if语句格式2",children:[]},{level:3,title:"2.3 if语句格式3",slug:"_2-3-if语句格式3",link:"#_2-3-if语句格式3",children:[]}]},{level:2,title:"第三章 switch语句",slug:"第三章-switch语句",link:"#第三章-switch语句",children:[{level:3,title:"3.1 格式",slug:"_3-1-格式",link:"#_3-1-格式",children:[]},{level:3,title:"3.2 执行流程：",slug:"_3-2-执行流程",link:"#_3-2-执行流程",children:[]},{level:3,title:"3.3 switch的扩展知识：",slug:"_3-3-switch的扩展知识",link:"#_3-3-switch的扩展知识",children:[]}]},{level:2,title:"第四章 循环结构",slug:"第四章-循环结构",link:"#第四章-循环结构",children:[{level:3,title:"4.1 for循环结构（掌握）",slug:"_4-1-for循环结构-掌握",link:"#_4-1-for循环结构-掌握",children:[]},{level:3,title:"4.2 while循环",slug:"_4-2-while循环",link:"#_4-2-while循环",children:[]},{level:3,title:"4.3 do...while循环",slug:"_4-3-do-while循环",link:"#_4-3-do-while循环",children:[]},{level:3,title:"4.4 三种格式的区别：",slug:"_4-4-三种格式的区别",link:"#_4-4-三种格式的区别",children:[]}]}],path:"/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",pathLocale:"/",extraFields:["java\n格式：\nif (关系表达式) {\n    语句体;\t\n}",'java\npublic class IfDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("开始");\t\n\t\t//定义两个变量\n\t\tint a = 10;\n\t\tint b = 20;\t\n\t\t//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b\n\t\tif(a == b) {\n\t\t\tSystem.out.println("a等于b");\n\t\t}\t\t\n\t\t//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c\n\t\tint c = 10;\n\t\tif(a == c) {\n\t\t\tSystem.out.println("a等于c");\n\t\t}\t\t\n\t\tSystem.out.println("结束");\n\t}\n}','java\n//分析：\n//1.键盘录入女婿的酒量\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入女婿的酒量");\nint wine = sc.nextInt();//5\n//2.对酒量进行一个判断即可\nif(wine > 2) {\n    System.out.println("不错哟，小伙子！");\n}','java\n//分析：\n//1.键盘录入一个整数，表示小明的考试名次\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入小明的名次");\nint rank = sc.nextInt();\n//2.对小明的考试成绩进行判断即可\nif(rank == 1){\n    System.out.println("小红成为了小明的女朋友");\n}',"java\n格式：\nif (关系表达式) {\n    语句体1;\t\n} else {\n    语句体2;\t\n}",'java\npublic class IfDemo02 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("开始");\t\t\n\t\t//定义两个变量\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b\n\t\tif(a > b) {\n\t\t\tSystem.out.println("a的值大于b");\n\t\t} else {\n\t\t\tSystem.out.println("a的值不大于b");\n\t\t}\t\t\n\t\tSystem.out.println("结束");\n\t}\n}','java\n//分析：\n//1.键盘录入一个整数。表示身上的钱。\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个整数表示身上的钱");\nint money = sc.nextInt();\n//2.对钱进行判断\nif(money >= 100){\n    System.out.println("吃网红餐厅");\n}else{\n    System.out.println("福建大酒店");\n}','java\n//分析：\n//1.键盘录入票号\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入票号");\nint ticket = sc.nextInt();\nif(ticket >= 1 && ticket <= 100){\n    //合法\n    //2.对票号进行判断\n    if (ticket % 2 == 0) {\n        //偶数\n        System.out.println("坐右边");\n    } else {\n        //奇数\n        System.out.println("坐左边");\n    }\n}else{\n    //票号不合法\n    System.out.println("票号不合法");\n}',"java\n格式：\nif (关系表达式1) {\n    语句体1;\t\n} else if (关系表达式2) {\n    语句体2;\t\n} \n…\nelse {\n    语句体n+1;\n}",'java\n//95~100 自行车一辆\n//90~94   游乐场玩一天\n//80 ~ 89 变形金刚一个\n//80 以下  胖揍一顿\n\n//1.键盘录入一个值表示小明的分数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入小明的成绩");\nint score = sc.nextInt();\n//2.对分数的有效性进行判断\nif(score >= 0 && score <= 100){\n    //有效的分数\n    //3.对小明的分数进行判断，不同情况执行不同的代码\n    if(score >= 95 && score <= 100){\n        System.out.println("送自行车一辆");\n    }else if(score >= 90 && score <= 94){\n        System.out.println("游乐场玩一天");\n    }else if(score >= 80 && score <= 89){\n        System.out.println("变形金刚一个");\n    }else{\n        System.out.println("胖揍一顿");\n    }\n}else{\n    //无效的分数\n    System.out.println("分数不合法");\n}',"java\nswitch (表达式) {\n\tcase 1:\n\t\t语句体1;\n\t\tbreak;\n\tcase 2:\n\t\t语句体2;\n\t\tbreak;\n\t...\n\tdefault:\n\t\t语句体n+1;\n\t\tbreak;\n}",'java\npackage a01switch选择语句;\n\nimport java.util.Scanner;\n\npublic class SwitchDemo2 {\n    public static void main(String[] args) {\n        //1.键盘录入一个整数表示星期\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个整数表示星期");\n        int week = sc.nextInt();\n\n        //2.书写一个switch语句去跟week进行匹配\n        switch (week){\n            case 1:\n                System.out.println("跑步");\n                break;\n            case 2:\n                System.out.println("游泳");\n                break;\n            case 3:\n                System.out.println("慢走");\n                break;\n            case 4:\n                System.out.println("动感单车");\n                break;\n            case 5:\n                System.out.println("拳击");\n                break;\n            case 6:\n                System.out.println("爬山");\n                break;\n            case 7:\n                System.out.println("好好吃一顿");\n                break;\n            default:\n                System.out.println("输入错误，没有这个星期");\n                break;\n        }\n    }\n}','java\nint number = 10;\nswitch (number) {\n    case 1 -> System.out.println("一");\n    case 2 -> System.out.println("二");\n    case 3 -> System.out.println("三");\n    default -> System.out.println("其他");\n}','java\n//分析：\n//1.键盘录入星期数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入星期");\nint week = sc.nextInt();//3\n//2.利用switch进行匹配\n----------------------------------------------------\n利用case穿透简化代码\nswitch (week){\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        System.out.println("工作日");\n        break;\n    case 6:\n    case 7:\n        System.out.println("休息日");\n        break;\n    default:\n        System.out.println("没有这个星期");\n        break;\n}\n----------------------------------------------------\n利用JDK12简化代码书写\nswitch (week) {\n    case 1, 2, 3, 4, 5 -> System.out.println("工作日");\n    case 6, 7 -> System.out.println("休息日");\n    default -> System.out.println("没有这个星期");\n}',"java\nfor (初始化语句;条件判断语句;条件控制语句) {\n\t循环体语句;\n}",'java\n//1.确定循环的开始条件\n//2.确定循环的结束条件\n//3.确定要重复执行的代码\n\n//需求：打印5次HelloWorld\n//开始条件：1\n//结束条件：5\n//重复代码：打印语句\n\nfor (int i = 1; i <= 5; i++) {\n    System.out.println("HelloWorld");\n}','java\npublic class ForTest01 {\n    public static void main(String[] args) {\n\t\t//需求：输出数据1-5\n        for(int i=1; i<=5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t\tSystem.out.println("--------");\n\t\t//需求：输出数据5-1\n\t\tfor(int i=5; i>=1; i--) {\n\t\t\tSystem.out.println(i);\n\t\t}\n    }\n}','java\npublic class ForTest02 {\n    public static void main(String[] args) {\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n\t\tint sum = 0;\n\t\t//从1开始到5结束的数据，使用循环结构完成\n\t\tfor(int i=1; i<=5; i++) {\n\t\t\t//将反复进行的事情写入循环结构内部\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\n\t\t\tsum = sum + i;\n\t\t\t/*\n\t\t\t\tsum += i;\tsum = sum + i;\n\t\t\t\t第一次：sum = sum + i = 0 + 1 = 1;\n\t\t\t\t第二次：sum = sum + i = 1 + 2 = 3;\n\t\t\t\t第三次：sum = sum + i = 3 + 3 = 6;\n\t\t\t\t第四次：sum = sum + i = 6 + 4 = 10;\n\t\t\t\t第五次：sum = sum + i = 10 + 5 = 15;\n\t\t\t*/\n\t\t}\n\t\t//当循环执行完毕时，将最终数据打印出来\n\t\tSystem.out.println("1-5之间的数据和是：" + sum);\n    }\n}','java\npublic class ForTest03 {\n    public static void main(String[] args) {\n\t\t//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n\t\tint sum = 0;\n\t\t//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\n\t\tfor(int i=1; i<=100; i++) {\n\t\t\t//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\n\t\t\tif(i%2 == 0) {\n                //sum += i；\n\t\t\t\tsum = sum + i;\n\t\t\t}\n\t\t}\n\t\t//当循环执行完毕时，将最终数据打印出来\n\t\tSystem.out.println("1-100之间的偶数和是：" + sum);\n    }\n}',"java","java\n初始化语句;\nwhile(条件判断语句){\n\t循环体;\n\t条件控制语句;\n}",'java\nint i = 1;\nwhile(i <= 5){\n    System.out.println("HelloWorld");\n    i++;\n}\nSystem.out.println(i);',"java\n//1.定义一个变量表示珠穆朗玛峰的高度\nint height = 8844430;\n//2.定义一个变量表示纸张的厚度\ndouble paper = 0.1;\n\n//定义一个计数器（变量），用来统计折叠的次数\nint count = 0;\n\n//3.循环折叠纸张\n//只有纸张的厚度 < 穆朗玛峰的高度 循环才继续，否则循环就停止\n//坑：只有判断为真，循环才会继续\nwhile(paper < height){\n    //折叠纸张\n    paper = paper * 2;\n    count++;\n}\n\n//4.打印一下纸张的厚度\nSystem.out.println(count);//27","java\n初始化语句;\ndo{\n    循环体;\n    条件控制语句;\n}while(条件判断语句);"]},{title:"循环高级",headers:[{level:2,title:"1.无限循环",slug:"_1-无限循环",link:"#_1-无限循环",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]},{level:3,title:"for格式：",slug:"for格式",link:"#for格式",children:[]},{level:3,title:"while格式：",slug:"while格式",link:"#while格式",children:[]},{level:3,title:"do...while格式：",slug:"do-while格式",link:"#do-while格式",children:[]},{level:3,title:"无限循环的注意事项：",slug:"无限循环的注意事项",link:"#无限循环的注意事项",children:[]}]},{level:2,title:"2.条件控制语句",slug:"_2-条件控制语句",link:"#_2-条件控制语句",children:[{level:3,title:"break:",slug:"break",link:"#break",children:[]},{level:3,title:"continue:",slug:"continue",link:"#continue",children:[]}]},{level:2,title:"3. Random",slug:"_3-random",link:"#_3-random",children:[{level:3,title:"使用步骤：",slug:"使用步骤",link:"#使用步骤",children:[]}]},{level:2,title:"4. 逢七过",slug:"_4-逢七过",link:"#_4-逢七过",children:[]},{level:2,title:"5. 平方根",slug:"_5-平方根",link:"#_5-平方根",children:[]},{level:2,title:"6.判断是否为质数",slug:"_6-判断是否为质数",link:"#_6-判断是否为质数",children:[]},{level:2,title:"7. 猜数字小游戏",slug:"_7-猜数字小游戏",link:"#_7-猜数字小游戏",children:[]}],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.html",pathLocale:"/",extraFields:['java\nfor(;;){\n    System.out.println("循环执行一直在打印内容");\n}','java\nwhile(true){\n    System.out.println("循环执行一直在打印内容");\n}','java\ndo{\n    System.out.println("循环执行一直在打印内容");\n}while(true);','java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    System.out.println("在吃第" + i + "个包子");\n    //2.吃完第三个的时候就不吃了\n    if(i == 3){\n        break;//结束整个循环。\n    }\n}','java\n//1.吃1~5号包子\nfor (int i = 1; i <= 5; i++) {\n    //2.第3个包子有虫子就跳过，继续吃下面的包子\n    if(i == 3){\n        //跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。\n        continue;\n    }\n    System.out.println("在吃第" + i + "个包子");\n}',"java\nimport java.util.Random;\n导包的动作必须出现在类定义的上边。","java\nRandom r = new Random ();\n上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。","java\nint number = r.nextInt(随机数的范围);\n上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。\n随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10)","java\n//1.导包\nimport java.util.Random;\n\npublic class RandomDemo1 {\n    public static void main(String[] args) {\n        //2.创建对象\n        Random r = new Random();\n        //3.生成随机数\n        int number = r.nextInt(100);//包左不包右，包头不包尾\n        //0 ~ 99\n        System.out.println(number);\n\n    }\n}",'java\n/*朋友聚会的时候可能会玩一个游戏：逢7过\n        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过\n        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/\n//分析：\n//个位7  十位7   7倍数\n//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....\n//69 过 过 过 过 过 过... 80\n//1.得到1~100之间的每一个数字\n//开始：1\n//结束：100\nfor (int i = 1; i <= 100; i++) {\n    //2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字\n    if(i % 10 == 7 || i / 10 % 10 == 7  ||  i % 7 == 0){\n        System.out.println("过");\n        continue;\n    }\n    System.out.println(i);\n}','java\n/*需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。\n        结果只保留整数部分 ，小数部分将被舍去 。*/\n\n\n//分析：\n//平方根   16的平方根4\n//         4的平方根2\n\n\n// 10\n// 1 * 1 = 1 < 10\n// 2 * 2 = 4 < 10\n// 3 * 3 = 9 < 10\n// 4 * 4 = 16 > 10\n//推断：10的平方根是在3~4之间。\n\n\n// 20\n// 1 * 1 = 1 < 20\n// 2 * 2 = 4 < 20\n// 3 * 3 = 9 < 20\n// 4 * 4 = 16 < 20\n// 5 * 5 = 25 > 20\n//推断：20的平方根是在4~5之间。\n\n\n//在代码当中\n//从1开始循环，拿着数字的平方跟原来的数字进行比较\n//如果小于的，那么继续往后判断\n//如果相等，那么当前数字就是平方根\n//如果大于的，那么前一个数字就是平方跟的整数部分\n\n\n//1.键盘录入一个整数\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个整数");\nint number = sc.nextInt();\n//2.从1开始循环判断\n//开始：1 结束: number\nfor (int i = 1; i <= number; i++) {\n    //用i * i 再跟number进行比较\n    if(i * i == number){\n        System.out.println(i + "就是" + number + "的平方根");\n        //一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。\n        break;\n    }else if(i * i > number){\n        System.out.println((i - 1) + "就是" + number + "平方根的整数部分");\n        break;\n    }\n}','java\n//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。\n\n//质数：\n//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数\n//7 = 1 * 7 质数\n//8 = 1 * 8  2 * 4 合数\n\n\n//分析：\n//1.键盘录入一个正整数\n//number\nScanner sc = new Scanner(System.in);\nSystem.out.println("请输入一个正整数");\nint number = sc.nextInt();//9\n\n//定义一个变量，表示标记\n//标记着number是否为一个质数\n//true： 是一个质数\n//false : 不是一个质数\n\n//表示最初就认为number是一个质数\nboolean flag = true;\n\n\n//2.判断\n//写一个循环，从2开始判断，一直判断到number-1为止\n//看这个范围之内，有没有数字可以被number整除\nfor (int i = 2; i < number; i++) {\n    //i 依次表示这个范围之内的每一个数字\n    //看number是否能被i整除就可以了\n    if(number % i == 0){// 9 % 2 = 1\n        flag = false;\n        //System.out.println(number + "不是一个质数");\n        break;\n    }/*else{\n                System.out.println(number + "是一个质数");\n            }*/\n}\n\n//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了\n//此时才能断定number是一个质数\nif(flag){\n    System.out.println(number + "是一个质数");\n}else{\n    System.out.println(number + "不是一个质数");\n}','java\n//1.生成一个1-100之间的随机数\nRandom r = new Random();\nint number = r.nextInt(100) + 1;// 0 ~ 99 + 1 --- 1 ~ 100\nSystem.out.println(number);\n\n//2.使用键盘录入去猜出这个数字是多少？\nScanner sc = new Scanner(System.in);\nwhile(true){\n    System.out.println("请输入一个整数");\n    int guessNumber = sc.nextInt();\n    //3.比较\n    if(guessNumber > number){\n        System.out.println("您猜的数字大了");\n    }else if(guessNumber < number){\n        System.out.println("您猜的数字小了");\n    }else{\n        System.out.println("恭喜你，猜中了");\n        break;\n    }\n}']},{title:"数组",headers:[{level:2,title:"1.数组",slug:"_1-数组",link:"#_1-数组",children:[{level:3,title:"概念：",slug:"概念",link:"#概念",children:[]}]},{level:2,title:"2.数组的定义",slug:"_2-数组的定义",link:"#_2-数组的定义",children:[{level:3,title:"格式一：",slug:"格式一",link:"#格式一",children:[]},{level:3,title:"格式二：",slug:"格式二",link:"#格式二",children:[]},{level:3,title:"详解：",slug:"详解",link:"#详解",children:[]},{level:3,title:"注意点：",slug:"注意点",link:"#注意点",children:[]}]},{level:2,title:"3.数组的静态初始化",slug:"_3-数组的静态初始化",link:"#_3-数组的静态初始化",children:[{level:3,title:"完整格式：",slug:"完整格式",link:"#完整格式",children:[]},{level:3,title:"格式详解：",slug:"格式详解",link:"#格式详解",children:[]},{level:3,title:"注意点：",slug:"注意点-1",link:"#注意点-1",children:[]},{level:3,title:"简化格式:",slug:"简化格式",link:"#简化格式",children:[]},{level:3,title:"练习1：",slug:"练习1",link:"#练习1",children:[]},{level:3,title:"练习2：",slug:"练习2",link:"#练习2",children:[]},{level:3,title:"练习3：",slug:"练习3",link:"#练习3",children:[]}]},{level:2,title:"4.地址值",slug:"_4-地址值",link:"#_4-地址值",children:[]},{level:2,title:"5.数组元素访问",slug:"_5-数组元素访问",link:"#_5-数组元素访问",children:[{level:3,title:"格式：",slug:"格式",link:"#格式",children:[]},{level:3,title:"作用：",slug:"作用",link:"#作用",children:[]},{level:3,title:"代码示例：",slug:"代码示例",link:"#代码示例",children:[]}]},{level:2,title:"6.索引",slug:"_6-索引",link:"#_6-索引",children:[{level:3,title:"索引的特点：",slug:"索引的特点",link:"#索引的特点",children:[]}]},{level:2,title:"7.数组的遍历",slug:"_7-数组的遍历",link:"#_7-数组的遍历",children:[]},{level:2,title:"8.数组的动态初始化",slug:"_8-数组的动态初始化",link:"#_8-数组的动态初始化",children:[{level:3,title:"格式：",slug:"格式-1",link:"#格式-1",children:[]},{level:3,title:"举例：",slug:"举例",link:"#举例",children:[]},{level:3,title:"数组的默认初始化值：",slug:"数组的默认初始化值",link:"#数组的默认初始化值",children:[]}]},{level:2,title:"9.数组两种初始化方式的区别",slug:"_9-数组两种初始化方式的区别",link:"#_9-数组两种初始化方式的区别",children:[{level:3,title:"使用场景：",slug:"使用场景",link:"#使用场景",children:[]},{level:3,title:"举例：",slug:"举例-1",link:"#举例-1",children:[]}]},{level:2,title:"10.数组常见问题",slug:"_10-数组常见问题",link:"#_10-数组常见问题",children:[]},{level:2,title:"11.数组的练习",slug:"_11-数组的练习",link:"#_11-数组的练习",children:[{level:3,title:"练习1：求和",slug:"练习1-求和",link:"#练习1-求和",children:[]},{level:3,title:"练习2：统计个数",slug:"练习2-统计个数",link:"#练习2-统计个数",children:[]},{level:3,title:"练习3：变化数据",slug:"练习3-变化数据",link:"#练习3-变化数据",children:[]},{level:3,title:"练习4：求最值",slug:"练习4-求最值",link:"#练习4-求最值",children:[]},{level:3,title:"练习5：统计个数",slug:"练习5-统计个数",link:"#练习5-统计个数",children:[]},{level:3,title:"练习6：交换数据",slug:"练习6-交换数据",link:"#练习6-交换数据",children:[]},{level:3,title:"练习7：打乱数据",slug:"练习7-打乱数据",link:"#练习7-打乱数据",children:[]}]}],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.html",pathLocale:"/",extraFields:["java\n1.给数组限定什么类型？ int\n2.利用静态初始化完成创建并添加元素\nint[] agesArr = new int[]{18,19,20,21,22};\nint[] agesArr = {18,19,20,21,22};",'java\n1.给数组限定什么类型？ String\n2.利用静态初始化完成创建并添加元素\nString[] namesArr = new String[]{"zhangsan","lisi","wangwu"};\nString[] namesArr = {"zhangsan","lisi","wangwu"};',"java\n1.给数组限定什么类型？ double\n2.利用静态初始化完成创建并添加元素\ndouble[] heightsArr = new double[]{1.85,1.82,1.78,1.65};\ndouble[] heightsArr = {1.85,1.82,1.78,1.65};","java\nint[] arr = {1,2,3,4,5};\nSystem.out.println(arr);//[I@6d03e736\n\ndouble[] arr2 = {1.1,2.2,3.3};\nSystem.out.println(arr2);//[D@568db2f2",'java\npublic class ArrDemo2 {\n    /*\n\n        数组中元素访问的格式：\n                数组名[索引];\n\n         作用：\n            1.获取指定索引上对应的元素\n            2.修改指定索引上对应的元素\n\n\n    */\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5};\n       //需求1：获取arr数组中，3索引上的值\n        int number = arr[3];\n        System.out.println(number);\n        System.out.println(arr[3]);\n\n       //需求2：将arr数组中，3索引上的值修改为10\n            arr[3] = 10;\n        System.out.println("修改之后为:" + arr[3]);\n\n    }\n}',"java\nfor(int i = 0; i < arr.length; i++){\n    //在循环的过程中，i依次表示数组中的每一个索引\n    sout(arr[i]);//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。\n}","java\n//1.定义一个数组，存3个人的年龄，年龄未知\nint[] agesArr = new int[3];\n\n\n//2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。\nint[] scoresArr = new int[10];","java\npublic class ArrDemo6 {\n    public static void main(String[] args) {\n       int[] arr = {1,2,3,4,5,5,5,5,5};\n        //用索引来访问数组中的元素\n        System.out.println(arr[1]);\n        System.out.println(arr[10]);//ArrayIndexOutOfBoundsException\n\n    }\n}","java\n/*定义一个数组，存储1,2,3,4,5\n        遍历数组得到每一个元素，求数组里面所有的数据和*/\n\n\n//分析：\n//1.定义一个数组，并添加数据1,2,3,4,5\nint[] arr = {1,2,3,4,5};\n\n//求和变量\nint sum = 0;\n//2.遍历数组得到每一个数据，累加求和\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    sum = sum + arr[i];\n}\n\n//当循环结束之后，sum的值就是累加之后的结果\nSystem.out.println(sum);",'java\n//分析：\n//1.定义一个数组 存储1,2,3,4,5,6,7,8,9,10\nint[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n//定义一个变量，用来统计次数\nint count = 0;\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 表示数组里面的每一个索引\n    //arr[i] 表示数组里面的每一个元素\n    //3.判断当前的元素是否为3的倍数，如果是那么统计变量就需要自增一次。\n    if(arr[i] % 3 == 0){\n        // System.out.println(arr[i]);\n        count++;\n    }\n}\n//当循环结束之后，就表示数组里面所有的数字都判断完毕了，直接打印count即可\nSystem.out.println("数组中能被3整除的数字有" + count + "个");',"java\n//分析：\n//1.定义一个数组，存1,2,3,4,5,6,7,8,9,10\nint[] arr = {1,2,3,4,5,6,7,8,9,10};\n//2.遍历数组得到每一个元素\nfor (int i = 0; i < arr.length; i++) {\n    //i 依次表示数组里面的每一个索引\n    //arr[i] 依次表示数组里面的每一个元素\n    //3.对每一个元素进行判断\n    if(arr[i] % 2 == 0){\n        //偶数 变成二分之一\n        arr[i] = arr[i] / 2;\n    }else{\n        //奇数 扩大两倍\n        arr[i] = arr[i] * 2;\n    }\n}\n\n//遍历数组\n//一个循环尽量只做一件事情。\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}","java\n//定义数组求最大值：33,5,22,44,55\n\n//扩展问题：\n//1.根据求最大值的思路，自己改写一下求最小智\n//2.为什么max要记录为arr[0],默认值不能为0吗？\n//不能写0\n//max的初始化值一定要是数组中的值。\n//3.循环中开始条件一定是0吗？\n//循环的开始条件如果为0，那么第一次循环的时候是自己跟自己比了一下，对结果没有任何影响，但是效率偏低\n//为了提高效率，减少一次循环的次数，循环开始条件可以写1.\n\n\n//1.定义数组用来存储5个值\nint[] arr = {33,5,22,44,55};\n//2.定义一个变量max用来存储最大值\n//临时认为0索引的数据是最大的\nint max = arr[0];\n//3.循环获取数组中的每一个元素\n//拿着每一个元素跟max进行比较\nfor (int i = 1; i < arr.length; i++) {\n    //i 索引  arr[i] 元素\n    if(arr[i] > max){\n        max = arr[i];\n    }\n}\n//4.当循环结束之后，max记录的就是数组中的最大值\nSystem.out.println(max);//55",'java\n//分析：\n//1.定义数组\nint[] arr = new int[10];\n//2.把随机数存入到数组当中\nRandom r = new Random();\n\nfor (int i = 0; i < arr.length; i++) {\n    //每循环一次，就会生成一个新的随机数\n    int number = r.nextInt(100) + 1;\n    //把生成的随机数添加的数组当中\n    //数组名[索引] = 数据;\n    arr[i] = number;\n}\n\n\n// 1）求出所有数据的和\n//定义求和变量\nint sum = 0;\nfor (int i = 0; i < arr.length; i++) {\n    //循环得到每一个元素\n    //并把元素累加到sum当中\n    sum = sum + arr[i];\n}\nSystem.out.println("数组中所有数据的和为：" + sum);\n\n\n//2）求所有数据的平均数\nint avg = sum / arr.length;\nSystem.out.println("数组中平均数为：" + avg);\n\n\n\n//3）统计有多少个数据比平均值小\nint count = 0;\nfor (int i = 0; i < arr.length; i++) {\n    if(arr[i] < avg){\n        count++;\n    }\n}\n\n//当循环结束之后，就表示我已经找到了所有的比平均数小的数据\nSystem.out.println("在数组中，一共有" + count + "个数据，比平均数小");\n\n\n\n//遍历数组，验证答案\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}','java\n//1.定义数组存储数据\nint[] arr = {1,2,3,4,5};\n//2.利用循环去交换数据\nfor(int i = 0,j = arr.length - 1; i < j; i++,j--){\n    //交换变量i和变量j指向的元素\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n//当循环结束之后，那么数组中的数据就实现了头尾交换\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}','java\n//1.定义数组存储1~5\nint[] arr = {1, 2, 3, 4, 5};\n//2.循环遍历数组，从0索引开始打乱数据的顺序\nRandom r = new Random();\nfor (int i = 0; i < arr.length; i++) {\n    //生成一个随机索引\n    int randomIndex = r.nextInt(arr.length);\n    //拿着随机索引指向的元素 跟 i 指向的元素进行交换\n    int temp = arr[i];\n    arr[i] = arr[randomIndex];\n    arr[randomIndex] = temp;\n}\n//当循环结束之后，那么数组中所有的数据已经打乱顺序了\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + " ");\n}']},{title:"方法概述",headers:[{level:2,title:"1. 方法概述",slug:"_1-方法概述",link:"#_1-方法概述",children:[{level:3,title:"1.1 方法的概念",slug:"_1-1-方法的概念",link:"#_1-1-方法的概念",children:[]}]},{level:2,title:"2. 方法的定义和调用",slug:"_2-方法的定义和调用",link:"#_2-方法的定义和调用",children:[{level:3,title:"2.1 无参数方法定义和调用",slug:"_2-1-无参数方法定义和调用",link:"#_2-1-无参数方法定义和调用",children:[]},{level:3,title:"2.3 无参数方法的练习",slug:"_2-3-无参数方法的练习",link:"#_2-3-无参数方法的练习",children:[]}]},{level:2,title:"3. 带参数方法定义和调用",slug:"_3-带参数方法定义和调用",link:"#_3-带参数方法定义和调用",children:[{level:3,title:"3.1 带参数方法定义和调用",slug:"_3-1-带参数方法定义和调用",link:"#_3-1-带参数方法定义和调用",children:[]},{level:3,title:"3.2 形参和实参",slug:"_3-2-形参和实参",link:"#_3-2-形参和实参",children:[]},{level:3,title:"3.3 带参数方法练习",slug:"_3-3-带参数方法练习",link:"#_3-3-带参数方法练习",children:[]}]},{level:2,title:"4. 带返回值方法的定义和调用",slug:"_4-带返回值方法的定义和调用",link:"#_4-带返回值方法的定义和调用",children:[{level:3,title:"4.1 带返回值方法定义和调用",slug:"_4-1-带返回值方法定义和调用",link:"#_4-1-带返回值方法定义和调用",children:[]},{level:3,title:"4.2 带返回值方法练习1",slug:"_4-2-带返回值方法练习1",link:"#_4-2-带返回值方法练习1",children:[]},{level:3,title:"4.3 带返回值方法练习2",slug:"_4-3-带返回值方法练习2",link:"#_4-3-带返回值方法练习2",children:[]},{level:3,title:"4.4 带返回值方法练习3",slug:"_4-4-带返回值方法练习3",link:"#_4-4-带返回值方法练习3",children:[]}]},{level:2,title:"5. 方法的注意事项",slug:"_5-方法的注意事项",link:"#_5-方法的注意事项",children:[{level:3,title:"5.1 方法的注意事项",slug:"_5-1-方法的注意事项",link:"#_5-1-方法的注意事项",children:[]},{level:3,title:"5.2 方法的通用格式",slug:"_5-2-方法的通用格式",link:"#_5-2-方法的通用格式",children:[]}]},{level:2,title:"6. 方法重载",slug:"_6-方法重载",link:"#_6-方法重载",children:[{level:3,title:"6.1 方法重载",slug:"_6-1-方法重载",link:"#_6-1-方法重载",children:[]},{level:3,title:"6.2 方法重载练习",slug:"_6-2-方法重载练习",link:"#_6-2-方法重载练习",children:[]},{level:3,title:"7.3 数组遍历",slug:"_7-3-数组遍历",link:"#_7-3-数组遍历",children:[]},{level:3,title:"7.4 数组最大值",slug:"_7-4-数组最大值",link:"#_7-4-数组最大值",children:[]},{level:3,title:"7.6 获取索引",slug:"_7-6-获取索引",link:"#_7-6-获取索引",children:[]}]}],path:"/posts/java/basic/06-%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.html",pathLocale:"/",extraFields:["java\n  public static void 方法名 (   ) {\n  \t// 方法体;\n  }","java\n  public static void method (    ) {\n  \t// 方法体;\n  }","java\n  方法名();","java\n  method();","java\npublic class MethodTest {\n    public static void main(String[] args) {\n        //在main()方法中调用定义好的方法\n        getMax();\n    }\n\n    //定义一个方法，用于打印两个数字中的较大数，例如getMax()\n    public static void getMax() {\n        //方法中定义两个变量，用于保存两个数字\n        int a = 10;\n        int b = 20;\n\n        //使用分支语句分两种情况对两个数字的大小关系进行处理\n        if(a > b) {\n            System.out.println(a);\n        } else {\n            System.out.println(b);\n        }\n    }\n}","java\n  public static void 方法名 (参数1) {\n  \t方法体;\n  }\n  \n  public static void 方法名 (参数1, 参数2, 参数3...) {\n  \t方法体;\n  }","java\n  public static void isEvenNumber(int number){\n      ...\n  }\n  public static void getMax(int num1, int num2){\n      ...\n  }","java\n  方法名(参数)；\n  \n  方法名(参数1,参数2);","java\n  isEvenNumber(10);\n  \n  getMax(10,20);","java\npublic class MethodTest {\n    public static void main(String[] args) {\n        //在main()方法中调用定义好的方法（使用常量）\n        getMax(10,20);\n        //调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的\n        //getMax(30);\n        //getMax(10.0,20.0);\n\n        //在main()方法中调用定义好的方法（使用变量）\n        int a = 10;\n        int b = 20;\n        getMax(a, b);\n    }\n\n    //定义一个方法，用于打印两个数字中的较大数，例如getMax()\n    //为方法定义两个参数，用于接收两个数字\n    public static void getMax(int a, int b) {\n        //使用分支语句分两种情况对两个数字的大小关系进行处理\n        if(a > b) {\n            System.out.println(a);\n        } else {\n            System.out.println(b);\n        }\n    }\n}","java\n  public static 数据类型 方法名 ( 参数 ) { \n  \treturn 数据 ;\n  }","java\n  public static boolean isEvenNumber( int number ) {           \n  \treturn true ;\n  }\n  public static int getMax( int a, int b ) {\n  \treturn  100 ;\n  }","java\n  方法名 ( 参数 ) ;\n  数据类型 变量名 = 方法名 ( 参数 ) ;","java\n  isEvenNumber ( 5 ) ;\n  boolean  flag =  isEvenNumber ( 5 );","java\n  public class MethodTest {\n      public static void main(String[] args) {\n          //在main()方法中调用定义好的方法并使用变量保存\n          int result = getMax(10,20);\n          System.out.println(result);\n  \n          //在main()方法中调用定义好的方法并直接打印结果\n          System.out.println(getMax(10,20));\n      }\n  \n      //定义一个方法，用于获取两个数字中的较大数\n      public static int getMax(int a, int b) {\n          //使用分支语句分两种情况对两个数字的大小关系进行处理\n          //根据题设分别设置两种情况下对应的返回结果\n          if(a > b) {\n              return a;\n          } else {\n              return b;\n          }\n      }\n  }","java\npackage com.itheima.demo;\n\npublic class MethodDemo9 {\n    public static void main(String[] args) {\n        /*需求：定义一个方法，求一家商场每个季度的营业额。\n        根据方法结果再计算出全年营业额。*/\n        int sum1 = getSum(10, 20, 30);\n        int sum2 = getSum(10, 20, 30);\n        int sum3 = getSum(10, 20, 30);\n        int sum4 = getSum(10, 20, 30);\n\n        int sum = sum1 + sum2 + sum3 + sum4;\n        System.out.println(sum);\n\n    }\n\n    //心得：\n    //1.我要干嘛？  决定了方法体   每个季度的营业额\n    //2.我干这件事情，需要什么才能完成？ 决定了形参 需要三个月的营业额 a b c\n    //3.我干完这件事情，看调用处是否需要使用方法的结果。   决定了返回值\n    //如果需要使用，那么必须返回\n    //如果不需要使用，可以返回也可以不返回\n    public static int getSum(int month1,int month2,int month3){\n        int sum = month1 + month2 + month3;\n        //因为方法的调用处，需要继续使用这个结果\n        //所以我们必须要把sum返回\n        return sum;\n    }\n}",'java\nimport java.util.Scanner;\n\npublic class MethodDemo10 {\n    public static void main(String[] args) {\n        //需求：键盘录入两个圆的半径（整数），比较两个圆的面积。\n        //键盘录入圆的半径\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入圆的半径");\n        int radii1 = sc.nextInt();\n\n        System.out.println("请输入第二个圆的半径");\n        int radii2 = sc.nextInt();\n        double area1 = getArea(radii1);\n        double area2 = getArea(radii2);\n        if(area1 > area2){\n            System.out.println("第一个圆更大");\n        }else{\n            System.out.println("第二个圆更大");\n        }\n    }\n\n    //心得：\n    //1.我要干嘛？   求圆的面积\n    //2.我干这件事情，需要什么才能完成？        半径\n    //3.方法的调用处，是否需要继续使用方法的结果    要比较\n    public static double getArea(int radii) {\n        double area = 3.14 * radii * radii;\n        return area;\n    }\n}',"java\n    public class MethodDemo {\n        public static void main(String[] args) {\n    \n        }\n    \n        public static void methodOne() {\n    \t\tpublic static void methodTwo() {\n           \t\t// 这里会引发编译错误!!!\n        \t}\n        }\n    }","java\n    public class MethodDemo {\n        public static void main(String[] args) {\n    \n        }\n        public static void methodTwo() {\n            //return 100; 编译错误，因为没有具体返回值类型\n            return;\t\n            //System.out.println(100); return语句后面不能跟数据或代码\n        }\n    }","java\n  public static 返回值类型 方法名(参数) {\n     方法体; \n     return 数据 ;\n  }","java\n  public class MethodDemo {\n  \tpublic static void fn(int a) {\n      \t//方法体\n      }\n      public static int fn(double a) {\n      \t//方法体\n      }\n  }\n  \n  public class MethodDemo {\n  \tpublic static float fn(int a) {\n      \t//方法体\n      }\n      public static int fn(int a , int b) {\n      \t//方法体\n      }\n  }","java\n  public class MethodDemo {\n  \tpublic static void fn(int a) {\n      \t//方法体\n      }\n      public static int fn(int a) { \t/*错误原因：重载与返回值无关*/\n      \t//方法体\n      }\n  }\n  \n  public class MethodDemo01 {\n      public static void fn(int a) {\n          //方法体\n      }\n  } \n  public class MethodDemo02 {\n      public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\n          //方法体\n      }\n  }",'java\n  public class MethodTest {\n      public static void main(String[] args) {\n          //调用方法\n          System.out.println(compare(10, 20));\n          System.out.println(compare((byte) 10, (byte) 20));\n          System.out.println(compare((short) 10, (short) 20));\n          System.out.println(compare(10L, 20L));\n      }\n  \n      //int\n      public static boolean compare(int a, int b) {\n          System.out.println("int");\n          return a == b;\n      }\n  \n      //byte\n      public static boolean compare(byte a, byte b) {\n          System.out.println("byte");\n          return a == b;\n      }\n  \n      //short\n      public static boolean compare(short a, short b) {\n          System.out.println("short");\n          return a == b;\n      }\n  \n      //long\n      public static boolean compare(long a, long b) {\n          System.out.println("long");\n          return a == b;\n      }\n  \n  }','java\n  public class Test1 {\n      public static void main(String[] args) {\n        /*  //先打印数据，再进行换行\n          System.out.println("aaa");\n          //只打印不换行\n          System.out.print("bbb");\n          System.out.print("ddd");\n          //不打印任何内容，只换行\n          System.out.println();\n          System.out.print("cc");*/\n          //设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]\n          int[] arr = {1,2,3,4,5};\n          printArr(arr);\n      }\n      //1.我要遍历数组\n      //2.需要什么？  数组\n      //3.调用处是否需要使用方法的结果。\n      public static void printArr(int[] arr){\n          System.out.print("[");\n          for (int i = 0; i < arr.length; i++) {\n              if(i == arr.length - 1){\n                  System.out.println(arr[i] + "]");\n              }else{\n                  System.out.print(arr[i] + ", ");\n              }\n          }\n      }\n  }','java\n  public class MethodTest02 {\n      public static void main(String[] args) {\n          //定义一个数组，用静态初始化完成数组元素初始化\n          int[] arr = {12, 45, 98, 73, 60};\n  \n          //调用获取最大值方法，用变量接收返回结果\n          int number = getMax(arr);\n  \n          //把结果输出在控制台\n          System.out.println("number:" + number);\n      }\n  \n      //定义一个方法，用来获取数组中的最大值\n      /*\n          两个明确：\n              返回值类型：int\n              参数：int[] arr\n       */\n      public static int getMax(int[] arr) {\n          int max = arr[0];\n  \n          for(int x=1; x<arr.length; x++) {\n              if(arr[x] > max) {\n                  max = arr[x];\n              }\n          }\n          return max;\n      }\n  }',"java\npackage com.itheima.demo;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        //定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处\n        //如果有重复的，只要获取第一个即可\n\n        int[] arr = {1,2,3,4,5};\n        int index = contains(arr, 3);\n        System.out.println(index);\n    }\n\n    //1. 我要干嘛？判断数组中的某一个数是否存在\n    //2. 需要什么？数组 数字\n    //3. 调用处是否需要继续使用？返回\n    //获取number在arr中的位置\n    public static int contains(int[] arr, int number) {\n        //遍历arr得到每一个元素\n        for (int i = 0; i < arr.length; i++) {\n            //拿着每一个元素跟number比较\n            if(arr[i] == number){\n                //如果相等，表示找到了\n                return i;\n            }\n        }\n        //当循环结束之后，如果还不能返回索引，表示数组中不存在该数据\n        //可以返回-1\n        return -1;\n    }\n}"]},{title:"综合练习",headers:[{level:2,title:"练习一：飞机票",slug:"练习一-飞机票",link:"#练习一-飞机票",children:[]},{level:2,title:"练习二：打印素数",slug:"练习二-打印素数",link:"#练习二-打印素数",children:[]},{level:2,title:"练习三：验证码",slug:"练习三-验证码",link:"#练习三-验证码",children:[]},{level:2,title:"练习四：复制数组",slug:"练习四-复制数组",link:"#练习四-复制数组",children:[]},{level:2,title:"练习五：评委打分",slug:"练习五-评委打分",link:"#练习五-评委打分",children:[]},{level:2,title:"练习六：数字加密",slug:"练习六-数字加密",link:"#练习六-数字加密",children:[]},{level:2,title:"练习六扩展：",slug:"练习六扩展",link:"#练习六扩展",children:[]},{level:2,title:"练习七：数字解密",slug:"练习七-数字解密",link:"#练习七-数字解密",children:[]},{level:2,title:"练习八：抽奖",slug:"练习八-抽奖",link:"#练习八-抽奖",children:[{level:3,title:"解法一:",slug:"解法一",link:"#解法一",children:[]},{level:3,title:"解法二：",slug:"解法二",link:"#解法二",children:[]}]},{level:2,title:"练习九：双色球",slug:"练习九-双色球",link:"#练习九-双色球",children:[]}],path:"/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:['java\npackage com.itheima.test;\n\nimport java.util.Scanner;\n\npublic class Test1 {\n    public static void main(String[] args) {\n        /* 机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。\n        按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。*/\n\n        //分析：\n        //1.键盘录入机票原价、月份、头等舱或经济舱\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入机票的原价");\n        int ticket = sc.nextInt();\n        System.out.println("请输入当前的月份");\n        int month = sc.nextInt();\n        System.out.println("请输入当前购买的舱位 0 头等舱 1 经济舱");\n        int seat = sc.nextInt();\n        //2.先判断月份是旺季还是淡季\n        //ctrl + alt + M 自动抽取方法\n        if (month >= 5 && month <= 10) {\n            //旺季 //3.继续判断当前机票是经济舱还是头等舱\n            //ticket = getPrice(ticket, seat, 0.9, 0.85);\n            ticket = getTicket(ticket, seat, 0.9, 0.85);\n        } else if ((month >= 1 && month <= 4) || (month >= 11 && month <= 12)) {\n            //淡季\n            //ticket = getPrice(ticket, seat, 0.7, 0.65);\n            ticket = getTicket(ticket, seat, 0.7, 0.65);\n        } else {\n            //表示键盘录入的月份是一个非法数据\n            System.out.println("键盘录入的月份不合法");\n        }\n\n        System.out.println(ticket);\n    }\n\n    public static int getTicket(int ticket, int seat, double v, double v2) {\n        if (seat == 0) {\n            //头等舱\n            ticket = (int) (ticket * v);\n        } else if (seat == 1) {\n            //经济舱\n            ticket = (int) (ticket * v2);\n        } else {\n            System.out.println("没有这个舱位");\n        }\n        return ticket;\n    }\n\n    //1.我要干嘛？根据舱位和折扣来计算最终的票价\n    //2.我干这件事，需要什么才能完成？原价 舱位 头等舱的折扣 经济舱的折扣\n    //3.方法的调用处是否需要继续使用这个结果  需要\n    /*  public static int getPrice(int ticket, int seat, double v0, double v1) {\n        if (seat == 0) {\n            //头等舱\n            ticket = (int) (ticket * v0);\n        } else if (seat == 1) {\n            //经济舱\n            ticket = (int) (ticket * v1);\n        } else {\n            System.out.println("没有这个舱位");\n        }\n        return ticket;\n    }*/\n}','java\npackage com.itheima.test;\n\npublic class Test2 {\n    public static void main(String[] args) {\n        //判断 101 ~ 200 之间有多少个素数，并打印所有素数\n\n        //思路一： 2 ~ 99\n        //定义变量i ，赋值100\n        //判断i是否为质数\n\n        //定义一个变量用来统计有多少个质数\n        int count = 0;\n        //外循环：遍历101~200这个范围，依次得到这个范围之内的每一个数字\n        for (int i = 101; i <= 200; i++) {\n            //i 依次表示循环中的每一个数字\n            //继续判断i是否为一个质数\n            boolean flag = true;\n            //内循环:判断当前数字是否为一个质数。\n            for (int j = 2; j < i; j++) {\n                //j 表示2~99之间的每一个数字\n                if(i % j == 0){\n                    flag = false;\n                    //跳出单层循环，内循环\n                    break;\n                }\n            }\n            if(flag){\n                System.out.println("当前数字"+i+"是质数");\n                count++;\n            }\n        }\n\n        System.out.println("一共有" + count + "个质数");\n\n        /* int i = 7;\n        boolean flag = true;\n        for (int j = 2; j < i; j++) {\n            //j 表示2~99之间的每一个数字\n            if(i % j == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println("当前数字是质数");\n        }else{\n            System.out.println("当前数字不是一个质数");\n        }*/\n    }\n}','java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*   需求：\n            定义方法实现随机产生一个5位的验证码\n            验证码格式：\n            长度为5\n            前四位是大写字母或者小写字母\n            最后一位是数字\n     */\n\n        //方法：\n        //在以后如果我们要在一堆没有什么规律的数据中随机抽取\n        //可以先把这些数据放到数组当中\n        //再随机抽取一个索引\n\n        //分析：\n        //1.大写字母和小写字母都放到数组当中\n        char[] chs = new char[52];\n        for (int i = 0; i < chs.length; i++) {\n            //ASCII码表\n            if(i <= 25){\n                //添加小写字母\n                chs[i] = (char)(97 + i);\n            }else{//27\n                //添加大写字母\n                // A --- 65\n                chs[i] = (char)(65 + i - 26);\n            }\n        }\n\n        //定义一个字符串类型的变量，用来记录最终的结果\n        String result = "";\n\n        //2.随机抽取4次\n        //随机抽取数组中的索引\n        Random r = new Random();\n        for (int i = 0; i < 4; i++) {\n            int randomIndex = r.nextInt(chs.length);\n            //利用随机索引，获取对应的元素\n            //System.out.println(chs[randomIndex]);\n            result = result + chs[randomIndex];\n        }\n        //System.out.println(result);\n        //3.随机抽取一个数字0~9\n        int number = r.nextInt(10);\n        //生成最终的结果\n        result = result + number;\n\n        //打印最终结果\n        System.out.println(result);\n\n    }\n}',"java\npackage com.itheima.test;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        /* 需求：\n        把一个数组中的元素复制到另一个新数组中去。*/\n\n        //分析：\n        //1.定义一个老数组并存储一些元素\n        int[] arr = {1,2,3,4,5};\n        //2.定义一个新数组的长度跟老数组一致\n        int[] newArr = new int[arr.length];\n        //3.遍历老数组，得到老数组中的每一个元素，依次存入到新数组当中\n        for (int i = 0; i < arr.length; i++) {\n            //i 表示老数组中的索引。新数组中的每一个索引\n            //arr[i]  表示老数组中的元素\n            newArr[i] = arr[i];\n        }\n\n        //4.新数组中已经存满元素了\n        for (int i = 0; i < newArr.length; i++) {\n            System.out.println(newArr[i]);\n        }\n\n    }\n}",'java\npackage com.itheima.test;\n\nimport java.util.Scanner;\n\npublic class Test5 {\n    public static void main(String[] args) {\n        //在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。\n        // 选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。\n\n\n        //分析：\n        //1.定义一个数组，用来存储6名评委的打分（0~100）\n        int[] scoreArr = getScores();\n        for (int i = 0; i < scoreArr.length; i++) {\n            System.out.println(scoreArr[i]);\n        }\n        //2.求出数组中的最大值\n        int max = getMax(scoreArr);\n        //3.求出数组中的最小值\n        int min = getMin(scoreArr);\n        //4.求出数组中6个分数的总和\n        int sum = getSum(scoreArr);\n        //5.（总和 - 最大值 - 最小值 ）/4\n        int avg =  (sum - max - min)/(scoreArr.length - 2);\n        //6.打印结果\n        System.out.println("选手的最终得分为：" + avg);\n    }\n\n\n    public static int getSum(int[] scoreArr){\n        int sum = 0;\n        for (int i = 0; i < scoreArr.length; i++) {\n            sum = sum + scoreArr[i];\n        }\n        return  sum;\n\n    }\n\n\n\n    //求数组的最大值\n    public static int getMax(int[] scoreArr){\n        int max = scoreArr[0];\n        for (int i = 1; i < scoreArr.length; i++) {\n            if(scoreArr[i] > max){\n                max = scoreArr[i];\n            }\n        }\n        return max;\n    }\n\n    //求数组的最小值\n    public static int getMin(int[] scoreArr){\n        int min = scoreArr[0];\n        for (int i = 1; i < scoreArr.length; i++) {\n            if(scoreArr[i] < min){\n                min = scoreArr[i];\n            }\n        }\n        return min;\n    }\n\n\n\n    //1.我要干嘛？定义一个数组，用来存储6名评委的打分（0~100）\n    //2.我需要什么？都不需要\n    //3.干完了这件事情，是否需要返回？必须返回\n    public static int[] getScores(){\n        //定义数组\n        int[] scores = new int[6];\n        //使用键盘录入的形式，输入分数：0~100\n        Scanner sc = new Scanner(System.in);\n        for (int i = 0; i < scores.length; ) {\n            System.out.println("请输入评委的打分");\n            int score = sc.nextInt();//100\n            if(score >=0 && score<= 100){\n                scores[i] = score;\n                i++;\n            }else{\n                System.out.println("成绩超出了范围,继续录入，当前的i为：" + i);\n            }\n        }\n        return  scores;\n    }\n}',"java\n\t\t1\t9\t8\t3\n+5\t\t6   14  13  8\n%10\t\t6   4   3   8\n反转\t   8   3   4   6\n加密后的结果就是：8346","java\npackage com.itheima.test;\n\npublic class Test6 {\n    public static void main(String[] args) {\n        /*\n        某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，\n        规则如下：\n            每位数加上5\n            再对10求余，\n            最后将所有数字反转，\n            得到一串新数。\n*/\n\n\n        //分析：\n        //1.把整数里面的每一位放到数组当中\n        int[] arr = {1, 9, 8, 3};\n        //2.加密\n        //每位数加上5\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] + 5;\n        }\n        //再对10求余，\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] % 10;\n        }\n        //将所有数字反转\n        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n        //8 3 4 6 --\x3e 8346\n        //3.把数组里面的每一个数字进行拼接，变成加密之后的结果\n        int number = 0;\n        for (int i = 0; i < arr.length; i++) {\n            number = number * 10 + arr[i];\n        }\n        System.out.println(number);\n    }\n}",'java\npackage com.itheima.test;\n\npublic class Test7 {\n    public static void main(String[] args) {\n        //需求：\n        //把整数上的每一位都添加到数组当中\n        //反向推导\n\n\n\n        //1.计算出数组的长度\n        int number = 12345;\n        //定义一个变量临时记录number的值，就是为了第三步的时候再次使用\n        int temp = number;\n        //定义一个变量进行统计\n        int count = 0;\n        while(number != 0){\n            //每一次循环就去掉右边的一个数字\n            number = number / 10;\n            //去掉一位计数器就自增一次。\n            count++;\n        }\n        //2.定义数组\n        //动态初始化\n        int[] arr = new int[count];\n        //3.把整数上的每一位都添加到数组当中\n        int index = arr.length -1;\n        while(temp != 0){//12345\n            //获取temp里面的每一位数组\n            int ge = temp % 10;\n            //再去掉右边的那位数字\n            temp = temp / 10;\n            //把当前获取到的个位添加到数组当中\n            arr[index] = ge;\n            index--;\n        }\n        //验证结果  1  2  3  4 5\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n    }\n}',"java\npackage com.itheima.test;\n\npublic class Test8 {\n    public static void main(String[] args) {\n        /*某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，\n        规则如下：\n            每位数加上5\n            再对10求余，\n            最后将所有数字反转，\n            得到一串新数。\n            按照以上规则进行解密：\n            比如1983加密之后变成8346，解密之后变成1983\n        */\n\n\n        //1.定义数组记录解密之后的结果\n        int[] arr = {8, 3, 4, 6};\n        //2.反转\n        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n        //3.由于加密是通过对10取余的方式进行获取的\n        //所以在解密的时候就需要判断，0~4之间+10  5~9数字不变\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] >= 0 && arr[i] <= 4) {\n                arr[i] = arr[i] + 10;\n            }\n        }\n        //4.每一位减5\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] - 5;\n        }\n        //5.获取数组里面的每一位数字拼接成最终的结果\n        int number = 0;\n        for (int i = 0; i < arr.length; i++) {\n            number = number * 10 + arr[i];\n        }\n        System.out.println(number);\n\n\n\n\n    }\n}","java\n888元的奖金被抽出\n588元的奖金被抽出\n10000元的奖金被抽出\n1000元的奖金被抽出\n2元的奖金被抽出","java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test9 {\n    public static void main(String[] args) {\n        /* 需求：\n        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。\n        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。\n        打印效果如下：（随机顺序，不一定是下面的顺序）\n            888元的奖金被抽出\n            588元的奖金被抽出\n            10000元的奖金被抽出\n            1000元的奖金被抽出\n            2元的奖金被抽出\n        */\n\n\n        //分析：\n        //1.定义数组表示奖池\n        int[] arr = {2, 588, 888, 1000, 10000};\n        //2.定义新数组用于存储抽奖的结果\n        int[] newArr = new int[arr.length];\n        //3.抽奖\n        Random r = new Random();\n        //因为有5个奖项，所以这里要循环5次\n        for (int i = 0; i < 5; ) {\n            //获取随机索引\n            int randomIndex = r.nextInt(arr.length);\n            //获取奖项\n            int prize = arr[randomIndex];\n            //判断当前的奖项是否存在，如果存在则重新抽取，如果不存在，就表示是有效奖项\n            boolean flag = contains(newArr, prize);\n            if(!flag){\n                //把当前抽取到的奖项添加到newArr当中\n                newArr[i] = prize;\n                //添加完毕之后，移动索引\n                i++;\n            }\n        }\n        //4.遍历newArr\n        for (int i = 0; i < newArr.length; i++) {\n            System.out.println(newArr[i]);\n        }\n\n\n    }\n\n    //判断prize在数组当中是否存在\n    //存在：true\n    //不存在：false\n    public static boolean contains(int[] arr,int prize){\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == prize){\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n}","java\npackage com.itheima.test;\n\nimport java.util.Random;\n\npublic class Test10 {\n    public static void main(String[] args) {\n       /* 需求：\n        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。\n        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。\n        打印效果如下：（随机顺序，不一定是下面的顺序）\n            888元的奖金被抽出\n            588元的奖金被抽出\n            10000元的奖金被抽出\n            1000元的奖金被抽出\n            2元的奖金被抽出\n        */\n\n        //1.把奖池里面的所有奖项打乱顺序\n        int[] arr = {2, 588, 888, 1000, 10000};\n        Random r = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            //获取随机索引\n            int randomIndex = r.nextInt(arr.length);\n            //拿着i跟随机索引randomIndex上的值进行交换\n            int temp = arr[i];\n            arr[i] = arr[randomIndex];\n            arr[randomIndex] = temp;\n        }\n        //2.遍历奖池,从0索引开始获取每一个奖项\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n\n\n    }\n}",'java\npackage com.itheima.test;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Test11 {\n    public static void main(String[] args) {\n        //1.生成中奖号码\n        int[] arr = createNumber(); // 123456  7\n\n        System.out.println("=======================");\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n\n        System.out.println("=======================");\n\n\n\n        //2.用户输入彩票号码（红球 + 蓝球）//654321\n        int[] userInputArr = userInputNumber();\n\n        //3.判断用户的中奖情况\n        //红球 蓝球\n        int redCount = 0;\n        int blueCount = 0;\n\n        //判断红球\n        for (int i = 0; i < userInputArr.length - 1; i++) {\n            int redNumber = userInputArr[i];\n            for (int j = 0; j < arr.length - 1; j++) {\n                if(redNumber == arr[j]){\n                    redCount++;\n                    //如果找到了，那么后面的数字就没有必要继续比较了\n                    //跳出内循环，继续判断下一个红球号码是否中奖\n                    break;\n                }\n            }\n        }\n\n        //判断蓝球\n        int blueNumber = userInputArr[userInputArr.length-1];\n        if(blueNumber == arr[arr.length - 1]){\n            blueCount++;\n        }\n\n        //根据红球的个数以及蓝球的个数来判断中奖情况\n        if(redCount == 6 && blueCount == 1){\n            System.out.println("恭喜你，中奖1000万");\n        }else if(redCount == 6 && blueCount == 0){\n            System.out.println("恭喜你，中奖500万");\n        }else if(redCount == 5 && blueCount == 1){\n            System.out.println("恭喜你，中奖3000");\n        }else if((redCount == 5 && blueCount == 0) ||  (redCount == 4 && blueCount == 1)){\n            System.out.println("恭喜你，中奖200");\n        }else if((redCount == 4 && blueCount == 0) ||  (redCount == 3 && blueCount == 1)){\n            System.out.println("恭喜你，中奖10");\n        }else if((redCount == 2 && blueCount == 1) ||  (redCount == 1 && blueCount == 1)|| (redCount == 0 && blueCount == 1)){\n            System.out.println("恭喜你，中奖5");\n        }else{\n            System.out.println("谢谢参与，谢谢惠顾");\n        }\n\n    }\n\n    public static int[] userInputNumber() {\n        //1.创建数组用于添加用户购买的彩票号码\n        //6个红球 1个蓝球 数组长度：7\n        int[] arr = new int[7];\n\n        //2.利用键盘录入让用输入\n        Scanner sc = new Scanner(System.in);\n        //让用户输入红球号码\n        for (int i = 0; i < 6; ) {\n            System.out.println("请输入第" + (i + 1) + "个红球号码");\n            int redNumber = sc.nextInt();\n            //redNumber  在1~33  唯一不重复\n            if (redNumber >= 1 && redNumber <= 33) {\n                boolean flag = contains(arr, redNumber);\n                if (!flag) {\n                    //不存在\n                    //有效的，可以添加到数组当中\n                    arr[i] = redNumber;\n                    i++;\n                } else {\n                    //存在\n                    System.out.println("当前红球号码已经存在，请重新输入");\n                }\n            } else {\n                System.out.println("当前红球号码超出范围");\n            }\n        }\n\n        //让用户输入篮球号码\n        System.out.println("请输入篮球号码");\n        //1~16\n        while (true) {\n            int blueNumber = sc.nextInt();\n            if (blueNumber >= 1 && blueNumber <= 16) {\n                arr[arr.length - 1] = blueNumber;\n                break;\n            } else {\n                System.out.println("当前篮球号码超出范围");\n            }\n        }\n        return arr;\n\n    }\n\n\n    public static int[] createNumber() {\n        //1.创建数组用于添加中奖号码\n        //6个红球 1个蓝球 数组长度：7\n        int[] arr = new int[7];\n\n        //2.随机生成号码并添加到数组当中\n        //红球：不能重复的  1 2 3 4 5 6\n        //蓝球：可以跟红球号码重复 5\n\n        //生成红球号码并添加到数组当中\n        Random r = new Random();\n        for (int i = 0; i < 6; ) {\n            //获取红球号码\n            int redNumber = r.nextInt(33) + 1;\n            boolean flag = contains(arr, redNumber);\n            if (!flag) {\n                //把红球号码添加到数组当中\n                arr[i] = redNumber;\n                i++;\n            }\n        }\n\n        //生成蓝球号码并添加到数组当中\n        int blueNumber = r.nextInt(16) + 1;\n        arr[arr.length - 1] = blueNumber;\n        return arr;\n    }\n\n    //用于判断数组在数组中是否存在\n    public static boolean contains(int[] arr, int number) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == number) {\n                return true;\n            }\n        }\n        return false;\n    }\n}']},{title:"类和对象",headers:[{level:2,title:"1. 类和对象",slug:"_1-类和对象",link:"#_1-类和对象",children:[{level:3,title:"1.1 类和对象的理解",slug:"_1-1-类和对象的理解",link:"#_1-1-类和对象的理解",children:[]},{level:3,title:"1.2 类的定义",slug:"_1-2-类的定义",link:"#_1-2-类的定义",children:[]},{level:3,title:"1.3 对象的使用",slug:"_1-3-对象的使用",link:"#_1-3-对象的使用",children:[]},{level:3,title:"1.4 学生对象-练习",slug:"_1-4-学生对象-练习",link:"#_1-4-学生对象-练习",children:[]}]},{level:2,title:"2. 对象内存图",slug:"_2-对象内存图",link:"#_2-对象内存图",children:[{level:3,title:"2.1 单个对象内存图",slug:"_2-1-单个对象内存图",link:"#_2-1-单个对象内存图",children:[]},{level:3,title:"2.2 多个对象内存图",slug:"_2-2-多个对象内存图",link:"#_2-2-多个对象内存图",children:[]}]},{level:2,title:"3. 成员变量和局部变量",slug:"_3-成员变量和局部变量",link:"#_3-成员变量和局部变量",children:[{level:3,title:"3.1 成员变量和局部变量的区别",slug:"_3-1-成员变量和局部变量的区别",link:"#_3-1-成员变量和局部变量的区别",children:[]}]},{level:2,title:"4. 封装",slug:"_4-封装",link:"#_4-封装",children:[{level:3,title:"4.1 封装思想",slug:"_4-1-封装思想",link:"#_4-1-封装思想",children:[]},{level:3,title:"4.2 private关键字",slug:"_4-2-private关键字",link:"#_4-2-private关键字",children:[]},{level:3,title:"4.3 private的使用",slug:"_4-3-private的使用",link:"#_4-3-private的使用",children:[]},{level:3,title:"4.4 this关键字",slug:"_4-4-this关键字",link:"#_4-4-this关键字",children:[]}]},{level:2,title:"5. 构造方法",slug:"_5-构造方法",link:"#_5-构造方法",children:[{level:3,title:"5.1 构造方法概述",slug:"_5-1-构造方法概述",link:"#_5-1-构造方法概述",children:[]},{level:3,title:"5.2 构造方法的注意事项",slug:"_5-2-构造方法的注意事项",link:"#_5-2-构造方法的注意事项",children:[]},{level:3,title:"5.3 标准类制作",slug:"_5-3-标准类制作",link:"#_5-3-标准类制作",children:[]},{level:3,title:"5.4 练习1",slug:"_5-4-练习1",link:"#_5-4-练习1",children:[]},{level:3,title:"5.4 练习2",slug:"_5-4-练习2",link:"#_5-4-练习2",children:[]}]}],path:"/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/day08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",pathLocale:"/",extraFields:["java\npublic class 类名 {\n\t// 成员变量\n\t变量1的数据类型 变量1；\n\t变量2的数据类型 变量2;\n\t…\n\t// 成员方法\n\t方法1;\n\t方法2;\t\n}",'java\n/*\n    手机类：\n        类名：\n        手机(Phone)\n\n        成员变量：\n        品牌(brand)\n        价格(price)\n\n        成员方法：\n        打电话(call)\n        发短信(sendMessage)\n */\npublic class Phone {\n    //成员变量\n    String brand;\n    int price;\n\n    //成员方法\n    public void call() {\n        System.out.println("打电话");\n    }\n\n    public void sendMessage() {\n        System.out.println("发短信");\n    }\n}','java\n/*\n    创建对象\n        格式：类名 对象名 = new 类名();\n        范例：Phone p = new Phone();\n\n    使用对象\n        1：使用成员变量\n            格式：对象名.变量名\n            范例：p.brand\n        2：使用成员方法\n            格式：对象名.方法名()\n            范例：p.call()\n */\npublic class PhoneDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Phone p = new Phone();\n\n        //使用成员变量\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        p.brand = "小米";\n        p.price = 2999;\n\n        System.out.println(p.brand);\n        System.out.println(p.price);\n\n        //使用成员方法\n        p.call();\n        p.sendMessage();\n    }\n}','java\npublic class Student {\n    //成员变量\n    String name;\n    int age;\n\n    //成员方法\n    public void study() {\n        System.out.println("好好学习，天天向上");\n    }\n\n    public void doHomework() {\n        System.out.println("键盘敲烂，月薪过万");\n    }\n}\n/*\n    学生测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n\n        //使用对象\n        System.out.println(s.name + "," + s.age);\n\n        s.name = "林青霞";\n        s.age = 30;\n\n        System.out.println(s.name + "," + s.age);\n\n        s.study();\n        s.doHomework();\n    }\n}','java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      String name;\n      private int age;\n  \n      //提供get/set方法\n      public void setAge(int a) {\n          if(a<0 || a>120) {\n              System.out.println("你给的年龄有误");\n          } else {\n              age = a;\n          }\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      //成员方法\n      public void show() {\n          System.out.println(name + "," + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n          //给成员变量赋值\n          s.name = "林青霞";\n          s.setAge(30);\n          //调用show方法\n          s.show();\n      }\n  }','java\n  /*\n      学生类\n   */\n  class Student {\n      //成员变量\n      private String name;\n      private int age;\n  \n      //get/set方法\n      public void setName(String n) {\n          name = n;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setAge(int a) {\n          age = a;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void show() {\n          System.out.println(name + "," + age);\n      }\n  }\n  /*\n      学生测试类\n   */\n  public class StudentDemo {\n      public static void main(String[] args) {\n          //创建对象\n          Student s = new Student();\n  \n          //使用set方法给成员变量赋值\n          s.setName("林青霞");\n          s.setAge(30);\n  \n          s.show();\n  \n          //使用get方法获取成员变量的值\n          System.out.println(s.getName() + "---" + s.getAge());\n          System.out.println(s.getName() + "," + s.getAge());\n  \n      }\n  }','java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}','java\nclass Student {\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n        System.out.println("无参构造方法");\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n        s.show();\n    }\n}','java\n/*\n    学生类\n */\nclass Student {\n    private String name;\n    private int age;\n\n    public Student() {}\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public Student(String name,int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    测试类\n */\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s1 = new Student();\n        s1.show();\n\n        //public Student(String name)\n        Student s2 = new Student("林青霞");\n        s2.show();\n\n        //public Student(int age)\n        Student s3 = new Student(30);\n        s3.show();\n\n        //public Student(String name,int age)\n        Student s4 = new Student("林青霞",30);\n        s4.show();\n    }\n}','java\nclass Student {\n    //成员变量\n    private String name;\n    private int age;\n\n    //构造方法\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    //成员方法\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void show() {\n        System.out.println(name + "," + age);\n    }\n}\n/*\n    创建对象并为其成员变量赋值的两种方式\n        1:无参构造方法创建对象后使用setXxx()赋值\n        2:使用带参构造方法直接创建带有属性值的对象\n*/\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //无参构造方法创建对象后使用setXxx()赋值\n        Student s1 = new Student();\n        s1.setName("林青霞");\n        s1.setAge(30);\n        s1.show();\n\n        //使用带参构造方法直接创建带有属性值的对象\n        Student s2 = new Student("林青霞",30);\n        s2.show();\n    }\n}','java\npublic class User {\n    //1.私有化全部的成员变量\n    //2.空参构造\n    //3.带全部参数的构造\n    //4.针对于每一个私有化的成员变量都要提供其对应的get和set方法\n    //5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为\n\n    private String username;//用户名\n    private String password;//密码\n    private String email;//邮箱\n    private char gender;//性别\n    private int age;//年龄\n\n    //空参构造方法\n    public User() {\n    }\n\n    //带全部参数的构造\n    public User(String username, String password, String email, char gender, int age) {\n        this.username = username;\n        this.password = password;\n        this.email = email;\n        this.gender = gender;\n        this.age = age;\n    }\n\n    //get和set\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void eat(){\n        System.out.println(username + "在吃饭");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //写一个标准的javabean类\n        //咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了\n\n\n        //利用空参构造创建对象\n        User u1 = new User();\n        //如果利用空参创建对象，还想赋值只能用set方法赋值\n        u1.setUsername("zhangsan");\n        u1.setPassword("1234qwer");\n        u1.setEmail("itheima@itcast.cn");\n        u1.setGender(\'男\');\n        u1.setAge(23);\n        //获取属性的值并打印\n        System.out.println(u1.getUsername() + ", " + u1.getPassword()\n                + ", " + u1.getEmail() + ", " + u1.getGender() + ", " + u1.getAge());\n        u1.eat();\n\n        System.out.println("=============================");\n\n        //简单的办法\n        //利用带全部参数的构造来创建对象\n        //快捷键:ctrl + p\n        User u2 = new User("lisi","12345678","lisi@itcast.cn",\'女\',24);\n        System.out.println(u2.getUsername() + ", " + u2.getPassword()\n                + ", " + u2.getEmail() + ", " + u2.getGender() + ", " + u2.getAge());\n        u2.eat();\n    }\n}']},{title:"扩展：键盘录入笔记",headers:[{level:2,title:"1）next（）、nextLine（）：",slug:"_1-next-、nextline",link:"#_1-next-、nextline",children:[{level:3,title:"代码示例：",slug:"代码示例",link:"#代码示例",children:[]},{level:3,title:"代码示例：",slug:"代码示例-1",link:"#代码示例-1",children:[]}]},{level:2,title:"2）nextInt（）：",slug:"_2-nextint",link:"#_2-nextint",children:[{level:3,title:"代码示例：",slug:"代码示例-2",link:"#代码示例-2",children:[]}]},{level:2,title:"3）nextDouble（）：",slug:"_3-nextdouble",link:"#_3-nextdouble",children:[{level:3,title:"代码示例：",slug:"代码示例-3",link:"#代码示例-3",children:[]},{level:3,title:"第一个细节：",slug:"第一个细节",link:"#第一个细节",children:[]},{level:3,title:"第二个细节：",slug:"第二个细节",link:"#第二个细节",children:[]},{level:3,title:"第三个细节：",slug:"第三个细节",link:"#第三个细节",children:[]},{level:3,title:"代码示例：",slug:"代码示例-5",link:"#代码示例-5",children:[]}]}],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E6%89%A9%E5%B1%95%EF%BC%9A%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:["java\nScanner sc = new Scanner(System.in);\nString s = sc.next();//录入的所有数据都会看做是字符串\nSystem.out.println(s);","java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();//录入的所有数据都会看做是字符串\nSystem.out.println(s);","java\nScanner sc = new Scanner(System.in);\nint s = sc.nextInt();//只能录入整数\nSystem.out.println(s);","java\nScanner sc = new Scanner(System.in);\ndouble d = sc.nextDouble();//录入的整数，小数都会看做小数。\n\t\t\t\t\t\t//录入字母会报错\nSystem.out.println(d);","java\nScanner sc = new Scanner(System.in);\ndouble d = sc.nextDouble();\nSystem.out.println(d);\n//键盘录入：1.1 2.2//注意录入的时候1.1和2.2之间加空格隔开。\n//此时控制台打印1.1\n//表示nextDouble方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。","java\nScanner sc = new Scanner(System.in);\nint i = sc.nextInt();\nSystem.out.println(i);\n//键盘录入：1 2//注意录入的时候1和2之间加空格隔开。\n//此时控制台打印1\n//表示nextInt方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。","java\nScanner sc = new Scanner(System.in);\nString s = sc.next();\nSystem.out.println(s);\n//键盘录入：a b//注意录入的时候a和b之间加空格隔开。\n//此时控制台打印a\n//表示next方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。","java\nScanner sc = new Scanner(System.in);\nString s1 = sc.next();\nString s2 = sc.next();\nSystem.out.println(s1);\nSystem.out.println(s2);\n//此时值键盘录入一次a b(注意a和b之间用空格隔开)\n//那么第一个next();会接收a，a后面是空格，那么就停止，所以打印s1是a\n//但是空格+b还在内存中。\n//第二个next会去掉前面的空格，只接收b\n//所以第二个s2打印出来是b","java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();\nSystem.out.println(s);\n//键盘录入a b(注意a和b之间用空格隔开)\n//那么nextLine不会过滤前面和后面的空格，会把这一整行数据全部接收完毕。","java\nScanner sc = new Scanner(System.in);//①\nint i = sc.nextInt();//②\nString s = sc.nextLine();//③\nSystem.out.println(i);//④\nSystem.out.println(s);//⑤",'java\nScanner sc = new Scanner(System.in);\nString s = sc.next();//键盘录入123\nSystem.out.println("此时为字符串" + s);//此时123是字符串\nint i = sc.nextInt();//键盘录入123\nSystem.out.println("此时为整数：" + i);','java\nScanner sc = new Scanner(System.in);\nString s = sc.nextLine();//键盘录入123\nSystem.out.println("此时为字符串" + s);//此时123是字符串\nint i = Integer.parseInt(s);//想要整数再进行转换\nSystem.out.println("此时为整数：" + i);']},{title:"面向对象综合训练综合练习",headers:[{level:2,title:"练习一：文字版格斗游戏",slug:"练习一-文字版格斗游戏",link:"#练习一-文字版格斗游戏",children:[]},{level:2,title:"练习二：文字版格斗游戏进阶",slug:"练习二-文字版格斗游戏进阶",link:"#练习二-文字版格斗游戏进阶",children:[]},{level:2,title:"练习三：对象数组（商品）",slug:"练习三-对象数组-商品",link:"#练习三-对象数组-商品",children:[]},{level:2,title:"练习四：对象数组（汽车）",slug:"练习四-对象数组-汽车",link:"#练习四-对象数组-汽车",children:[]},{level:2,title:"练习五：对象数组（手机）",slug:"练习五-对象数组-手机",link:"#练习五-对象数组-手机",children:[]},{level:2,title:"练习六：对象数组（女朋友）",slug:"练习六-对象数组-女朋友",link:"#练习六-对象数组-女朋友",children:[]},{level:2,title:"练习七：复杂的对象数组操作",slug:"练习七-复杂的对象数组操作",link:"#练习七-复杂的对象数组操作",children:[]}],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:['java\npublic class GameTest {\n    public static void main(String[] args) {\n        //1.创建第一个角色\n        Role r1 = new Role("乔峰",100);\n        //2.创建第二个角色\n        Role r2 = new Role("鸠摩智",100);\n\n        //3.开始格斗 回合制游戏\n        while(true){\n            //r1开始攻击r2\n            r1.attack(r2);\n            //判断r2的剩余血量\n            if(r2.getBlood() == 0){\n                System.out.println(r1.getName() + " K.O了" + r2.getName());\n                break;\n            }\n\n            //r2开始攻击r1\n            r2.attack(r1);\n            if(r1.getBlood() == 0){\n                System.out.println(r2.getName() + " K.O了" + r1.getName());\n                break;\n            }\n\n\n        }\n    }\n}\n\n\n\npublic class Role {\n    private String name;\n    private int blood;\n\n    public Role() {\n    }\n\n    public Role(String name, int blood) {\n        this.name = name;\n        this.blood = blood;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getBlood() {\n        return blood;\n    }\n\n    public void setBlood(int blood) {\n        this.blood = blood;\n    }\n\n\n    //定义一个方法用于攻击别人\n    //思考：谁攻击谁？\n    //Role r1 = new Role（）；\n    //Role r2 = new Role（）；\n    //r1.攻击(r2);\n    //方法的调用者去攻击参数\n    public void attack(Role role) {\n        //计算造成的伤害 1 ~ 20\n        Random r = new Random();\n        int hurt = r.nextInt(20) + 1;\n\n        //剩余血量\n        int remainBoold = role.getBlood() - hurt;\n        //对剩余血量做一个验证，如果为负数了，就修改为0\n        remainBoold = remainBoold < 0 ? 0 : remainBoold;\n        //修改一下挨揍的人的血量\n        role.setBlood(remainBoold);\n\n        //this表示方法的调用者\n        System.out.println(this.getName() + "举起拳头，打了" + role.getName() + "一下，" +\n                "造成了" + hurt + "点伤害，" + role.getName() + "还剩下了" + remainBoold + "点血");\n    }\n\n}','java\n//男生长相数组\nString[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};\n//女生长相数组\nString[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};','java\n//attack 攻击描述：\nString[] attacks_desc = {\n    "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",\n    "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",\n    "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",\n    "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",\n    "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",\n    "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"','java\n//injured 受伤描述：\nString[] injureds_desc = {\n    "结果%s退了半步，毫发无损",\n    "结果给%s造成一处瘀伤",\n    "结果一击命中，%s痛得弯下腰",\n    "结果%s痛苦地闷哼了一声，显然受了点内伤",\n    "结果%s摇摇晃晃，一跤摔倒在地",\n    "结果%s脸色一下变得惨白，连退了好几步",\n    "结果『轰』的一声，%s口中鲜血狂喷而出",\n    "结果%s一声惨叫，像滩软泥般塌了下去"','java\npublic class Test {\n    public static void main(String[] args) {\n        //两部分参数：\n        //第一部分参数：要输出的内容%s（占位）\n        //第二部分参数：填充的数据\n        \n        System.out.printf("你好啊%s","张三");//用张三填充第一个%s\n        System.out.println();//换行\n        System.out.printf("%s你好啊%s","张三","李四");//用张三填充第一个%s，李四填充第二个%s\n    }\n}','java\npackage com.itheima.test2;\n\nimport java.util.Random;\n\npublic class Role {\n    private String name;\n    private int blood;\n    private char gender;\n    private String face;//长相是随机的\n\n    String[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};\n    String[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};\n\n    //attack 攻击描述：\n    String[] attacks_desc = {\n            "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",\n            "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",\n            "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",\n            "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",\n            "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",\n            "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"\n    };\n\n    //injured 受伤描述：\n    String[] injureds_desc = {\n            "结果%s退了半步，毫发无损",\n            "结果给%s造成一处瘀伤",\n            "结果一击命中，%s痛得弯下腰",\n            "结果%s痛苦地闷哼了一声，显然受了点内伤",\n            "结果%s摇摇晃晃，一跤摔倒在地",\n            "结果%s脸色一下变得惨白，连退了好几步",\n            "结果『轰』的一声，%s口中鲜血狂喷而出",\n            "结果%s一声惨叫，像滩软泥般塌了下去"\n    };\n\n    public Role() {\n    }\n\n    public Role(String name, int blood, char gender) {\n        this.name = name;\n        this.blood = blood;\n        this.gender = gender;\n        //随机长相\n        setFace(gender);\n    }\n\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public String getFace() {\n        return face;\n    }\n\n    public void setFace(char gender) {\n        Random r = new Random();\n        //长相是随机的\n        if (gender == \'男\') {\n            //从boyfaces里面随机长相\n            int index = r.nextInt(boyfaces.length);\n            this.face = boyfaces[index];\n        } else if (gender == \'女\') {\n            //从girlfaces里面随机长相\n            int index = r.nextInt(girlfaces.length);\n            this.face = girlfaces[index];\n        } else {\n            this.face = "面目狰狞";\n        }\n\n\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getBlood() {\n        return blood;\n    }\n\n    public void setBlood(int blood) {\n        this.blood = blood;\n    }\n\n\n    //定义一个方法用于攻击别人\n    //思考：谁攻击谁？\n    //Role r1 = new Role（）；\n    //Role r2 = new Role（）；\n    //r1.攻击(r2);\n    //方法的调用者去攻击参数\n    public void attack(Role role) {\n        Random r = new Random();\n        int index = r.nextInt(attacks_desc.length);\n        String KungFu = attacks_desc[index];\n\n        //输出一个攻击的效果\n        System.out.printf(KungFu, this.getName(), role.getName());\n        System.out.println();\n\n        //计算造成的伤害 1 ~ 20\n        int hurt = r.nextInt(20) + 1;\n\n        //剩余血量\n        int remainBoold = role.getBlood() - hurt;\n        //对剩余血量做一个验证，如果为负数了，就修改为0\n        remainBoold = remainBoold < 0 ? 0 : remainBoold;\n        //修改一下挨揍的人的血量\n        role.setBlood(remainBoold);\n\n        //受伤的描述\n        //血量> 90 0索引的描述\n        //80 ~  90  1索引的描述\n        //70 ~  80  2索引的描述\n        //60 ~  70  3索引的描述\n        //40 ~  60  4索引的描述\n        //20 ~  40  5索引的描述\n        //10 ~  20  6索引的描述\n        //小于10的   7索引的描述\n        if (remainBoold > 90) {\n            System.out.printf(injureds_desc[0], role.getName());\n        }else if(remainBoold > 80 && remainBoold <= 90){\n            System.out.printf(injureds_desc[1], role.getName());\n        }else if(remainBoold > 70 && remainBoold <= 80){\n            System.out.printf(injureds_desc[2], role.getName());\n        }else if(remainBoold > 60 && remainBoold <= 70){\n            System.out.printf(injureds_desc[3], role.getName());\n        }else if(remainBoold > 40 && remainBoold <= 60){\n            System.out.printf(injureds_desc[4], role.getName());\n        }else if(remainBoold > 20 && remainBoold <= 40){\n            System.out.printf(injureds_desc[5], role.getName());\n        }else if(remainBoold > 10 && remainBoold <= 20){\n            System.out.printf(injureds_desc[6], role.getName());\n        }else{\n            System.out.printf(injureds_desc[7], role.getName());\n        }\n        System.out.println();\n\n\n    }\n\n\n    public void showRoleInfo() {\n        System.out.println("姓名为：" + getName());\n        System.out.println("血量为：" + getBlood());\n        System.out.println("性别为：" + getGender());\n        System.out.println("长相为：" + getFace());\n    }\n\n}\n\n\n\npackage com.itheima.test2;\n\npublic class GameTest {\n    public static void main(String[] args) {\n        //1.创建第一个角色\n        Role r1 = new Role("乔峰",100,\'男\');\n        //2.创建第二个角色\n        Role r2 = new Role("鸠摩智",100,\'男\');\n\n        //展示一下角色的信息\n        r1.showRoleInfo();\n        r2.showRoleInfo();\n\n        //3.开始格斗 回合制游戏\n        while(true){\n            //r1开始攻击r2\n            r1.attack(r2);\n            //判断r2的剩余血量\n            if(r2.getBlood() == 0){\n                System.out.println(r1.getName() + " K.O了" + r2.getName());\n                break;\n            }\n\n            //r2开始攻击r1\n            r2.attack(r1);\n            if(r1.getBlood() == 0){\n                System.out.println(r2.getName() + " K.O了" + r1.getName());\n                break;\n            }\n        }\n    }\n}','java\npackage com.itheima.test3;\n\npublic class Goods {\n    private String id;\n    private String name;\n    private double price;\n    private int count;\n\n    public Goods() {\n    }\n\n    public Goods(String id, String name, double price, int count) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n        this.count = count;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public void setCount(int count) {\n        this.count = count;\n    }\n}\n\n\n\npackage com.itheima.test3;\n\npublic class GoodsTest {\n    public static void main(String[] args) {\n        //1.创建一个数组\n        Goods[] arr = new Goods[3];\n\n        //2.创建三个商品对象\n        Goods g1 = new Goods("001","华为P40",5999.0,100);\n        Goods g2 = new Goods("002","保温杯",227.0,50);\n        Goods g3 = new Goods("003","枸杞",12.7,70);\n\n        //3.把商品添加到数组中\n        arr[0] = g1;\n        arr[1] = g2;\n        arr[2] = g3;\n\n        //4.遍历\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引 arr[i] 元素\n            Goods goods = arr[i];\n            System.out.println(goods.getId() + ", " + goods.getName() + ", " + goods.getPrice() + ", " + goods.getCount());\n        }\n    }\n}','java\npackage com.itheima.test5;\n\npublic class Car {\n    private String brand;//品牌\n    private int price;//价格\n    private String color;//颜色\n\n\n    public Car() {\n    }\n\n    public Car(String brand, int price, String color) {\n        this.brand = brand;\n        this.price = price;\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npackage com.itheima.test5;\n\nimport java.util.Scanner;\n\npublic class CarTest {\n    public static void main(String[] args) {\n        //1.创建一个数组用来存3个汽车对象\n        Car[] arr = new Car[3];\n\n        //2.创建汽车对象，数据来自于键盘录入\n        Scanner sc = new Scanner(System.in);\n        for (int i = 0; i < arr.length; i++) {\n            //创建汽车的对象\n            Car c = new Car();\n            //录入品牌\n            System.out.println("请输入汽车的品牌");\n            String brand = sc.next();\n            c.setBrand(brand);\n            //录入价格\n            System.out.println("请输入汽车的价格");\n            int price = sc.nextInt();\n            c.setPrice(price);\n            //录入颜色\n            System.out.println("请输入汽车的颜色");\n            String color = sc.next();\n            c.setColor(color);\n\n            //把汽车对象添加到数组当中\n            arr[i] = c;\n        }\n\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            Car car = arr[i];\n            System.out.println(car.getBrand() + ", " + car.getPrice() + ", " + car.getColor());\n        }\n    }\n}','java\npackage com.itheima.test6;\n\npublic class Phone {\n    private String brand;//品牌\n    private int price;//价格\n    private String color;//颜色\n\n    public Phone() {\n    }\n\n    public Phone(String brand, int price, String color) {\n        this.brand = brand;\n        this.price = price;\n        this.color = color;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npackage com.itheima.test6;\n\nimport java.math.BigDecimal;\n\npublic class PhoneTest {\n    public static void main(String[] args) {\n        //1.创建一个数组\n        Phone[] arr = new Phone[3];\n\n        //2.创建手机的对象\n        Phone p1 = new Phone("小米",1999,"白色");\n        Phone p2 = new Phone("华为",4999,"蓝色");\n        Phone p3 = new Phone("魅族",3999,"红色");\n\n        //3.把手机对象添加到数组当中\n        arr[0] = p1;\n        arr[1] = p2;\n        arr[2] = p3;\n\n        //4.获取三部手机的平均价格\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引  arr[i] 元素（手机对象）\n            Phone phone = arr[i];\n            sum = sum + phone.getPrice();\n        }\n\n        //5.求平均值\n        //数据能不写死，尽量不写死\n        //int avg = sum / arr.length;\n\n        double avg2 = sum * 1.0 / arr.length;\n\n        System.out.println(avg2);//3665.6666666666665\n    }\n}','java\npackage com.itheima.test7;\n\npublic class GirlFriend {\n    private String name;//姓名\n    private int age;//年龄\n    private String gender;//性别\n    private String hobby;//爱好\n\n\n    public GirlFriend() {\n    }\n\n    public GirlFriend(String name, int age, String gender, String hobby) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.hobby = hobby;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getHobby() {\n        return hobby;\n    }\n\n    public void setHobby(String hobby) {\n        this.hobby = hobby;\n    }\n}\n\n\npackage com.itheima.test7;\n\npublic class GirlFriendTest {\n    public static void main(String[] args) {\n        //1.定义数组存入女朋友的对象\n        GirlFriend[] arr = new GirlFriend[4];\n\n        //2.创建女朋友对象\n        GirlFriend gf1 = new GirlFriend("小诗诗",18,"萌妹子","吃零食");\n        GirlFriend gf2 = new GirlFriend("小丹丹",19,"萌妹子","玩游戏");\n        GirlFriend gf3 = new GirlFriend("小惠惠",20,"萌妹子","看书，学习");\n        GirlFriend gf4 = new GirlFriend("小莉莉",21,"憨妹子","睡觉");\n\n        //3.把对象添加到数组当中\n        arr[0] = gf1;\n        arr[1] = gf2;\n        arr[2] = gf3;\n        arr[3] = gf4;\n\n        //4.求和\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引 arr[i] 元素（女朋友对象）\n            GirlFriend gf = arr[i];\n            //累加\n            sum = sum + gf.getAge();\n        }\n\n        //5.平均值\n        int avg = sum / arr.length;\n\n        //6.统计年龄比平均值低的有几个，打印他们的信息\n        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            GirlFriend gf = arr[i];\n            if(gf.getAge() < avg){\n                count++;\n                System.out.println(gf.getName() + ", " + gf.getAge() + ", " + gf.getGender() + ", " + gf.getHobby());\n            }\n        }\n\n        System.out.println(count + "个");\n    }\n}',"java\npackage com.itheima.test8;\n\npublic class Student {\n    private int id;\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public Student(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}",'java\npublic class Test {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n        要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\n        要求2：添加完毕之后，遍历所有学生信息。\n\t\t*/\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n\n\n        //要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\n        Student stu4 = new Student(1, "zhaoliu", 26);\n\n        //唯一性判断\n        //已存在 --- 不用添加\n        //不存在 --- 就可以把学生对象添加进数组\n        boolean flag = contains(arr, stu4.getId());\n        if(flag){\n            //已存在 --- 不用添加\n            System.out.println("当前id重复，请修改id后再进行添加");\n        }else{\n            //不存在 --- 就可以把学生对象添加进数组\n            //把stu4添加到数组当中\n            //1.数组已经存满 --- 只能创建一个新的数组，新数组的长度 = 老数组 + 1\n            //2.数组没有存满 --- 直接添加\n            int count = getCount(arr);\n            if(count == arr.length){\n                //已经存满\n                //创建一个新的数组，长度 = 老数组的长度 + 1\n                //然后把老数组的元素，拷贝到新数组当中\n                Student[] newArr = creatNewArr(arr);\n                //把stu4添加进去\n                newArr[count] = stu4;\n\n                //要求2：添加完毕之后，遍历所有学生信息。\n                printArr(newArr);\n\n            }else{\n                //没有存满\n                //[stu1,stu2,null]\n                //getCount获取到的是2，表示数组当中已经有了2个元素\n                //还有一层意思：如果下一次要添加数据，就是添加到2索引的位置\n                arr[count] = stu4;\n                //要求2：添加完毕之后，遍历所有学生信息。\n                printArr(arr);\n\n            }\n        }\n    }\n\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n\n    //创建一个新的数组，长度 = 老数组的长度 + 1\n    //然后把老数组的元素，拷贝到新数组当中\n    public static Student[] creatNewArr(Student[] arr){\n        Student[] newArr = new Student[arr.length + 1];\n\n        //循环遍历得到老数组中的每一个元素\n        for (int i = 0; i < arr.length; i++) {\n            //把老数组中的元素添加到新数组当中\n            newArr[i] = arr[i];\n        }\n\n        //把新数组返回\n        return newArr;\n\n    }\n\n    //定义一个方法判断数组中已经存了几个元素\n    public static int getCount(Student[] arr){\n        //定义一个计数器用来统计\n        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] != null){\n                count++;\n            }\n        }\n        //当循环结束之后，我就知道了数组中一共有几个元素\n        return count;\n    }\n\n\n    //1.我要干嘛？  唯一性判断\n    //2.我干这件事情，需要什么才能完成？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 必须返回\n    public static boolean contains(Student[] arr, int id) {\n        for (int i = 0; i < arr.length; i++) {\n            //依次获取到数组里面的每一个学生对象\n            Student stu = arr[i];\n            if(stu != null){\n                //获取数组中学生对象的id\n                int sid = stu.getId();\n                //比较\n                if(sid == id){\n                    return true;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到一样的，那么就表示数组中要查找的id是不存在的。\n        return false;\n    }\n\n\n}','java\npackage com.itheima.test8;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n\n        要求3：通过id删除学生信息\n            如果存在，则删除，如果不存在，则提示删除失败。\n        要求4：删除完毕之后，遍历所有学生信息。\n\n       */\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n        Student stu3 = new Student(3, "wangwu", 25);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n        arr[2] = stu3;\n\n        /*要求3：通过id删除学生信息\n        如果存在，则删除，如果不存在，则提示删除失败。*/\n\n        //要找到id在数组中对应的索引\n        int index = getIndex(arr, 2);\n        if (index >= 0){\n            //如果存在，则删除\n            arr[index] = null;\n            //遍历数组\n            printArr(arr);\n        }else{\n            //如果不存在，则提示删除失败\n            System.out.println("当前id不存在，删除失败");\n        }\n\n\n\n\n\n    }\n\n\n\n    //1.我要干嘛？  找到id在数组中的索引\n    //2.我需要什么？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 要\n    public static int getIndex(Student[] arr , int id){\n        for (int i = 0; i < arr.length; i++) {\n            //依次得到每一个学生对象\n            Student stu = arr[i];\n            //对stu进行一个非空判断\n            if(stu != null){\n                int sid = stu.getId();\n                if(sid == id){\n                    return i;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到就表示不存在\n        return -1;\n    }\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n\n\n}','java\npackage com.itheima.test8;\n\npublic class Test4 {\n    public static void main(String[] args) {\n        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\n        学生的属性：学号，姓名，年龄。\n\n        要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/\n\n\n        //1.创建一个数组用来存储学生对象\n        Student[] arr = new Student[3];\n        //2.创建学生对象并添加到数组当中\n        Student stu1 = new Student(1, "zhangsan", 23);\n        Student stu2 = new Student(2, "lisi", 24);\n        Student stu3 = new Student(3, "wangwu", 25);\n\n        //3.把学生对象添加到数组当中\n        arr[0] = stu1;\n        arr[1] = stu2;\n        arr[2] = stu3;\n\n\n        //4.先要找到id为2的学生对于的索引\n        int index = getIndex(arr, 2);\n\n        //5.判断索引\n        if(index >= 0){\n            //存在， 则将他的年龄+1岁\n            Student stu = arr[index];\n            //把原来的年龄拿出来\n            int newAge = stu.getAge() + 1;\n            //把+1之后的年龄塞回去\n            stu.setAge(newAge);\n            //遍历数组\n            printArr(arr);\n        }else{\n            //不存在，则直接提示\n            System.out.println("当前id不存在，修改失败");\n        }\n\n\n    }\n\n    //1.我要干嘛？  找到id在数组中的索引\n    //2.我需要什么？ 数组 id\n    //3.调用处是否需要继续使用方法的结果？ 要\n    public static int getIndex(Student[] arr , int id){\n        for (int i = 0; i < arr.length; i++) {\n            //依次得到每一个学生对象\n            Student stu = arr[i];\n            //对stu进行一个非空判断\n            if(stu != null){\n                int sid = stu.getId();\n                if(sid == id){\n                    return i;\n                }\n            }\n        }\n\n        //当循环结束之后，还没有找到就表示不存在\n        return -1;\n    }\n\n    public static void printArr(Student[] arr){\n        for (int i = 0; i < arr.length; i++) {\n            Student stu = arr[i];\n            if(stu != null){\n                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());\n            }\n        }\n    }\n}']},{title:"常用API",headers:[{level:2,title:"1.API",slug:"_1-api",link:"#_1-api",children:[{level:3,title:"1.1.API概述",slug:"_1-1-api概述",link:"#_1-1-api概述",children:[]},{level:3,title:"1.2.如何使用API帮助文档",slug:"_1-2-如何使用api帮助文档",link:"#_1-2-如何使用api帮助文档",children:[]}]},{level:2,title:"2.String类",slug:"_2-string类",link:"#_2-string类",children:[{level:3,title:"2.1.String类概述",slug:"_2-1-string类概述",link:"#_2-1-string类概述",children:[]},{level:3,title:"2.2.String类的特点",slug:"_2-2-string类的特点",link:"#_2-2-string类的特点",children:[]},{level:3,title:"2.3.String类的构造方法",slug:"_2-3-string类的构造方法",link:"#_2-3-string类的构造方法",children:[]},{level:3,title:"2.4.创建字符串对象两种方式的区别",slug:"_2-4-创建字符串对象两种方式的区别",link:"#_2-4-创建字符串对象两种方式的区别",children:[]},{level:3,title:"2.5.字符串的比较",slug:"_2-5-字符串的比较",link:"#_2-5-字符串的比较",children:[]},{level:3,title:"2.6.用户登录案例",slug:"_2-6-用户登录案例",link:"#_2-6-用户登录案例",children:[]},{level:3,title:"2.7.遍历字符串案例",slug:"_2-7-遍历字符串案例",link:"#_2-7-遍历字符串案例",children:[]},{level:3,title:"2.8.统计字符次数案例",slug:"_2-8-统计字符次数案例",link:"#_2-8-统计字符次数案例",children:[]},{level:3,title:"2.9.字符串拼接案例",slug:"_2-9-字符串拼接案例",link:"#_2-9-字符串拼接案例",children:[]},{level:3,title:"2.10.字符串反转案例",slug:"_2-10-字符串反转案例",link:"#_2-10-字符串反转案例",children:[]},{level:3,title:"2.11.金额转换",slug:"_2-11-金额转换",link:"#_2-11-金额转换",children:[]},{level:3,title:"2.12.手机号屏蔽",slug:"_2-12-手机号屏蔽",link:"#_2-12-手机号屏蔽",children:[]},{level:3,title:"2.13.敏感词替换",slug:"_2-13-敏感词替换",link:"#_2-13-敏感词替换",children:[]},{level:3,title:"2.14.身份证信息查看",slug:"_2-14-身份证信息查看",link:"#_2-14-身份证信息查看",children:[]}]},{level:2,title:"3.StringBuilder",slug:"_3-stringbuilder",link:"#_3-stringbuilder",children:[{level:3,title:"3.1.基本使用",slug:"_3-1-基本使用",link:"#_3-1-基本使用",children:[]},{level:3,title:"3.2.链式编程",slug:"_3-2-链式编程",link:"#_3-2-链式编程",children:[]},{level:3,title:"3.3.练习1：对称字符串",slug:"_3-3-练习1-对称字符串",link:"#_3-3-练习1-对称字符串",children:[]},{level:3,title:"3.4.练习2：拼接字符串",slug:"_3-4-练习2-拼接字符串",link:"#_3-4-练习2-拼接字符串",children:[]}]},{level:2,title:"4.StringJoiner",slug:"_4-stringjoiner",link:"#_4-stringjoiner",children:[]},{level:2,title:"5.关于字符串的小扩展：",slug:"_5-关于字符串的小扩展",link:"#_5-关于字符串的小扩展",children:[]}],path:"/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%B8%B8%E7%94%A8API.html",pathLocale:"/",extraFields:['java\n  public class StringDemo01 {\n      public static void main(String[] args) {\n          //public String()：创建一个空白字符串对象，不含有任何内容\n          String s1 = new String();\n          System.out.println("s1:" + s1);\n  \n          //public String(char[] chs)：根据字符数组的内容，来创建字符串对象\n          char[] chs = {\'a\', \'b\', \'c\'};\n          String s2 = new String(chs);\n          System.out.println("s2:" + s2);\n  \n          //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象\n          byte[] bys = {97, 98, 99};\n          String s3 = new String(bys);\n          System.out.println("s3:" + s3);\n  \n          //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc\n          String s4 = "abc";\n          System.out.println("s4:" + s4);\n      }\n  }',"java\n  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写","java\n  public class StringDemo02 {\n      public static void main(String[] args) {\n          //构造方法的方式得到对象\n          char[] chs = {'a', 'b', 'c'};\n          String s1 = new String(chs);\n          String s2 = new String(chs);\n  \n          //直接赋值的方式得到对象\n          String s3 = \"abc\";\n          String s4 = \"abc\";\n  \n          //比较字符串对象地址是否相同\n          System.out.println(s1 == s2);\n          System.out.println(s1 == s3);\n          System.out.println(s3 == s4);\n          System.out.println(\"--------\");\n  \n          //比较字符串内容是否相同\n          System.out.println(s1.equals(s2));\n          System.out.println(s1.equals(s3));\n          System.out.println(s3.equals(s4));\n      }\n  }",'java\npublic class Test1登录案例 {\n    public static void main(String[] args) {\n        //1.定义两个变量用来记录正确的用户名和密码\n        String rightUsername = "itheima";\n        String rightPassword = "1234qwer";\n\n        //2.键盘录入用户名和密码\n        //ctrl + alt + T 选择包裹方式\n\n        for (int i = 0; i < 3; i++) {//0 1 2\n            Scanner sc = new Scanner(System.in);\n            System.out.println("请输入用户名");\n            String username = sc.next();\n            System.out.println("请输入密码");\n            String password = sc.next();\n\n            //3.判断比较\n            if (username.equals(rightUsername) && password.equals(rightPassword)) {\n                System.out.println("登录成功");\n                //如果正确，循环结束\n                break;\n            } else {\n                //最后一次机会\n                if(i == 2){\n                    System.out.println("账户" + username + "被锁定，请联系黑马程序员官方小姐姐：XXXXXXX");\n                }else{\n                    //不是最后一次机会\n                    System.out.println("用户名或密码错误，登录失败,还剩下" + (2 - i) + "次机会");//2 1 0\n                }\n            }\n        }\n\n    }\n}','java\npublic class Test2字符串直接遍历 {\n    public static void main(String[] args) {\n        //两个方法：\n        //charAt()：会根据索引获取对应的字符\n        //length(): 会返回字符串的长度\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入字符串");\n        String str = sc.next();\n        System.out.println(str);\n\n        //2.遍历\n        for (int i = 0; i < str.length(); i++) {\n            //i 依次表示字符串的每一个索引\n            //索引的范围：0 ~  长度-1\n\n            //根据索引获取字符串里面的每一个字符\n            //ctrl + alt + V 自动生成左边的接受变量\n            char c = str.charAt(i);\n            System.out.println(c);\n        }\n    }\n}','java\npublic class Test4统计个数 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，统计大写，小写，数字出现的次数\n\n\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n\n\n        //2.统计 --- 计数器count\n        //此时我要统计的有3样东西，所以要定义3个计数器分别进行统计\n        int bigCount = 0;\n        int smallCount = 0;\n        int numberCount = 0;\n        //得到这个字符串里面每一个字符\n        for (int i = 0; i < str.length(); i++) {\n            //i 表示字符串中的索引\n            //c 表示字符串中的每一个字符\n            char c = str.charAt(i);\n\n            //对c进行判断\n            if (c >= \'a\' && c <= \'z\') {\n                smallCount++;\n            }else if(c >= \'A\' && c <= \'Z\'){\n                bigCount++;\n            }else if(c >= \'0\' && c <= \'9\'){\n                numberCount++;\n            }\n        }\n\n        //3.当循环结束之后，三个变量记录的就是对应的个数\n        System.out.println("大写字符有:" + bigCount + "个");\n        System.out.println("小写字符有:" + smallCount + "个");\n        System.out.println("数字字符有:" + numberCount + "个");\n    }\n}','java\npublic class Test5数组拼接成字符串 {\n    public static void main(String[] args) {\n        //定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，\n        //并在控制台输出结果。例如，数组为 int[] arr = {1,2,3};\n        //执行方法后的输出结果为：[1, 2, 3]\n\n\n        int[] arr = {1, 2, 3, 4, 5};\n\n        String str = arrToString(arr);\n        System.out.println(str);\n\n    }\n\n\n    //作用：把一个数组变成字符串\n    public static String arrToString(int[] arr) {\n        String s = "";\n        //拼接左括号\n        s = s + "["; //此时是拿着长度为0的字符串，跟[进行拼接，产生一个新的字符串。\n        //把新的字符串再赋值给s，此时变量s记录的就是新的字符串"["的地址值\n\n        //下面我想得到数组里面的每一个元素并进行拼接\n        //那么就需要遍历数组，得到每一个元素才行\n        for (int i = 0; i < arr.length; i++) {\n            //假设第一次循环:i = 0 获取的就是0索引上的元素\n            //在拼接的时候："[" + 1 + ", " 拼接完毕之后产生一个新的字符串 "[1, "\n            //第二次循环：i = 1 获取的就是1索引上的元素\n            //在拼接的时候： 此时s就是第一次循环结束后拼接完毕的结果："[1, "\n            //在拼接的时候："[1, " + 2 + ", " 拼接完毕之后产生一个新的字符串 "[1, 2, "\n            //...\n           if(i == arr.length - 1){\n               //如果是最后一个元素，那么不需要拼接逗号空格\n               s = s + arr[i];\n           }else{\n               //如果不是最后一个元素，需要拼接元素和逗号空格\n               s = s + arr[i] + ", ";\n           }\n        }\n\n        //等循环结束之后，再拼接最后一个右括号\n        s = s + "]";\n\n        return s;\n\n    }\n\n\n    //用来遍历数组\n    public static void printArr(int[] arr) {\n        System.out.print("[");\n        for (int i = 0; i < arr.length; i++) {\n            if (i == arr.length - 1) {\n                System.out.print(arr[i]);\n            } else {\n                System.out.print(arr[i] + ", ");\n            }\n        }\n        System.out.println("]");\n\n        //[1, 2, 3, 4, 5]\n        //我们现在要知道，这个最终结果是怎么来的？\n        //从到右依次打印得来的。\n    }\n}','java\npublic class Test6反转字符串 {\n    public static void main(String[] args) {\n        /*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果\n        例如，键盘录入 abc，输出结果 cba*/\n\n\n\n        //1.定义一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n        //2.定义一个方法，反转字符串\n        //abc  ---\x3e  cba\n        //可以把字符串倒着遍历，再拼接\n        String result = reverse(str);\n        System.out.println(result);\n\n\n    }\n\n    //注释：方法的作用就是反转字符串\n    //把传递进来的字符串进行反转\n    public static String reverse(String str){//abc\n        //核心思想：倒着遍历并进行拼接就可以了\n        //fori :正着遍历  forr：倒着遍历\n        String s = "";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            //i 依次表示字符串里面的每一个索引（倒着的）\n            //我们就可以拿到里面的每一个字符并拼接\n            s = s + str.charAt(i);\n        }\n\n        //把倒着拼接之后的结果返回即可\n        return s;\n\n    }\n}','java\npackage com.itheima.stringdemo;\n\nimport java.util.Scanner;\n\npublic class StringDemo9 {\n    public static void main(String[] args) {\n        //1.键盘录入一个金额\n        Scanner sc = new Scanner(System.in);\n        int money;\n        while (true) {\n            System.out.println("请录入一个金额");\n            money = sc.nextInt();\n            if (money >= 0 && money <= 9999999) {\n                break;\n            } else {\n                System.out.println("金额无效");\n            }\n        }\n\n        //定义一个变量用来表示钱的大写\n        String moneyStr = "";\n\n        //2.得到money里面的每一位数字,再转成中文\n        while (true) {//2135\n            //从右往左获取数据，因为右侧是数据的个位\n            int ge = money % 10;\n            String capitalNumber = getCapitalNumber(ge);\n            //把转换之后的大写拼接到moneyStr当中\n            moneyStr = capitalNumber + moneyStr;\n            //第一次循环 ： "伍" + "" = "伍"\n            //第二次循环 ： "叁" + "伍" = "叁伍"\n            //去掉刚刚获取的数据\n            money = money / 10;\n\n            //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束\n            if (money == 0) {\n                break;\n            }\n        }\n\n        //3.在前面补0，补齐7位\n        int count = 7 - moneyStr.length();\n        for (int i = 0; i < count; i++) {\n            moneyStr = "零" + moneyStr;\n        }\n        System.out.println(moneyStr);//零零零贰壹叁伍\n\n        //4.插入单位\n        //定义一个数组表示单位\n        String[] arr = {"佰","拾","万","仟","佰","拾","元"};\n        //               零    零   零   贰   壹   叁   伍\n\n        //遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍\n        //然后把arr的单位插入进去\n\n        String result = "";\n        for (int i = 0; i < moneyStr.length(); i++) {\n            char c = moneyStr.charAt(i);\n            //把大写数字和单位拼接到result当中\n            result = result + c + arr[i];\n        }\n\n        //5.打印最终结果\n        System.out.println(result);\n\n    }\n\n\n    //定义一个方法把数字变成大写的中文\n    //1 -- 壹\n    public static String getCapitalNumber(int number) {\n        //定义数组，让数字跟大写的中文产生一个对应关系\n        String[] arr = {"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"};\n        //返回结果\n        return arr[number];\n    }\n\n}','java\npublic class Test8手机号屏蔽 {\n    public static void main(String[] args) {\n        /*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽\n        最终效果为：131****9468*/\n\n        //1.键盘录入一个手机号码\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入手机号码");\n        String phoneNumber = sc.next();//13112349408\n\n        //2.截取手机号码中的前三位\n        String star = phoneNumber.substring(0, 3);\n\n        //3.截取手机号码中的最后四位\n        //此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好\n        //因为现在我要截取到最后，所以建议使用1个参数的。\n        String end = phoneNumber.substring(7);\n\n        //4.拼接\n        String result = star + "****" + end;\n\n        System.out.println(result);\n\n    }\n}','java\npublic class Test9敏感词替换 {\n    public static void main(String[] args) {\n        //1.定义一个变量表示骂人的话\n        String talk = "后裔你玩什么啊，TMD";\n\n\n        //2.把这句话中的敏感词进行替换\n        String result = talk.replace("TMD", "***");\n\n        //3.打印\n        System.out.println(talk);\n        System.out.println(result);\n    }\n}','java\npublic class Test10多个敏感词替换 {\n    public static void main(String[] args) {\n        //实际开发中，敏感词会有很多很多\n\n        //1.先键盘录入要说的话\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要说的话");\n        String talk = sc.next();//后裔你玩什么啊，TMD,GDX,ctmd,ZZ\n\n        //2.定义一个数组用来存多个敏感词\n        String[] arr = {"TMD","GDX","ctmd","ZZ","lj","FW","nt"};\n\n        //3.把说的话中所有的敏感词都替换为***\n\n        for (int i = 0; i < arr.length; i++) {\n            //i 索引\n            //arr[i] 元素 --- 敏感词\n            talk = talk.replace(arr[i],"***");\n        }\n\n        //4.打印结果\n        System.out.println(talk);//后裔你玩什么啊，***,***,***,***\n\n    }\n}',"java\npackage com.itheima.stringdemo;\n\npublic class StringDemo11 {\n    public static void main(String[] args) {\n        //1.定义一个字符串记录身份证号码\n        String id = \"321281202001011234\";\n\n        //2.获取出生年月日\n        String year = id.substring(6, 10);\n        String month = id.substring(10, 12);\n        String day = id.substring(12, 14);\n\n\n        System.out.println(\"人物信息为：\");\n        System.out.println(\"出生年月日:\" + year + \"年\" + month + \"月\" + day + \"日\");\n\n        //3.获取性别\n        char gender = id.charAt(16);//'3'  ---\x3e 3\n        //利用ASCII码表进行转换\n        //'0' ---\x3e  48\n        //'1' ---\x3e  49\n        //'2' ---\x3e  50\n        //'3' ---\x3e  51\n        //'4' ---\x3e  52\n        //'5' ---\x3e  53\n        //'6' ---\x3e  54\n        //'7' ---\x3e  55\n        //'8' ---\x3e  56\n        //'9' ---\x3e  57\n\n       int num = gender - 48;\n        if(num % 2 == 0){\n            System.out.println(\"性别为:女\");\n        }else{\n            System.out.println(\"性别为:男\");\n        }\n    }\n}",'java\npublic class StringBuilderDemo3 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder("abc");\n\n        //2.添加元素\n        /*sb.append(1);\n        sb.append(2.3);\n        sb.append(true);*/\n\n        //反转\n        sb.reverse();\n\n        //获取长度\n        int len = sb.length();\n        System.out.println(len);\n\n\n        //打印\n        //普及：\n        //因为StringBuilder是Java已经写好的类\n        //java在底层对他做了一些特殊处理。\n        //打印对象不是地址值而是属性值。\n        System.out.println(sb);\n    }\n}','java\npublic class StringBuilderDemo4 {\n    public static void main(String[] args) {\n        //1.创建对象\n        StringBuilder sb = new StringBuilder();\n\n        //2.添加字符串\n        sb.append("aaa").append("bbb").append("ccc").append("ddd");\n\n        System.out.println(sb);//aaabbbcccddd\n\n        //3.再把StringBuilder变回字符串\n        String str = sb.toString();\n        System.out.println(str);//aaabbbcccddd\n\n    }\n}','java\npublic class StringBuilderDemo6 {\n    //使用StringBuilder的场景：\n    //1.字符串的拼接\n    //2.字符串的反转\n\n    public static void main(String[] args) {\n        //1.键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入一个字符串");\n        String str = sc.next();\n\n        //2.反转键盘录入的字符串\n        String result = new StringBuilder().append(str).reverse().toString();\n\n        //3.比较\n        if(str.equals(result)){\n            System.out.println("当前字符串是对称字符串");\n        }else{\n            System.out.println("当前字符串不是对称字符串");\n        }\n\n    }\n}','java\npackage com.itheima.stringbuilderdemo;\n\npublic class StringBuilderDemo7 {\n    public static void main(String[] args) {\n        //1.定义数组\n        int[] arr = {1,2,3};\n\n        //2.调用方法把数组变成字符串\n        String str = arrToString(arr);\n\n        System.out.println(str);\n\n    }\n\n\n    public static String arrToString(int[] arr){\n        StringBuilder sb = new StringBuilder();\n        sb.append("[");\n\n        for (int i = 0; i < arr.length; i++) {\n            if(i == arr.length - 1){\n                sb.append(arr[i]);\n            }else{\n                sb.append(arr[i]).append(", ");\n            }\n        }\n        sb.append("]");\n\n        return sb.toString();\n    }\n}','java\n//1.创建一个对象，并指定中间的间隔符号\nStringJoiner sj = new StringJoiner("---");\n//2.添加元素\nsj.add("aaa").add("bbb").add("ccc");\n//3.打印结果\nSystem.out.println(sj);//aaa---bbb---ccc','java\n//1.创建对象\nStringJoiner sj = new StringJoiner(", ","[","]");\n//2.添加元素\nsj.add("aaa").add("bbb").add("ccc");\nint len = sj.length();\nSystem.out.println(len);//15\n//3.打印\nSystem.out.println(sj);//[aaa, bbb, ccc]\nString str = sj.toString();\nSystem.out.println(str);//[aaa, bbb, ccc]']},{title:"ArrayList&学生管理系统",headers:[{level:2,title:"1.ArrayList",slug:"_1-arraylist",link:"#_1-arraylist",children:[{level:3,title:"集合和数组的优势对比：",slug:"集合和数组的优势对比",link:"#集合和数组的优势对比",children:[]},{level:3,title:"1.1 ArrayList类概述",slug:"_1-1-arraylist类概述",link:"#_1-1-arraylist类概述",children:[]},{level:3,title:"1.2 ArrayList类常用方法",slug:"_1-2-arraylist类常用方法",link:"#_1-2-arraylist类常用方法",children:[]},{level:3,title:"1.3 ArrayList存储字符串并遍历",slug:"_1-3-arraylist存储字符串并遍历",link:"#_1-3-arraylist存储字符串并遍历",children:[]},{level:3,title:"1.4 ArrayList存储学生对象并遍历",slug:"_1-4-arraylist存储学生对象并遍历",link:"#_1-4-arraylist存储学生对象并遍历",children:[]},{level:3,title:"1.5 查找用户的索引",slug:"_1-5-查找用户的索引",link:"#_1-5-查找用户的索引",children:[]},{level:3,title:"1.6 判断用户的是否存在",slug:"_1-6-判断用户的是否存在",link:"#_1-6-判断用户的是否存在",children:[]}]},{level:2,title:"2.学生管理系统",slug:"_2-学生管理系统",link:"#_2-学生管理系统",children:[{level:3,title:"2.1学生管理系统实现步骤",slug:"_2-1学生管理系统实现步骤",link:"#_2-1学生管理系统实现步骤",children:[]},{level:3,title:"2.2学生类的定义",slug:"_2-2学生类的定义",link:"#_2-2学生类的定义",children:[]},{level:3,title:"2.3测试类的定义",slug:"_2-3测试类的定义",link:"#_2-3测试类的定义",children:[]}]}],path:"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html",pathLocale:"/",extraFields:['java\npublic class ArrayListDemo02 {\n    public static void main(String[] args) {\n        //创建集合\n        ArrayList<String> array = new ArrayList<String>();\n\n        //添加元素\n        array.add("hello");\n        array.add("world");\n        array.add("java");\n\n        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功\n        //        System.out.println(array.remove("world"));\n        //        System.out.println(array.remove("javaee"));\n\n        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素\n        //        System.out.println(array.remove(1));\n\n        //IndexOutOfBoundsException\n        //        System.out.println(array.remove(3));\n\n        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素\n        //        System.out.println(array.set(1,"javaee"));\n\n        //IndexOutOfBoundsException\n        //        System.out.println(array.set(3,"javaee"));\n\n        //public E get(int index)：返回指定索引处的元素\n        //        System.out.println(array.get(0));\n        //        System.out.println(array.get(1));\n        //        System.out.println(array.get(2));\n        //System.out.println(array.get(3)); //？？？？？？ 自己测试\n\n        //public int size()：返回集合中的元素的个数\n        System.out.println(array.size());\n\n        //输出集合\n        System.out.println("array:" + array);\n    }\n}','java\npublic class ArrayListDemo3 {\n    public static void main(String[] args) {\n        //1.创建集合对象\n        ArrayList<String> list = new ArrayList<>();\n\n        //2.添加元素\n        list.add("aaa");\n        list.add("bbb");\n        list.add("ccc");\n        list.add("ddd");\n\n        //3.遍历\n        //快捷键: list.fori 正向遍历\n        //list.forr 倒着遍历\n        System.out.print("[");\n        for (int i = 0; i < list.size(); i++) {\n            //i 依次表示集合里面的每一个索引\n\n            if(i == list.size() - 1){\n                //最大索引\n                System.out.print(list.get(i));\n            }else{\n                //非最大索引\n                System.out.print(list.get(i) + ", ");\n            }\n        }\n        System.out.print("]");\n    }\n}','java\npublic class ArrayListDemo4 {\n    public static void main(String[] args) {\n        //1.创建集合对象，用来存储数据\n        ArrayList<Student> list = new ArrayList<>();\n\n        //2.创建学生对象\n        Student s1 = new Student("zhangsan",16);\n        Student s2 = new Student("lisi",15);\n        Student s3 = new Student("wangwu",18);\n\n        //3.把学生对象添加到集合中\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n\n        //4.遍历\n        for (int i = 0; i < list.size(); i++) {\n            //i 依次表示集合中的每一个索引\n            Student stu = list.get(i);\n            System.out.println(stu.getName() + ", " + stu.getAge());\n        }\n\n\n\n    }\n}','java\npublic class ArrayListDemo6 {\n    public static void main(String[] args) {\n        /*需求：\n        1，main方法中定义一个集合，存入三个用户对象。\n        用户属性为：id，username，password\n        2，要求：定义一个方法，根据id查找对应的学生信息。\n        如果存在，返回索引\n        如果不存在，返回-1*/\n\n\n        //1.创建集合对象\n        ArrayList<User> list = new ArrayList<>();\n\n        //2.创建用户对象\n        User u1 = new User("heima001", "zhangsan", "123456");\n        User u2 = new User("heima002", "lisi", "1234");\n        User u3 = new User("heima003", "wangwu", "1234qwer");\n\n        //3.把用户对象添加到集合当中\n        list.add(u1);\n        list.add(u2);\n        list.add(u3);\n\n        //4.调用方法，通过id获取对应的索引\n        int index = getIndex(list, "heima001");\n\n        System.out.println(index);\n\n    }\n\n\n    //1.我要干嘛？  根据id查找对应的学生信息\n    //2.我干这件事情需要什么才能完成？   集合 id\n    //3.方法的调用处是否需要继续使用方法的结果？\n    //要用必须返回，不要用可以返回也可以不返回\n    //明确说明需要有返回值 int\n    public static int getIndex(ArrayList<User> list, String id) {\n        //遍历集合得到每一个元素\n        for (int i = 0; i < list.size(); i++) {\n            User u = list.get(i);\n            String uid = u.getId();\n            if(uid.equals(id)){\n                return i;\n            }\n        }\n        //因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。\n        return -1;\n    }\n}','java\npublic class ArrayListDemo5 {\n    public static void main(String[] args) {\n       /* 需求：\n        1，main方法中定义一个集合，存入三个用户对象。\n        用户属性为：id，username，password\n        2，要求：定义一个方法，根据id查找对应的学生信息。\n        如果存在，返回true\n        如果不存在，返回false*/\n\n        //1.定义集合\n        ArrayList<User> list = new ArrayList<>();\n\n        //2.创建对象\n        User u1 = new User("heima001","zhangsan","123456");\n        User u2 = new User("heima002","lisi","12345678");\n        User u3 = new User("heima003","wangwu","1234qwer");\n\n        //3.把用户对象添加到集合当中\n        list.add(u1);\n        list.add(u2);\n        list.add(u3);\n\n        //4.调用方法，查询id是否存在\n        boolean result = contains(list, "heima001");\n        System.out.println(result);\n\n    }\n\n    //定义在测试类中的方法需要加static\n    //1.我要干嘛？ 我要根据id查询学生是否存在\n    //2.我干这件事情，需要什么才能完成？ 集合 id\n    //3.方法的调用处是否需要使用方法的结果？\n    //如果要用，必须返回，如果不用，可以返回也可以不返回\n    //但是本题明确说明需要返回\n    public static boolean contains(ArrayList<User> list, String id){\n        //循环遍历集合，得到集合里面的每一个元素\n        //再进行判断\n\n        for (int i = 0; i < list.size(); i++) {\n            //i 索引  list.get(i); 元素\n            User u = list.get(i);\n            //判断id是否存在，我是拿着谁跟谁比较\n            //需要把用户对象里面的id拿出来再进行比较。\n            String uid = u.getId();\n            if(id.equals(uid)){\n                return true;//return 关键字：作用就是结束方法。\n            }\n        }\n        //只有当集合里面所有的元素全部比较完毕才能认为是不存在的。\n        return false;\n    }\n\n}',"java\npackage com.itheima.studentsystem;\n\npublic class Student {\n    private String id;\n    private String name;\n    private int age;\n    private String address;\n\n \t//下面是空参，有参，get和set方法\n}",'java\npublic class StudentSystem {\n    public static void main(String[] args) {\n        ArrayList<Student> list = new ArrayList<>();\n        loop:\n        while (true) {\n            System.out.println("-----------------欢迎来到黑马学生管理系统-------------------");\n            System.out.println("1:添加学生");\n            System.out.println("2:删除学生");\n            System.out.println("3:修改学生");\n            System.out.println("4:查询学生");\n            System.out.println("5:退出");\n            System.out.println("请输入您的选择：");\n            Scanner sc = new Scanner(System.in);\n            String choose = sc.next();\n            switch (choose) {\n                case "1" -> addStudent(list);\n                case "2" -> deleteStudent(list);\n                case "3" -> updateStudent(list);\n                case "4" -> queryStudent(list);\n                case "5" -> {\n                    System.out.println("退出");\n                    //break loop;\n                    System.exit(0);//停止虚拟机运行\n                }\n                default -> System.out.println("没有这个选项");\n            }\n        }\n    }\n\n    //添加学生\n    public static void addStudent(ArrayList<Student> list) {\n        //利用空参构造先创建学生对象\n        Student s = new Student();\n\n        Scanner sc = new Scanner(System.in);\n        String id = null;\n        while (true) {\n            System.out.println("请输入学生的id");\n            id = sc.next();\n            boolean flag = contains(list, id);\n            if(flag){\n                //表示id已经存在，需要重新录入\n                System.out.println("id已经存在，请重新录入");\n            }else{\n                //表示id不存在，表示可以使用\n                s.setId(id);\n                break;\n            }\n        }\n\n        System.out.println("请输入学生的姓名");\n        String name = sc.next();\n        s.setName(name);\n\n        System.out.println("请输入学生的年龄");\n        int age = sc.nextInt();\n        s.setAge(age);\n\n        System.out.println("请输入学生的家庭住址");\n        String address = sc.next();\n        s.setAddress(address);\n\n\n        //把学生对象添加到集合当中\n        list.add(s);\n\n        //提示一下用户\n        System.out.println("学生信息添加成功");\n    }\n\n    //删除学生\n    public static void deleteStudent(ArrayList<Student> list) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要删除的id");\n        String id = sc.next();\n        //查询id在集合中的索引\n        int index = getIndex(list, id);\n        //对index进行判断\n        //如果-1，就表示不存在，结束方法，回到初始菜单\n        if(index >= 0){\n            //如果大于等于0的，表示存在，直接删除\n            list.remove(index);\n            System.out.println("id为：" + id + "的学生删除成功");\n        }else{\n            System.out.println("id不存在，删除失败");\n        }\n    }\n\n    //修改学生\n    public static void updateStudent(ArrayList<Student> list) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入要修改学生的id");\n        String id = sc.next();\n\n        int index = getIndex(list, id);\n\n        if(index == -1){\n            System.out.println("要修改的id" + id + "不存在，请重新输入");\n            return;\n        }\n\n        //当代码执行到这里，表示什么？表示当前id是存在的。\n        //获取要修改的学生对象\n        Student stu = list.get(index);\n\n        //输入其他的信息并修改\n        System.out.println("请输入要修改的学生姓名");\n        String newName = sc.next();\n        stu.setName(newName);\n\n        System.out.println("请输入要修改的学生年龄");\n        int newAge = sc.nextInt();\n        stu.setAge(newAge);\n\n        System.out.println("请输入要修改的学生家庭住址");\n        String newAddress = sc.next();\n        stu.setAddress(newAddress);\n\n        System.out.println("学生信息修改成功");\n\n\n    }\n\n\n    //查询学生\n    public static void queryStudent(ArrayList<Student> list) {\n        if (list.size() == 0) {\n            System.out.println("当前无学生信息，请添加后再查询");\n            //结束方法\n            return;\n        }\n\n        //打印表头信息\n        System.out.println("id\\t\\t姓名\\t年龄\\t家庭住址");\n        //当代码执行到这里，表示集合中是有数据的\n        for (int i = 0; i < list.size(); i++) {\n            Student stu = list.get(i);\n            System.out.println(stu.getId() + "\\t" + stu.getName() + "\\t" + stu.getAge() + "\\t" + stu.getAddress());\n        }\n    }\n\n\n    //判断id在集合中是否存在\n    public static boolean contains(ArrayList<Student> list, String id) {\n        //循环遍历集合得到里面的每一个学生对象\n        /*for (int i = 0; i < list.size(); i++) {\n            //拿到学生对象后，获取id并进行判断\n            Student stu = list.get(i);\n            String sid = stu.getId();\n            if(sid.equals(id)){\n                //存在，true\n                return true;\n            }\n        }\n        // 不存在false\n        return false;*/\n       return getIndex(list,id) >= 0;\n    }\n\n    //通过id获取索引的方法\n    public static int getIndex(ArrayList<Student> list, String id){\n        //遍历集合\n        for (int i = 0; i < list.size(); i++) {\n            //得到每一个学生对象\n            Student stu = list.get(i);\n            //得到每一个学生对象的id\n            String sid = stu.getId();\n            //拿着集合中的学生id跟要查询的id进行比较\n            if(sid.equals(id)){\n                //如果一样，那么就返回索引\n                return i;\n            }\n        }\n        //当循环结束之后还没有找到，就表示不存在，返回-1.\n        return -1;\n    }\n}']},{title:"面向对象进阶部分学习方法",headers:[{level:2,title:"第一章 复习回顾",slug:"第一章-复习回顾",link:"#第一章-复习回顾",children:[{level:3,title:"1.1 如何定义类",slug:"_1-1-如何定义类",link:"#_1-1-如何定义类",children:[]},{level:3,title:"1.2 如何通过类创建对象",slug:"_1-2-如何通过类创建对象",link:"#_1-2-如何通过类创建对象",children:[]},{level:3,title:"1.3 封装",slug:"_1-3-封装",link:"#_1-3-封装",children:[]},{level:3,title:"1.4 构造方法",slug:"_1-4-构造方法",link:"#_1-4-构造方法",children:[]},{level:3,title:"1.5 this关键字的作用",slug:"_1-5-this关键字的作用",link:"#_1-5-this关键字的作用",children:[]}]},{level:2,title:"第二章 static关键字",slug:"第二章-static关键字",link:"#第二章-static关键字",children:[{level:3,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:3,title:"2.2 定义格式和使用",slug:"_2-2-定义格式和使用",link:"#_2-2-定义格式和使用",children:[]},{level:3,title:"2.3 小结",slug:"_2-3-小结",link:"#_2-3-小结",children:[]}]},{level:2,title:"第三章 继承",slug:"第三章-继承",link:"#第三章-继承",children:[{level:3,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:3,title:"3.2 继承的格式",slug:"_3-2-继承的格式",link:"#_3-2-继承的格式",children:[]},{level:3,title:"3.3 继承案例",slug:"_3-3-继承案例",link:"#_3-3-继承案例",children:[]},{level:3,title:"3.4 子类不能继承的内容",slug:"_3-4-子类不能继承的内容",link:"#_3-4-子类不能继承的内容",children:[]},{level:3,title:"3.5 继承后的特点—成员变量",slug:"_3-5-继承后的特点—成员变量",link:"#_3-5-继承后的特点—成员变量",children:[]},{level:3,title:"3.6 继承后的特点—成员方法",slug:"_3-6-继承后的特点—成员方法",link:"#_3-6-继承后的特点—成员方法",children:[]},{level:3,title:"3.7 方法重写",slug:"_3-7-方法重写",link:"#_3-7-方法重写",children:[]},{level:3,title:"3.8 继承后的特点—构造方法",slug:"_3-8-继承后的特点—构造方法",link:"#_3-8-继承后的特点—构造方法",children:[]},{level:3,title:"3.9 super(...)和this(...)",slug:"_3-9-super-和this",link:"#_3-9-super-和this",children:[]},{level:3,title:"3.10 继承的特点",slug:"_3-10-继承的特点",link:"#_3-10-继承的特点",children:[]},{level:3,title:"4. 关于今天知识的小结：",slug:"_4-关于今天知识的小结",link:"#_4-关于今天知识的小结",children:[]}]}],path:"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html",pathLocale:"/",extraFields:["java\n修饰符 class 类名 {\n    // 1.成员变量（属性）\n    // 2.成员方法 (行为) \n    // 3.构造方法 （初始化类的对象数据的）\n}","java\npublic class Student {\n    // 1.成员变量\n    public String name ;\n    public char sex ; // '男'  '女'\n    public int age;\n}","java\n类名 对象名称 = new 类名();","java\nStudent stu = new Student();","java\npublic class Student {\n    private String name;\n    private int age;\n}",'java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String n) {\n      \tname = n;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int a) {\n        if (a > 0 && a <200) {\n            age = a;\n        } else {\n            System.out.println("年龄非法！");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}',"java\n修饰符 类名(形参列表) {\n    // 构造体代码，执行代码\n}",'java\npublic class Student {\n    // 1.成员变量\n    public String name;\n    public int age;\n\n    // 2.构造方法\n    public Student() {\n\t\tSystem.out.println("无参数构造方法被调用")；\n    }\n}','java\npublic class CreateStu02 {\n    public static void main(String[] args) {\n        // 创建一个学生对象\n        // 类名 变量名称 = new 类名();\n        Student s1 = new Student();\n        // 使用对象访问成员变量，赋值\n        s1.name = "张三";\n        s1.age = 20 ;\n\n        // 使用对象访问成员变量 输出值\n        System.out.println(s1.name);\n        System.out.println(s1.age); \n\n        Student s2 = new Student();\n        // 使用对象访问成员变量 赋值\n        s2.name = "李四";\n        s2.age = 18 ;\n        System.out.println(s2.name);\n        System.out.println(s2.age);\n    }\n}','java\npublic class Student {\n    private String name;\n    private int age;\n\n    public void setName(String name) {\n      \tthis.name = name;\n    }\n\n    public String getName() {\n      \treturn name;\n    }\n\n    public void setAge(int age) {\n        if (age > 0 && age < 200) {\n            this.age = age;\n        } else {\n            System.out.println("年龄非法！");\n        }\n    }\n\n    public int getAge() {\n      \treturn age;\n    }\n}',"java\npublic class Student {\n    private String name;\n    private int age;\n    \n    // 无参数构造方法\n    public Student() {} \n    \n    // 有参数构造方法\n    public Student(String name,int age) {\n    \tthis.name = name;\n    \tthis.age = age; \n    }\n}","java\npublic class Student {\n    // 成员变量\n    public String name;\n    public char sex; // '男'  '女'\n    public int age;\n\n    // 无参数构造方法\n    public Student() {\n\n    }\n    \n    // 有参数构造方法\n    public Student(String  a) {\n\n    }\n}","java\n修饰符 static 数据类型 变量名 = 初始值；",'java\npublic class Student {\n    public static String schoolName = "传智播客"； // 属于类，只有一份。\n    // .....\n}','java\npublic static void  main(String[] args){\n    System.out.println(Student.schoolName); // 传智播客\n    Student.schoolName = "黑马程序员";\n    System.out.println(Student.schoolName); // 黑马程序员\n}','java\npublic class Student{\n    public static String schoolName = "传智播客"； // 属于类，只有一份。\n    // .....\n    public static void study(){\n    \tSystem.out.println("我们都在黑马程序员学习");   \n    }\n}',"java\npublic static void  main(String[] args){\n    Student.study();\n}",'java\npublic class Student {\n    // 实例变量\n    private String name ;\n    // 2.方法：行为\n    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用\n    public void run(){\n        System.out.println("学生可以跑步");\n    }\n\t// 无 static修饰，实例方法\n    public  void sleep(){\n        System.out.println("学生睡觉");\n    }\n    public static void study(){\n        \n    }\n}','java\npublic static void main(String[] args){\n    // 创建对象 \n    Student stu = new Student ;\n    stu.name = "徐干";\n    // Student.sleep();// 报错，必须用对象访问。\n    stu.sleep();\n    stu.run();\n}',"java\nclass 父类 {\n\t...\n}\n\nclass 子类 extends 父类 {\n\t...\n}","java\n public class Human {\n    // 合理隐藏\n    private String name ;\n    private int age ;\n\t\n    // 合理暴露\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n }",'java\npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n    // 特有方法\n    public void teach(){\n        System.out.println("老师在认真教技术！")；\n    }\n\n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}',"java\npublic class Student extends Human{\n \n}",'java \npublic class Teacher extends Human {\n    // 工资\n    private double salary ;\n    \n       // 特有方法\n    public void admin(){\n        System.out.println("班主任强调纪律问题！")；\n    }\n    \n    public double getSalary() {\n        return salary;\n    }\n\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n}','java\n  public class Test {\n      public static void main(String[] args) {\n          Teacher dlei = new Teacher();\n          dlei.setName("播仔");\n          dlei.setAge("31");\n          dlei.setSalary(1000.99);\n          System.out.println(dlei.getName());\n          System.out.println(dlei.getAge());\n          System.out.println(dlei.getSalary());\n          dlei.teach();\n          \n          BanZhuRen linTao = new BanZhuRen();\n          linTao.setName("灵涛");\n          linTao.setAge("28");\n          linTao.setSalary(1000.99);\n          System.out.println(linTao.getName());\n          System.out.println(linTao.getAge());\n          System.out.println(linTao.getSalary());\n          linTao.admin();\n\n          Student xugan = new Student();\n          xugan.setName("播仔");\n          xugan.setAge("31");\n          //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！\n          System.out.println(xugan.getName());\n          System.out.println(xugan.getAge());\n\n\n\n      }\n  }','java\npublic class Demo03 {\n    public static void main(String[] args) {\n        Zi z = new Zi();\n        System.out.println(z.num1);\n//\t\tSystem.out.println(z.num2); // 私有的子类无法使用\n        // 通过getter/setter方法访问父类的private成员变量\n        System.out.println(z.getNum2());\n\n        z.show1();\n        // z.show2(); // 私有的子类无法使用\n    }\n}\n\nclass Fu {\n    public int num1 = 10;\n    private int num2 = 20;\n\n    public void show1() {\n        System.out.println("show1");\n    }\n\n    private void show2() {\n        System.out.println("show2");\n    }\n\n    public int getNum2() {\n        return num2;\n    }\n\n    public void setNum2(int num2) {\n        this.num2 = num2;\n    }\n}\n\nclass Zi extends Fu {\n}','java\nclass Fu {\n\t// Fu中的成员变量\n\tint num = 5;\n}\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num2 = 6;\n  \n\t// Zi中的成员方法\n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println("Fu num="+num); // 继承而来，所以直接访问。\n\t\t// 访问子类中的num2\n\t\tSystem.out.println("Zi num2="+num2);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n        // 创建子类对象\n\t\tZi z = new Zi(); \n      \t// 调用子类中的show方法\n\t\tz.show();  \n\t}\n}\n\n演示结果：\nFu num = 5\nZi num2 = 6','java\nclass Fu1 {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\nclass Zi1 extends Fu1 {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n\t\t// 访问父类中的num\n\t\tSystem.out.println("Fu num=" + num);\n\t\t// 访问子类中的num\n\t\tSystem.out.println("Zi num=" + num);\n\t}\n}\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n演示结果：\nFu num = 6\nZi num = 6',"java\nsuper.父类成员变量名",'java\nclass Fu {\n\t// Fu中的成员变量。\n\tint num = 5;\n}\n\nclass Zi extends Fu {\n\t// Zi中的成员变量\n\tint num = 6;\n  \n\tpublic void show() {\n        int num = 1;\n      \n        // 访问方法中的num\n        System.out.println("method num=" + num);\n        // 访问子类中的num\n        System.out.println("Zi num=" + this.num);\n        // 访问父类中的num\n        System.out.println("Fu num=" + super.num);\n\t}\n}\n\nclass Demo04 {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n\t\tZi1 z = new Zi1(); \n      \t// 调用子类中的show方法\n\t\tz1.show(); \n\t}\n}\n\n演示结果：\nmethod num=1\nZi num=6\nFu num=5','java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println("Fu类中的show方法执行");\n\t}\n}\nclass Zi extends Fu {\n\tpublic void show2() {\n\t\tSystem.out.println("Zi类中的show2方法执行");\n\t}\n}\npublic  class Demo05 {\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t//子类中没有show方法，但是可以找到父类方法去执行\n\t\tz.show(); \n\t\tz.show2();\n\t}\n}','java\nclass Fu {\n\tpublic void show() {\n\t\tSystem.out.println("Fu show");\n\t}\n}\nclass Zi extends Fu {\n\t//子类重写了父类的show方法\n\tpublic void show() {\n\t\tSystem.out.println("Zi show");\n\t}\n}\npublic class ExtendsDemo05{\n\tpublic static void main(String[] args) {\n\t\tZi z = new Zi();\n     \t// 子类中有show方法，只执行重写后的show方法\n\t\tz.show();  // Zi show\n\t}\n}','java\npublic class Animal  {\n    public void run(){\n        System.out.println("动物跑的很快！");\n    }\n    public void cry(){\n        System.out.println("动物都可以叫~~~");\n    }\n}','java\npublic class Cat extends Animal {\n    public void cry(){\n        System.out.println("我们一起学猫叫，喵喵喵！喵的非常好听！");\n    }\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n      \t// 创建子类对象\n      \tCat ddm = new Cat()；\n        // 调用父类继承而来的方法\n        ddm.run();\n      \t// 调用子类重写的方法\n      \tddm.cry();\n\t}\n}','java\n  public class Cat extends Animal {\n       // 声明不变，重新实现\n      // 方法名称与父类全部一样，只是方法体中的功能重写写了！\n      @Override\n      public void cry(){\n          System.out.println("我们一起学猫叫，喵喵喵！喵的非常好听！");\n      }\n  }','java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        Student s1 = new Student();\n        System.out.println("----------");\n        Student s2 = new Student(99.9);\n    }\n}\n\n输出结果：\n父类无参\n子类无参\n----------\n父类无参\n子类有参','java \nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(double score) {\n        //super();  // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student(99.9);\n        System.out.println(s2.getScore()); // 99.9\n        System.out.println(s2.getName()); // 输出 null\n        System.out.println(s2.getAge()); // 输出 0\n    }\n}',"java\nthis.成员变量    \t--    本类的\nsuper.成员变量    \t--    父类的\n\nthis.成员方法名()  \t--    本类的    \nsuper.成员方法名()   --    父类的","java\nsuper(...) -- 调用父类的构造方法，根据参数匹配确认\nthis(...) -- 调用本类的其他构造方法，根据参数匹配确认",'java\nclass Person {\n    private String name ="凤姐";\n    private int age = 20;\n\n    public Person() {\n        System.out.println("父类无参");\n    }\n    \n    public Person(String name , int age){\n        this.name = name ;\n        this.age = age ;\n    }\n\n    // getter/setter省略\n}\n\nclass Student extends Person {\n    private double score = 100;\n\n    public Student() {\n        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行\n        System.out.println("子类无参");\n    }\n    \n     public Student(String name ， int age，double score) {\n        super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age\n        this.score = score;    \n        System.out.println("子类有参");\n     }\n      // getter/setter省略\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 调用子类有参数构造方法\n        Student s2 = new Student("张三"，20，99);\n        System.out.println(s2.getScore()); // 99\n        System.out.println(s2.getName()); // 输出 张三\n        System.out.println(s2.getAge()); // 输出 20\n    }\n}',"java\npackage com.itheima._08this和super调用构造方法;\n/**\n * this(...):\n *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。\n *    为了借用其他构造方法的功能。\n *\n */\npublic class ThisDemo01 {\n    public static void main(String[] args) {\n        Student xuGan = new Student();\n        System.out.println(xuGan.getName()); // 输出:徐干\n        System.out.println(xuGan.getAge());// 输出:21\n        System.out.println(xuGan.getSex());// 输出： 男\n    }\n}\n\nclass Student{\n    private String name ;\n    private int age ;\n    private char sex ;\n\n    public Student() {\n  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)\n        this(\"徐干\",21,'男');\n    }\n\n    public Student(String name, int age, char sex) {\n        this.name = name ;\n        this.age = age   ;\n        this.sex = sex   ;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getSex() {\n        return sex;\n    }\n\n    public void setSex(char sex) {\n        this.sex = sex;\n    }\n}","java\n// 一个类只能有一个父类，不可以有多个父类。\nclass A {}\nclass B {}\nclass C1 extends A {} // ok\n// class C2 extends A, B {} // error","java\n// A可以有多个子类\nclass A {}\nclass C1 extends A {}\nclass C2 extends  A {}","java\nclass A {}\nclass C1 extends A {}\nclass D extends C1 {}",'java\npackage com.itheima.test4;\n\npublic class Animal {\n    //姓名，年龄，颜色\n    private String name;\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(String name, int age, String color) {\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\n\npublic class Cat extends Animal{\n    //因为猫类中没有独有的属性。\n    //所以此时不需要写私有的成员变量\n\n    //空参\n    public Cat() {\n    }\n\n    //需要带子类和父类中所有的属性\n    public Cat(String name, int age, String color) {\n        super(name,age,color);\n    }\n}\n\n\npublic class Dog extends Animal{\n    //Dog ：吼叫\n    private String wang;\n\n    //构造\n    public Dog() {\n    }\n\n    //带参构造：带子类加父类所有的属性\n    public Dog(String name, int age, String color,String wang) {\n        //共性的属性交给父类赋值\n        super(name,age,color);\n        //独有的属性自己赋值\n        this.wang = wang;\n    }\n\n    public String getWang() {\n        return wang;\n    }\n\n    public void setWang(String wang) {\n        this.wang = wang;\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        //Animal ： 姓名，年龄，颜色\n        //Cat :\n        //Dog ：吼叫\n\n        //创建狗的对象\n        Dog d = new Dog("旺财",2,"黑色","嗷呜~~");\n        System.out.println(d.getName()+", " + d.getAge() + ", " + d.getColor() + ", " + d.getWang());\n\n        //创建猫的对象\n        Cat c = new Cat("中华田园猫",3,"黄色");\n        System.out.println(c.getName() + ", " + c.getAge() + ", " + c.getColor());\n    }\n}']},{title:"多态",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 多态的形式",slug:"_1-1-多态的形式",link:"#_1-1-多态的形式",children:[]},{level:2,title:"1.2 多态的使用场景",slug:"_1-2-多态的使用场景",link:"#_1-2-多态的使用场景",children:[]},{level:2,title:"1.3 多态的定义和前提",slug:"_1-3-多态的定义和前提",link:"#_1-3-多态的定义和前提",children:[]},{level:2,title:"1.4 多态的运行特点",slug:"_1-4-多态的运行特点",link:"#_1-4-多态的运行特点",children:[]},{level:2,title:"1.5 多态的弊端",slug:"_1-5-多态的弊端",link:"#_1-5-多态的弊端",children:[]},{level:2,title:"1.6 引用类型转换",slug:"_1-6-引用类型转换",link:"#_1-6-引用类型转换",children:[{level:3,title:"1.6.1 为什么要转型",slug:"_1-6-1-为什么要转型",link:"#_1-6-1-为什么要转型",children:[]},{level:3,title:"1.6.2 向上转型（自动转换）",slug:"_1-6-2-向上转型-自动转换",link:"#_1-6-2-向上转型-自动转换",children:[]},{level:3,title:"1.6.3 向下转型（强制转换）",slug:"_1-6-3-向下转型-强制转换",link:"#_1-6-3-向下转型-强制转换",children:[]},{level:3,title:"1.6.4 案例演示",slug:"_1-6-4-案例演示",link:"#_1-6-4-案例演示",children:[]},{level:3,title:"1.6.5 转型的异常",slug:"_1-6-5-转型的异常",link:"#_1-6-5-转型的异常",children:[]},{level:3,title:"1.6.6 instanceof关键字",slug:"_1-6-6-instanceof关键字",link:"#_1-6-6-instanceof关键字",children:[]},{level:3,title:"1.6.7 instanceof新特性",slug:"_1-6-7-instanceof新特性",link:"#_1-6-7-instanceof新特性",children:[]},{level:3,title:"1.7 综合练习",slug:"_1-7-综合练习",link:"#_1-7-综合练习",children:[]}]},{level:2,title:"2.1 包",slug:"_2-1-包",link:"#_2-1-包",children:[]},{level:2,title:"2.2 导包",slug:"_2-2-导包",link:"#_2-2-导包",children:[]},{level:2,title:"2.3 使用不同包下的相同类怎么办？",slug:"_2-3-使用不同包下的相同类怎么办",link:"#_2-3-使用不同包下的相同类怎么办",children:[]},{level:2,title:"3.1 权限修饰符",slug:"_3-1-权限修饰符",link:"#_3-1-权限修饰符",children:[]},{level:2,title:"3.2 不同权限的访问能力",slug:"_3-2-不同权限的访问能力",link:"#_3-2-不同权限的访问能力",children:[]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 使用方式",slug:"_4-2-使用方式",link:"#_4-2-使用方式",children:[{level:3,title:"4.2.1 修饰类",slug:"_4-2-1-修饰类",link:"#_4-2-1-修饰类",children:[]},{level:3,title:"4.2.2 修饰方法",slug:"_4-2-2-修饰方法",link:"#_4-2-2-修饰方法",children:[]},{level:3,title:"4.2.3 修饰变量-局部变量",slug:"_4-2-3-修饰变量-局部变量",link:"#_4-2-3-修饰变量-局部变量",children:[]},{level:3,title:"4.2.4 修饰变量-成员变量",slug:"_4-2-4-修饰变量-成员变量",link:"#_4-2-4-修饰变量-成员变量",children:[]}]}],path:"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:["java\n父类类型 变量名 = new 子类/实现类构造器;\n变量名.方法名();",'java\n父类：\npublic class Person {\n    private String name;\n    private int age;\n\n    空参构造\n    带全部参数的构造\n    get和set方法\n\n    public void show(){\n        System.out.println(name + ", " + age);\n    }\n}\n\n子类1：\npublic class Administrator extends Person {\n    @Override\n    public void show() {\n        System.out.println("管理员的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n子类2：\npublic class Student extends Person{\n\n    @Override\n    public void show() {\n        System.out.println("学生的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n子类3：\npublic class Teacher extends Person{\n\n    @Override\n    public void show() {\n        System.out.println("老师的信息为：" + getName() + ", " + getAge());\n    }\n}\n\n测试类：\npublic class Test {\n    public static void main(String[] args) {\n        //创建三个对象，并调用register方法\n\n        Student s = new Student();\n        s.setName("张三");\n        s.setAge(18);\n\n\n        Teacher t = new Teacher();\n        t.setName("王建国");\n        t.setAge(30);\n\n        Administrator admin = new Administrator();\n        admin.setName("管理员");\n        admin.setAge(35);\n\n\n\n        register(s);\n        register(t);\n        register(admin);\n\n\n    }\n\n\n\n    //这个方法既能接收老师，又能接收学生，还能接收管理员\n    //只能把参数写成这三个类型的父类\n    public static void register(Person p){\n        p.show();\n    }\n}',"java\nFu f = new Zi()；\n//编译看左边的父类中有没有name这个属性，没有就报错\n//在实际运行的时候，把父类name属性的值打印出来\nSystem.out.println(f.name);\n//编译看左边的父类中有没有show这个方法，没有就报错\n//在实际运行的时候，运行的是子类中的show方法\nf.show();",'java \nclass Animal{\n    public  void eat()｛\n        System.out.println("动物吃东西！")\n    ｝\n}\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println("吃鱼");  \n    }  \n   \n    public void catchMouse() {  \n        System.out.println("抓老鼠");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println("吃骨头");  \n    }  \n}\n\nclass Test{\n    public static void main(String[] args){\n        Animal a = new Cat();\n        a.eat();\n        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法\n    }\n}',"java\n父类类型  变量名 = new 子类类型();\n如：Animal a = new Cat();","java\n子类类型 变量名 = (子类类型) 父类变量名;\n如:Aniaml a = new Cat();\n   Cat c =(Cat) a;",'java\nabstract class Animal {  \n    abstract void eat();  \n}  \n\nclass Cat extends Animal {  \n    public void eat() {  \n        System.out.println("吃鱼");  \n    }  \n    public void catchMouse() {  \n        System.out.println("抓老鼠");  \n    }  \n}  \n\nclass Dog extends Animal {  \n    public void eat() {  \n        System.out.println("吃骨头");  \n    }  \n    public void watchHouse() {  \n        System.out.println("看家");  \n    }  \n}',"java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat(); \t\t\t\t// 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Cat c = (Cat)a;       \n        c.catchMouse(); \t\t// 调用的是 Cat 的 catchMouse\n    }  \n}","java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        Dog d = (Dog)a;       \n        d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】\n    }  \n}","java\n变量名 instanceof 数据类型 \n如果变量属于该数据类型或者其子类类型，返回true。\n如果变量不属于该数据类型或者其子类类型，返回false。","java\npublic class Test {\n    public static void main(String[] args) {\n        // 向上转型  \n        Animal a = new Cat();  \n        a.eat();               // 调用的是 Cat 的 eat\n\n        // 向下转型  \n        if (a instanceof Cat){\n            Cat c = (Cat)a;       \n            c.catchMouse();        // 调用的是 Cat 的 catchMouse\n        } else if (a instanceof Dog){\n            Dog d = (Dog)a;       \n            d.watchHouse();       // 调用的是 Dog 的 watchHouse\n        }\n    }  \n}",'java\n//新特性\n//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d\n//如果不是，则不强转，结果直接是false\nif(a instanceof Dog d){\n    d.lookHome();\n}else if(a instanceof Cat c){\n    c.catchMouse();\n}else{\n    System.out.println("没有这个类型，无法转换");\n}',"java\n需求：根据需求完成代码:\n\t1.定义狗类\n\t\t属性：\n\t\t\t年龄，颜色\n\t\t行为:\n\t\t\teat(String something)(something表示吃的东西)\n\t\t\t看家lookHome方法(无参数)\n2.定义猫类\n\t属性：\n\t\t年龄，颜色\n\t行为:\n\t\teat(String something)方法(something表示吃的东西)\n\t\t逮老鼠catchMouse方法(无参数)\n3.定义Person类//饲养员\n\t属性：\n\t\t姓名，年龄\n\t行为：\n\t\tkeepPet(Dog dog,String something)方法\n\t\t\t功能：喂养宠物狗，something表示喂养的东西\n\t行为：\n\t\tkeepPet(Cat cat,String something)方法\n\t\t\t功能：喂养宠物猫，something表示喂养的东西\n\t生成空参有参构造，set和get方法  \n4.定义测试类(完成以下打印效果):\n\tkeepPet(Dog dog,String somethind)方法打印内容如下：\n\t\t年龄为30岁的老王养了一只黑颜色的2岁的狗\n\t\t2岁的黑颜色的狗两只前腿死死的抱住骨头猛吃\n\tkeepPet(Cat cat,String somethind)方法打印内容如下：\n\t\t年龄为25岁的老李养了一只灰颜色的3岁的猫\n\t\t3岁的灰颜色的猫眯着眼睛侧着头吃鱼\n5.思考：\t\t\n\t1.Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？\n\t2.Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？",'java\n//动物类（父类）\npublic class Animal {\n    private int age;\n    private String color;\n\n\n    public Animal() {\n    }\n\n    public Animal(int age, String color) {\n        this.age = age;\n        this.color = color;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public void eat(String something){\n        System.out.println("动物在吃" + something);\n    }\n}\n\n//猫类（子类）\npublic class Cat extends Animal {\n\n    public Cat() {\n    }\n\n    public Cat(int age, String color) {\n        super(age, color);\n    }\n\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + "岁的" + getColor() + "颜色的猫眯着眼睛侧着头吃" + something);\n    }\n\n    public void catchMouse(){\n        System.out.println("猫抓老鼠");\n    }\n\n}\n\n//狗类（子类）\npublic class Dog extends Animal {\n    public Dog() {\n    }\n\n    public Dog(int age, String color) {\n        super(age, color);\n    }\n\n    //行为\n    //eat(String something)(something表示吃的东西)\n    //看家lookHome方法(无参数)\n    @Override\n    public void eat(String something) {\n        System.out.println(getAge() + "岁的" + getColor() + "颜色的狗两只前腿死死的抱住" + something + "猛吃");\n    }\n\n    public void lookHome(){\n        System.out.println("狗在看家");\n    }\n}\n\n\n//饲养员类\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    //饲养狗\n   /* public void keepPet(Dog dog, String something) {\n        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + dog.getColor() + "颜色的" + dog.getAge() + "岁的狗");\n        dog.eat(something);\n    }\n\n    //饲养猫\n    public void keepPet(Cat cat, String something) {\n        System.out.println("年龄为" + age + "岁的" + name + "养了一只" + cat.getColor() + "颜色的" + cat.getAge() + "岁的猫");\n        cat.eat(something);\n    }*/\n\n\n    //想要一个方法，能接收所有的动物，包括猫，包括狗\n    //方法的形参：可以写这些类的父类 Animal\n    public void keepPet(Animal a, String something) {\n        if(a instanceof Dog d){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + a.getColor() + "颜色的" + a.getAge() + "岁的狗");\n            d.eat(something);\n        }else if(a instanceof Cat c){\n            System.out.println("年龄为" + age + "岁的" + name + "养了一只" + c.getColor() + "颜色的" + c.getAge() + "岁的猫");\n            c.eat(something);\n        }else{\n            System.out.println("没有这种动物");\n        }\n    }\n}\n\n//测试类\npublic class Test {\n    public static void main(String[] args) {\n        //创建对象并调用方法\n       /* Person p1 = new Person("老王",30);\n        Dog d = new Dog(2,"黑");\n        p1.keepPet(d,"骨头");\n\n\n        Person p2 = new Person("老李",25);\n        Cat c = new Cat(3,"灰");\n        p2.keepPet(c,"鱼");*/\n\n\n        //创建饲养员的对象\n        Person p = new Person("老王",30);\n        Dog d = new Dog(2,"黑");\n        Cat c = new Cat(3,"灰");\n        p.keepPet(d,"骨头");\n        p.keepPet(c,"鱼");\n\n    }\n}',"java\n路径名.路径名.xxx.xxx\n// 例如：com.itheima.oa","java\n//使用全类名的形式即可。\n//全类名：包名 + 类名\n//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference\ncom.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();\ncom.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();","java\nfinal class 类名 {\n}","java\nfinal class Fu {\n}\n// class Zi extends Fu {} // 报错,不能继承final的类","java\n修饰符 final 返回值类型 方法名(参数列表){\n    //方法体\n}",'java\nclass Fu2 {\n\tfinal public void show1() {\n\t\tSystem.out.println("Fu2 show1");\n\t}\n\tpublic void show2() {\n\t\tSystem.out.println("Fu2 show2");\n\t}\n}\n\nclass Zi2 extends Fu2 {\n//\t@Override\n//\tpublic void show1() {\n//\t\tSystem.out.println("Zi2 show1");\n//\t}\n\t@Override\n\tpublic void show2() {\n\t\tSystem.out.println("Zi2 show2");\n\t}\n}',"java\npublic class FinalDemo1 {\n    public static void main(String[] args) {\n        // 声明变量，使用final修饰\n        final int a;\n        // 第一次赋值 \n        a = 10;\n        // 第二次赋值\n        a = 20; // 报错,不可重新赋值\n\n        // 声明变量，直接赋值，使用final修饰\n        final int b = 10;\n        // 第二次赋值\n        b = 20; // 报错,不可重新赋值\n    }\n}","java\nfinal int c = 0;\nfor (int i = 0; i < 10; i++) {\n    c = i;\n    System.out.println(c);\n}","java\nfor (int i = 0; i < 10; i++) {\n    final int c = i;\n    System.out.println(c);\n}","java\npublic class Student {\n    final int num = 10;\n}","java\npublic class Student {\n    final int num = 10;\n    final int num2;\n\n    public Student() {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n    \n     public Student(String name) {\n        this.num2 = 20;\n//     this.num2 = 20;\n    }\n}"]},{title:"抽象类",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[{level:3,title:"1.1.1 抽象类引入",slug:"_1-1-1-抽象类引入",link:"#_1-1-1-抽象类引入",children:[]}]},{level:2,title:"1.2 abstract使用格式",slug:"_1-2-abstract使用格式",link:"#_1-2-abstract使用格式",children:[{level:3,title:"1.2.1 抽象方法",slug:"_1-2-1-抽象方法",link:"#_1-2-1-抽象方法",children:[]},{level:3,title:"1.2.2 抽象类",slug:"_1-2-2-抽象类",link:"#_1-2-2-抽象类",children:[]},{level:3,title:"1.2.3 抽象类的使用",slug:"_1-2-3-抽象类的使用",link:"#_1-2-3-抽象类的使用",children:[]}]},{level:2,title:"1.3 抽象类的特征",slug:"_1-3-抽象类的特征",link:"#_1-3-抽象类的特征",children:[]},{level:2,title:"1.4 抽象类的细节",slug:"_1-4-抽象类的细节",link:"#_1-4-抽象类的细节",children:[]},{level:2,title:"1.5 抽象类存在的意义",slug:"_1-5-抽象类存在的意义",link:"#_1-5-抽象类存在的意义",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 定义格式",slug:"_2-2-定义格式",link:"#_2-2-定义格式",children:[]},{level:2,title:"2.3 接口成分的特点",slug:"_2-3-接口成分的特点",link:"#_2-3-接口成分的特点",children:[{level:3,title:"2.3.1.抽象方法",slug:"_2-3-1-抽象方法",link:"#_2-3-1-抽象方法",children:[]},{level:3,title:"2.3.2 常量",slug:"_2-3-2-常量",link:"#_2-3-2-常量",children:[]},{level:3,title:"2.3.3 案例演示",slug:"_2-3-3-案例演示",link:"#_2-3-3-案例演示",children:[]}]},{level:2,title:"2.4 基本的实现",slug:"_2-4-基本的实现",link:"#_2-4-基本的实现",children:[{level:3,title:"2.4.1 实现接口的概述",slug:"_2-4-1-实现接口的概述",link:"#_2-4-1-实现接口的概述",children:[]},{level:3,title:"2.4.2 实现接口的格式",slug:"_2-4-2-实现接口的格式",link:"#_2-4-2-实现接口的格式",children:[]},{level:3,title:"2.4.3 类实现接口的要求和意义",slug:"_2-4-3-类实现接口的要求和意义",link:"#_2-4-3-类实现接口的要求和意义",children:[]},{level:3,title:"2.4.4  类与接口基本实现案例",slug:"_2-4-4-类与接口基本实现案例",link:"#_2-4-4-类与接口基本实现案例",children:[]},{level:3,title:"2.4.5 类与接口的多实现案例",slug:"_2-4-5-类与接口的多实现案例",link:"#_2-4-5-类与接口的多实现案例",children:[]}]},{level:2,title:"2.5 接口与接口的多继承",slug:"_2-5-接口与接口的多继承",link:"#_2-5-接口与接口的多继承",children:[]},{level:2,title:"2.6扩展：接口的细节",slug:"_2-6扩展-接口的细节",link:"#_2-6扩展-接口的细节",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[{level:3,title:"3.1.1 什么是内部类",slug:"_3-1-1-什么是内部类",link:"#_3-1-1-什么是内部类",children:[]},{level:3,title:"3.1.2 什么时候使用内部类",slug:"_3-1-2-什么时候使用内部类",link:"#_3-1-2-什么时候使用内部类",children:[]}]},{level:2,title:"3.2 内部类的分类",slug:"_3-2-内部类的分类",link:"#_3-2-内部类的分类",children:[]},{level:2,title:"3.3 成员内部类",slug:"_3-3-成员内部类",link:"#_3-3-成员内部类",children:[]},{level:2,title:"3.4 成员内部类的细节",slug:"_3-4-成员内部类的细节",link:"#_3-4-成员内部类的细节",children:[]},{level:2,title:"3.5 成员内部类面试题",slug:"_3-5-成员内部类面试题",link:"#_3-5-成员内部类面试题",children:[]},{level:2,title:"3.6 成员内部类内存图",slug:"_3-6-成员内部类内存图",link:"#_3-6-成员内部类内存图",children:[]},{level:2,title:"3.7 静态内部类",slug:"_3-7-静态内部类",link:"#_3-7-静态内部类",children:[]},{level:2,title:"3.8 局部内部类",slug:"_3-8-局部内部类",link:"#_3-8-局部内部类",children:[]},{level:2,title:"3.9 匿名内部类【重点】",slug:"_3-9-匿名内部类【重点】",link:"#_3-9-匿名内部类【重点】",children:[{level:3,title:"3.9.1 概述",slug:"_3-9-1-概述",link:"#_3-9-1-概述",children:[]},{level:3,title:"3.9.2 格式",slug:"_3-9-2-格式",link:"#_3-9-2-格式",children:[]},{level:3,title:"3.9.2 什么时候用到匿名内部类",slug:"_3-9-2-什么时候用到匿名内部类",link:"#_3-9-2-什么时候用到匿名内部类",children:[]},{level:3,title:"3.9.3 匿名内部类前提和格式",slug:"_3-9-3-匿名内部类前提和格式",link:"#_3-9-3-匿名内部类前提和格式",children:[]},{level:3,title:"3.9.4 使用方式",slug:"_3-9-4-使用方式",link:"#_3-9-4-使用方式",children:[]},{level:3,title:"3.9.5 匿名内部类的特点",slug:"_3-9-5-匿名内部类的特点",link:"#_3-9-5-匿名内部类的特点",children:[]},{level:3,title:"3.9.6 匿名内部类的使用场景",slug:"_3-9-6-匿名内部类的使用场景",link:"#_3-9-6-匿名内部类的使用场景",children:[]}]}],path:"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html",pathLocale:"/",extraFields:["java\n修饰符 abstract 返回值类型 方法名 (参数列表)；","java\npublic abstract void run()；","java\nabstract class 类名字 { \n  \n}","java\npublic abstract class Animal {\n    public abstract void run()；\n}",'java\n// 父类,抽象类\nabstract class Employee {\n\tprivate String id;\n\tprivate String name;\n\tprivate double salary;\n\t\n\tpublic Employee() {\n\t}\n\t\n\tpublic Employee(String id, String name, double salary) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\t\n\t// 抽象方法\n\t// 抽象方法必须要放在抽象类中\n\tabstract public void work();\n}\n\n// 定义一个子类继承抽象类\nclass Manager extends Employee {\n\tpublic Manager() {\n\t}\n\tpublic Manager(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t// 2.重写父类的抽象方法\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println("管理其他人");\n\t}\n}\n\n// 定义一个子类继承抽象类\nclass Cook extends Employee {\n\tpublic Cook() {\n\t}\n\tpublic Cook(String id, String name, double salary) {\n\t\tsuper(id, name, salary);\n\t}\n\t@Override\n\tpublic void work() {\n\t\tSystem.out.println("厨师炒菜多加点盐...");\n\t}\n}\n\n// 测试类\npublic class Demo10 {\n\tpublic static void main(String[] args) {\n\t\t// 创建抽象类,抽象类不能创建对象\n\t\t// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象\n//\t\tEmployee e = new Employee();\n//\t\te.work();\n\t\t\n\t\t// 3.创建子类\n\t\tManager m = new Manager();\n\t\tm.work();\n\t\t\n\t\tCook c = new Cook("ap002", "库克", 1);\n\t\tc.work();\n\t}\n}',"java\n//接口的定义格式：\ninterface 接口名称{\n    // 抽象方法\n}\n\n// 接口的声明：interface\n// 接口名称：首字母大写，满足“驼峰模式”",'java\npublic interface InterF {\n    // 抽象方法！\n    //    public abstract void run();\n    void run();\n\n    //    public abstract String getName();\n    String getName();\n\n    //    public abstract int add(int a , int b);\n    int add(int a , int b);\n\n\n    // 它的最终写法是：\n    // public static final int AGE = 12 ;\n    int AGE  = 12; //常量\n    String SCHOOL_NAME = "黑马程序员";\n\n}',"java\n/**接口的实现：\n    在Java中接口是被实现的，实现接口的类称为实现类。\n    实现类的格式:*/\nclass 类名 implements 接口1,接口2,接口3...{\n\n}","java\n/**\n   接口：接口体现的是规范。\n * */\npublic interface SportMan {\n    void run(); // 抽象方法，跑步。\n    void law(); // 抽象方法，遵守法律。\n    String compittion(String project);  // 抽象方法，比赛。\n}",'java\npackage com.itheima._03接口的实现;\n/**\n * 接口的实现：\n *    在Java中接口是被实现的，实现接口的类称为实现类。\n *    实现类的格式:\n *      class 类名 implements 接口1,接口2,接口3...{\n *\n *\n *      }\n * */\npublic class PingPongMan  implements SportMan {\n    @Override\n    public void run() {\n        System.out.println("乒乓球运动员稍微跑一下！！");\n    }\n\n    @Override\n    public void law() {\n        System.out.println("乒乓球运动员守法！");\n    }\n\n    @Override\n    public String compittion(String project) {\n        return "参加"+project+"得金牌！";\n    }\n}','java\npublic class TestMain {\n    public static void main(String[] args) {\n        // 创建实现类对象。\n        PingPongMan zjk = new PingPongMan();\n        zjk.run();\n        zjk.law();\n        System.out.println(zjk.compittion("全球乒乓球比赛"));\n\n    }\n}',"java\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n}\n\n/** 这一个运动员的规范：接口*/\npublic interface SportMan {\n    void run();\n}",'java\n/**\n * Java中接口是可以被多实现的：\n *    一个类可以实现多个接口: Law, SportMan\n *\n * */\npublic class JumpMan implements Law ,SportMan {\n    @Override\n    public void rule() {\n        System.out.println("尊长守法");\n    }\n\n    @Override\n    public void run() {\n        System.out.println("训练跑步！");\n    }\n}',"java \npublic interface Abc {\n    void go();\n    void test();\n}\n\n/** 法律规范：接口*/\npublic interface Law {\n    void rule();\n    void test();\n}\n\n *\n *  总结：\n *     接口与类之间是多实现的。\n *     接口与接口之间是多继承的。\n * */\npublic interface SportMan extends Law , Abc {\n    void run();\n}","java\n 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类","java\n外部类.内部类 变量 = new 外部类（）.new 内部类（）;",'java\n方式一：\npublic class Test {\n    public static void main(String[] args) {\n        //  宿主：外部类对象。\n       // Outer out = new Outer();\n        // 创建内部类对象。\n        Outer.Inner oi = new Outer().new Inner();\n        oi.method();\n    }\n}\n\nclass Outer {\n    // 成员内部类，属于外部类对象的。\n    // 拓展：成员内部类不能定义静态成员。\n    public class Inner{\n        // 这里面的东西与类是完全一样的。\n        public void method(){\n            System.out.println("内部类中的方法被调用了");\n        }\n    }\n}\n\n\n方式二：\npublic class Outer {\n    String name;\n    private class Inner{\n        static int a = 10;\n    }\n    public Inner getInstance(){\n        return new Inner();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Outer o = new Outer();\n        System.out.println(o.getInstance());\n\n\n    }\n}',"java\npublic class Test {\n    public static void main(String[] args) {\n        Outer.inner oi = new Outer().new inner();\n        oi.method();\n    }\n}\n\nclass Outer {\t// 外部类\n    private int a = 30;\n\n    // 在成员位置定义一个类\n    class inner {\n        private int a = 20;\n\n        public void method() {\n            int a = 10;\n            System.out.println(???);\t// 10   答案：a\n            System.out.println(???);\t// 20\t答案：this.a\n            System.out.println(???);\t// 30\t答案：Outer.this.a\n        }\n    }\n}","外部类.内部类。","java\n外部类.内部类  变量 = new  外部类.内部类构造器;",'java\n// 外部类：Outer01\nclass Outer01{\n    private static  String sc_name = "黑马程序";\n    // 内部类: Inner01\n    public static class Inner01{\n        // 这里面的东西与类是完全一样的。\n        private String name;\n        public Inner01(String name) {\n            this.name = name;\n        }\n        public void showName(){\n            System.out.println(this.name);\n            // 拓展:静态内部类可以直接访问外部类的静态成员。\n            System.out.println(sc_name);\n        }\n    }\n}\n\npublic class InnerClassDemo01 {\n    public static void main(String[] args) {\n        // 创建静态内部类对象。\n        // 外部类.内部类  变量 = new  外部类.内部类构造器;\n        Outer01.Inner01 in  = new Outer01.Inner01("张三");\n        in.showName();\n    }\n}',"java\nclass 外部类名 {\n\t数据类型 变量名;\n\t\n\t修饰符 返回值类型 方法名(参数列表) {\n\t\t// …\n\t\tclass 内部类 {\n\t\t\t// 成员变量\n\t\t\t// 成员方法\n\t\t}\n\t}\n}","java\nnew 类名或者接口名() {\n     重写方法;\n};",'java\ninterface Swim {\n    public abstract void swimming();\n}\n\n// 1. 定义接口的实现类\nclass Student implements Swim {\n    // 2. 重写抽象方法\n    @Override\n    public void swimming() {\n        System.out.println("狗刨式...");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        // 3. 创建实现类对象\n        Student s = new Student();\n        // 4. 调用方法\n        s.swimming();\n    }\n}',"java\nnew 父类名或者接口名(){\n    // 方法重写\n    @Override \n    public void method() {\n        // 执行语句\n    }\n};",'java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 使用匿名内部类\n\t\tnew Swim() {\n\t\t\t@Override\n\t\t\tpublic void swimming() {\n\t\t\t\tSystem.out.println("自由泳...");\n\t\t\t}\n\t\t}.swimming();\n\n        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法\n        Swim s2 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println("蛙泳...");\n            }\n        };\n\n        s2.swimming();\n        s2.swimming();\n    }\n}','java\ninterface Swim {\n    public abstract void swimming();\n}\n\npublic class Demo07 {\n    public static void main(String[] args) {\n        // 普通方式传入对象\n        // 创建实现类对象\n        Student s = new Student();\n        \n        goSwimming(s);\n        // 匿名内部类使用场景:作为方法参数传递\n        Swim s3 = new Swim() {\n            @Override\n            public void swimming() {\n                System.out.println("蝶泳...");\n            }\n        };\n        // 传入匿名内部类\n        goSwimming(s3);\n\n        // 完美方案: 一步到位\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println("大学生, 蛙泳...");\n            }\n        });\n\n        goSwimming(new Swim() {\n            public void swimming() {\n                System.out.println("小学生, 自由泳...");\n            }\n        });\n    }\n\n    // 定义一个方法,模拟请一些人去游泳\n    public static void goSwimming(Swim s) {\n        s.swimming();\n    }\n}']},{title:"day16-面向对象综合练习（上）",headers:[{level:2,title:"1. 设计游戏的目的",slug:"_1-设计游戏的目的",link:"#_1-设计游戏的目的",children:[]},{level:2,title:"2. 游戏的最终效果呈现",slug:"_2-游戏的最终效果呈现",link:"#_2-游戏的最终效果呈现",children:[]},{level:2,title:"3. 实现思路",slug:"_3-实现思路",link:"#_3-实现思路",children:[]},{level:2,title:"4. 三行代码实现主界面搭建",slug:"_4-三行代码实现主界面搭建",link:"#_4-三行代码实现主界面搭建",children:[{level:3,title:"界面效果：",slug:"界面效果",link:"#界面效果",children:[]},{level:3,title:"实现步骤：",slug:"实现步骤",link:"#实现步骤",children:[]}]},{level:2,title:"5. 主界面的其他设置",slug:"_5-主界面的其他设置",link:"#_5-主界面的其他设置",children:[]},{level:2,title:"6. 利用继承简化代码",slug:"_6-利用继承简化代码",link:"#_6-利用继承简化代码",children:[]},{level:2,title:"7. 菜单制作",slug:"_7-菜单制作",link:"#_7-菜单制作",children:[{level:3,title:"7.1菜单的组成",slug:"_7-1菜单的组成",link:"#_7-1菜单的组成",children:[]},{level:3,title:"7.2代码书写步骤",slug:"_7-2代码书写步骤",link:"#_7-2代码书写步骤",children:[]}]},{level:2,title:"8.添加图片",slug:"_8-添加图片",link:"#_8-添加图片",children:[{level:3,title:"8.1使用到的Java类",slug:"_8-1使用到的java类",link:"#_8-1使用到的java类",children:[]},{level:3,title:"8.2位置坐标",slug:"_8-2位置坐标",link:"#_8-2位置坐标",children:[]},{level:3,title:"8.3添加步骤：",slug:"_8-3添加步骤",link:"#_8-3添加步骤",children:[]},{level:3,title:"8.4 打乱图片的位置",slug:"_8-4-打乱图片的位置",link:"#_8-4-打乱图片的位置",children:[]}]},{level:2,title:"9. 事件",slug:"_9-事件",link:"#_9-事件",children:[{level:3,title:"9.1 常见的三个核心要素",slug:"_9-1-常见的三个核心要素",link:"#_9-1-常见的三个核心要素",children:[]},{level:3,title:"9.2 常见的三种事件监听",slug:"_9-2-常见的三种事件监听",link:"#_9-2-常见的三种事件监听",children:[]},{level:3,title:"9.3 动作监听",slug:"_9-3-动作监听",link:"#_9-3-动作监听",children:[]}]}],path:"/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/day16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89.html",pathLocale:"/",extraFields:["java\n//1.召唤主界面\nJFrame jFrame = new JFrame();\n\n//2.设置主界面的大小\njFrame.setSize(514,595);\n\n//3.让主界面显示出来\njFrame.setVisible(true);",'java\n//1.召唤主界面\nJFrame jFrame = new JFrame();\n\n//设置主界面的大小\njFrame.setSize(514,595);\n\n//将主界面设置到屏幕的正中央\njFrame.setLocationRelativeTo(null);\n\n//将主界面置顶\njFrame.setAlwaysOnTop(true);\n\n//关闭主界面的时候让代码一起停止\njFrame.setDefaultCloseOperation(3);\n\n//给主界面设置一个标题\njFrame.setTitle("拼图游戏单机版 v1.0");\n\n//2.让主界面显示出来\njFrame.setVisible(true);','java\n//登录界面\npublic class LoginJFrame extends JFrame {\n    //LoginJFrame 表示登录界面\n    //以后所有跟登录相关的代码，都写在这里\n\n\n    public LoginJFrame(){\n        //在创建登录界面的时候，同时给这个界面去设置一些信息\n        //比如，宽高，直接展示出来\n        this.setSize(488,430);\n        //设置界面的标题\n        this.setTitle("拼图 登录");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //让显示显示出来，建议写在最后\n        this.setVisible(true);\n    }\n}\n\n\n\n//注册界面\npublic class RegisterJFrame extends JFrame {\n    //跟注册相关的代码，都写在这个界面中\n    public RegisterJFrame(){\n        this.setSize(488,500);\n        //设置界面的标题\n        this.setTitle("拼图 注册");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //让显示显示出来，建议写在最后\n        this.setVisible(true);\n\n\n        getContentPane();\n    }\n}\n\n//游戏主界面\npublic class GameJFrame extends JFrame {\n\n    public GameJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n    }\n}','java\n//创建一个菜单对象\nJMenuBar jMenuBar = new JMenuBar();\n//设置菜单的宽高\njMenuBar.setSize(514, 20);\n//创建一个选项\nJMenu jMenu1 = new JMenu("功能");\n//创建一个条目\njMenuItem1 = new JMenuItem("重新游戏");\n\n//把条目添加到选项当中\njMenu1.add(jMenuItem1);\n//把选项添加到菜单当中\njMenuBar.add(jMenu1);\n//把菜单添加到最外层的窗体当中\nthis.setJMenuBar(jMenuBar);','java\n//1，先对整个界面进行设置\n\t//取消内部居中放置方式\n\tthis.setLayout(null);\n//2，创建ImageIcon对象，并制定图片位置。\n\tImageIcon imageIcon1 = new ImageIcon("image\\\\1.png");\n//3，创建JLabel对象，并把ImageIcon对象放到小括号中。\n\tJLabel jLabel1 = new JLabel(imageIcon1);\n//4，利用JLabel对象设置大小，宽高。\n\tjLabel1.setBounds(0, 0, 100, 100);\n//5，将JLabel对象添加到整个界面当中。\n\tthis.add(jLabel1);','java\npublic class Test1 {\n    public static void main(String[] args) {\n        //需求：\n        //把一个一维数组中的数据：0~15 打乱顺序\n        //然后再按照4个一组的方式添加到二维数组当中\n\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n        //3.遍历数组\n        for (int i = 0; i < tempArr.length; i++) {\n            System.out.print(tempArr[i] + " ");\n        }\n        System.out.println();\n\n        //4.创建一个二维数组\n        int[][] data = new int[4][4];\n\n        //5.给二维数组添加数据\n        //解法一：\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            data[i / 4][i % 4] = tempArr[i];\n        }\n\n        //遍历二维数组\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                System.out.print(data[i][j] + " ");\n            }\n            System.out.println();\n        }\n    }\n}','java\npublic class GameJFrame extends JFrame {\n    //JFrame 界面，窗体\n    //子类呢？也表示界面，窗体\n    //规定：GameJFrame这个界面表示的就是游戏的主界面\n    //以后跟游戏相关的所有逻辑都写在这个类中\n\n    //创建一个二维数组\n    //目的：用来管理数据\n    //加载图片的时候，会根据二维数组中的数据进行加载\n    int[][] data = new int[4][4];\n\n    public GameJFrame() {\n        //初始化界面\n        initJFrame();\n\n        //初始化菜单\n        initJMenuBar();\n\n        //初始化数据（打乱）\n        initData();\n\n        //初始化图片（根据打乱之后的结果去加载图片）\n        initImage();\n\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n\n    }\n\n    //初始化数据（打乱）\n    private void initData() {\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n\n        //4.给二维数组添加数据\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            data[i / 4][i % 4] = tempArr[i];\n        }\n\n\n    }\n\n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\animal\\\\animal3\\\\" + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j, 105 * i, 105, 105);\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n\n        }\n\n\n    }\n\n\n    private void initJMenuBar() {\n        //创建整个的菜单对象\n        JMenuBar jMenuBar = new JMenuBar();\n\n        //创建菜单上面的两个选项的对象 （功能  关于我们）\n        JMenu functionJMenu = new JMenu("功能");\n        JMenu aboutJMenu = new JMenu("关于我们");\n\n        //创建选项下面的条目对象\n        JMenuItem replayItem = new JMenuItem("重新游戏");\n        JMenuItem reLoginItem = new JMenuItem("重新登录");\n        JMenuItem closeItem = new JMenuItem("关闭游戏");\n\n        JMenuItem accountItem = new JMenuItem("公众号");\n\n        //将每一个选项下面的条目天极爱到选项当中\n        functionJMenu.add(replayItem);\n        functionJMenu.add(reLoginItem);\n        functionJMenu.add(closeItem);\n\n        aboutJMenu.add(accountItem);\n\n        //将菜单里面的两个选项添加到菜单当中\n        jMenuBar.add(functionJMenu);\n        jMenuBar.add(aboutJMenu);\n\n        //给整个界面设置菜单\n        this.setJMenuBar(jMenuBar);\n    }\n\n    private void initJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n\n    }\n}','java\npublic class Test3 {\n    public static void main(String[] args) {\n        JFrame jFrame = new JFrame();\n        //设置界面的宽高\n        jFrame.setSize(603, 680);\n        //设置界面的标题\n        jFrame.setTitle("事件演示");\n        //设置界面置顶\n        jFrame.setAlwaysOnTop(true);\n        //设置界面居中\n        jFrame.setLocationRelativeTo(null);\n        //设置关闭模式\n        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        jFrame.setLayout(null);\n\n\n        //创建一个按钮对象\n        JButton jtb = new JButton("点我啊");\n        //设置位置和宽高\n        jtb.setBounds(0,0,100,50);\n        //给按钮添加动作监听\n        //jtb:组件对象，表示你要给哪个组件添加事件\n        //addActionListener：表示我要给组件添加哪个事件监听（动作监听包含鼠标左键点击，空格）\n        //参数：表示事件被触发之后要执行的代码\n        jtb.addActionListener(new MyActionListener());\n\n\n        //把按钮添加到界面当中\n        jFrame.getContentPane().add(jtb);\n\n\n        jFrame.setVisible(true);\n    }\n}\n\n\npublic class MyActionListener implements ActionListener {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        System.out.println("按钮被点击了");\n    }\n}','java\npublic class Test3 {\n    public static void main(String[] args) {\n        JFrame jFrame = new JFrame();\n        //设置界面的宽高\n        jFrame.setSize(603, 680);\n        //设置界面的标题\n        jFrame.setTitle("事件演示");\n        //设置界面置顶\n        jFrame.setAlwaysOnTop(true);\n        //设置界面居中\n        jFrame.setLocationRelativeTo(null);\n        //设置关闭模式\n        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        jFrame.setLayout(null);\n\n\n        //创建一个按钮对象\n        JButton jtb = new JButton("点我啊");\n        //设置位置和宽高\n        jtb.setBounds(0,0,100,50);\n        //给按钮添加动作监听\n        //jtb:组件对象，表示你要给哪个组件添加事件\n        //addActionListener：表示我要给组件添加哪个事件监听（动作监听包含鼠标左键点击，空格）\n        //参数：表示事件被触发之后要执行的代码\n\n        jtb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println("达咩~不要点我哟~");\n            }\n        });\n\n\n        //把按钮添加到界面当中\n        jFrame.getContentPane().add(jtb);\n\n\n        jFrame.setVisible(true);\n    }\n}','java\npublic class MyJFrame extends JFrame implements ActionListener {\n\n    //创建一个按钮对象\n    JButton jtb1 = new JButton("点我啊");\n    //创建一个按钮对象\n    JButton jtb2 = new JButton("再点我啊");\n\n    public MyJFrame(){\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n\n\n        //给按钮设置位置和宽高\n        jtb1.setBounds(0,0,100,50);\n        //给按钮添加事件\n        jtb1.addActionListener(this);\n\n\n        //给按钮设置位置和宽高\n        jtb2.setBounds(100,0,100,50);\n        jtb2.addActionListener(this);\n\n\n        //那按钮添加到整个界面当中\n        this.getContentPane().add(jtb1);\n        this.getContentPane().add(jtb2);\n\n        //让整个界面显示出来\n        this.setVisible(true);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //对当前的按钮进行判断\n\n        //获取当前被操作的那个按钮对象\n        Object source = e.getSource();\n\n        if(source == jtb1){\n            jtb1.setSize(200,200);\n        }else if(source == jtb2){\n            Random r = new Random();\n            jtb2.setLocation(r.nextInt(500),r.nextInt(500));\n        }\n    }\n}']},{title:"day16-面向对象综合练习（下）",headers:[{level:2,title:"1. 美化界面",slug:"_1-美化界面",link:"#_1-美化界面",children:[{level:3,title:"1.1 小图片居中",slug:"_1-1-小图片居中",link:"#_1-1-小图片居中",children:[]},{level:3,title:"1.2 添加背景图片",slug:"_1-2-添加背景图片",link:"#_1-2-添加背景图片",children:[]},{level:3,title:"1.3 添加图片的边框",slug:"_1-3-添加图片的边框",link:"#_1-3-添加图片的边框",children:[]},{level:3,title:"1.4 优化路径",slug:"_1-4-优化路径",link:"#_1-4-优化路径",children:[]}]},{level:2,title:"2. 上下左右移动的逻辑",slug:"_2-上下左右移动的逻辑",link:"#_2-上下左右移动的逻辑",children:[]},{level:2,title:"3. 查看完整图片的功能",slug:"_3-查看完整图片的功能",link:"#_3-查看完整图片的功能",children:[]},{level:2,title:"4. 作弊码",slug:"_4-作弊码",link:"#_4-作弊码",children:[]},{level:2,title:"5. 判断胜利",slug:"_5-判断胜利",link:"#_5-判断胜利",children:[]},{level:2,title:"6. 计步功能",slug:"_6-计步功能",link:"#_6-计步功能",children:[]},{level:2,title:"7. 其他功能",slug:"_7-其他功能",link:"#_7-其他功能",children:[]},{level:2,title:"8.游戏完整代码",slug:"_8-游戏完整代码",link:"#_8-游戏完整代码",children:[]}],path:"/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/day17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89.html",pathLocale:"/",extraFields:['java\nfor (int i = 0; i < 4; i++) {\n    //内循环 --- 表示在一行添加4张图片\n    for (int j = 0; j < 4; j++) {\n        //获取当前要加载图片的序号\n        int num = data[i][j];\n        //创建一个JLabel的对象（管理容器）\n        JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n        //指定图片位置，并进行适当的偏移\n        jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n        //给图片添加边框\n        //0:表示让图片凸起来\n        //1：表示让图片凹下去\n        jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n        //把管理容器添加到界面中\n        this.getContentPane().add(jLabel);\n    }\n}','java\nfor (int i = 0; i < 4; i++) {\n    //内循环 --- 表示在一行添加4张图片\n    for (int j = 0; j < 4; j++) {\n        //获取当前要加载图片的序号\n        int num = data[i][j];\n        //创建一个JLabel的对象（管理容器）\n        JLabel jLabel = new JLabel(new ImageIcon("F:\\\\JavaSE最新版\\\\day17-面向对象综合练习（下）\\\\代码\\\\" + num + ".jpg"));\n        //指定图片位置\n        jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n        //给图片添加边框\n        //0:表示让图片凸起来\n        //1：表示让图片凹下去\n        jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n        //把管理容器添加到界面中\n        this.getContentPane().add(jLabel);\n    }\n}\n\n\n//添加背景图片\nJLabel background = new JLabel(new ImageIcon("F:\\JavaSE最新版\\day17-面向对象综合练习（下）\\代码\\puzzlegame\\\\image\\\\background.png"));\nbackground.setBounds(40, 40, 508, 560);\n//把背景图片添加到界面当中\nthis.getContentPane().add(background);',"java\n//给图片添加边框\n//括号中也可以写0或者1\n//要注意，这个凸凹跟大家自己理解的可能会有偏差\n//0:表示让图片凸起来，图片凸起来，边框就会凹下去\n//1：表示让图片凹下去，图片凹下去，边框就会凸起来\n//但是0和1不好记，所以Java中就定义了常亮表示，方便记忆\n//BevelBorder.LOWERED：表示1\n//BevelBorder.RAISED：表示0\njLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));","java\nF:\\JavaSE最新版\\day17-面向对象综合练习（下）\\代码\\puzzlegame\\image\\animal\\animal3\\1.jpg","java\nC:\\\\a.txt","java\naaa\\\\bbb\\\\a.txt","java\naaa\\\\bbb\\\\a.txt",'java\n//添加背景图片\nJLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\nbackground.setBounds(40, 40, 508, 560);\n//把背景图片添加到界面当中\nthis.getContentPane().add(background);','java\n//松开按键的时候会调用这个方法\n@Override\npublic void keyReleased(KeyEvent e) {\n    //对上，下，左，右进行判断\n    //左：37 上：38 右：39 下：40\n    int code = e.getKeyCode();\n    if (code == 37) {\n        System.out.println("向左移动");\n        //逻辑：\n        //把空白方块右方的数字往左移动\n        data[x][y] = data[x][y + 1];\n        data[x][y + 1] = 0;\n        y++;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    } else if (code == 38) {\n        System.out.println("向上移动");\n        //逻辑：\n        //把空白方块下方的数字往上移动\n        //x，y  表示空白方块\n        //x + 1， y 表示空白方块下方的数字\n        //把空白方块下方的数字赋值给空白方块\n        data[x][y] = data[x + 1][y];\n        data[x + 1][y] = 0;\n        x++;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    } else if (code == 39) {\n        System.out.println("向右移动");\n        //逻辑：\n        //把空白方块左方的数字往右移动\n        data[x][y] = data[x][y - 1];\n        data[x][y - 1] = 0;\n        y--;\n        //每移动一次，计数器就自增一次。\n        initImage();\n    } else if (code == 40) {\n        System.out.println("向下移动");\n        //逻辑：\n        //把空白方块上方的数字往下移动\n        data[x][y] = data[x - 1][y];\n        data[x - 1][y] = 0;\n        x--;\n        //调用方法按照最新的数字加载图片\n        initImage();\n    }\n}','java\n//按下不松时会调用这个方法\n@Override\npublic void keyPressed(KeyEvent e) {\n    int code = e.getKeyCode();\n    if (code == 65){\n        //把界面中所有的图片全部删除\n        this.getContentPane().removeAll();\n        //加载第一张完整的图片\n        JLabel all = new JLabel(new ImageIcon(path + "all.jpg"));\n        all.setBounds(83,134,420,420);\n        this.getContentPane().add(all);\n        //加载背景图片\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n        //刷新界面\n        this.getContentPane().repaint();\n\n\n    }\n}\n\n\n//松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        ...\n        else if(code == 65){\n            initImage();\n        }\n        ....\n    }',"java\n//松开按键的时候会调用这个方法\n@Override\npublic void keyReleased(KeyEvent e) {\n    ...\n        else if(code == 87){\n            data = new int[][]{\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12},\n                {13,14,15,0}\n            };\n            initImage();\n        }\n    ....\n}",'java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    ...\n        //定义一个二维数组，存储正确的数据\n        int[][] win = {\n        {1,2,3,4},\n        {5,6,7,8},\n        {9,10,11,12},\n        {13,14,15,0}\n    };\n\n    private void initImage() {\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }   \n        \n        ...\n            \n    }   \n\n    //判断data数组中的数据是否跟win数组中相同\n    //如果全部相同，返回true。否则返回false\n    public boolean victory(){\n        for (int i = 0; i < data.length; i++) {\n            //i : 依次表示二维数组 data里面的索引\n            //data[i]：依次表示每一个一维数组\n            for (int j = 0; j < data[i].length; j++) {\n                if(data[i][j] != win[i][j]){\n                    //只要有一个数据不一样，则返回false\n                    return false;\n                }\n            }\n        }\n        //循环结束表示数组遍历比较完毕，全都一样返回true\n        return true;\n    }\n}','java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    ...\n    //定义变量用来统计步数\n    int step = 0;\n    \n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }\n\n\n        JLabel stepCount = new JLabel("步数：" + step);\n        stepCount.setBounds(50,30,100,20);\n        this.getContentPane().add(stepCount);\n\n\n        //路径分为两种：\n        //绝对路径：一定是从盘符开始的。C:\\  D：\\\n        //相对路径：不是从盘符开始的\n        //相对路径相对当前项目而言的。 aaa\\\\bbb\n        //在当前项目下，去找aaa文件夹，里面再找bbb文件夹。\n\n        //细节：\n        //先加载的图片在上方，后加载的图片塞在下面。\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n                //给图片添加边框\n                //0:表示让图片凸起来\n                //1：表示让图片凹下去\n                jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n        }\n\n\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n\n\n        //刷新一下界面\n        this.getContentPane().repaint();\n\n\n    }\n\n   //松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        //判断游戏是否胜利，如果胜利，此方法需要直接结束，不能再执行下面的移动代码了\n        if(victory()){\n            //结束方法\n            return;\n        }\n        //对上，下，左，右进行判断\n        //左：37 上：38 右：39 下：40\n        int code = e.getKeyCode();\n        System.out.println(code);\n        if (code == 37) {\n            System.out.println("向左移动");\n            if(y == 3){\n                return;\n            }\n            //逻辑：\n            //把空白方块右方的数字往左移动\n            data[x][y] = data[x][y + 1];\n            data[x][y + 1] = 0;\n            y++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n\n        } else if (code == 38) {\n            System.out.println("向上移动");\n            if(x == 3){\n                //表示空白方块已经在最下方了，他的下面没有图片再能移动了\n                return;\n            }\n            //逻辑：\n            //把空白方块下方的数字往上移动\n            //x，y  表示空白方块\n            //x + 1， y 表示空白方块下方的数字\n            //把空白方块下方的数字赋值给空白方块\n            data[x][y] = data[x + 1][y];\n            data[x + 1][y] = 0;\n            x++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 39) {\n            System.out.println("向右移动");\n            if(y == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块左方的数字往右移动\n            data[x][y] = data[x][y - 1];\n            data[x][y - 1] = 0;\n            y--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 40) {\n            System.out.println("向下移动");\n            if(x == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块上方的数字往下移动\n            data[x][y] = data[x - 1][y];\n            data[x - 1][y] = 0;\n            x--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        }else if(code == 65){\n            initImage();\n        }else if(code == 87){\n            data = new int[][]{\n                    {1,2,3,4},\n                    {5,6,7,8},\n                    {9,10,11,12},\n                    {13,14,15,0}\n            };\n            initImage();\n        }\n    }\n    \n    ...\n}','java\n@Override\npublic void actionPerformed(ActionEvent e) {\n    //获取当前被点击的条目对象\n    Object obj = e.getSource();\n    //判断\n    if(obj == replayItem){\n        System.out.println("重新游戏");\n        //计步器清零\n        step = 0;\n        //再次打乱二维数组中的数据\n        initData();\n        //重新加载图片\n        initImage();\n    }else if(obj == reLoginItem){\n        System.out.println("重新登录");\n        //关闭当前的游戏界面\n        this.setVisible(false);\n        //打开登录界面\n        new LoginJFrame();\n    }else if(obj == closeItem){\n        System.out.println("关闭游戏");\n        //直接关闭虚拟机即可\n        System.exit(0);\n    }else if(obj == accountItem){\n        System.out.println("公众号");\n\n        //创建一个弹框对象\n        JDialog jDialog = new JDialog();\n        //创建一个管理图片的容器对象JLabel\n        JLabel jLabel = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\about.png"));\n        //设置位置和宽高\n        jLabel.setBounds(0,0,258,258);\n        //把图片添加到弹框当中\n        jDialog.getContentPane().add(jLabel);\n        //给弹框设置大小\n        jDialog.setSize(344,344);\n        //让弹框置顶\n        jDialog.setAlwaysOnTop(true);\n        //让弹框居中\n        jDialog.setLocationRelativeTo(null);\n        //弹框不关闭则无法操作下面的界面\n        jDialog.setModal(true);\n        //让弹框显示出来\n        jDialog.setVisible(true);\n    }\n}','java\npublic class GameJFrame extends JFrame implements KeyListener,ActionListener{\n    //JFrame 界面，窗体\n    //子类呢？也表示界面，窗体\n    //规定：GameJFrame这个界面表示的就是游戏的主界面\n    //以后跟游戏相关的所有逻辑都写在这个类中\n\n    //创建一个二维数组\n    //目的：用来管理数据\n    //加载图片的时候，会根据二维数组中的数据进行加载\n    int[][] data = new int[4][4];\n\n    //记录空白方块在二维数组中的位置\n    int x = 0;\n    int y = 0;\n\n    //定义一个变量，记录当前展示图片的路径\n    String path = "puzzlegame\\\\image\\\\animal\\\\animal3\\\\";\n\n\n\n\n\n    //定义一个二维数组，存储正确的数据\n    int[][] win = {\n        {1,2,3,4},\n        {5,6,7,8},\n        {9,10,11,12},\n        {13,14,15,0}\n    };\n\n    //定义变量用来统计步数\n    int step = 0;\n\n\n    //创建选项下面的条目对象\n    JMenuItem replayItem = new JMenuItem("重新游戏");\n    JMenuItem reLoginItem = new JMenuItem("重新登录");\n    JMenuItem closeItem = new JMenuItem("关闭游戏");\n\n    JMenuItem accountItem = new JMenuItem("公众号");\n\n\n    public GameJFrame() {\n        //初始化界面\n        initJFrame();\n\n        //初始化菜单\n        initJMenuBar();\n\n\n        //初始化数据（打乱）\n        initData();\n\n        //初始化图片（根据打乱之后的结果去加载图片）\n        initImage();\n\n        //让界面显示出来，建议写在最后\n        this.setVisible(true);\n\n    }\n\n\n    //初始化数据（打乱）\n    private void initData() {\n        //1.定义一个一维数组\n        int[] tempArr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n        //2.打乱数组中的数据的顺序\n        //遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换\n        Random r = new Random();\n        for (int i = 0; i < tempArr.length; i++) {\n            //获取到随机索引\n            int index = r.nextInt(tempArr.length);\n            //拿着遍历到的每一个数据，跟随机索引上的数据进行交换\n            int temp = tempArr[i];\n            tempArr[i] = tempArr[index];\n            tempArr[index] = temp;\n        }\n\n        /*\n        *\n        *           5   6   8   9\n        *           10  11  15  1\n        *           4   7   12  13\n        *           2   3   0  14\n        *\n        *           5   6   8   9   10  11  15  1   4   7   12  13  2   3   0   14\n        * */\n\n        //4.给二维数组添加数据\n        //遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中\n        for (int i = 0; i < tempArr.length; i++) {\n            if (tempArr[i] == 0) {\n                x = i / 4;\n                y = i % 4;\n            }\n            data[i / 4][i % 4] = tempArr[i];\n        }\n    }\n\n    //初始化图片\n    //添加图片的时候，就需要按照二维数组中管理的数据添加图片\n    private void initImage() {\n\n        //清空原本已经出现的所有图片\n        this.getContentPane().removeAll();\n\n        if (victory()) {\n            //显示胜利的图标\n            JLabel winJLabel = new JLabel(new ImageIcon("C:\\\\Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\puzzlegame\\\\image\\\\win.png"));\n            winJLabel.setBounds(203,283,197,73);\n            this.getContentPane().add(winJLabel);\n        }\n\n\n        JLabel stepCount = new JLabel("步数：" + step);\n        stepCount.setBounds(50,30,100,20);\n        this.getContentPane().add(stepCount);\n\n\n        //路径分为两种：\n        //绝对路径：一定是从盘符开始的。C:\\  D：\\\n        //相对路径：不是从盘符开始的\n        //相对路径相对当前项目而言的。 aaa\\\\bbb\n        //在当前项目下，去找aaa文件夹，里面再找bbb文件夹。\n\n        //细节：\n        //先加载的图片在上方，后加载的图片塞在下面。\n        //外循环 --- 把内循环重复执行了4次。\n        for (int i = 0; i < 4; i++) {\n            //内循环 --- 表示在一行添加4张图片\n            for (int j = 0; j < 4; j++) {\n                //获取当前要加载图片的序号\n                int num = data[i][j];\n                //创建一个JLabel的对象（管理容器）\n                JLabel jLabel = new JLabel(new ImageIcon(path + num + ".jpg"));\n                //指定图片位置\n                jLabel.setBounds(105 * j + 83, 105 * i + 134, 105, 105);\n                //给图片添加边框\n                //0:表示让图片凸起来\n                //1：表示让图片凹下去\n                jLabel.setBorder(new BevelBorder(BevelBorder.LOWERED));\n                //把管理容器添加到界面中\n                this.getContentPane().add(jLabel);\n            }\n        }\n\n\n        //添加背景图片\n        JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n        background.setBounds(40, 40, 508, 560);\n        //把背景图片添加到界面当中\n        this.getContentPane().add(background);\n\n\n        //刷新一下界面\n        this.getContentPane().repaint();\n\n\n    }\n\n    private void initJMenuBar() {\n        //创建整个的菜单对象\n        JMenuBar jMenuBar = new JMenuBar();\n        //创建菜单上面的两个选项的对象 （功能  关于我们）\n        JMenu functionJMenu = new JMenu("功能");\n        JMenu aboutJMenu = new JMenu("关于我们");\n\n\n\n        //将每一个选项下面的条目添加到选项当中\n        functionJMenu.add(replayItem);\n        functionJMenu.add(reLoginItem);\n        functionJMenu.add(closeItem);\n\n        aboutJMenu.add(accountItem);\n\n        //给条目绑定事件\n        replayItem.addActionListener(this);\n        reLoginItem.addActionListener(this);\n        closeItem.addActionListener(this);\n        accountItem.addActionListener(this);\n\n        //将菜单里面的两个选项添加到菜单当中\n        jMenuBar.add(functionJMenu);\n        jMenuBar.add(aboutJMenu);\n\n\n\n\n        //给整个界面设置菜单\n        this.setJMenuBar(jMenuBar);\n    }\n\n    private void initJFrame() {\n        //设置界面的宽高\n        this.setSize(603, 680);\n        //设置界面的标题\n        this.setTitle("拼图单机版 v1.0");\n        //设置界面置顶\n        this.setAlwaysOnTop(true);\n        //设置界面居中\n        this.setLocationRelativeTo(null);\n        //设置关闭模式\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件\n        this.setLayout(null);\n        //给整个界面添加键盘监听事件\n        this.addKeyListener(this);\n\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n    //按下不松时会调用这个方法\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == 65){\n            //把界面中所有的图片全部删除\n            this.getContentPane().removeAll();\n            //加载第一张完整的图片\n            JLabel all = new JLabel(new ImageIcon(path + "all.jpg"));\n            all.setBounds(83,134,420,420);\n            this.getContentPane().add(all);\n            //加载背景图片\n            //添加背景图片\n            JLabel background = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\background.png"));\n            background.setBounds(40, 40, 508, 560);\n            //把背景图片添加到界面当中\n            this.getContentPane().add(background);\n            //刷新界面\n            this.getContentPane().repaint();\n\n\n        }\n    }\n\n    //松开按键的时候会调用这个方法\n    @Override\n    public void keyReleased(KeyEvent e) {\n        //判断游戏是否胜利，如果胜利，此方法需要直接结束，不能再执行下面的移动代码了\n        if(victory()){\n            //结束方法\n            return;\n        }\n        //对上，下，左，右进行判断\n        //左：37 上：38 右：39 下：40\n        int code = e.getKeyCode();\n        System.out.println(code);\n        if (code == 37) {\n            System.out.println("向左移动");\n            if(y == 3){\n                return;\n            }\n            //逻辑：\n            //把空白方块右方的数字往左移动\n            data[x][y] = data[x][y + 1];\n            data[x][y + 1] = 0;\n            y++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n\n        } else if (code == 38) {\n            System.out.println("向上移动");\n            if(x == 3){\n                //表示空白方块已经在最下方了，他的下面没有图片再能移动了\n                return;\n            }\n            //逻辑：\n            //把空白方块下方的数字往上移动\n            //x，y  表示空白方块\n            //x + 1， y 表示空白方块下方的数字\n            //把空白方块下方的数字赋值给空白方块\n            data[x][y] = data[x + 1][y];\n            data[x + 1][y] = 0;\n            x++;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 39) {\n            System.out.println("向右移动");\n            if(y == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块左方的数字往右移动\n            data[x][y] = data[x][y - 1];\n            data[x][y - 1] = 0;\n            y--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        } else if (code == 40) {\n            System.out.println("向下移动");\n            if(x == 0){\n                return;\n            }\n            //逻辑：\n            //把空白方块上方的数字往下移动\n            data[x][y] = data[x - 1][y];\n            data[x - 1][y] = 0;\n            x--;\n            //每移动一次，计数器就自增一次。\n            step++;\n            //调用方法按照最新的数字加载图片\n            initImage();\n        }else if(code == 65){\n            initImage();\n        }else if(code == 87){\n            data = new int[][]{\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12},\n                {13,14,15,0}\n            };\n            initImage();\n        }\n    }\n\n\n    //判断data数组中的数据是否跟win数组中相同\n    //如果全部相同，返回true。否则返回false\n    public boolean victory(){\n        for (int i = 0; i < data.length; i++) {\n            //i : 依次表示二维数组 data里面的索引\n            //data[i]：依次表示每一个一维数组\n            for (int j = 0; j < data[i].length; j++) {\n                if(data[i][j] != win[i][j]){\n                    //只要有一个数据不一样，则返回false\n                    return false;\n                }\n            }\n        }\n        //循环结束表示数组遍历比较完毕，全都一样返回true\n        return true;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //获取当前被点击的条目对象\n        Object obj = e.getSource();\n        //判断\n        if(obj == replayItem){\n            System.out.println("重新游戏");\n            //计步器清零\n            step = 0;\n            //再次打乱二维数组中的数据\n            initData();\n            //重新加载图片\n            initImage();\n        }else if(obj == reLoginItem){\n            System.out.println("重新登录");\n            //关闭当前的游戏界面\n            this.setVisible(false);\n            //打开登录界面\n            new LoginJFrame();\n        }else if(obj == closeItem){\n            System.out.println("关闭游戏");\n            //直接关闭虚拟机即可\n            System.exit(0);\n        }else if(obj == accountItem){\n            System.out.println("公众号");\n\n            //创建一个弹框对象\n            JDialog jDialog = new JDialog();\n            //创建一个管理图片的容器对象JLabel\n            JLabel jLabel = new JLabel(new ImageIcon("puzzlegame\\\\image\\\\about.png"));\n            //设置位置和宽高\n            jLabel.setBounds(0,0,258,258);\n            //把图片添加到弹框当中\n            jDialog.getContentPane().add(jLabel);\n            //给弹框设置大小\n            jDialog.setSize(344,344);\n            //让弹框置顶\n            jDialog.setAlwaysOnTop(true);\n            //让弹框居中\n            jDialog.setLocationRelativeTo(null);\n            //弹框不关闭则无法操作下面的界面\n            jDialog.setModal(true);\n            //让弹框显示出来\n            jDialog.setVisible(true);\n        }\n    }\n}']},{title:"常见API，对象克隆",headers:[{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:2,title:"1.2 常见方法",slug:"_1-2-常见方法",link:"#_1-2-常见方法",children:[]},{level:2,title:"1.3 算法小题(质数)",slug:"_1-3-算法小题-质数",link:"#_1-3-算法小题-质数",children:[]},{level:2,title:"1.4 算法小题(自幂数)",slug:"_1-4-算法小题-自幂数",link:"#_1-4-算法小题-自幂数",children:[]},{level:2,title:"1.5 课后练习",slug:"_1-5-课后练习",link:"#_1-5-课后练习",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 常见方法",slug:"_2-2-常见方法",link:"#_2-2-常见方法",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 常见方法",slug:"_3-2-常见方法",link:"#_3-2-常见方法",children:[]},{level:2,title:"3.3 恶搞好基友",slug:"_3-3-恶搞好基友",link:"#_3-3-恶搞好基友",children:[]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 常见方法",slug:"_4-2-常见方法",link:"#_4-2-常见方法",children:[]},{level:2,title:"5.1 概述",slug:"_5-1-概述",link:"#_5-1-概述",children:[]},{level:2,title:"5.2 常见方法",slug:"_5-2-常见方法",link:"#_5-2-常见方法",children:[]},{level:2,title:"6.1 引入",slug:"_6-1-引入",link:"#_6-1-引入",children:[]},{level:2,title:"6.2  概述",slug:"_6-2-概述",link:"#_6-2-概述",children:[]},{level:2,title:"6.3 常见方法",slug:"_6-3-常见方法",link:"#_6-3-常见方法",children:[]},{level:2,title:"6.4 底层存储方式：",slug:"_6-4-底层存储方式",link:"#_6-4-底层存储方式",children:[]},{level:2,title:"7.1 引入",slug:"_7-1-引入",link:"#_7-1-引入",children:[]},{level:2,title:"7.2 概述",slug:"_7-2-概述",link:"#_7-2-概述",children:[]},{level:2,title:"7.3 常见方法",slug:"_7-3-常见方法",link:"#_7-3-常见方法",children:[]},{level:2,title:"7.4 底层存储方式：",slug:"_7-4-底层存储方式",link:"#_7-4-底层存储方式",children:[]}],path:"/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/API.html",pathLocale:"/",extraFields:["java\npublic static int abs(int a)\t\t\t\t\t// 返回参数的绝对值\npublic static double ceil(double a)\t\t\t\t// 返回大于或等于参数的最小整数\npublic static double floor(double a)\t\t\t// 返回小于或等于参数的最大整数\npublic static int round(float a)\t\t\t\t// 按照四舍五入返回最接近参数的int类型的值\npublic static int max(int a,int b)\t\t\t\t// 获取两个int值中的较大值\npublic static int min(int a,int b)\t\t\t\t// 获取两个int值中的较小值\npublic static double pow (double a,double b)\t// 计算a的b次幂的值\npublic static double random()\t\t\t\t\t// 返回一个[0.0,1.0)的随机值",'java\npublic class MathDemo01 {\n\n    public static void main(String[] args) {\n\n        // public static int abs(int a)         返回参数的绝对值\n        System.out.println("-2的绝对值为：" + Math.abs(-2));\n        System.out.println("2的绝对值为：" + Math.abs(2));\n\n        // public static double ceil(double a)  返回大于或等于参数的最小整数\n        System.out.println("大于或等于23.45的最小整数位：" + Math.ceil(23.45));\n        System.out.println("大于或等于-23.45的最小整数位：" + Math.ceil(-23.45));\n\n        // public static double floor(double a) 返回小于或等于参数的最大整数\n        System.out.println("小于或等于23.45的最大整数位：" + Math.floor(23.45));\n        System.out.println("小于或等于-23.45的最大整数位：" + Math.floor(-23.45));\n\n        // public static int round(float a)     按照四舍五入返回最接近参数的int\n        System.out.println("23.45四舍五入的结果为：" + Math.round(23.45));\n        System.out.println("23.55四舍五入的结果为：" + Math.round(23.55));\n\n        // public static int max(int a,int b)   返回两个int值中的较大值\n        System.out.println("23和45的最大值为: " + Math.max(23, 45));\n\n        // public static int min(int a,int b)   返回两个int值中的较小值\n        System.out.println("12和34的最小值为: " + Math.min(12 , 34));\n\n        // public static double pow (double a,double b)返回a的b次幂的值\n        System.out.println("2的3次幂计算结果为: " + Math.pow(2,3));\n\n        // public static double random()返回值为double的正值，[0.0,1.0)\n        System.out.println("获取到的0-1之间的随机数为: " + Math.random());\n    }\n\n}',"java\n-2的绝对值为：2\n2的绝对值为：2\n大于或等于23.45的最小整数位：24.0\n大于或等于-23.45的最小整数位：-23.0\n小于或等于23.45的最大整数位：23.0\n小于或等于-23.45的最大整数位：-24.0\n23.45四舍五入的结果为：23\n23.55四舍五入的结果为：24\n23和45的最大值为: 45\n12和34的最小值为: 12\n2的3次幂计算结果为: 8.0\n获取到的0-1之间的随机数为: 0.7322484131745958","java\npublic class MathDemo2 {\n    public static void main(String[] args) {\n        //判断一个数是否为一个质数\n        System.out.println(isPrime(997));\n        //997 2~996 995次\n    }\n\n    public static boolean isPrime(int number) {\n        int count = 0;\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            count++;\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        System.out.println(count);\n        return true;\n    }\n}","java\n//水仙花数:100 ~ 999\nint count = 0;\n//得到每一个三位数\nfor (int i = 100; i <= 999; i++) {\n    //个位 十位 百位\n    int ge = i % 10;\n    int shi = i / 10 % 10;\n    int bai = i / 100 % 10;\n    //判断:\n    //每一位的三次方之和 跟本身 进行比较。\n    double sum = Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3);\n    if (sum == i) {\n        count++;\n        //System.out.println(i);\n\n        System.out.println(count);\n    }\n}","java\npublic static long currentTimeMillis()\t\t\t// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置）\npublic static void exit(int status)\t\t\t\t// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); // 进行数值元素copy",'java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 获取当前时间所对应的毫秒值\n        long millis = System.currentTimeMillis();\n\n        // 输出结果\n        System.out.println("当前时间所对应的毫秒值为：" + millis);\n\n    }\n\n}',"java\n当前时间所对应的毫秒值为：1576050298343","java\npublic class SystemDemo2 {\n    public static void main(String[] args) {\n        //判断1~100000之间有多少个质数\n\n        long start = System.currentTimeMillis();\n\n        for (int i = 1; i <= 100000; i++) {\n            boolean flag = isPrime2(i);\n            if (flag) {\n                System.out.println(i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        //获取程序运行的总时间\n        System.out.println(end - start); //方式一：1514 毫秒  方式二：71毫秒\n    }\n\n    //以前判断是否为质数的方式\n    public static boolean isPrime1(int number) {\n        for (int i = 2; i < number; i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //改进之后判断是否为质数的方式（效率高）\n    public static boolean isPrime2(int number) {\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            if (number % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",'java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n        \n        // 输出\n        System.out.println("程序开始执行了.....");\n        \n        // 终止JVM\n        System.exit(0);\n        \n        // 输出\n        System.out.println("程序终止了..........");\n        \n    }\n    \n}',"java\n程序开始执行了.....","java\n// src: \t 源数组\n// srcPos：  源数值的开始位置\n// dest：    目标数组\n// destPos： 目标数组开始位置\n// length:   要复制的元素个数\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);",'java\npublic class SystemDemo01 {\n\n    public static void main(String[] args) {\n\n        // 定义源数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n\n        // 定义目标数组\n        int[] desArray = new int[10] ;\n\n        // 进行数组元素的copy: 把srcArray数组中从0索引开始的3个元素，从desArray数组中的1索引开始复制过去\n        System.arraycopy(srcArray , 0 , desArray , 1 , 3);\n\n        // 遍历目标数组\n        for(int x = 0 ; x < desArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(desArray[x] + ", ");\n            }else {\n                System.out.println(desArray[x]);\n            }\n\n        }\n\n    }\n\n}',"java\n0, 23, 45, 67, 0, 0, 0, 0, 0, 0",'java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != desArray.length - 1) {\n                System.out.print(srcArray[x] + ", ");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}',"java\n23, 45, 89, 14, 56, 56",'java\npublic class SystemDemo02 {\n    public static void main(String[] args) {\n        // 定义一个数组\n        int[] srcArray = {23 , 45 , 67 , 89 , 14 , 56 } ;\n        // 删除数组中第3个元素(67)：要删除67这个元素，我们只需要将67后面的其他元素依次向前进行移动即可\n        System.arraycopy(srcArray , 3 , srcArray , 2 , 3);\n        // 将最后一个位置的元素设置为0\n        srcArray[srcArray.length - 1] = 0 ;\n        // 遍历srcArray数组\n        for(int x = 0 ; x < srcArray.length ; x++) {\n            if(x != srcArray.length - 1 ) {\n                System.out.print(srcArray[x] + ", ");\n            }else {\n                System.out.println(srcArray[x]);\n            }\n        }\n    }\n}',"java\n23, 45, 89, 14, 56, 0",'java\npublic class SystemDemo3 {\n    public static void main(String[] args) {\n        //public static void arraycopy(数据源数组，起始索引，目的地数组，起始索引，拷贝个数) 数组拷贝\n        //细节:\n        //1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\n        //2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\n        //3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\n\n        Student s1 = new Student("zhangsan", 23);\n        Student s2 = new Student("lisi", 24);\n        Student s3 = new Student("wangwu", 25);\n\n        Student[] arr1 = {s1, s2, s3};\n        Person[] arr2 = new Person[3];\n        //把arr1中对象的地址值赋值给arr2中\n        System.arraycopy(arr1, 0, arr2, 0, 3);\n\n        //遍历数组arr2\n        for (int i = 0; i < arr2.length; i++) {\n            Student stu = (Student) arr2[i];\n            System.out.println(stu.getName() + "," + stu.getAge());\n        }\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     *\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     *\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     *\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     *\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Person{name = " + name + ", age = " + age + "}";\n    }\n}\n\n\nclass Student extends Person {\n\n    public Student() {\n    }\n\n    public Student(String name, int age) {\n        super(name, age);\n    }\n}',"java\npublic static Runtime getRuntime()\t\t//当前系统的运行环境对象\npublic void exit(int status)\t\t\t//停止虚拟机\npublic int availableProcessors()\t\t//获得CPU的线程数\npublic long maxMemory()\t\t\t\t    //JVM能从系统中获取总内存大小（单位byte）\npublic long totalMemory()\t\t\t\t//JVM已经从系统中获取总内存大小（单位byte）\npublic long freeMemory()\t\t\t\t//JVM剩余内存大小（单位byte）\npublic Process exec(String command) \t//运行cmd命令",'java\npublic class RunTimeDemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n            public static Runtime getRuntime() 当前系统的运行环境对象\n            public void exit(int status) 停止虚拟机\n            public int availableProcessors() 获得CPU的线程数\n            public long maxMemory() JVM能从系统中获取总内存大小(单位byte)\n            public long totalMemory() JVM已经从系统中获取总内存大小(单位byte)\n            public long freeMemory() JVM剩余内存大小(单位byte)\n            public Process exec(string command) 运行cmd命令\n        */\n\n        //1.获取Runtime的对象\n        //Runtime r1 =Runtime.getRuntime();\n\n        //2.exit 停止虚拟机\n        //Runtime.getRuntime().exit(0);\n        //System.out.println("看看我执行了吗?");\n\n\n        //3.获得CPU的线程数\n        System.out.println(Runtime.getRuntime().availableProcessors());//8\n        //4.总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().maxMemory() / 1024 / 1024);//4064\n        //5.已经获取的总内存大小,单位byte字节\n        System.out.println(Runtime.getRuntime().totalMemory() / 1024 / 1024);//254\n        //6.剩余内存大小\n        System.out.println(Runtime.getRuntime().freeMemory() / 1024 / 1024);//251\n\n        //7.运行cmd命令\n        //shutdown :关机\n        //加上参数才能执行\n        //-s :默认在1分钟之后关机\n        //-s -t 指定时间 : 指定关机时间\n        //-a :取消关机操作\n        //-r: 关机并重启\n        Runtime.getRuntime().exec("shutdown -s -t 3600");\n\n\n    }\n}',"java\npublic class Test {\n    public static void main(String[] args) {\n        new MyJframe();\n    }\n}",'java\npublic class MyJframe extends JFrame implements ActionListener {\n\n    JButton yesBut = new JButton("帅爆了");\n    JButton midBut = new JButton("一般般吧");\n    JButton noBut = new JButton("不帅，有点磕碜");\n    JButton dadBut = new JButton("饶了我吧！");\n\n\n    //决定了上方的按钮是否展示\n    boolean flag = false;\n\n\n    public MyJframe() {\n        initJFrame();\n\n\n        initView();\n\n\n        //显示\n        this.setVisible(true);\n    }\n\n    private void initView() {\n\n        this.getContentPane().removeAll();\n\n        if (flag) {\n            //展示按钮\n            dadBut.setBounds(50, 20, 100, 30);\n            dadBut.addActionListener(this);\n            this.getContentPane().add(dadBut);\n        }\n\n\n        JLabel text = new JLabel("你觉得自己帅吗？");\n        text.setFont(new Font("微软雅黑", 0, 30));\n        text.setBounds(120, 150, 300, 50);\n\n\n        yesBut.setBounds(200, 250, 100, 30);\n        midBut.setBounds(200, 325, 100, 30);\n        noBut.setBounds(160, 400, 180, 30);\n\n        yesBut.addActionListener(this);\n        midBut.addActionListener(this);\n        noBut.addActionListener(this);\n\n        this.getContentPane().add(text);\n        this.getContentPane().add(yesBut);\n        this.getContentPane().add(midBut);\n        this.getContentPane().add(noBut);\n\n        this.getContentPane().repaint();\n    }\n\n    private void initJFrame() {\n        //设置宽高\n        this.setSize(500, 600);\n        //设置标题\n        this.setTitle("恶搞好基友");\n        //设置关闭模式\n        this.setDefaultCloseOperation(3);\n        //置顶\n        this.setAlwaysOnTop(true);\n        //居中\n        this.setLocationRelativeTo(null);\n        //取消内部默认布局\n        this.setLayout(null);\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        Object obj = e.getSource();\n        if (obj == yesBut) {\n            //给好基友一个弹框\n            showJDialog("xxx，你太自信了，给你一点小惩罚");\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 3600");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n            flag = true;\n            initView();\n\n        } else if (obj == midBut) {\n            System.out.println("你的好基友点击了一般般吧");\n\n            //给好基友一个弹框\n            showJDialog("xxx，你还是太自信了，也要给你一点小惩罚");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 7200");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n\n\n        } else if (obj == noBut) {\n            System.out.println("你的好基友点击了不帅");\n\n            //给好基友一个弹框\n            showJDialog("xxx，你还是有一点自知之明的，也要给你一点小惩罚");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -s -t 1800");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n            flag = true;\n            initView();\n        } else if (obj == dadBut) {\n            //给好基友一个弹框\n            showJDialog("xxx，这次就饶了你~");\n\n            try {\n                Runtime.getRuntime().exec("shutdown -a");\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n\n        }\n    }\n\n    public void showJDialog(String content) {\n        //创建一个弹框对象\n        JDialog jDialog = new JDialog();\n        //给弹框设置大小\n        jDialog.setSize(200, 150);\n        //让弹框置顶\n        jDialog.setAlwaysOnTop(true);\n        //让弹框居中\n        jDialog.setLocationRelativeTo(null);\n        //弹框不关闭永远无法操作下面的界面\n        jDialog.setModal(true);\n\n        //创建Jlabel对象管理文字并添加到弹框当中\n        JLabel warning = new JLabel(content);\n        warning.setBounds(0, 0, 200, 150);\n        jDialog.getContentPane().add(warning);\n\n        //让弹框展示出来\n        jDialog.setVisible(true);\n    }\n}',"java\npublic String toString()\t\t\t\t//返回该对象的字符串表示形式(可以看做是对象的内存地址值)\npublic boolean equals(Object obj)\t\t//比较两个对象地址值是否相等；true表示相同，false表示不相同\nprotected Object clone()    \t\t\t//对象克隆","java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 无参构造方法和有参构造方法以及get和set方法略\n    ...\n        \n}",'java\npublic class ObjectDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用toString方法获取s1对象的字符串表现形式\n        String result1 = s1.toString();\n\n        // 输出结果\n        System.out.println("s1对象的字符串表现形式为：" + result1);\n\n    }\n\n}',"java\ns1对象的字符串表现形式为：com.itheima.api.system.demo04.Student@3f3afe78",'java\npublic String toString() {\t\t// Object类中toString方法的源码定义\n\treturn getClass().getName() + "@" + Integer.toHexString(hashCode());\n}',"java\n@Override\npublic String toString() {\n    return \"Student{\" +\n        \"name='\" + name + '\\'' +\n        \", age='\" + age + '\\'' +\n        '}';\n}","java\ns1对象的字符串表现形式为：Student{name='itheima', age='14'}",'java\n// 创建学生对象\nStudent s1 = new Student("itheima" , "14") ;\n\n// 直接输出对象s1\nSystem.out.println(s1);',"java\nStudent{name='itheima', age='14'}",'java\n// 创建学生对象\nStudent s1 = new Student("itheima" , "14") ;\n\n// 调用s1的toString方法，把结果进行输出\nSystem.out.println(s1.toString());','java\npublic class ObjectDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n        Student s2 = new Student("itheima" , "14") ;\n\n        // 比较两个对象是否相等\n        System.out.println(s1 == s2);\n\n    }\n\n}',"java\nfalse","java\n// 调用equals方法比较两个对象是否相等\nboolean result = s1.equals(s2);\n\n// 输出结果\nSystem.out.println(result);","java\nfalse","java\npublic boolean equals(Object obj) {\t\t// Object类中的equals方法的源码\n    return (this == obj);\n}","java\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Student student = (Student) o;\n    return Objects.equals(name, student.name) && Objects.equals(age, student.age);\t// 比较的是对象的name属性值和age属性值\n}\n\n@Override\npublic int hashCode() {\n    return 0;\n}","java\ntrue",'java\npackage com.itheima.a04objectdemo;\n\npublic class ObjectDemo4 {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        // protected object clone(int a) 对象克隆 \n\n        //1.先创建一个对象\n        int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};\n        User u1 = new User(1, "zhangsan", "1234qwer", "girl11", data);\n\n        //2.克隆对象\n        //细节:\n        //方法在底层会帮我们创建一个对象,并把原对象中的数据拷贝过去。\n        //书写细节:\n        //1.重写Object中的clone方法\n        //2.让javabean类实现Cloneable接口\n        //3.创建原对象并调用clone就可以了\n        //User u2 =(User)u1.clone();\n\n        //验证一件事情：Object中的克隆是浅克隆\n        //想要进行深克隆，就需要重写clone方法并修改里面的方法体\n        //int[] arr = u1.getData();\n        //arr[0] = 100;\n\n        //System.out.println(u1);\n        //System.out.println(u2);\n\n\n        //以后一般会用第三方工具进行克隆\n        //1.第三方写的代码导入到项目中\n        //2.编写代码\n        //Gson gson =new Gson();\n        //把对象变成一个字符串\n        //String s=gson.toJson(u1);\n        //再把字符串变回对象就可以了\n        //User user =gson.fromJson(s, User.class);\n\n        //int[] arr=u1.getData();\n        //arr[0] = 100;\n\n        //打印对象\n        //System.out.println(user);\n\n    }\n}\n\npackage com.itheima.a04objectdemo;\n\nimport java.util.StringJoiner;\n\n\n\n//Cloneable\n//如果一个接口里面没有抽象方法\n//表示当前的接口是一个标记性接口\n//现在Cloneable表示一旦实现了，那么当前类的对象就可以被克降\n//如果没有实现，当前类的对象就不能克隆\npublic class User implements Cloneable {\n    private int id;\n    private String username;\n    private String password;\n    private String path;\n    private int[] data;\n\n\n\n\n    public User() {\n    }\n\n    public User(int id, String username, String password, String path, int[] data) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.path = path;\n        this.data = data;\n    }\n\n    /**\n     * 获取\n     *\n     * @return id\n     */\n    public int getId() {\n        return id;\n    }\n\n    /**\n     * 设置\n     *\n     * @param id\n     */\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    /**\n     * 获取\n     *\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * 设置\n     *\n     * @param username\n     */\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    /**\n     * 获取\n     *\n     * @return password\n     */\n    public String getPassword() {\n        return password;\n    }\n\n    /**\n     * 设置\n     *\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * 获取\n     *\n     * @return path\n     */\n    public String getPath() {\n        return path;\n    }\n\n    /**\n     * 设置\n     *\n     * @param path\n     */\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    /**\n     * 获取\n     *\n     * @return data\n     */\n    public int[] getData() {\n        return data;\n    }\n\n    /**\n     * 设置\n     *\n     * @param data\n     */\n    public void setData(int[] data) {\n        this.data = data;\n    }\n\n    public String toString() {\n        return "角色编号为：" + id + "，用户名为：" + username + "密码为：" + password + ", 游戏图片为:" + path + ", 进度:" + arrToString();\n    }\n\n\n    public String arrToString() {\n        StringJoiner sj = new StringJoiner(", ", "[", "]");\n\n        for (int i = 0; i < data.length; i++) {\n            sj.add(data[i] + "");\n        }\n        return sj.toString();\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        //调用父类中的clone方法\n        //相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。\n\n        //先把被克隆对象中的数组获取出来\n        int[] data = this.data;\n        //创建新的数组\n        int[] newData =new int[data.length];\n        //拷贝数组中的数据\n        for (int i = 0; i < data.length; i++) {\n            newData[i] = data[i];\n        }\n        //调用父类中的方法克隆对象\n            User u=(User)super.clone();\n        //因为父类中的克隆方法是浅克隆，替换克隆出来对象中的数组地址值\n        u.data =newData;\n        return u;\n    }\n}',"java\npublic static String toString(Object o) \t\t\t\t\t// 获取对象的字符串表现形式\npublic static boolean equals(Object a, Object b)\t\t\t// 比较两个对象是否相等\npublic static boolean isNull(Object obj)\t\t\t\t\t// 判断对象是否为null\npublic static boolean nonNull(Object obj)\t\t\t\t\t// 判断对象是否不为null","java\npublic static <T> T requireNonNull(T obj)\t\t\t\t\t// 检查对象是否不为null,如果为null直接抛出异常；如果不是null返回该对象；\npublic static <T> T requireNonNullElse(T obj, T defaultObj) // 检查对象是否不为null，如果不为null，返回该对象；如果为null返回defaultObj值\npublic static <T> T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)\t// 检查对象是否不为null，如果不为null，返回该对象；如果\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // 为null,返回由Supplier所提供的值","java\npublic class Student {\n\n    private String name ;       // 姓名\n    private String age ;        // 年龄\n\n    // 其他代码略\n    ...\n        \n}",'java\npublic class ObjectsDemo01 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_04() ;\n\n    }\n\n    // 测试nonNull方法\n    public static void method_04() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的nonNull方法\n        boolean result = Objects.nonNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试isNull方法\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的isNull方法\n        boolean result = Objects.isNull(s1);\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试equals方法\n    public static void method_02() {\n\n        // 创建两个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n        Student s2 = new Student("itheima" , "14") ;\n\n        // 调用Objects类中的equals方法，比较两个对象是否相等\n        boolean result = Objects.equals(s1, s2);     // 如果Student没有重写Object类中的equals方法，此处比较的还是对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n    // 测试toString方法\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects中的toString方法,获取s1对象的字符串表现形式\n        String result = Objects.toString(s1);       // 如果Student没有重写Object类中的toString方法，此处还是返回的对象的地址值\n\n        // 输出结果\n        System.out.println(result);\n\n    }\n\n}','java\npublic class ObjectsDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03();\n\n    }\n\n    // 演示requireNonNullElseGet\n    public static void method_03() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNullElseGet方法,该方法的第二个参数是Supplier类型的，查看源码我们发现Supplier是一个函数式接口,\n        // 那么我们就可以为其传递一个Lambda表达式，而在Supplier接口中所定义的方法是无参有返回值的方法，因此具体调用所传入的Lambda表达式如下所示\n        Student student = Objects.requireNonNullElseGet(s1, () -> {\n            return new Student("itcast", "14");\n        });\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNullElse\n    public static void method_02() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNullElse方法\n        Student student = Objects.requireNonNullElse(s1, new Student("itcast", "14"));\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n    // 演示requireNonNull\n    public static void method_01() {\n\n        // 创建一个学生对象\n        Student s1 = new Student("itheima" , "14") ;\n\n        // 调用Objects对象的requireNonNull方法\n        Student student = Objects.requireNonNull(s1);\n\n        // 输出\n        System.out.println(student);\n\n    }\n\n}',"java\npublic BigInteger(int num, Random rnd) \t\t//获取随机大整数，范围：[0 ~ 2的num次方-1]\npublic BigInteger(String val) \t\t\t\t//获取指定的大整数\npublic BigInteger(String val, int radix) \t//获取指定进制的大整数\n    \n下面这个不是构造，而是一个静态方法获取BigInteger对象\npublic static BigInteger valueOf(long val) \t//静态方法获取BigInteger的对象，内部有优化","java\npublic BigInteger add(BigInteger val)\t\t\t\t\t//加法\npublic BigInteger subtract(BigInteger val)\t\t\t\t//减法\npublic BigInteger multiply(BigInteger val)\t\t\t\t//乘法\npublic BigInteger divide(BigInteger val)\t\t\t\t//除法\npublic BigInteger[] divideAndRemainder(BigInteger val)\t //除法，获取商和余数\npublic  boolean equals(Object x) \t\t\t\t\t    //比较是否相同\npublic  BigInteger pow(int exponent) \t\t\t\t\t//次幂、次方\npublic  BigInteger max/min(BigInteger val) \t\t\t\t//返回较大值/较小值\npublic  int intValue(BigInteger val) \t\t\t\t\t//转为int类型整数，超出范围数据有误",'java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo1 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger(int num, Random rnd) 获取随机大整数，范围:[0~ 2的num次方-11\n            public BigInteger(String val) 获取指定的大整数\n            public BigInteger(String val, int radix) 获取指定进制的大整数\n\n            public static BigInteger valueOf(long val) 静态方法获取BigInteger的对象，内部有优化\n\n            细节:\n            对象一旦创建里面的数据不能发生改变。\n        */\n\n\n        //1.获取一个随机的大整数\n        /* Random r=new Random();\n            for (int i = e; i < 100; i++) {\n            BigInteger bd1 = new BigInteger(4,r);\n            System.out.println(bd1);//[@ ~ 15]}\n            }\n        */\n\n        //2.获取一个指定的大整数，可以超出long的取值范围\n        //细节:字符串中必须是整数，否则会报错\n        /* BigInteger bd2 = new BigInteger("1.1");\n            System.out.println(bd2);\n        */\n\n        /*\n            BigInteger bd3 = new BigInteger("abc");\n            System.out.println(bd3);\n         */\n\n        //3.获取指定进制的大整数\n        //细节:\n        //1.字符串中的数字必须是整数\n        //2.字符串中的数字必须要跟进制吻合。\n        //比如二进制中，那么只能写日和1，写其他的就报错。\n        BigInteger bd4 = new BigInteger("123", 2);\n        System.out.println(bd4);\n\n        //4.静态方法获取BigInteger的对象，内部有优化\n        //细节:\n        //1.能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了。\n        //2.在内部对常用的数字: -16 ~ 16 进行了优化。\n        //  提前把-16~16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。\n        BigInteger bd5 = BigInteger.valueOf(16);\n        BigInteger bd6 = BigInteger.valueOf(16);\n        System.out.println(bd5 == bd6);//true\n\n\n        BigInteger bd7 = BigInteger.valueOf(17);\n        BigInteger bd8 = BigInteger.valueOf(17);\n        System.out.println(bd7 == bd8);//false\n\n\n        //5.对象一旦创建内部的数据不能发生改变\n        BigInteger bd9 =BigInteger.valueOf(1);\n        BigInteger bd10 =BigInteger.valueOf(2);\n        //此时，不会修改参与计算的BigInteger对象中的借，而是产生了一个新的BigInteger对象记录\n        BigInteger result=bd9.add(bd10);\n        System.out.println(result);//3\n\n    }\n}',"java\npackage com.itheima.a06bigintegerdemo;\n\nimport java.math.BigInteger;\n\npublic class BigIntegerDemo2 {\n    public static void main(String[] args) {\n        /*\n            public BigInteger add(BigInteger val) 加法\n            public BigInteger subtract(BigInteger val) 减法\n            public BigInteger multiply(BigInteger val) 乘法\n            public BigInteger divide(BigInteger val) 除法，获取商\n            public BigInteger[] divideAndRemainder(BigInteger val) 除法，获取商和余数\n            public boolean equals(Object x) 比较是否相同\n            public BigInteger pow(int exponent) 次幂\n            public BigInteger max/min(BigInteger val) 返回较大值/较小值\n            public int intValue(BigInteger val) 转为int类型整数，超出范围数据有误\n        */\n\n        //1.创建两个BigInteger对象\n        BigInteger bd1 = BigInteger.valueOf(10);\n        BigInteger bd2 = BigInteger.valueOf(5);\n\n        //2.加法\n        BigInteger bd3 = bd1.add(bd2);\n        System.out.println(bd3);\n\n        //3.除法，获取商和余数\n        BigInteger[] arr = bd1.divideAndRemainder(bd2);\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n\n        //4.比较是否相同\n        boolean result = bd1.equals(bd2);\n        System.out.println(result);\n\n        //5.次幂\n        BigInteger bd4 = bd1.pow(2);\n        System.out.println(bd4);\n\n        //6.max\n        BigInteger bd5 = bd1.max(bd2);\n\n\n        //7.转为int类型整数，超出范围数据有误\n        /* BigInteger bd6 = BigInteger.valueOf(2147483647L);\n         int i = bd6.intValue();\n         System.out.println(i);\n         */\n\n        BigInteger bd6 = BigInteger.valueOf(200);\n        double v = bd6.doubleValue();\n        System.out.println(v);//200.0\n    }\n}","java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n        System.out.println(0.09 + 0.01);\n    }\n\n}","java\n0.09999999999999999","java\npublic BigDecimal add(BigDecimal value)\t\t\t\t// 加法运算\npublic BigDecimal subtract(BigDecimal value)\t\t// 减法运算\npublic BigDecimal multiply(BigDecimal value)\t\t// 乘法运算\npublic BigDecimal divide(BigDecimal value)\t\t\t// 触发运算",'java\npublic class BigDecimalDemo01 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("0.3") ;\n        BigDecimal b2 = new BigDecimal("4") ;\n\n        // 调用方法进行b1和b2的四则运算，并将其运算结果在控制台进行输出\n        System.out.println(b1.add(b2));         // 进行加法运算\n        System.out.println(b1.subtract(b2));    // 进行减法运算\n        System.out.println(b1.multiply(b2));    // 进行乘法运算\n        System.out.println(b1.divide(b2));      // 进行除法运算\n\n    }\n\n}',"java\n4.3\n-3.7\n1.2\n0.075",'java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2));\n\n    }\n\n}','java\nException in thread "main" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n\tat java.base/java.math.BigDecimal.divide(BigDecimal.java:1716)\n\tat com.itheima.api.bigdecimal.demo02.BigDecimalDemo02.main(BigDecimalDemo02.java:14)',"java\nBigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","divisor:\t\t\t除数对应的BigDecimal对象；\nscale:\t\t\t\t精确的位数；\nroundingMode:\t\t取舍模式；\n取舍模式被封装到了RoundingMode这个枚举类中（关于枚举我们后期再做重点讲解），在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个：\nUP(直接进1) ， FLOOR(直接删除) ， HALF_UP(4舍五入),我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名",'java\npublic class BigDecimalDemo02 {\n\n    public static void main(String[] args) {\n\n        // 调用方法\n        method_03() ;\n\n    }\n\n    // 演示取舍模式HALF_UP\n    public static void method_03() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("0.3") ;\n        BigDecimal b2 = new BigDecimal("4") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.HALF_UP));\n\n    }\n\n    // 演示取舍模式FLOOR\n    public static void method_02() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.FLOOR));\n\n    }\n\n    // 演示取舍模式UP\n    public static void method_01() {\n\n        // 创建两个BigDecimal对象\n        BigDecimal b1 = new BigDecimal("1") ;\n        BigDecimal b2 = new BigDecimal("3") ;\n\n        // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出\n        System.out.println(b1.divide(b2 , 2 , RoundingMode.UP));\n\n    }\n\n}']},{title:"正则表达式",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 正则表达式的概念及演示",slug:"_1-1-正则表达式的概念及演示",link:"#_1-1-正则表达式的概念及演示",children:[]},{level:2,title:"1.2 正则表达式-字符类",slug:"_1-2-正则表达式-字符类",link:"#_1-2-正则表达式-字符类",children:[]},{level:2,title:"1.3 正则表达式-逻辑运算符",slug:"_1-3-正则表达式-逻辑运算符",link:"#_1-3-正则表达式-逻辑运算符",children:[]},{level:2,title:"1.4 正则表达式-预定义字符",slug:"_1-4-正则表达式-预定义字符",link:"#_1-4-正则表达式-预定义字符",children:[]},{level:2,title:"1.5 正则表达式-数量词",slug:"_1-5-正则表达式-数量词",link:"#_1-5-正则表达式-数量词",children:[]},{level:2,title:"1.6 正则表达式练习1",slug:"_1-6-正则表达式练习1",link:"#_1-6-正则表达式练习1",children:[]},{level:2,title:"1.7 正则表达式练习2",slug:"_1-7-正则表达式练习2",link:"#_1-7-正则表达式练习2",children:[]},{level:2,title:"1.8 本地数据爬取",slug:"_1-8-本地数据爬取",link:"#_1-8-本地数据爬取",children:[]},{level:2,title:"1.9 网络数据爬取（了解）",slug:"_1-9-网络数据爬取-了解",link:"#_1-9-网络数据爬取-了解",children:[]},{level:2,title:"1.10 爬取数据练习",slug:"_1-10-爬取数据练习",link:"#_1-10-爬取数据练习",children:[]},{level:2,title:"1.11 按要求爬取",slug:"_1-11-按要求爬取",link:"#_1-11-按要求爬取",children:[]},{level:2,title:"1.12 贪婪爬取和非贪婪爬取",slug:"_1-12-贪婪爬取和非贪婪爬取",link:"#_1-12-贪婪爬取和非贪婪爬取",children:[]},{level:2,title:"1.13 String的split方法中使用正则表达式",slug:"_1-13-string的split方法中使用正则表达式",link:"#_1-13-string的split方法中使用正则表达式",children:[]},{level:2,title:"1.14 String类的replaceAll方法中使用正则表达式",slug:"_1-14-string类的replaceall方法中使用正则表达式",link:"#_1-14-string类的replaceall方法中使用正则表达式",children:[]},{level:2,title:"1.15 正则表达式-分组括号( )",slug:"_1-15-正则表达式-分组括号",link:"#_1-15-正则表达式-分组括号",children:[]},{level:2,title:"1.16 分组练习",slug:"_1-16-分组练习",link:"#_1-16-分组练习",children:[]},{level:2,title:"1.17 忽略大小写的写法",slug:"_1-17-忽略大小写的写法",link:"#_1-17-忽略大小写的写法",children:[]},{level:2,title:"1.18 非捕获分组",slug:"_1-18-非捕获分组",link:"#_1-18-非捕获分组",children:[]},{level:2,title:"1.19 正则表达式练习",slug:"_1-19-正则表达式练习",link:"#_1-19-正则表达式练习",children:[]}],path:"/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",pathLocale:"/",extraFields:['java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo1 {\n    public static void main(String[] args) {\n        /* 假如现在要求校验一个qq号码是否正确。\n            规则:6位及20位之内，日不能在开头，必须全部是数字。\n            先使用目前所学知识完成校验需求然后体验一下正则表达式检验。\n        */\n\n        String qq ="1234567890";\n        System.out.println(checkQQ(qq));\n\n        System.out.println(qq.matches("[1-9]\\\\d{5,19}"));\n\n    }\n\n    public static boolean checkQQ(String qq) {\n        //规则:6位及20位之内，日不能在开头，必须全部是数字 。\n        //核心思想:\n        //先把异常数据进行过滤\n        //下面的就是满足要求的数据了。\n        int len = qq.length();\n        if (len < 6 || len > 20) {\n            return false;\n        }\n        //0不能在开头\n        if (qq.startsWith("0")) {\n            return false;\n        }\n        //必须全部是数字\n        for (int i = 0; i < qq.length(); i++) {\n            char c = qq.charAt(i);\n            if (c < \'0\' | c > \'9\') {\n                return false;\n            }\n        }\n        return true;\n    }\n}','java\npublic class Demo {\n    public static void main(String[] args) {\n        String qq ="1234567890";\n        System.out.println(qq.matches("[1-9]\\\\d{5,19}"));\n    }\n}','java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo2 {\n    public static void main(String[] args) {\n        //public boolean matches(String regex):判断是否与正则表达式匹配，匹配返回true\n        // 只能是a b c\n        System.out.println("-----------1-------------");\n        System.out.println("a".matches("[abc]")); // true\n        System.out.println("z".matches("[abc]")); // false\n\n        // 不能出现a b c\n        System.out.println("-----------2-------------");\n        System.out.println("a".matches("[^abc]")); // false\n        System.out.println("z".matches("[^abc]")); // true\n        System.out.println("zz".matches("[^abc]")); //false\n        System.out.println("zz".matches("[^abc][^abc]")); //true\n\n        // a到zA到Z(包括头尾的范围)\n        System.out.println("-----------3-------------");\n        System.out.println("a".matches("[a-zA-z]")); // true\n        System.out.println("z".matches("[a-zA-z]")); // true\n        System.out.println("aa".matches("[a-zA-z]"));//false\n        System.out.println("zz".matches("[a-zA-Z]")); //false\n        System.out.println("zz".matches("[a-zA-Z][a-zA-Z]")); //true\n        System.out.println("0".matches("[a-zA-Z]"));//false\n        System.out.println("0".matches("[a-zA-Z0-9]"));//true\n\n\n        // [a-d[m-p]] a到d，或m到p\n        System.out.println("-----------4-------------");\n        System.out.println("a".matches("[a-d[m-p]]"));//true\n        System.out.println("d".matches("[a-d[m-p]]")); //true\n        System.out.println("m".matches("[a-d[m-p]]")); //true\n        System.out.println("p".matches("[a-d[m-p]]")); //true\n        System.out.println("e".matches("[a-d[m-p]]")); //false\n        System.out.println("0".matches("[a-d[m-p]]")); //false\n\n        // [a-z&&[def]] a-z和def的交集。为:d，e，f\n        System.out.println("----------5------------");\n        System.out.println("a".matches("[a-z&[def]]")); //false\n        System.out.println("d".matches("[a-z&&[def]]")); //true\n        System.out.println("0".matches("[a-z&&[def]]")); //false\n\n        // [a-z&&[^bc]] a-z和非bc的交集。(等同于[ad-z])\n        System.out.println("-----------6------------_");\n        System.out.println("a".matches("[a-z&&[^bc]]"));//true\n        System.out.println("b".matches("[a-z&&[^bc]]")); //false\n        System.out.println("0".matches("[a-z&&[^bc]]")); //false\n\n        // [a-z&&[^m-p]] a到z和除了m到p的交集。(等同于[a-1q-z])\n        System.out.println("-----------7-------------");\n        System.out.println("a".matches("[a-z&&[^m-p]]")); //true\n        System.out.println("m".matches("[a-z&&[^m-p]]")); //false\n        System.out.println("0".matches("[a-z&&[^m-p]]")); //false\n\n    }\n}','java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\tString str = "had";\n\t\t\n\t\t//1.要求字符串是小写辅音字符开头，后跟ad\n\t\tString regex = "[a-z&&[^aeiou]]ad";\n\t\tSystem.out.println("1." + str.matches(regex));\n\t\t\n\t\t//2.要求字符串是aeiou中的某个字符开头，后跟ad\n\t\tregex = "[a|e|i|o|u]ad";//这种写法相当于：regex = "[aeiou]ad";\n\t\tSystem.out.println("2." + str.matches(regex));\n\t}\n}','java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo3 {\n    public static void main(String[] args) {\n        // \\ 转义字符 改变后面那个字符原本的含义\n        //练习:以字符串的形式打印一个双引号\n        //"在Java中表示字符串的开头或者结尾\n\n        //此时\\表示转义字符，改变了后面那个双引号原本的含义\n        //把他变成了一个普普通通的双引号而已。\n        System.out.println("\\"");\n\n        // \\表示转义字符\n        //两个\\的理解方式：前面的\\是一个转义字符，改变了后面\\原本的含义，把他变成一个普普通通的\\而已。\n        System.out.println("c:Users\\\\moon\\\\IdeaProjects\\\\basic-code\\\\myapi\\\\src\\\\com\\\\itheima\\\\a08regexdemo\\\\RegexDemo1.java");\n\n\n\n\n    }\n}','java\npublic class Demo {\n\tpublic static void main(String[] args) {\n        //.表示任意一个字符\n        System.out.println("你".matches("..")); //false\n        System.out.println("你".matches(".")); //true\n        System.out.println("你a".matches(".."));//true\n\n        // \\\\d 表示任意的一个数字\n        // \\\\d只能是任意的一位数字\n        // 简单来记:两个\\表示一个\\\n        System.out.println("a".matches("\\\\d")); // false\n        System.out.println("3".matches("\\\\d")); // true\n        System.out.println("333".matches("\\\\d")); // false\n\n        //\\\\w只能是一位单词字符[a-zA-Z_0-9]\n        System.out.println("z".matches("\\\\w")); // true\n        System.out.println("2".matches("\\\\w")); // true\n        System.out.println("21".matches("\\\\w")); // false\n        System.out.println("你".matches("\\\\w"));//false\n\n        // 非单词字符\n        System.out.println("你".matches("\\\\W")); // true\n        System.out.println("---------------------------------------------");\n        // 以上正则匹配只能校验单个字符。\n\n\n        // 必须是数字 字母 下划线 至少 6位\n        System.out.println("2442fsfsf".matches("\\\\w{6,}"));//true\n        System.out.println("244f".matches("\\\\w{6,}"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println("23dF".matches("[a-zA-Z0-9]{4}"));//true\n        System.out.println("23 F".matches("[a-zA-Z0-9]{4}"));//false\n        System.out.println("23dF".matches("[\\\\w&&[^_]]{4}"));//true\n        System.out.println("23_F".matches("[\\\\w&&[^_]]{4}"));//false\n\t\t\n\t}\n}','java\npublic class Demo {\n\tpublic static void main(String[] args) {\n\t\t // 必须是数字 字母 下划线 至少 6位\n        System.out.println("2442fsfsf".matches("\\\\w{6,}"));//true\n        System.out.println("244f".matches("\\\\w{6,}"));//false\n\n        // 必须是数字和字符 必须是4位\n        System.out.println("23dF".matches("[a-zA-Z0-9]{4}"));//true\n        System.out.println("23 F".matches("[a-zA-Z0-9]{4}"));//false\n        System.out.println("23dF".matches("[\\\\w&&[^_]]{4}"));//true\n        System.out.println("23_F".matches("[\\\\w&&[^_]]{4}"));//false\n\t}\n}','java\npackage com.itheima.a08regexdemo;\n\npublic class RegexDemo4 {\n    public static void main(String[] args) {\n        /*\n            需求\n            请编写正则表达式验证用户输入的手机号码是否满足要求。请编写正则表达式验证用户输入的邮箱号是否满足要求。请编写正则表达式验证用户输入的电话号码是否满足要求。\n            验证手机号码 13112345678 13712345667 13945679027 139456790271\n            验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434\n            验证邮箱号码 3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        */\n\n        //心得:\n        //拿着一个正确的数据，从左到右依次去写。\n        //13112345678\n        //分成三部分:\n        //第一部分:1 表示手机号码只能以1开头\n        //第二部分:[3-9] 表示手机号码第二位只能是3-9之间的\n        //第三部分:\\\\d{9} 表示任意数字可以出现9次，也只能出现9次\n        String regex1 = "1[3-9]\\\\d{9}";\n        System.out.println("13112345678".matches(regex1));//true\n        System.out.println("13712345667".matches(regex1));//true\n        System.out.println("13945679027".matches(regex1));//true\n        System.out.println("139456790271".matches(regex1));//false\n        System.out.println("-----------------------------------");\n\n        //座机电话号码\n        //020-2324242 02122442 027-42424 0712-3242434\n        //思路:\n        //在书写座机号正则的时候需要把正确的数据分为三部分\n        //一:区号@\\\\d{2,3}\n        //      0:表示区号一定是以0开头的\n        //      \\\\d{2,3}:表示区号从第二位开始可以是任意的数字，可以出现2到3次。\n        //二:- ?表示次数，日次或一次\n        //三:号码 号码的第一位也不能以日开头，从第二位开始可以是任意的数字，号码的总长度:5-10位\n        String regex2 = "0\\\\d{2,3}-?[1-9]\\\\d{4,9}";\n        System.out.println("020-2324242".matches(regex2));\n        System.out.println("02122442".matches(regex2));\n        System.out.println("027-42424".matches(regex2));\n        System.out.println("0712-3242434".matches(regex2));\n\n        //邮箱号码\n        //3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn\n        //思路:\n        //在书写邮箱号码正则的时候需要把正确的数据分为三部分\n        //第一部分:@的左边 \\\\w+\n        //      任意的字母数字下划线，至少出现一次就可以了\n        //第二部分:@ 只能出现一次\n        //第三部分:\n        //      3.1         .的左边[\\\\w&&[^_]]{2,6}\n        //                  任意的字母加数字，总共出现2-6次(此时不能出现下划线)\n        //      3.2         . \\\\.\n        //      3.3         大写字母，小写字母都可以，只能出现2-3次[a-zA-Z]{2,3}\n        //      我们可以把3.2和3.3看成一组，这一组可以出现1次或者两次\n        String regex3 = "\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}";\n        System.out.println("3232323@qq.com".matches(regex3));\n        System.out.println("zhangsan@itcast.cnn".matches(regex3));\n        System.out.println("dlei0009@163.com".matches(regex3));\n        System.out.println("dlei0009@pci.com.cn".matches(regex3));\n\n\n        //24小时的正则表达式\n        String regex4 = "([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d";\n        System.out.println("23:11:11".matches(regex4));\n\n        String regex5 = "([01]\\\\d 2[0-3])(:[0-5]\\\\d){2}";\n        System.out.println("23:11:11".matches(regex5));\n    }\n}','java\npublic class RegexDemo5 {\n    public static void main(String[] args) {\n        /*\n            正则表达式练习:\n            需求\n            请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位\n            请编写正则表达式验证身份证号码是否满足要求。\n            简单要求:\n                18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n            复杂要求:\n                按照身份证号码的格式严格要求。\n\n            身份证号码:\n            41080119930228457x\n            510801197609022309\n            15040119810705387X\n            130133197204039024 I\n            430102197606046442\n        */\n\n        //用户名要求:大小写字母，数字，下划线一共4-16位\n        String regex1 = "\\\\w{4,16}";\n        System.out.println("zhangsan".matches(regex1));\n        System.out.println("lisi".matches(regex1));\n        System.out.println("wangwu".matches(regex1));\n        System.out.println("$123".matches(regex1));\n\n\n        //身份证号码的简单校验:\n        //18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x\n        String regex2 = "[1-9]\\\\d{16}(\\\\d|x|x)";\n        String regex3 = "[1-9]\\\\d{16}[\\\\dXx]";\n        String regex5 = "[1-9]\\\\d{16}(\\\\d(?i)x)";\n\n        System.out.println("41080119930228457x".matches(regex3));\n        System.out.println("510801197609022309".matches(regex3));\n        System.out.println("15040119810705387X".matches(regex3));\n        System.out.println("130133197204039024".matches(regex3));\n        System.out.println("430102197606046442".matches(regex3));\n\n\n        //忽略大小写的书写方式\n        //在匹配的时候忽略abc的大小写\n        String regex4 = "a((?i)b)c";\n        System.out.println("------------------------------");\n        System.out.println("abc".matches(regex4));//true\n        System.out.println("ABC".matches(regex4));//false\n        System.out.println("aBc".matches(regex4));//true\n\n\n        //身份证号码的严格校验\n        //编写正则的小心得:\n        //第一步:按照正确的数据进行拆分\n        //第二步:找每一部分的规律，并编写正则表达式\n        //第三步:把每一部分的正则拼接在一起，就是最终的结果\n        //书写的时候:从左到右去书写。\n\n        //410801 1993 02 28 457x\n        //前面6位:省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字       [1-9]\\\\d{5}\n        //年的前半段: 18 19 20                                                (18|19|20)\n        //年的后半段: 任意数字出现两次                                           \\\\d{2}\n        //月份: 01~ 09 10 11 12                                               (@[1-9]|1[0-2])\n        //日期: 01~09 10~19 20~29 30 31                                       (0[1-9]|[12]\\\\d|3[01])\n        //后面四位: 任意数字出现3次 最后一位可以是数字也可以是大写x或者小写x        \\\\d{3}[\\\\dXx]\n        String regex6 = "[1-9]\\\\d{5}(18|19|20)\\\\d{2}(@[1-9]|1[0-2])(@[1-9]|[12]\\\\d|3[01])\\\\d{3}[\\\\dxXx]";\n\n        System.out.println("41080119930228457x".matches(regex6));\n        System.out.println("510801197609022309".matches(regex6));\n        System.out.println("15040119810705387X".matches(regex6));\n        System.out.println("130133197204039024".matches(regex6));\n        System.out.println("430102197606046442".matches(regex6));\n\n\n    }\n}','java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo6 {\n    public static void main(String[] args) {\n        /* 有如下文本，请按照要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n                要求:找出里面所有的JavaXX\n         */\n\n        String str = "Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，" +\n                "因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile("Java\\\\d{0,2}");\n        //2.获取文本匹配器的对象\n        //拿着m去读取str，找符合p规则的子串\n        Matcher m = p.matcher(str);\n\n        //3.利用循环获取\n        while (m.find()) {\n            String s = m.group();\n            System.out.println(s);\n        }\n\n\n    }\n\n    private static void method1(String str) {\n        //Pattern:表示正则表达式\n        //Matcher: 文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\n        //          在大串中去找符合匹配规则的子串。\n\n        //获取正则表达式的对象\n        Pattern p = Pattern.compile("Java\\\\d{0,2}");\n        //获取文本匹配器的对象\n        //m:文本匹配器的对象\n        //str:大串\n        //p:规则\n        //m要在str中找符合p规则的小串\n        Matcher m = p.matcher(str);\n\n        //拿着文本匹配器从头开始读取，寻找是否有满足规则的子串\n        //如果没有，方法返回false\n        //如果有，返回true。在底层记录子串的起始索引和结束索引+1\n        // 0,4\n        boolean b = m.find();\n\n        //方法底层会根据find方法记录的索引进行字符串的截取\n        // substring(起始索引，结束索引);包头不包尾\n        // (0,4)但是不包含4索引\n        // 会把截取的小串进行返回。\n        String s1 = m.group();\n        System.out.println(s1);\n\n\n        //第二次在调用find的时候，会继续读取后面的内容\n        //读取到第二个满足要求的子串，方法会继续返回true\n        //并把第二个子串的起始索引和结束索引+1，进行记录\n        b = m.find();\n\n        //第二次调用group方法的时候，会根据find方法记录的索引再次截取子串\n        String s2 = m.group();\n        System.out.println(s2);\n    }\n}','java\npublic class RegexDemo7 {\n    public static void main(String[] args) throws IOException {\n        /* 扩展需求2:\n            把连接:https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i\n            中所有的身份证号码都爬取出来。\n        */\n\n        //创建一个URL对象\n        URL url = new URL("https://m.sengzan.com/jiaoyu/29104.html?ivk sa=1025883i");\n        //连接上这个网址\n        //细节:保证网络是畅通\n        URLConnection conn = url.openConnection();//创建一个对象去读取网络中的数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String line;\n        //获取正则表达式的对象pattern\n        String regex = "[1-9]\\\\d{17}";\n        Pattern pattern = Pattern.compile(regex);//在读取的时候每次读一整行\n        while ((line = br.readLine()) != null) {\n            //拿着文本匹配器的对象matcher按照pattern的规则去读取当前的这一行信息\n            Matcher matcher = pattern.matcher(line);\n            while (matcher.find()) {\n                System.out.println(matcher.group());\n            }\n        }\n        br.close();\n    }\n}','java\npackage com.itheima.a08regexdemo;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexDemo8 {\n    public static void main(String[] args) {\n        /*\n            需求:把下面文本中的座机电话，邮箱，手机号，热线都爬取出来。\n            来黑马程序员学习Java，\n            手机号:18512516758，18512508907或者联系邮箱:boniu@itcast.cn，\n            座机电话:01036517895，010-98951256邮箱:bozai@itcast.cn，\n            热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090\n\n            手机号的正则表达式:1[3-9]\\d{9}\n            邮箱的正则表达式:\\w+@[\\w&&[^_]]{2,6}(\\.[a-zA-Z]{2,3}){1,2}座机电话的正则表达式:θ\\d{2,3}-?[1-9]\\d{4,9}\n            热线电话的正则表达式:400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3}\n\n        */\n\n        String s = "来黑马程序员学习Java，" +\n                "电话:18512516758，18512508907" + "或者联系邮箱:boniu@itcast.cn，" +\n                "座机电话:01036517895，010-98951256" + "邮箱:bozai@itcast.cn，" +\n                "热线电话:400-618-9090 ，400-618-4000，4006184000，4006189090";\n\n        System.out.println("400-618-9090");\n\n        String regex = "(1[3-9]\\\\d{9})|(\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2})" +\n                "|(0\\\\d{2,3}-?[1-9]\\\\d{4,9})" +\n                "(400-?[1-9]\\\\d{2}-?[1-9]\\\\d{3})";\n\n        //1.获取正则表达式的对象\n        Pattern p = Pattern.compile(regex);\n\n        //2.获取文本匹配器的对象\n        //利用m去读取s，会按照p的规则找里面的小串\n        Matcher m = p.matcher(s);\n        //3.利用循环获取每一个数据 while(m.find()){\n        String str = m.group();\n        System.out.println(str);\n\n    }\n}','java\npublic class RegexDemo9 {\n    public static void main(String[] args) {\n        /*\n            有如下文本，按要求爬取数据。\n                Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\n                因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\n\n\n            需求1:爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。\n            需求2:爬取版本号为8，11，17的Java文本。正确爬取结果为:Java8 Java11 Java17 Java17\n            需求3:爬取除了版本号为8，11.17的Java文本，\n        */\n        String s = "Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，" +\n            "因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n        //1.定义正则表达式\n        //?理解为前面的数据Java\n        //=表示在Java后面要跟随的数据\n        //但是在获取的时候，只获取前半部分\n        //需求1:\n        String regex1 = "((?i)Java)(?=8|11|17)";\n        //需求2:\n        String regex2 = "((?i)Java)(8|11|17)";\n        String regex3 = "((?i)Java)(?:8|11|17)";\n        //需求3:\n        String regex4 = "((?i)Java)(?!8|11|17)";\n\n        Pattern p = Pattern.compile(regex4);\n        Matcher m = p.matcher(s);\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n    }\n}',"java\n只写+和表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取\n+? 非贪婪匹配\n*? 非贪婪匹配\n贪婪爬取:在爬取数据的时候尽可能的多获取数据\n非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n举例：\n如果获取数据：ab+\n贪婪爬取获取结果:abbbbbbbbbbbb\n非贪婪爬取获取结果:ab",'java\npublic class RegexDemo10 {\n    public static void main(String[] args) {\n        /*\n            只写+和*表示贪婪匹配\n\n            +? 非贪婪匹配\n            *? 非贪婪匹配\n\n            贪婪爬取:在爬取数据的时候尽可能的多获取数据\n            非贪婪爬取:在爬取数据的时候尽可能的少获取数据\n\n            ab+:\n            贪婪爬取:abbbbbbbbbbbb\n            非贪婪爬取:ab\n        */\n        String s = "Java自从95年问世以来，abbbbbbbbbbbbaaaaaaaaaaaaaaaaaa" +\n                "经历了很多版木，目前企业中用的最多的是]ava8和]ava11，因为这两个是长期支持版木。" +\n                "下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台";\n\n        String regex = "ab+";\n        Pattern p = Pattern.compile(regex);\n        Matcher m = p.matcher(s);\n\n        while (m.find()) {\n            System.out.println(m.group());\n        }\n\n\n    }\n}','java\n  public String[] split(String regex)\n  //参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为"分隔符"来切割字符串。','java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = "小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就切割。\nString[] arr = s.split("[\\\\w&&[^_]]+");\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(arr[i]);\n}',"java\npublic String replaceAll(String regex,String newStr)\n//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。",'java\n/*\n            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠\n            要求1:把字符串中三个姓名之间的字母替换为vs\n            要求2:把字符串中的三个姓名切割出来*/\n\nString s = "小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠";\n//细节:\n//方法在底层跟之前一样也会创建文本解析器的对象\n//然后从头开始去读取字符串中的内容，只要有满足的，那么就用第一个参数去替换。\nString result1 = s.replaceAll("[\\\\w&&[^_]]+", "vs");\nSystem.out.println(result1);','java\n//需求1:判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符\n//举例: a123a b456b 17891 &abc& a123b(false)\n// \\\\组号:表示把第X组的内容再出来用一次\nString regex1 = "(.).+\\\\1";\nSystem.out.println("a123a".matches(regex1));\nSystem.out.println("b456b".matches(regex1));\nSystem.out.println("17891".matches(regex1));\nSystem.out.println("&abc&".matches(regex1));\nSystem.out.println("a123b".matches(regex1));\nSystem.out.println("--------------------------");\n\n\n//需求2:判断一个字符串的开始部分和结束部分是否一致?可以有多个字符\n//举例: abc123abc b456b 123789123 &!@abc&!@ abc123abd(false)\nString regex2 = "(.+).+\\\\1";\nSystem.out.println("abc123abc".matches(regex2));\nSystem.out.println("b456b".matches(regex2));\nSystem.out.println("123789123".matches(regex2));\nSystem.out.println("&!@abc&!@".matches(regex2));\nSystem.out.println("abc123abd".matches(regex2));\nSystem.out.println("---------------------");\n\n//需求3:判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致\n//举例: aaa123aaa bbb456bbb 111789111 &&abc&&\n//(.):把首字母看做一组\n// \\\\2:把首字母拿出来再次使用\n// *:作用于\\\\2,表示后面重复的内容出现日次或多次\nString regex3 = "((.)\\\\2*).+\\\\1";\nSystem.out.println("aaa123aaa".matches(regex3));\nSystem.out.println("bbb456bbb".matches(regex3));\nSystem.out.println("111789111".matches(regex3));\nSystem.out.println("&&abc&&".matches(regex3));\nSystem.out.println("aaa123aab".matches(regex3));','java\nString str = "我要学学编编编编程程程程程程";\n\n//需求:把重复的内容 替换为 单个的\n//学学                学\n//编编编编            编\n//程程程程程程        程\n//  (.)表示把重复内容的第一个字符看做一组\n//  \\\\1表示第一字符再次出现\n//  + 至少一次\n//  $1 表示把正则表达式中第一组的内容，再拿出来用\nString result = str.replaceAll("(.)\\\\1+", "$1");\nSystem.out.println(result);','java\n//(?i) ：表示忽略后面数据的大小写\n//忽略abc的大小写\nString regex = "(?i)abc";\n//a需要一模一样，忽略bc的大小写\nString regex = "a(?i)bc";\n//ac需要一模一样，忽略b的大小写\nString regex = "a((?i)b)c";','java\n//身份证号码的简易正则表达式\n//非捕获分组:仅仅是把数据括起来\n//特点:不占用组号\n//这里\\\\1报错原因:(?:)就是非捕获分组，此时是不占用组号的。\n\n\n//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个\n//String regex1 ="[1-9]\\\\d{16}(?:\\\\d|x|x)\\\\1";\nString regex2 ="[1-9]\\\\d{16}(\\\\d Xx)\\\\1";\n//^([01]\\d|2[0-3]):[0-5]\\d:[@-5]\\d$\n\nSystem.out.println("41080119930228457x".matches(regex2));',"java\n手机号码:1[3-9]\\\\d{9}\n座机号码：0\\\\d{2,3}-?[1-9]\\\\d{4,9}\n邮箱号码：\\\\w+@[\\\\w&&[^_]]{2,6}(\\\\.[a-zA-Z]{2,3}){1,2}\n24小时：([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\n\t   ([01]\\\\d|2[0-3])(:[0-5]\\\\d){2}\n用户名:\t\\\\w{4,16}\n身份证号码，简单校验：\n\t\t[1-9]\\\\d{16}(\\\\d|X|x)\n\t\t[1-9]\\\\d{16}[\\\\dXx]\n\t\t[1-9]\\\\d{16}(\\\\d(?i)X)\n身份证号码，严格校验：\n\t\t[1-9]\\\\d{5}(18|19|20)\\\\d{2}(0[1-9]|1[0-2])(0[1-9|[12])\\\\d|3[01])\\\\d{3}[\\\\dXx]"]},{title:"常用API",headers:[{level:2,title:"今日内容",slug:"今日内容",link:"#今日内容",children:[]},{level:2,title:"教学目标",slug:"教学目标",link:"#教学目标",children:[]},{level:2,title:"1.1 Date概述",slug:"_1-1-date概述",link:"#_1-1-date概述",children:[]},{level:2,title:"1.2 Date常用方法",slug:"_1-2-date常用方法",link:"#_1-2-date常用方法",children:[]},{level:2,title:"2.1 构造方法",slug:"_2-1-构造方法",link:"#_2-1-构造方法",children:[]},{level:2,title:"2.2 格式规则",slug:"_2-2-格式规则",link:"#_2-2-格式规则",children:[]},{level:2,title:"2.3 常用方法",slug:"_2-3-常用方法",link:"#_2-3-常用方法",children:[]},{level:2,title:"2.4 练习1(初恋女友的出生日期)",slug:"_2-4-练习1-初恋女友的出生日期",link:"#_2-4-练习1-初恋女友的出生日期",children:[]},{level:2,title:"2.5 练习2(秒杀活动)",slug:"_2-5-练习2-秒杀活动",link:"#_2-5-练习2-秒杀活动",children:[]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 常用方法",slug:"_3-2-常用方法",link:"#_3-2-常用方法",children:[]},{level:2,title:"3.3 get方法示例",slug:"_3-3-get方法示例",link:"#_3-3-get方法示例",children:[]},{level:2,title:"3.4 set方法示例：",slug:"_3-4-set方法示例",link:"#_3-4-set方法示例",children:[]},{level:2,title:"3.5 add方法示例：",slug:"_3-5-add方法示例",link:"#_3-5-add方法示例",children:[]},{level:2,title:"4.1  ZoneId 时区",slug:"_4-1-zoneid-时区",link:"#_4-1-zoneid-时区",children:[]},{level:2,title:"4.2  Instant 时间戳",slug:"_4-2-instant-时间戳",link:"#_4-2-instant-时间戳",children:[]},{level:2,title:"4.3 ZoneDateTime  带时区的时间",slug:"_4-3-zonedatetime-带时区的时间",link:"#_4-3-zonedatetime-带时区的时间",children:[]},{level:2,title:"4.4DateTimeFormatter   用于时间的格式化和解析",slug:"_4-4datetimeformatter-用于时间的格式化和解析",link:"#_4-4datetimeformatter-用于时间的格式化和解析",children:[]},{level:2,title:"4.5LocalDate  年、月、日",slug:"_4-5localdate-年、月、日",link:"#_4-5localdate-年、月、日",children:[]},{level:2,title:"4.6 LocalTime  时、分、秒",slug:"_4-6-localtime-时、分、秒",link:"#_4-6-localtime-时、分、秒",children:[]},{level:2,title:"4.7 LocalDateTime  年、月、日、时、分、秒",slug:"_4-7-localdatetime-年、月、日、时、分、秒",link:"#_4-7-localdatetime-年、月、日、时、分、秒",children:[]},{level:2,title:"4.8 Duration  时间间隔（秒，纳，秒）",slug:"_4-8-duration-时间间隔-秒-纳-秒",link:"#_4-8-duration-时间间隔-秒-纳-秒",children:[]},{level:2,title:"4.9 Period  时间间隔（年，月，日）",slug:"_4-9-period-时间间隔-年-月-日",link:"#_4-9-period-时间间隔-年-月-日",children:[]},{level:2,title:"4.10 ChronoUnit  时间间隔（所有单位）",slug:"_4-10-chronounit-时间间隔-所有单位",link:"#_4-10-chronounit-时间间隔-所有单位",children:[]},{level:2,title:"5.1 概述",slug:"_5-1-概述",link:"#_5-1-概述",children:[]},{level:2,title:"5.2 Integer类",slug:"_5-2-integer类",link:"#_5-2-integer类",children:[]},{level:2,title:"5.3 装箱与拆箱",slug:"_5-3-装箱与拆箱",link:"#_5-3-装箱与拆箱",children:[]},{level:2,title:"5.4 自动装箱与自动拆箱",slug:"_5-4-自动装箱与自动拆箱",link:"#_5-4-自动装箱与自动拆箱",children:[]},{level:2,title:"5.5 基本类型与字符串之间的转换",slug:"_5-5-基本类型与字符串之间的转换",link:"#_5-5-基本类型与字符串之间的转换",children:[{level:3,title:"基本类型转换为String",slug:"基本类型转换为string",link:"#基本类型转换为string",children:[]},{level:3,title:"String转换成基本类型",slug:"string转换成基本类型",link:"#string转换成基本类型",children:[]}]},{level:2,title:"5.6 底层原理",slug:"_5-6-底层原理",link:"#_5-6-底层原理",children:[]},{level:2,title:"练习一：",slug:"练习一",link:"#练习一",children:[]},{level:2,title:"练习二：",slug:"练习二",link:"#练习二",children:[]},{level:2,title:"练习三：",slug:"练习三",link:"#练习三",children:[]},{level:2,title:"练习四：",slug:"练习四",link:"#练习四",children:[]},{level:2,title:"练习五：",slug:"练习五",link:"#练习五",children:[]}],path:"/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/API.html",pathLocale:"/",extraFields:["java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}",'java\npublic class DateDemo02 {\n    public static void main(String[] args) {\n        //创建日期对象\n        Date d = new Date();\n        \n        //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n        //System.out.println(d.getTime());\n        //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + "年");\n\n        //public void setTime(long time):设置时间，给的是毫秒值\n        //long time = 1000*60*60;\n        long time = System.currentTimeMillis();\n        d.setTime(time);\n\n        System.out.println(d);\n    }\n}','java\n  package com.itheima.a01jdk7datedemo;\n  \n  import java.text.ParseException;\n  import java.text.SimpleDateFormat;\n  import java.util.Date;\n  \n  public class A03_SimpleDateFormatDemo1 {\n      public static void main(String[] args) throws ParseException {\n          /*\n              public simpleDateFormat() 默认格式\n              public simpleDateFormat(String pattern) 指定格式\n              public final string format(Date date) 格式化(日期对象 ->字符串)\n              public Date parse(string source) 解析(字符串 ->日期对象)\n          */\n  \n          //1.定义一个字符串表示时间\n          String str = "2023-11-11 11:11:11";\n          //2.利用空参构造创建simpleDateFormat对象\n          // 细节:\n          //创建对象的格式要跟字符串的格式完全一致\n          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n          Date date = sdf.parse(str);\n          //3.打印结果\n          System.out.println(date.getTime());//1699672271000\n  \n  \n      }\n  \n      private static void method1() {\n          //1.利用空参构造创建simpleDateFormat对象，默认格式\n          SimpleDateFormat sdf1 = new SimpleDateFormat();\n          Date d1 = new Date(0L);\n          String str1 = sdf1.format(d1);\n          System.out.println(str1);//1970/1/1 上午8:00\n  \n          //2.利用带参构造创建simpleDateFormat对象，指定格式\n          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");\n          String str2 = sdf2.format(d1);\n          System.out.println(str2);//1970年01月01日 08:00:00\n  \n          //课堂练习:yyyy年MM月dd日 时:分:秒 星期\n      }\n  }','java\n/*\n     假设，你初恋的出生年月日为:2000-11-11\n     请用字符串表示这个数据，并将其转换为:2000年11月11日\n\n     创建一个Date对象表示2000年11月11日\n     创建一个SimpleDateFormat对象，并定义格式为年月日把时间变成:2000年11月11日\n*/\n\n//1.可以通过2000-11-11进行解析，解析成一个Date对象\nString str = "2000-11-11";\n//2.解析\nSimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");\nDate date = sdf1.parse(str);\n//3.格式化\nSimpleDateFormat sdf2 = new SimpleDateFormat("yyyy年MM月dd日");\nString result = sdf2.format(date);\nSystem.out.println(result);','java\n/* 需求:\n            秒杀活动开始时间:2023年11月11日 0:0:0(毫秒值)\n            秒杀活动结束时间:2023年11月11日 0:10:0(毫秒值)\n\n            小贾下单并付款的时间为:2023年11月11日 0:01:0\n            小皮下单并付款的时间为:2023年11月11日 0:11:0\n            用代码说明这两位同学有没有参加上秒杀活动?\n         */\n\n//1.定义字符串表示三个时间\nString startstr = "2023年11月11日 0:0:0";\nString endstr = "2023年11月11日 0:10:0";\nString orderstr = "2023年11月11日 0:01:00";\n//2.解析上面的三个时间，得到Date对象\nSimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");\nDate startDate = sdf.parse(startstr);\nDate endDate = sdf.parse(endstr);\nDate orderDate = sdf.parse(orderstr);\n\n//3.得到三个时间的毫秒值\nlong startTime = startDate.getTime();\nlong endTime = endDate.getTime();\nlong orderTime = orderDate.getTime();\n\n//4.判断\nif (orderTime >= startTime && orderTime <= endTime) {\n    System.out.println("参加秒杀活动成功");\n} else {\n    System.out.println("参加秒杀活动失败");\n}','java\npublic class Demo {\n    public static void main(String[] args) {\n        //1.获取一个GregorianCalendar对象\n        Calendar instance = Calendar.getInstance();//获取子类对象\n\n        //2.打印子类对象\n        System.out.println(instance);\n\n        //3.获取属性\n        int year = instance.get(Calendar.YEAR);\n        int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11\n        int day = instance.get(Calendar.DAY_OF_MONTH);\n\n        int hour = instance.get(Calendar.HOUR);\n        int minute = instance.get(Calendar.MINUTE);\n        int second = instance.get(Calendar.SECOND);\n\n        int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示："星期日","星期一","星期二",...,"星期六"\n\n        System.out.println(year + "年" + month + "月" + day + "日" + \n                           \thour + ":" + minute + ":" + second);\n        System.out.println(getWeek(week));\n\n    }\n\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}','java\npublic class Demo {\n    public static void main(String[] args) {\n        //设置属性——set(int field,int value):\n\t\tCalendar c1 = Calendar.getInstance();//获取当前日期\n\n\t\t//计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)\n\t\tc1.set(Calendar.YEAR, 1998);\n\t\tc1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值\n\t\tc1.set(Calendar.DAY_OF_MONTH, 18);\n\n\t\tint w = c1.get(Calendar.DAY_OF_WEEK);\n\t\tSystem.out.println("班长出生那天是：" + getWeek(w));\n\n        \n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}','java\npublic class Demo {\n    public static void main(String[] args) {\n        //计算200天以后是哪年哪月哪日，星期几？\n\t\tCalendar c2 = Calendar.getInstance();//获取当前日期\n        c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200\n\n        int y = c2.get(Calendar.YEAR);\n        int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份\n        int d = c2.get(Calendar.DAY_OF_MONTH);\n\n        int wk = c2.get(Calendar.DAY_OF_WEEK);\n        System.out.println("200天后是：" + y + "年" + m + "月" + d + "日" + getWeek(wk));\n\n    }\n    //查表法，查询星期几\n    public static String getWeek(int w) {//w = 1 --- 7\n        //做一个表(数组)\n        String[] weekArray = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};\n        //            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]\n        //查表\n        return weekArray[w - 1];\n    }\n}','java\n/*\n        static Set<string> getAvailableZoneIds() 获取Java中支持的所有时区\n        static ZoneId systemDefault() 获取系统默认时区\n        static Zoneld of(string zoneld) 获取一个指定时区\n        */\n\n//1.获取所有的时区名称\nSet<String> zoneIds = ZoneId.getAvailableZoneIds();\nSystem.out.println(zoneIds.size());//600\nSystem.out.println(zoneIds);// Asia/Shanghai\n\n//2.获取当前系统的默认时区\nZoneId zoneId = ZoneId.systemDefault();\nSystem.out.println(zoneId);//Asia/Shanghai\n\n//3.获取指定的时区\nZoneId zoneId1 = ZoneId.of("Asia/Pontianak");\nSystem.out.println(zoneId1);//Asia/Pontianak','java\n/*\n            static Instant now() 获取当前时间的Instant对象(标准时间)\n            static Instant ofXxxx(long epochMilli) 根据(秒/毫秒/纳秒)获取Instant对象\n            ZonedDateTime atZone(ZoneIdzone) 指定时区\n            boolean isxxx(Instant otherInstant) 判断系列的方法\n            Instant minusXxx(long millisToSubtract) 减少时间系列的方法\n            Instant plusXxx(long millisToSubtract) 增加时间系列的方法\n        */\n//1.获取当前时间的Instant对象(标准时间)\nInstant now = Instant.now();\nSystem.out.println(now);\n\n//2.根据(秒/毫秒/纳秒)获取Instant对象\nInstant instant1 = Instant.ofEpochMilli(0L);\nSystem.out.println(instant1);//1970-01-01T00:00:00z\n\nInstant instant2 = Instant.ofEpochSecond(1L);\nSystem.out.println(instant2);//1970-01-01T00:00:01Z\n\nInstant instant3 = Instant.ofEpochSecond(1L, 1000000000L);\nSystem.out.println(instant3);//1970-01-01T00:00:027\n\n//3. 指定时区\nZonedDateTime time = Instant.now().atZone(ZoneId.of("Asia/Shanghai"));\nSystem.out.println(time);\n\n\n//4.isXxx 判断\nInstant instant4=Instant.ofEpochMilli(0L);\nInstant instant5 =Instant.ofEpochMilli(1000L);\n\n//5.用于时间的判断\n//isBefore:判断调用者代表的时间是否在参数表示时间的前面\nboolean result1=instant4.isBefore(instant5);\nSystem.out.println(result1);//true\n\n//isAfter:判断调用者代表的时间是否在参数表示时间的后面\nboolean result2 = instant4.isAfter(instant5);\nSystem.out.println(result2);//false\n\n//6.Instant minusXxx(long millisToSubtract) 减少时间系列的方法\nInstant instant6 =Instant.ofEpochMilli(3000L);\nSystem.out.println(instant6);//1970-01-01T00:00:03Z\n\nInstant instant7 =instant6.minusSeconds(1);\nSystem.out.println(instant7);//1970-01-01T00:00:02Z','java\n/*\n            static ZonedDateTime now() 获取当前时间的ZonedDateTime对象\n            static ZonedDateTime ofXxxx(。。。) 获取指定时间的ZonedDateTime对象\n            ZonedDateTime withXxx(时间) 修改时间系列的方法\n            ZonedDateTime minusXxx(时间) 减少时间系列的方法\n            ZonedDateTime plusXxx(时间) 增加时间系列的方法\n         */\n//1.获取当前时间对象(带时区)\nZonedDateTime now = ZonedDateTime.now();\nSystem.out.println(now);\n\n//2.获取指定的时间对象(带时区)1/年月日时分秒纳秒方式指定\nZonedDateTime time1 = ZonedDateTime.of(2023, 10, 1,\n                                       11, 12, 12, 0, ZoneId.of("Asia/Shanghai"));\nSystem.out.println(time1);\n\n//通过Instant + 时区的方式指定获取时间对象\nInstant instant = Instant.ofEpochMilli(0L);\nZoneId zoneId = ZoneId.of("Asia/Shanghai");\nZonedDateTime time2 = ZonedDateTime.ofInstant(instant, zoneId);\nSystem.out.println(time2);\n\n\n//3.withXxx 修改时间系列的方法\nZonedDateTime time3 = time2.withYear(2000);\nSystem.out.println(time3);\n\n//4. 减少时间\nZonedDateTime time4 = time3.minusYears(1);\nSystem.out.println(time4);\n\n//5.增加时间\nZonedDateTime time5 = time4.plusYears(1);\nSystem.out.println(time5);','java\n/*\n            static DateTimeFormatter ofPattern(格式) 获取格式对象\n            String format(时间对象) 按照指定方式格式化\n        */\n//获取时间对象\nZonedDateTime time = Instant.now().atZone(ZoneId.of("Asia/Shanghai"));\n\n// 解析/格式化器\nDateTimeFormatter dtf1=DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm;ss EE a");\n// 格式化\nSystem.out.println(dtf1.format(time));','java\n//1.获取当前时间的日历对象(包含 年月日)\nLocalDate nowDate = LocalDate.now();\n//System.out.println("今天的日期:" + nowDate);\n//2.获取指定的时间的日历对象\nLocalDate ldDate = LocalDate.of(2023, 1, 1);\nSystem.out.println("指定日期:" + ldDate);\n\nSystem.out.println("=============================");\n\n//3.get系列方法获取日历中的每一个属性值//获取年\nint year = ldDate.getYear();\nSystem.out.println("year: " + year);\n//获取月//方式一:\nMonth m = ldDate.getMonth();\nSystem.out.println(m);\nSystem.out.println(m.getValue());\n\n//方式二:\nint month = ldDate.getMonthValue();\nSystem.out.println("month: " + month);\n\n\n//获取日\nint day = ldDate.getDayOfMonth();\nSystem.out.println("day:" + day);\n\n//获取一年的第几天\nint dayofYear = ldDate.getDayOfYear();\nSystem.out.println("dayOfYear:" + dayofYear);\n\n//获取星期\nDayOfWeek dayOfWeek = ldDate.getDayOfWeek();\nSystem.out.println(dayOfWeek);\nSystem.out.println(dayOfWeek.getValue());\n\n//is开头的方法表示判断\nSystem.out.println(ldDate.isBefore(ldDate));\nSystem.out.println(ldDate.isAfter(ldDate));\n\n//with开头的方法表示修改，只能修改年月日\nLocalDate withLocalDate = ldDate.withYear(2000);\nSystem.out.println(withLocalDate);\n\n//minus开头的方法表示减少，只能减少年月日\nLocalDate minusLocalDate = ldDate.minusYears(1);\nSystem.out.println(minusLocalDate);\n\n\n//plus开头的方法表示增加，只能增加年月日\nLocalDate plusLocalDate = ldDate.plusDays(1);\nSystem.out.println(plusLocalDate);\n\n//-------------\n// 判断今天是否是你的生日\nLocalDate birDate = LocalDate.of(2000, 1, 1);\nLocalDate nowDate1 = LocalDate.now();\n\nMonthDay birMd = MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());\nMonthDay nowMd = MonthDay.from(nowDate1);\n\nSystem.out.println("今天是你的生日吗? " + birMd.equals(nowMd));//今天是你的生日吗?','java\n// 获取本地时间的日历对象。(包含 时分秒)\nLocalTime nowTime = LocalTime.now();\nSystem.out.println("今天的时间:" + nowTime);\n\nint hour = nowTime.getHour();//时\nSystem.out.println("hour: " + hour);\n\nint minute = nowTime.getMinute();//分\nSystem.out.println("minute: " + minute);\n\nint second = nowTime.getSecond();//秒\nSystem.out.println("second:" + second);\n\nint nano = nowTime.getNano();//纳秒\nSystem.out.println("nano:" + nano);\nSystem.out.println("------------------------------------");\nSystem.out.println(LocalTime.of(8, 20));//时分\nSystem.out.println(LocalTime.of(8, 20, 30));//时分秒\nSystem.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒\nLocalTime mTime = LocalTime.of(8, 20, 30, 150);\n\n//is系列的方法\nSystem.out.println(nowTime.isBefore(mTime));\nSystem.out.println(nowTime.isAfter(mTime));\n\n//with系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.withHour(10));\n\n//plus系列的方法，只能修改时、分、秒\nSystem.out.println(nowTime.plusHours(10));','java\n// 当前时间的的日历对象(包含年月日时分秒)\nLocalDateTime nowDateTime = LocalDateTime.now();\n\nSystem.out.println("今天是:" + nowDateTime);//今天是：\nSystem.out.println(nowDateTime.getYear());//年\nSystem.out.println(nowDateTime.getMonthValue());//月\nSystem.out.println(nowDateTime.getDayOfMonth());//日\nSystem.out.println(nowDateTime.getHour());//时\nSystem.out.println(nowDateTime.getMinute());//分\nSystem.out.println(nowDateTime.getSecond());//秒\nSystem.out.println(nowDateTime.getNano());//纳秒\n// 日:当年的第几天\nSystem.out.println("dayofYear:" + nowDateTime.getDayOfYear());\n//星期\nSystem.out.println(nowDateTime.getDayOfWeek());\nSystem.out.println(nowDateTime.getDayOfWeek().getValue());\n//月份\nSystem.out.println(nowDateTime.getMonth());\nSystem.out.println(nowDateTime.getMonth().getValue());\n\nLocalDate ld = nowDateTime.toLocalDate();\nSystem.out.println(ld);\n\nLocalTime lt = nowDateTime.toLocalTime();\nSystem.out.println(lt.getHour());\nSystem.out.println(lt.getMinute());\nSystem.out.println(lt.getSecond());','java\n// 本地日期时间对象。\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n\n// 出生的日期时间对象\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1, 0, 0, 0);\nSystem.out.println(birthDate);\n\nDuration duration = Duration.between(birthDate, today);//第二个参数减第一个参数\nSystem.out.println("相差的时间间隔对象:" + duration);\n\nSystem.out.println("============================================");\nSystem.out.println(duration.toDays());//两个时间差的天数\nSystem.out.println(duration.toHours());//两个时间差的小时数\nSystem.out.println(duration.toMinutes());//两个时间差的分钟数\nSystem.out.println(duration.toMillis());//两个时间差的毫秒数\nSystem.out.println(duration.toNanos());//两个时间差的纳秒数','java\n// 当前本地 年月日\nLocalDate today = LocalDate.now();\nSystem.out.println(today);\n\n// 生日的 年月日\nLocalDate birthDate = LocalDate.of(2000, 1, 1);\nSystem.out.println(birthDate);\n\nPeriod period = Period.between(birthDate, today);//第二个参数减第一个参数\n\nSystem.out.println("相差的时间间隔对象:" + period);\nSystem.out.println(period.getYears());\nSystem.out.println(period.getMonths());\nSystem.out.println(period.getDays());\n\nSystem.out.println(period.toTotalMonths());','java\n// 当前时间\nLocalDateTime today = LocalDateTime.now();\nSystem.out.println(today);\n// 生日时间\nLocalDateTime birthDate = LocalDateTime.of(2000, 1, 1,0, 0, 0);\nSystem.out.println(birthDate);\n\nSystem.out.println("相差的年数:" + ChronoUnit.YEARS.between(birthDate, today));\nSystem.out.println("相差的月数:" + ChronoUnit.MONTHS.between(birthDate, today));\nSystem.out.println("相差的周数:" + ChronoUnit.WEEKS.between(birthDate, today));\nSystem.out.println("相差的天数:" + ChronoUnit.DAYS.between(birthDate, today));\nSystem.out.println("相差的时数:" + ChronoUnit.HOURS.between(birthDate, today));\nSystem.out.println("相差的分数:" + ChronoUnit.MINUTES.between(birthDate, today));\nSystem.out.println("相差的秒数:" + ChronoUnit.SECONDS.between(birthDate, today));\nSystem.out.println("相差的毫秒数:" + ChronoUnit.MILLIS.between(birthDate, today));\nSystem.out.println("相差的微秒数:" + ChronoUnit.MICROS.between(birthDate, today));\nSystem.out.println("相差的纳秒数:" + ChronoUnit.NANOS.between(birthDate, today));\nSystem.out.println("相差的半天数:" + ChronoUnit.HALF_DAYS.between(birthDate, today));\nSystem.out.println("相差的十年数:" + ChronoUnit.DECADES.between(birthDate, today));\nSystem.out.println("相差的世纪(百年)数:" + ChronoUnit.CENTURIES.between(birthDate, today));\nSystem.out.println("相差的千年数:" + ChronoUnit.MILLENNIA.between(birthDate, today));\nSystem.out.println("相差的纪元数:" + ChronoUnit.ERAS.between(birthDate, today));','java\n//public Integer(int value)：根据 int 值创建 Integer 对象(过时)\nInteger i1 = new Integer(100);\nSystem.out.println(i1);\n\n//public Integer(String s)：根据 String 值创建 Integer 对象(过时)\nInteger i2 = new Integer("100");\n//Integer i2 = new Integer("abc"); //NumberFormatException\nSystem.out.println(i2);\nSystem.out.println("--------");\n\n//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\nInteger i3 = Integer.valueOf(100);\nSystem.out.println(i3);\n\n//public static Integer valueOf(String s)：返回保存指定String值的Integer对象 \nInteger i4 = Integer.valueOf("100");\nSystem.out.println(i4);','java\n/*\n            public static string tobinarystring(int i) 得到二进制\n            public static string tooctalstring(int i) 得到八进制\n            public static string toHexstring(int i) 得到十六进制\n            public static int parseInt(string s) 将字符串类型的整数转成int类型的整数\n */\n\n//1.把整数转成二进制，十六进制\nString str1 = Integer.toBinaryString(100);\nSystem.out.println(str1);//1100100\n\n//2.把整数转成八进制\nString str2 = Integer.toOctalString(100);\nSystem.out.println(str2);//144\n\n//3.把整数转成十六进制\nString str3 = Integer.toHexString(100);\nSystem.out.println(str3);//64\n\n//4.将字符串类型的整数转成int类型的整数\n//强类型语言:每种数据在java中都有各自的数据类型\n//在计算的时候，如果不是同一种数据类型，是无法直接计算的。\nint i = Integer.parseInt("123");\nSystem.out.println(i);\nSystem.out.println(i + 1);//124\n//细节1:\n//在类型转换的时候，括号中的参数只能是数字不能是其他，否则代码会报错\n//细节2:\n//8种包装类当中，除了Character都有对应的parseXxx的方法，进行类型转换\nString str = "true";\nboolean b = Boolean.parseBoolean(str);\nSystem.out.println(b);',"java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法","java\nint num = i.intValue();","java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。",'java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //int --- String\n        int number = 100;\n        //方式1\n        String s1 = number + "";\n        System.out.println(s1);\n        //方式2\n        //public static String valueOf(int i)\n        String s2 = String.valueOf(number);\n        System.out.println(s2);\n        System.out.println("--------");\n    }\n}','java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //String --- int\n        String s = "100";\n        //方式1：String --- Integer --- int\n        Integer i = Integer.valueOf(s);\n        //public int intValue()\n        int x = i.intValue();\n        System.out.println(x);\n        //方式2\n        //public static int parseInt(String s)\n        int y = Integer.parseInt(s);\n        System.out.println(y);\n    }\n}','java\n//1.利用构造方法获取Integer的对象(JDK5以前的方式)\n/*Integer i1 = new Integer(1);\n        Integer i2 = new Integer("1");\n        System.out.println(i1);\n        System.out.println(i2);*/\n\n//2.利用静态方法获取Integer的对象(JDK5以前的方式)\nInteger i3 = Integer.valueOf(123);\nInteger i4 = Integer.valueOf("123");\nInteger i5 = Integer.valueOf("123", 8);\n\nSystem.out.println(i3);\nSystem.out.println(i4);\nSystem.out.println(i5);\n\n//3.这两种方式获取对象的区别(掌握)\n//底层原理：\n//因为在实际开发中，-128~127之间的数据，用的比较多。\n//如果每次使用都是new对象，那么太浪费内存了\n//所以，提前把这个范围之内的每一个数据都创建好对象\n//如果要用到了不会创建新的，而是返回已经创建好的对象。\nInteger i6 = Integer.valueOf(127);\nInteger i7 = Integer.valueOf(127);\nSystem.out.println(i6 == i7);//true\n\nInteger i8 = Integer.valueOf(128);\nInteger i9 = Integer.valueOf(128);\nSystem.out.println(i8 == i9);//false\n\n//因为看到了new关键字，在Java中，每一次new都是创建了一个新的对象\n//所以下面的两个对象都是new出来，地址值不一样。\n/*Integer i10 = new Integer(127);\n        Integer i11 = new Integer(127);\n        System.out.println(i10 == i11);\n\n        Integer i12 = new Integer(128);\n        Integer i13 = new Integer(128);\n        System.out.println(i12 == i13);*/','java\npublic class Test1 {\n    public static void main(String[] args) {\n        /*\n            键盘录入一些1~10日之间的整数，并添加到集合中。直到集合中所有数据和超过200为止。\n        */\n        //1.创建一个集合用来添加整数\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.键盘录入数据添加到集合中\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.println("请输入一个整数");\n            String numStr = sc.nextLine();\n            int num = Integer.parseInt(numStr);//先把异常数据先进行过滤\n            if (num < 1 || num > 100){\n                System.out.println("当前数字不在1~100的范围当中，请重新输入");\n                continue;\n            }\n            //添加到集合中//细节:\n            //num:基本数据类型\n            //集合里面的数据是Integer\n            //在添加数据的时候触发了自动装箱\n            list.add(num);\n            //统计集合中所有的数据和\n            int sum = getSum(list);\n            //对sum进行判断\n            if(sum > 200){\n            System.out.println("集合中所有的数据和已经满足要求");\n            break;\n        }\n    }\n\n}\n\n\n    private static int getSum(ArrayList<Integer> list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            //i :索引\n            //list.get(i);\n            int num = list.get(i);\n            sum = sum + num;//+=\n        }\n        return sum;\n    }\n}','java\npublic class Test2 {\n    public static void main(String[] args) {\n        /*\n            自己实现parseInt方法的效果，将字符串形式的数据转成整数。要求:\n            字符串中只能是数字不能有其他字符最少一位，最多10位日不能开头\n        */\n\n        //1.定义一个字符串\n        String str = "123";\n        //2.校验字符串\n        //习惯:会先把异常数据进行过滤，剩下来就是正常的数据。\n        if (!str.matches("[1-9]\\\\d{0,9}")) {\n            //错误的数据\n            System.out.println("数据格式有误");\n        } else {\n            //正确的数据\n            System.out.println("数据格式正确");\n            //3.定义一个变量表示最终的结果\n            int number = 0;\n            //4.遍历字符串得到里面的每一个字符\n            for (int i = 0; i < str.length(); i++) {\n                int c = str.charAt(i) - \'0\';//把每一位数字放到number当中\n                number = number * 10 + c;\n            }\n            System.out.println(number);\n            System.out.println(number + 1);\n        }\n    }\n}',"java\npackage com.itheima.a04test;\n\npublic class Test3 {\n    public static void main(String[] args) {\n        /*\n\n            定义一个方法自己实现toBinaryString方法的效果，将一个十进制整数转成字符串表示的二进制\n\n         */\n    }\n\n\n    public static String tobinarystring(int number) {//6\n        //核心逻辑:\n        //不断的去除以2，得到余数，一直到商为日就结束。\n        //还需要把余数倒着拼接起来\n\n        //定义一个StringBuilder用来拼接余数\n        StringBuilder sb = new StringBuilder();\n        //利用循环不断的除以2获取余数\n        while (true) {\n            if (number == 0) {\n                break;\n            }\n            //获取余数 %\n            int remaindar = number % 2;//倒着拼接\n            sb.insert(0, remaindar);\n            //除以2 /\n            number = number / 2;\n        }\n        return sb.toString();\n    }\n}",'java\npublic class Test4 {\n    public static void main(String[] args) throws ParseException {\n        //请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成\n        //JDK7\n        //规则:只要对时间进行计算或者判断，都需要先获取当前时间的毫秒值\n        //1.计算出生年月日的毫秒值\n        String birthday = "2000年1月1日";\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");\n        Date date = sdf.parse(birthday);\n        long birthdayTime = date.getTime();\n        //2.获取当前时间的毫秒值\n        long todayTime = System.currentTimeMillis();\n        //3.计算间隔多少天\n        long time = todayTime - birthdayTime;\n        System.out.println(time / 1000 / 60 / 60 / 24);\n\n\n        //JDK8\n        LocalDate ld1 = LocalDate.of(2000, 1, 1);\n        LocalDate ld2 = LocalDate.now();\n        long days = ChronoUnit.DAYS.between(ld1, ld2);\n        System.out.println(days);\n    }\n}',"java\npublic class Test5 {\n    public static void main(String[] args) {\n        /*\n            判断任意的一个年份是闰年还是平年要求:用JDK7和JDK8两种方式判断提示:\n            二月有29天是闰年一年有366天是闰年\n        */\n\n        //jdk7\n        //我们可以把时间设置为2000年3月1日\n        Calendar c = Calendar.getInstance();\n        c.set(2000, 2, 1);\n        //月份的范围:0~11\n        //再把日历往前减一天\n        c.add(Calendar.DAY_OF_MONTH, -1);\n        //看当前的时间是28号还是29号?\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        System.out.println(day);\n\n\n        //jdk8\n        //月份的范围:1~12\n        //设定时间为2000年的3月1日\n        LocalDate ld = LocalDate.of(2001, 3, 1);\n        //把时间往前减一天\n        LocalDate ld2 = ld.minusDays(1);\n        //获取这一天是一个月中的几号\n        int day2 = ld2.getDayOfMonth();\n        System.out.println(day2);\n\n        //true:闰年\n        //false:平年\n        System.out.println(ld.isLeapYear());\n    }\n}"]},{title:"常见的七种查找算法",headers:[{level:2,title:"1. 基本查找",slug:"_1-基本查找",link:"#_1-基本查找",children:[]},{level:2,title:"2. 二分查找",slug:"_2-二分查找",link:"#_2-二分查找",children:[]},{level:2,title:"3. 插值查找",slug:"_3-插值查找",link:"#_3-插值查找",children:[]},{level:2,title:"4. 斐波那契查找",slug:"_4-斐波那契查找",link:"#_4-斐波那契查找",children:[]},{level:2,title:"5. 分块查找",slug:"_5-分块查找",link:"#_5-分块查找",children:[]},{level:2,title:"6. 哈希查找",slug:"_6-哈希查找",link:"#_6-哈希查找",children:[]},{level:2,title:"7. 树表查找",slug:"_7-树表查找",link:"#_7-树表查找",children:[]},{level:2,title:"1. 冒泡排序",slug:"_1-冒泡排序",link:"#_1-冒泡排序",children:[{level:3,title:"1.1 算法步骤",slug:"_1-1-算法步骤",link:"#_1-1-算法步骤",children:[]},{level:3,title:"1.2 动图演示",slug:"_1-2-动图演示",link:"#_1-2-动图演示",children:[]},{level:3,title:"1.3 代码示例",slug:"_1-3-代码示例",link:"#_1-3-代码示例",children:[]}]},{level:2,title:"2. 选择排序",slug:"_2-选择排序",link:"#_2-选择排序",children:[{level:3,title:"2.1 算法步骤",slug:"_2-1-算法步骤",link:"#_2-1-算法步骤",children:[]},{level:3,title:"2.2 动图演示",slug:"_2-2-动图演示",link:"#_2-2-动图演示",children:[]}]},{level:2,title:"3. 插入排序",slug:"_3-插入排序",link:"#_3-插入排序",children:[{level:3,title:"3.1 算法步骤",slug:"_3-1-算法步骤",link:"#_3-1-算法步骤",children:[]},{level:3,title:"3.2 动图演示",slug:"_3-2-动图演示",link:"#_3-2-动图演示",children:[]}]},{level:2,title:"4. 快速排序",slug:"_4-快速排序",link:"#_4-快速排序",children:[{level:3,title:"4.1 算法步骤",slug:"_4-1-算法步骤",link:"#_4-1-算法步骤",children:[]},{level:3,title:"4.2 动图演示",slug:"_4-2-动图演示",link:"#_4-2-动图演示",children:[]}]}],path:"/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/%E7%AE%97%E6%B3%95.html",pathLocale:"/",extraFields:["java\npublic class A01_BasicSearchDemo1 {\n    public static void main(String[] args) {\n        //基本查找/顺序查找\n        //核心：\n        //从0索引开始挨个往后查找\n\n        //需求：定义一个方法利用基本查找，查询某个元素是否存在\n        //数据如下：{131, 127, 147, 81, 103, 23, 7, 79}\n\n\n        int[] arr = {131, 127, 147, 81, 103, 23, 7, 79};\n        int number = 82;\n        System.out.println(basicSearch(arr, number));\n\n    }\n\n    //参数：\n    //一：数组\n    //二：要查找的元素\n\n    //返回值：\n    //元素是否存在\n    public static boolean basicSearch(int[] arr, int number){\n        //利用基本查找来查找number在数组中是否存在\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] == number){\n                return true;\n            }\n        }\n        return false;\n    }\n}","java\npackage com.itheima.search;\n\npublic class A02_BinarySearchDemo1 {\n    public static void main(String[] args) {\n        //二分查找/折半查找\n        //核心：\n        //每次排除一半的查找范围\n\n        //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引\n        //数据如下：{7, 23, 79, 81, 103, 127, 131, 147}\n\n        int[] arr = {7, 23, 79, 81, 103, 127, 131, 147};\n        System.out.println(binarySearch(arr, 150));\n    }\n\n    public static int binarySearch(int[] arr, int number){\n        //1.定义两个变量记录要查找的范围\n        int min = 0;\n        int max = arr.length - 1;\n\n        //2.利用循环不断的去找要查找的数据\n        while(true){\n            if(min > max){\n                return -1;\n            }\n            //3.找到min和max的中间位置\n            int mid = (min + max) / 2;\n            //4.拿着mid指向的元素跟要查找的元素进行比较\n            if(arr[mid] > number){\n                //4.1 number在mid的左边\n                //min不变，max = mid - 1；\n                max = mid - 1;\n            }else if(arr[mid] < number){\n                //4.2 number在mid的右边\n                //max不变，min = mid + 1;\n                min = mid + 1;\n            }else{\n                //4.3 number跟mid指向的元素一样\n                //找到了\n                return mid;\n            }\n\n        }\n    }\n}","java\npublic class FeiBoSearchDemo {\n    public static int maxSize = 20;\n\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 10, 89, 1000, 1234};\n        System.out.println(search(arr, 1234));\n    }\n\n    public static int[] getFeiBo() {\n        int[] arr = new int[maxSize];\n        arr[0] = 1;\n        arr[1] = 1;\n        for (int i = 2; i < maxSize; i++) {\n            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        return arr;\n    }\n\n    public static int search(int[] arr, int key) {\n        int low = 0;\n        int high = arr.length - 1;\n        //表示斐波那契数分割数的下标值\n        int index = 0;\n        int mid = 0;\n        //调用斐波那契数列\n        int[] f = getFeiBo();\n        //获取斐波那契分割数值的下标\n        while (high > (f[index] - 1)) {\n            index++;\n        }\n        //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐\n        int[] temp = Arrays.copyOf(arr, f[index]);\n        //实际需要使用arr数组的最后一个数来填充不足的部分\n        for (int i = high + 1; i < temp.length; i++) {\n            temp[i] = arr[high];\n        }\n        //使用while循环处理，找到key值\n        while (low <= high) {\n            mid = low + f[index - 1] - 1;\n            if (key < temp[mid]) {//向数组的前面部分进行查找\n                high = mid - 1;\n                /*\n                  对k--进行理解\n                  1.全部元素=前面的元素+后面的元素\n                  2.f[k]=k[k-1]+f[k-2]\n                  因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3]\n                  即在f[k-1]的前面继续查找k--\n                  即下次循环,mid=f[k-1-1]-1\n                 */\n                index--;\n            } else if (key > temp[mid]) {//向数组的后面的部分进行查找\n                low = mid + 1;\n                index -= 2;\n            } else {//找到了\n                //需要确定返回的是哪个下标\n                if (mid <= high) {\n                    return mid;\n                } else {\n                    return high;\n                }\n            }\n        }\n        return -1;\n    }\n}",'java\npackage com.itheima.search;\n\npublic class A03_BlockSearchDemo {\n    public static void main(String[] args) {\n        /*\n            分块查找\n            核心思想：\n                块内无序，块间有序\n            实现步骤：\n                1.创建数组blockArr存放每一个块对象的信息\n                2.先查找blockArr确定要查找的数据属于哪一块\n                3.再单独遍历这一块数据即可\n        */\n        int[] arr = {16, 5, 9, 12,21, 18,\n                     32, 23, 37, 26, 45, 34,\n                     50, 48, 61, 52, 73, 66};\n\n        //创建三个块的对象\n        Block b1 = new Block(21,0,5);\n        Block b2 = new Block(45,6,11);\n        Block b3 = new Block(73,12,17);\n\n        //定义数组用来管理三个块的对象（索引表）\n        Block[] blockArr = {b1,b2,b3};\n\n        //定义一个变量用来记录要查找的元素\n        int number = 37;\n\n        //调用方法，传递索引表，数组，要查找的元素\n        int index = getIndex(blockArr,arr,number);\n\n        //打印一下\n        System.out.println(index);\n\n\n\n    }\n\n    //利用分块查找的原理，查询number的索引\n    private static int getIndex(Block[] blockArr, int[] arr, int number) {\n        //1.确定number是在那一块当中\n        int indexBlock = findIndexBlock(blockArr, number);\n\n        if(indexBlock == -1){\n            //表示number不在数组当中\n            return -1;\n        }\n\n        //2.获取这一块的起始索引和结束索引   --- 30\n        // Block b1 = new Block(21,0,5);   ----  0\n        // Block b2 = new Block(45,6,11);  ----  1\n        // Block b3 = new Block(73,12,17); ----  2\n        int startIndex = blockArr[indexBlock].getStartIndex();\n        int endIndex = blockArr[indexBlock].getEndIndex();\n\n        //3.遍历\n        for (int i = startIndex; i <= endIndex; i++) {\n            if(arr[i] == number){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n    //定义一个方法，用来确定number在哪一块当中\n    public static int findIndexBlock(Block[] blockArr,int number){ //100\n\n\n        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的\n        for (int i = 0; i < blockArr.length; i++) {\n            if(number <= blockArr[i].getMax()){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n\n}\n\nclass Block{\n    private int max;//最大值\n    private int startIndex;//起始索引\n    private int endIndex;//结束索引\n\n\n    public Block() {\n    }\n\n    public Block(int max, int startIndex, int endIndex) {\n        this.max = max;\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n    }\n\n    /**\n     * 获取\n     * @return max\n     */\n    public int getMax() {\n        return max;\n    }\n\n    /**\n     * 设置\n     * @param max\n     */\n    public void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * 获取\n     * @return startIndex\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * 设置\n     * @param startIndex\n     */\n    public void setStartIndex(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    /**\n     * 获取\n     * @return endIndex\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * 设置\n     * @param endIndex\n     */\n    public void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n\n    public String toString() {\n        return "Block{max = " + max + ", startIndex = " + startIndex + ", endIndex = " + endIndex + "}";\n    }\n}','java\npublic class A01_BubbleDemo {\n    public static void main(String[] args) {\n        /*\n            冒泡排序：\n            核心思想：\n            1，相邻的元素两两比较，大的放右边，小的放左边。\n            2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。\n            3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。\n        */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n        //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5\n\n        //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮\n        for (int i = 0; i < arr.length - 1; i++) {\n            //内循环：每一轮中我如何比较数据并找到当前的最大值\n            //-1：为了防止索引越界\n            //-i：提高效率，每一轮执行的次数应该比上一轮少一次。\n            for (int j = 0; j < arr.length - 1 - i; j++) {\n                //i 依次表示数组中的每一个索引：0 1 2 3 4\n                if(arr[j] > arr[j + 1]){\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n\n        printArr(arr);\n\n\n\n\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n}','java\npublic class A02_SelectionDemo {\n    public static void main(String[] args) {\n\n        /*\n            选择排序：\n                1，从0索引开始，跟后面的元素一一比较。\n                2，小的放前面，大的放后面。\n                3，第一次循环结束后，最小的数据已经确定。\n                4，第二次循环从1索引开始以此类推。\n\n         */\n\n\n        //1.定义数组\n        int[] arr = {2, 4, 5, 3, 1};\n\n\n        //2.利用选择排序让数组变成 1 2 3 4 5\n       /* //第一轮：\n        //从0索引开始，跟后面的元素一一比较。\n        for (int i = 0 + 1; i < arr.length; i++) {\n            //拿着0索引跟后面的数据进行比较\n            if(arr[0] > arr[i]){\n                int temp = arr[0];\n                arr[0] = arr[i];\n                arr[i] = temp;\n            }\n        }*/\n\n        //最终代码：\n        //外循环：几轮\n        //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换\n        for (int i = 0; i < arr.length -1; i++) {\n            //内循环：每一轮我要干什么事情？\n            //拿着i跟i后面的数据进行比较交换\n            for (int j = i + 1; j < arr.length; j++) {\n                if(arr[i] > arr[j]){\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n\n\n        printArr(arr);\n\n\n    }\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n\n}','java\npackage com.itheima.mysort;\n\n\npublic class A03_InsertDemo {\n    public static void main(String[] args) {\n        /*\n            插入排序：\n                将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。\n                遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。\n                N的范围：0~最大索引\n\n        */\n        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};\n\n        //1.找到无序的哪一组数组是从哪个索引开始的。  2\n        int startIndex = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i] > arr[i + 1]){\n                startIndex = i + 1;\n                break;\n            }\n        }\n\n        //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素\n        for (int i = startIndex; i < arr.length; i++) {\n            //问题：如何把遍历到的数据，插入到前面有序的这一组当中\n\n            //记录当前要插入数据的索引\n            int j = i;\n\n            while(j > 0 && arr[j] < arr[j - 1]){\n                //交换位置\n                int temp = arr[j];\n                arr[j] = arr[j - 1];\n                arr[j - 1] = temp;\n                j--;\n            }\n\n        }\n        printArr(arr);\n    }\n\n    private static void printArr(int[] arr) {\n        //3.遍历数组\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n        System.out.println();\n    }\n\n}','java\npackage com.itheima.mysort;\n\nimport java.util.Arrays;\n\npublic class A05_QuickSortDemo {\n    public static void main(String[] args) {\n        System.out.println(Integer.MAX_VALUE);\n        System.out.println(Integer.MIN_VALUE);\n      /*\n        快速排序：\n            第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。\n            比基准数小的全部在左边，比基准数大的全部在右边。\n            后面以此类推。\n      */\n\n        int[] arr = {1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8};\n\n\n        //int[] arr = new int[1000000];\n\n       /* Random r = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = r.nextInt();\n        }*/\n\n\n        long start = System.currentTimeMillis();\n        quickSort(arr, 0, arr.length - 1);\n        long end = System.currentTimeMillis();\n\n        System.out.println(end - start);//149\n\n        System.out.println(Arrays.toString(arr));\n        //课堂练习：\n        //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率\n        //得到一个结论：快速排序真的非常快。\n\n       /* for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }*/\n\n    }\n\n\n    /*\n     *   参数一：我们要排序的数组\n     *   参数二：要排序数组的起始索引\n     *   参数三：要排序数组的结束索引\n     * */\n    public static void quickSort(int[] arr, int i, int j) {\n        //定义两个变量记录要查找的范围\n        int start = i;\n        int end = j;\n\n        if(start > end){\n            //递归的出口\n            return;\n        }\n\n\n\n        //记录基准数\n        int baseNumber = arr[i];\n        //利用循环找到要交换的数字\n        while(start != end){\n            //利用end，从后往前开始找，找比基准数小的数字\n            //int[] arr = {1, 6, 2, 7, 9, 3, 4, 5, 10, 8};\n            while(true){\n                if(end <= start || arr[end] < baseNumber){\n                    break;\n                }\n                end--;\n            }\n            System.out.println(end);\n            //利用start，从前往后找，找比基准数大的数字\n            while(true){\n                if(end <= start || arr[start] > baseNumber){\n                    break;\n                }\n                start++;\n            }\n\n\n\n            //把end和start指向的元素进行交换\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n        }\n\n        //当start和end指向了同一个元素的时候，那么上面的循环就会结束\n        //表示已经找到了基准数在数组中应存入的位置\n        //基准数归位\n        //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换\n        int temp = arr[i];\n        arr[i] = arr[start];\n        arr[start] = temp;\n\n        //确定6左边的范围，重复刚刚所做的事情\n        quickSort(arr,i,start - 1);\n        //确定6右边的范围，重复刚刚所做的事情\n        quickSort(arr,start + 1,j);\n\n    }\n}']},{title:"Collection集合",headers:[{level:2,title:"1.Collection集合",slug:"_1-collection集合",link:"#_1-collection集合",children:[{level:3,title:"1.1数组和集合的区别【理解】",slug:"_1-1数组和集合的区别【理解】",link:"#_1-1数组和集合的区别【理解】",children:[]},{level:3,title:"1.2集合类体系结构【理解】",slug:"_1-2集合类体系结构【理解】",link:"#_1-2集合类体系结构【理解】",children:[]},{level:3,title:"1.3Collection 集合概述和使用【应用】",slug:"_1-3collection-集合概述和使用【应用】",link:"#_1-3collection-集合概述和使用【应用】",children:[]},{level:3,title:"1.4Collection集合的遍历",slug:"_1-4collection集合的遍历",link:"#_1-4collection集合的遍历",children:[]}]},{level:2,title:"2.List集合",slug:"_2-list集合",link:"#_2-list集合",children:[{level:3,title:"2.1List集合的概述和特点【记忆】",slug:"_2-1list集合的概述和特点【记忆】",link:"#_2-1list集合的概述和特点【记忆】",children:[]},{level:3,title:"2.2List集合的特有方法【应用】",slug:"_2-2list集合的特有方法【应用】",link:"#_2-2list集合的特有方法【应用】",children:[]},{level:3,title:"2.3List集合的五种遍历方式【应用】",slug:"_2-3list集合的五种遍历方式【应用】",link:"#_2-3list集合的五种遍历方式【应用】",children:[]},{level:3,title:"2.4 细节点注意：",slug:"_2-4-细节点注意",link:"#_2-4-细节点注意",children:[]}]},{level:2,title:"3.数据结构",slug:"_3-数据结构",link:"#_3-数据结构",children:[{level:3,title:"3.1数据结构之栈和队列【记忆】",slug:"_3-1数据结构之栈和队列【记忆】",link:"#_3-1数据结构之栈和队列【记忆】",children:[]},{level:3,title:"3.2数据结构之数组和链表【记忆】",slug:"_3-2数据结构之数组和链表【记忆】",link:"#_3-2数据结构之数组和链表【记忆】",children:[]}]},{level:2,title:"4.List集合的实现类",slug:"_4-list集合的实现类",link:"#_4-list集合的实现类",children:[{level:3,title:"4.1List集合子类的特点【记忆】",slug:"_4-1list集合子类的特点【记忆】",link:"#_4-1list集合子类的特点【记忆】",children:[]},{level:3,title:"4.2LinkedList集合的特有功能【应用】",slug:"_4-2linkedlist集合的特有功能【应用】",link:"#_4-2linkedlist集合的特有功能【应用】",children:[]}]},{level:2,title:"5. 源码分析",slug:"_5-源码分析",link:"#_5-源码分析",children:[{level:3,title:"5.1 ArrayList源码分析：",slug:"_5-1-arraylist源码分析",link:"#_5-1-arraylist源码分析",children:[]},{level:3,title:"5.2 LinkedList源码分析：",slug:"_5-2-linkedlist源码分析",link:"#_5-2-linkedlist源码分析",children:[]},{level:3,title:"5.3 迭代器源码分析：",slug:"_5-3-迭代器源码分析",link:"#_5-3-迭代器源码分析",children:[]}]}],path:"/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%8801.html",pathLocale:"/",extraFields:['java\n  public class IteratorDemo1 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Collection<String> c = new ArrayList<>();\n  \n          //添加元素\n          c.add("hello");\n          c.add("world");\n          c.add("java");\n          c.add("javaee");\n  \n          //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n          Iterator<String> it = c.iterator();\n  \n          //用while循环改进元素的判断和获取\n          while (it.hasNext()) {\n              String s = it.next();\n              System.out.println(s);\n          }\n      }\n  }','java\n  public class IteratorDemo2 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n  \n          Iterator<String> it = list.iterator();\n          while(it.hasNext()){\n              String s = it.next();\n              if("b".equals(s)){\n                  //指向谁,那么此时就删除谁.\n                  it.remove();\n              }\n          }\n          System.out.println(list);\n      }\n  }','java\n  public class MyCollectonDemo1 {\n      public static void main(String[] args) {\n          ArrayList<String> list =  new ArrayList<>();\n          list.add("a");\n          list.add("b");\n          list.add("c");\n          list.add("d");\n          list.add("e");\n          list.add("f");\n  \n          //1,数据类型一定是集合或者数组中元素的类型\n          //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素\n          //3,list就是要遍历的集合或者数组\n          for(String str : list){\n              System.out.println(str);\n          }\n      }\n  }','java\npublic class A04_CollectionDemo4 {\n    public static void main(String[] args) {\n      /*\n        迭代器的细节注意点：\n            1.报错NoSuchElementException\n            2.迭代器遍历完毕，指针不会复位\n            3.循环中只能用一次next方法\n            4.迭代器遍历时，不能用集合的方法进行增加或者删除\n            \t暂时当做一个结论先行记忆，在今天我们会讲解源码详细的再来分析。\n                如果我实在要删除：那么可以用迭代器提供的remove方法进行删除。\n                如果我要添加，暂时没有办法。(只是暂时)\n       */\n\n        //1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add("aaa");\n        coll.add("bbb");\n        coll.add("ccc");\n        coll.add("ddd");\n\n        //2.获取迭代器对象\n        //迭代器就好比是一个箭头，默认指向集合的0索引处\n        Iterator<String> it = coll.iterator();\n        //3.利用循环不断的去获取集合中的每一个元素\n        while(it.hasNext()){\n            //4.next方法的两件事情：获取元素并移动指针\n            String str = it.next();\n            System.out.println(str);\n        }\n\n        //当上面循环结束之后，迭代器的指针已经指向了最后没有元素的位置\n        //System.out.println(it.next());//NoSuchElementException\n\n        //迭代器遍历完毕，指针不会复位\n        System.out.println(it.hasNext());\n\n        //如果我们要继续第二次遍历集合，只能再次获取一个新的迭代器对象\n        Iterator<String> it2 = coll.iterator();\n        while(it2.hasNext()){\n            String str = it2.next();\n            System.out.println(str);\n        }\n    }\n}','java\npublic class A07_CollectionDemo7 {\n    public static void main(String[] args) {\n       /* \n        lambda表达式遍历：\n                default void forEach(Consumer<? super T> action):\n        */\n\n        //1.创建集合并添加元素\n        Collection<String> coll = new ArrayList<>();\n        coll.add("zhangsan");\n        coll.add("lisi");\n        coll.add("wangwu");\n        //2.利用匿名内部类的形式\n        //底层原理：\n        //其实也会自己遍历集合，依次得到每一个元素\n        //把得到的每一个元素，传递给下面的accept方法\n        //s依次表示集合中的每一个数据\n       /* coll.forEach(new Consumer<String>() {\n            @Override\n            public void accept(String s) {\n                System.out.println(s);\n            }\n        });*/\n\n        //lambda表达式\n        coll.forEach(s -> System.out.println(s));\n    }\n}','java\n  public class MyListDemo {\n      public static void main(String[] args) {\n          List<String> list = new ArrayList<>();\n          list.add("aaa");\n          list.add("bbb");\n          list.add("ccc");\n          //method1(list);\n          //method2(list);\n          //method3(list);\n          //method4(list);\n      }\n  \n      private static void method4(List<String> list) {\n          //        E get(int index)\t\t返回指定索引处的元素\n          String s = list.get(0);\n          System.out.println(s);\n      }\n  \n      private static void method3(List<String> list) {\n          //        E set(int index,E element)\t修改指定索引处的元素，返回被修改的元素\n          //被替换的那个元素,在集合中就不存在了.\n          String result = list.set(0, "qqq");\n          System.out.println(result);\n          System.out.println(list);\n      }\n  \n      private static void method2(List<String> list) {\n          //        E remove(int index)\t\t删除指定索引处的元素，返回被删除的元素\n          //在List集合中有两个删除的方法\n          //第一个 删除指定的元素,返回值表示当前元素是否删除成功\n          //第二个 删除指定索引的元素,返回值表示实际删除的元素\n          String s = list.remove(0);\n          System.out.println(s);\n          System.out.println(list);\n      }\n  \n      private static void method1(List<String> list) {\n          //        void add(int index,E element)\t在此集合中的指定位置插入指定的元素\n          //原来位置上的元素往后挪一个索引.\n          list.add(0,"qqq");\n          System.out.println(list);\n      }\n  }','java\n//创建集合并添加元素\nList<String> list = new ArrayList<>();\nlist.add("aaa");\nlist.add("bbb");\nlist.add("ccc");\n\n//1.迭代器\n/*Iterator<String> it = list.iterator();\n     while(it.hasNext()){\n        String str = it.next();\n        System.out.println(str);\n}*/\n\n\n//2.增强for\n//下面的变量s，其实就是一个第三方的变量而已。\n//在循环的过程中，依次表示集合中的每一个元素\n/* for (String s : list) {\n       System.out.println(s);\n   }*/\n\n//3.Lambda表达式\n//forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素\n//并把每一个元素传递给下面的accept方法\n//accept方法的形参s，依次表示集合中的每一个元素\n//list.forEach(s->System.out.println(s) );\n\n\n//4.普通for循环\n//size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素\n/*for (int i = 0; i < list.size(); i++) {\n            //i:依次表示集合中的每一个索引\n            String s = list.get(i);\n            System.out.println(s);\n        }*/\n\n// 5.列表迭代器\n//获取一个列表迭代器的对象，里面的指针默认也是指向0索引的\n\n//额外添加了一个方法：在遍历的过程中，可以添加元素\nListIterator<String> it = list.listIterator();\nwhile(it.hasNext()){\n    String str = it.next();\n    if("bbb".equals(str)){\n        //qqq\n        it.add("qqq");\n    }\n}\nSystem.out.println(list);',"java\n1.直接删除元素\n2.通过索引进行删除","java\n//List系列集合中的两个删除的方法\n//1.直接删除元素\n//2.通过索引进行删除\n\n//1.创建集合并添加元素\nList<Integer> list = new ArrayList<>();\n\nlist.add(1);\nlist.add(2);\nlist.add(3);\n\n\n//2.删除元素\n//请问：此时删除的是1这个元素，还是1索引上的元素？\n//为什么？\n//因为在调用方法的时候，如果方法出现了重载现象\n//优先调用，实参跟形参类型一致的那个方法。\n\n//list.remove(1);\n\n\n//手动装箱，手动把基本数据类型的1，变成Integer类型\nInteger i = Integer.valueOf(1);\n\nlist.remove(i);\n\nSystem.out.println(list);",'java\n  public class MyLinkedListDemo4 {\n      public static void main(String[] args) {\n          LinkedList<String> list = new LinkedList<>();\n          list.add("aaa");\n          list.add("bbb");\n          list.add("ccc");\n  //        public void addFirst(E e)\t在该列表开头插入指定的元素\n          //method1(list);\n  \n  //        public void addLast(E e)\t将指定的元素追加到此列表的末尾\n          //method2(list);\n  \n  //        public E getFirst()\t\t返回此列表中的第一个元素\n  //        public E getLast()\t\t返回此列表中的最后一个元素\n          //method3(list);\n  \n  //        public E removeFirst()\t\t从此列表中删除并返回第一个元素\n  //        public E removeLast()\t\t从此列表中删除并返回最后一个元素\n          //method4(list);\n        \n      }\n  \n      private static void method4(LinkedList<String> list) {\n          String first = list.removeFirst();\n          System.out.println(first);\n  \n          String last = list.removeLast();\n          System.out.println(last);\n  \n          System.out.println(list);\n      }\n  \n      private static void method3(LinkedList<String> list) {\n          String first = list.getFirst();\n          String last = list.getLast();\n          System.out.println(first);\n          System.out.println(last);\n      }\n  \n      private static void method2(LinkedList<String> list) {\n          list.addLast("www");\n          System.out.println(list);\n      }\n  \n      private static void method1(LinkedList<String> list) {\n          list.addFirst("qqq");\n          System.out.println(list);\n      }\n  }']},{title:"泛型",headers:[{level:2,title:"1.泛型",slug:"_1-泛型",link:"#_1-泛型",children:[{level:3,title:"1.1泛型概述",slug:"_1-1泛型概述",link:"#_1-1泛型概述",children:[]}]},{level:2,title:"2.Set集合",slug:"_2-set集合",link:"#_2-set集合",children:[{level:3,title:"2.1Set集合概述和特点【应用】",slug:"_2-1set集合概述和特点【应用】",link:"#_2-1set集合概述和特点【应用】",children:[]},{level:3,title:"2.2Set集合的使用【应用】",slug:"_2-2set集合的使用【应用】",link:"#_2-2set集合的使用【应用】",children:[]}]},{level:2,title:"3.TreeSet集合",slug:"_3-treeset集合",link:"#_3-treeset集合",children:[{level:3,title:"3.1TreeSet集合概述和特点【应用】",slug:"_3-1treeset集合概述和特点【应用】",link:"#_3-1treeset集合概述和特点【应用】",children:[]},{level:3,title:"3.2TreeSet集合基本使用【应用】",slug:"_3-2treeset集合基本使用【应用】",link:"#_3-2treeset集合基本使用【应用】",children:[]},{level:3,title:"3.3自然排序Comparable的使用【应用】",slug:"_3-3自然排序comparable的使用【应用】",link:"#_3-3自然排序comparable的使用【应用】",children:[]},{level:3,title:"3.4比较器排序Comparator的使用【应用】",slug:"_3-4比较器排序comparator的使用【应用】",link:"#_3-4比较器排序comparator的使用【应用】",children:[]},{level:3,title:"3.5两种比较方式总结【理解】",slug:"_3-5两种比较方式总结【理解】",link:"#_3-5两种比较方式总结【理解】",children:[]}]},{level:2,title:"4.数据结构",slug:"_4-数据结构",link:"#_4-数据结构",children:[{level:3,title:"4.1二叉树【理解】",slug:"_4-1二叉树【理解】",link:"#_4-1二叉树【理解】",children:[]},{level:3,title:"4.2二叉查找树【理解】",slug:"_4-2二叉查找树【理解】",link:"#_4-2二叉查找树【理解】",children:[]},{level:3,title:"4.3平衡二叉树【理解】",slug:"_4-3平衡二叉树【理解】",link:"#_4-3平衡二叉树【理解】",children:[]},{level:3,title:"4.3红黑树【理解】",slug:"_4-3红黑树【理解】",link:"#_4-3红黑树【理解】",children:[]},{level:3,title:"5.1HashSet集合概述和特点【应用】",slug:"_5-1hashset集合概述和特点【应用】",link:"#_5-1hashset集合概述和特点【应用】",children:[]},{level:3,title:"5.2HashSet集合的基本应用【应用】",slug:"_5-2hashset集合的基本应用【应用】",link:"#_5-2hashset集合的基本应用【应用】",children:[]},{level:3,title:"5.3哈希值【理解】",slug:"_5-3哈希值【理解】",link:"#_5-3哈希值【理解】",children:[]},{level:3,title:"5.4哈希表结构【理解】",slug:"_5-4哈希表结构【理解】",link:"#_5-4哈希表结构【理解】",children:[]},{level:3,title:"5.5HashSet集合存储学生对象并遍历【应用】",slug:"_5-5hashset集合存储学生对象并遍历【应用】",link:"#_5-5hashset集合存储学生对象并遍历【应用】",children:[]}]}],path:"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html",pathLocale:"/",extraFields:['java\npublic class MySet1 {\n    public static void main(String[] args) {\n      \t//创建集合对象\n        Set<String> set = new TreeSet<>();\n      \t//添加元素\n        set.add("ccc");\n        set.add("aaa");\n        set.add("aaa");\n        set.add("bbb");\n\n//        for (int i = 0; i < set.size(); i++) {\n//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法\n//        }\n      \n      \t//遍历集合\n        Iterator<String> it = set.iterator();\n        while (it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("-----------------------------------");\n        for (String s : set) {\n            System.out.println(s);\n        }\n    }\n}',"java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n\n        ts.add(30);\n\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }\n    }\n}","java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return \"Student{\" +\n                  \"name='\" + name + '\\'' +\n                  \", age=\" + age +\n                  '}';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照对象的年龄进行排序\n          //主要判断条件: 按照年龄从小到大排序\n          int result = this.age - o.age;\n          //次要判断条件: 年龄相同时，按照姓名的字母顺序排序\n          result = result == 0 ? this.name.compareTo(o.getName()) : result;\n          return result;\n      }\n  }",'java\n  public class MyTreeSet2 {\n      public static void main(String[] args) {\n          //创建集合对象\n          TreeSet<Student> ts = new TreeSet<>();\n  \t    //创建学生对象\n          Student s1 = new Student("zhangsan",28);\n          Student s2 = new Student("lisi",27);\n          Student s3 = new Student("wangwu",29);\n          Student s4 = new Student("zhaoliu",28);\n          Student s5 = new Student("qianqi",30);\n  \t\t//把学生添加到集合\n          ts.add(s1);\n          ts.add(s2);\n          ts.add(s3);\n          ts.add(s4);\n          ts.add(s5);\n  \t\t//遍历集合\n          for (Student student : ts) {\n              System.out.println(student);\n          }\n      }\n  }',"java\n  public class Teacher {\n      private String name;\n      private int age;\n\n      public Teacher() {\n      }\n\n      public Teacher(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return \"Teacher{\" +\n                  \"name='\" + name + '\\'' +\n                  \", age=\" + age +\n                  '}';\n      }\n  }",'java\n  public class MyTreeSet4 {\n      public static void main(String[] args) {\n        \t//创建集合对象\n          TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {\n              @Override\n              public int compare(Teacher o1, Teacher o2) {\n                  //o1表示现在要存入的那个元素\n                  //o2表示已经存入到集合中的元素\n                \n                  //主要条件\n                  int result = o1.getAge() - o2.getAge();\n                  //次要条件\n                  result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;\n                  return result;\n              }\n          });\n  \t\t//创建老师对象\n          Teacher t1 = new Teacher("zhangsan",23);\n          Teacher t2 = new Teacher("lisi",22);\n          Teacher t3 = new Teacher("wangwu",24);\n          Teacher t4 = new Teacher("zhaoliu",24);\n  \t\t//把老师添加到集合\n          ts.add(t1);\n          ts.add(t2);\n          ts.add(t3);\n          ts.add(t4);\n  \t\t//遍历集合\n          for (Teacher teacher : ts) {\n              System.out.println(teacher);\n          }\n      }\n  }','java\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> set = new HashSet<String>();\n\n        //添加元素\n        set.add("hello");\n        set.add("world");\n        set.add("java");\n        //不包含重复元素的集合\n        set.add("world");\n\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}',"java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  \n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n  \n          Student student = (Student) o;\n  \n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n  \n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }",'java\n  public class HashSetDemo02 {\n      public static void main(String[] args) {\n          //创建HashSet集合对象\n          HashSet<Student> hs = new HashSet<Student>();\n  \n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n  \n          Student s4 = new Student("王祖贤", 33);\n  \n          //把学生添加到集合\n          hs.add(s1);\n          hs.add(s2);\n          hs.add(s3);\n          hs.add(s4);\n  \n          //遍历集合(增强for)\n          for (Student s : hs) {\n              System.out.println(s.getName() + "," + s.getAge());\n          }\n      }\n  }']},{title:"Map集合",headers:[{level:2,title:"1.Map集合",slug:"_1-map集合",link:"#_1-map集合",children:[{level:3,title:"1.1Map集合概述和特点【理解】",slug:"_1-1map集合概述和特点【理解】",link:"#_1-1map集合概述和特点【理解】",children:[]},{level:3,title:"1.2Map集合的基本功能【应用】",slug:"_1-2map集合的基本功能【应用】",link:"#_1-2map集合的基本功能【应用】",children:[]},{level:3,title:"1.3Map集合的获取功能【应用】",slug:"_1-3map集合的获取功能【应用】",link:"#_1-3map集合的获取功能【应用】",children:[]},{level:3,title:"1.4Map集合的遍历(方式1)【应用】",slug:"_1-4map集合的遍历-方式1-【应用】",link:"#_1-4map集合的遍历-方式1-【应用】",children:[]},{level:3,title:"1.5Map集合的遍历(方式2)【应用】",slug:"_1-5map集合的遍历-方式2-【应用】",link:"#_1-5map集合的遍历-方式2-【应用】",children:[]}]},{level:2,title:"2.HashMap集合",slug:"_2-hashmap集合",link:"#_2-hashmap集合",children:[{level:3,title:"2.1HashMap集合概述和特点【理解】",slug:"_2-1hashmap集合概述和特点【理解】",link:"#_2-1hashmap集合概述和特点【理解】",children:[]},{level:3,title:"2.2HashMap集合应用案例【应用】",slug:"_2-2hashmap集合应用案例【应用】",link:"#_2-2hashmap集合应用案例【应用】",children:[]}]},{level:2,title:"3.TreeMap集合",slug:"_3-treemap集合",link:"#_3-treemap集合",children:[{level:3,title:"3.1TreeMap集合概述和特点【理解】",slug:"_3-1treemap集合概述和特点【理解】",link:"#_3-1treemap集合概述和特点【理解】",children:[]},{level:3,title:"3.2TreeMap集合应用案例【应用】",slug:"_3-2treemap集合应用案例【应用】",link:"#_3-2treemap集合应用案例【应用】",children:[]}]}],path:"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html",pathLocale:"/",extraFields:["java\n  interface Map<K,V>  K：键的类型；V：值的类型",'java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n          map.put("itheima001","林青霞");\n          map.put("itheima002","张曼玉");\n          map.put("itheima003","王祖贤");\n          map.put("itheima003","柳岩");\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }','java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String,String> map = new HashMap<String,String>();\n\n          //V put(K key,V value)：添加元素\n          map.put("张无忌","赵敏");\n          map.put("郭靖","黄蓉");\n          map.put("杨过","小龙女");\n\n          //V remove(Object key)：根据键删除键值对元素\n  //        System.out.println(map.remove("郭靖"));\n  //        System.out.println(map.remove("郭襄"));\n\n          //void clear()：移除所有的键值对元素\n  //        map.clear();\n\n          //boolean containsKey(Object key)：判断集合是否包含指定的键\n  //        System.out.println(map.containsKey("郭靖"));\n  //        System.out.println(map.containsKey("郭襄"));\n\n          //boolean isEmpty()：判断集合是否为空\n  //        System.out.println(map.isEmpty());\n\n          //int size()：集合的长度，也就是集合中键值对的个数\n          System.out.println(map.size());\n\n          //输出集合对象\n          System.out.println(map);\n      }\n  }','java\n  public class MapDemo03 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //V get(Object key):根据键获取值\n  //        System.out.println(map.get("张无忌"));\n  //        System.out.println(map.get("张三丰"));\n\n          //Set<K> keySet():获取所有键的集合\n  //        Set<String> keySet = map.keySet();\n  //        for(String key : keySet) {\n  //            System.out.println(key);\n  //        }\n\n          //Collection<V> values():获取所有值的集合\n          Collection<String> values = map.values();\n          for(String value : values) {\n              System.out.println(value);\n          }\n      }\n  }','java\n  public class MapDemo01 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键的集合。用keySet()方法实现\n          Set<String> keySet = map.keySet();\n          //遍历键的集合，获取到每一个键。用增强for实现\n          for (String key : keySet) {\n              //根据键去找值。用get(Object key)方法实现\n              String value = map.get(key);\n              System.out.println(key + "," + value);\n          }\n      }\n  }','java\n  public class MapDemo02 {\n      public static void main(String[] args) {\n          //创建集合对象\n          Map<String, String> map = new HashMap<String, String>();\n\n          //添加元素\n          map.put("张无忌", "赵敏");\n          map.put("郭靖", "黄蓉");\n          map.put("杨过", "小龙女");\n\n          //获取所有键值对对象的集合\n          Set<Map.Entry<String, String>> entrySet = map.entrySet();\n          //遍历键值对对象的集合，得到每一个键值对对象\n          for (Map.Entry<String, String> me : entrySet) {\n              //根据键值对对象获取键和值\n              String key = me.getKey();\n              String value = me.getValue();\n              System.out.println(key + "," + value);\n          }\n      }\n  }',"java\n  public class Student {\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n\n          Student student = (Student) o;\n\n          if (age != student.age) return false;\n          return name != null ? name.equals(student.name) : student.name == null;\n      }\n\n      @Override\n      public int hashCode() {\n          int result = name != null ? name.hashCode() : 0;\n          result = 31 * result + age;\n          return result;\n      }\n  }",'java\n  public class HashMapDemo {\n      public static void main(String[] args) {\n          //创建HashMap集合对象\n          HashMap<Student, String> hm = new HashMap<Student, String>();\n\n          //创建学生对象\n          Student s1 = new Student("林青霞", 30);\n          Student s2 = new Student("张曼玉", 35);\n          Student s3 = new Student("王祖贤", 33);\n          Student s4 = new Student("王祖贤", 33);\n\n          //把学生添加到集合\n          hm.put(s1, "西安");\n          hm.put(s2, "武汉");\n          hm.put(s3, "郑州");\n          hm.put(s4, "北京");\n\n          //遍历集合\n          Set<Student> keySet = hm.keySet();\n          for (Student key : keySet) {\n              String value = hm.get(key);\n              System.out.println(key.getName() + "," + key.getAge() + "," + value);\n          }\n      }\n  }',"java\n  public class Student implements Comparable<Student>{\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return \"Student{\" +\n                  \"name='\" + name + '\\'' +\n                  \", age=\" + age +\n                  '}';\n      }\n\n      @Override\n      public int compareTo(Student o) {\n          //按照年龄进行排序\n          int result = o.getAge() - this.getAge();\n          //次要条件，按照姓名排序。\n          result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n          return result;\n      }\n  }",'java\n  public class Test1 {\n      public static void main(String[] args) {\n        \t// 创建TreeMap集合对象\n          TreeMap<Student,String> tm = new TreeMap<>();\n        \n  \t\t// 创建学生对象\n          Student s1 = new Student("xiaohei",23);\n          Student s2 = new Student("dapang",22);\n          Student s3 = new Student("xiaomei",22);\n        \n  \t\t// 将学生对象添加到TreeMap集合中\n          tm.put(s1,"江苏");\n          tm.put(s2,"北京");\n          tm.put(s3,"天津");\n        \n  \t\t// 遍历TreeMap集合,打印每个学生的信息\n          tm.forEach(\n                  (Student key, String value)->{\n                      System.out.println(key + "---" + value);\n                  }\n          );\n      }\n  }']},{title:"可变参数&综合练习",headers:[{level:2,title:"2.1 Collections常用功能",slug:"_2-1-collections常用功能",link:"#_2-1-collections常用功能",children:[]},{level:2,title:"2.2 Comparator比较器",slug:"_2-2-comparator比较器",link:"#_2-2-comparator比较器",children:[{level:3,title:"练习1：随机点名器",slug:"练习1-随机点名器",link:"#练习1-随机点名器",children:[]},{level:3,title:"练习2：带概率的随机",slug:"练习2-带概率的随机",link:"#练习2-带概率的随机",children:[]},{level:3,title:"练习3：随机不重复",slug:"练习3-随机不重复",link:"#练习3-随机不重复",children:[]}]},{level:2,title:"练习4：集合的嵌套",slug:"练习4-集合的嵌套",link:"#练习4-集合的嵌套",children:[]},{level:2,title:"4.1 案例介绍",slug:"_4-1-案例介绍",link:"#_4-1-案例介绍",children:[]},{level:2,title:"4.2 案例分析",slug:"_4-2-案例分析",link:"#_4-2-案例分析",children:[]},{level:2,title:"4.3 代码实现",slug:"_4-3-代码实现",link:"#_4-3-代码实现",children:[]},{level:2,title:"4.4 排序（第一种排序方式）",slug:"_4-4-排序-第一种排序方式",link:"#_4-4-排序-第一种排序方式",children:[]},{level:2,title:"4.5 排序（第二种排序方式）",slug:"_4-5-排序-第二种排序方式",link:"#_4-5-排序-第二种排序方式",children:[]}],path:"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html",pathLocale:"/",extraFields:["修饰符 返回值类型 方法名(参数类型... 形参名){  }","java\n  public class ChangeArgs {\n    public static void main(String[] args) {\n        int sum = getSum(6, 7, 2, 12, 2121);\n        System.out.println(sum);\n    }\n    \n    public static int getSum(int... arr) {\n   \t\tint sum = 0;\n   \t     for (int a : arr) {\n         sum += a;\n        }\n   \t\t return sum;\n    }\n}","java\npublic class CollectionsDemo {\n\tpublic static void main(String[] args) {\n      ArrayList<Integer> list = new ArrayList<Integer>();\n      //原来写法\n      //list.add(12);\n      //list.add(14);\n      //list.add(15);\n      //list.add(1000);\n      //采用工具类 完成 往集合中添加元素  \n      Collections.addAll(list, 5, 222, 1，2);\n      System.out.println(list);\n}","java\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        ArrayList<Integer> list = new ArrayList<Integer>();\n   \n        list.add(100);\n        list.add(300);\n        list.add(200);\n        list.add(50);\n        //排序方法 \n        Collections.sort(list);\n        System.out.println(list);\n    }\n}\n结果：\n[50,100, 200, 300]","java\npublic class Student{\n    private String name;\n    private int age;\n\t//构造方法\n    //get/set\n \t//toString\n}","java\npublic class Demo {\n    public static void main(String[] args) {\n        // 创建四个学生对象 存储到集合中\n        ArrayList<Student> list = new ArrayList<Student>();\n\n        list.add(new Student(\"rose\",18));\n        list.add(new Student(\"jack\",16));\n        list.add(new Student(\"abc\",20));\n\t\tCollections.sort(list, new Comparator<Student>() {\n  \t\t  @Override\n    \t\tpublic int compare(Student o1, Student o2) {\n        \treturn o1.getAge()-o2.getAge();//以学生的年龄升序\n   \t\t }\n\t\t});\n\n\n        for (Student student : list) {\n            System.out.println(student);\n        }\n    }\n}\nStudent{name='jack', age=16}\nStudent{name='rose', age=18}\nStudent{name='abc', age=20}",'java\npublic class Test1 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生，学生属性:姓名，年龄，性别。\n        实现随机点名器。*/\n\n\n        //1.定义集合\n        ArrayList<String> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,"范闲","范建","范统","杜子腾","杜琦燕","宋合泛","侯笼藤","朱益群","朱穆朗玛峰","袁明媛");\n        //3.随机点名\n        /* Random r = new Random();\n        int index = r.nextInt(list.size());\n        String name = list.get(index);\n        System.out.println(name);*/\n\n        //打乱\n        Collections.shuffle(list);\n\n        String name = list.get(0);\n        System.out.println(name);\n\n\n    }\n}','java\npublic class Test2 {\n    public static void main(String[] args) {\n        /* 班级里有N个学生\n        要求：\n        70%的概率随机到男生\n        30%的概率随机到女生\n\n        "范闲","范建","范统","杜子腾","宋合泛","侯笼藤","朱益群","朱穆朗玛峰",\n        "杜琦燕","袁明媛","李猜","田蜜蜜",\n        */\n        //1.创建集合\n        ArrayList<Integer> list = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list,1,1,1,1,1,1,1);\n        Collections.addAll(list,0,0,0);\n        //3.打乱集合中的数据\n        Collections.shuffle(list);\n        //4.从list集合中随机抽取0或者1\n        Random r = new Random();\n        int index = r.nextInt(list.size());\n        int number = list.get(index);\n        System.out.println(number);\n        //5.创建两个集合分别存储男生和女生的名字\n        ArrayList<String> boyList = new ArrayList<>();\n        ArrayList<String> girlList = new ArrayList<>();\n\n        Collections.addAll(boyList,"范闲","范建","范统","杜子腾","宋合泛","侯笼藤","朱益群","朱穆朗玛峰");\n        Collections.addAll(girlList,"杜琦燕","袁明媛","李猜","田蜜蜜");\n\n        //6.判断此时是从boyList里面抽取还是从girlList里面抽取\n        if(number == 1){\n            //boyList\n            int boyIndex = r.nextInt(boyList.size());\n            String name = boyList.get(boyIndex);\n            System.out.println(name);\n        }else{\n            //girlList\n            int girlIndex = r.nextInt(girlList.size());\n            String name = girlList.get(girlIndex);\n            System.out.println(name);\n        }\n\n\n    }\n}','java\npublic class Test3 {\n    public static void main(String[] args) {\n       /* 班级里有5个学生\n        要求：\n        被点到的学生不会再被点到。\n        但是如果班级中所有的学生都点完了，需要重新开启第二轮点名。*/\n\n\n        //1.定义集合\n        ArrayList<String> list1 = new ArrayList<>();\n        //2.添加数据\n        Collections.addAll(list1, "范闲", "范建", "范统", "杜子腾", "杜琦燕", "宋合泛", "侯笼藤", "朱益群", "朱穆朗玛峰", "袁明媛");\n        //创建一个临时的集合，用来存已经被点到学生的名字\n        ArrayList<String> list2 = new ArrayList<>();\n        //外循环：表示轮数\n        for (int i = 1; i <= 10; i++) {\n            System.out.println("=========第" + i + "轮点名开始了======================");\n            //3.获取集合的长度\n            int count = list1.size();\n            //4.随机点名\n            Random r = new Random();\n            //内循环：每一轮中随机循环抽取的过程\n            for (int j = 0; j < count; j++) {\n                int index = r.nextInt(list1.size());\n                String name = list1.remove(index);\n                list2.add(name);\n                System.out.println(name);\n            }\n            //此时表示一轮点名结束\n            //list1 空了 list2 10个学生的名字\n            list1.addAll(list2);\n            list2.clear();\n\n        }\n    }\n}','java\npublic class Test4 {\n    public static void main(String[] args) {\n        /* 需求\n        定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\n        添加完毕后，遍历结果格式如下：\n                江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\n                湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\n                河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市*/\n\n\n        //1.创建Map集合\n        HashMap<String, ArrayList<String>> hm = new HashMap<>();\n\n        //2.创建单列集合存储市\n        ArrayList<String> city1 = new ArrayList<>();\n        city1.add("南京市");\n        city1.add("扬州市");\n        city1.add("苏州市");\n        city1.add("无锡市");\n        city1.add("常州市");\n\n        ArrayList<String> city2 = new ArrayList<>();\n        city2.add("武汉市");\n        city2.add("孝感市");\n        city2.add("十堰市");\n        city2.add("宜昌市");\n        city2.add("鄂州市");\n\n        ArrayList<String> city3 = new ArrayList<>();\n        city3.add("石家庄市");\n        city3.add("唐山市");\n        city3.add("邢台市");\n        city3.add("保定市");\n        city3.add("张家口市");\n\n        //3.把省份和多个市添加到map集合\n        hm.put("江苏省",city1);\n        hm.put("湖北省",city2);\n        hm.put("河北省",city3);\n\n        Set<Map.Entry<String, ArrayList<String>>> entries = hm.entrySet();\n        for (Map.Entry<String, ArrayList<String>> entry : entries) {\n            //entry依次表示每一个键值对对象\n            String key = entry.getKey();\n            ArrayList<String> value = entry.getValue();\n            StringJoiner sj = new StringJoiner(", ","","");\n            for (String city : value) {\n                sj.add(city);\n            }\n            System.out.println(key + " = " + sj);\n\n        }\n    }\n}','java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的三步：\n          准备牌\n          洗牌\n          发牌\n       */\n        //从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\npublic class PokerGame {\n    //牌盒\n    //♥3 ♣3\n    static ArrayList<String> list = new ArrayList<>();\n\n    //静态代码块\n    //特点：随着类的加载而在加载的，而且只执行一次。\n    static {\n        //准备牌\n        // "♦", "♣", "♥", "♠"\n        // "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"\n        String[] color = {"♦", "♣", "♥", "♠" };\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        for (String c : color) {\n            //c依次表示每一种花色\n            for (String n : number) {\n                //n 依次表示每一个数字\n                list.add(c + n);\n            }\n        }\n        list.add("小王");\n        list.add("大王");\n    }\n\n    public PokerGame(){\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        //遍历牌盒得到每一张牌\n        for (int i = 0; i < list.size(); i++) {\n            //i：索引\n            String poker = list.get(i);\n            if(i <= 2){\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if(i % 3 == 0){\n                player1.add(poker);\n            }else if(i % 3 == 1){\n                player2.add(poker);\n            }else{\n                player3.add(poker);\n            }\n        }\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：每位玩家的牌\n    * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + ": ");\n        for (String poker : list) {\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n    }\n}','java\npublic class App {\n    public static void main(String[] args) {\n      /*\n        完成控制台版的四步：\n          准备牌\n          洗牌\n          发牌\n          排序\n\n       */\n\n\t\t//从程序的主入口开启斗地主游戏\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒 Map\n    //此时我们只要把牌跟序号产生对应关系就可以了，不需要按照序号进行排序，所以只要HashMap就可以了\n    static HashMap<Integer, String> hm = new HashMap<>();\n    static ArrayList<Integer> list = new ArrayList<>();\n\n    static {\n        String[] color = {"♦", "♣", "♥", "♠"};\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        //序号\n        int serialNumber = 1;\n        //细节\n        for (String n : number) {\n            //依次表示每一个数字\n            for (String c : color) {\n                //依次表示每一个花色\n                hm.put(serialNumber, c + n);\n                list.add(serialNumber);\n                serialNumber++;\n            }\n        }\n\n        hm.put(serialNumber, "小王");\n        list.add(serialNumber);\n        serialNumber++;\n        hm.put(serialNumber, "大王");\n        list.add(serialNumber);\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        TreeSet<Integer> lord = new TreeSet<>();\n        TreeSet<Integer> player1 = new TreeSet<>();\n        TreeSet<Integer> player2 = new TreeSet<>();\n        TreeSet<Integer> player3 = new TreeSet<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            //i :依次表示集合中的每一个索引\n            //list.get(i)元素：牌的序号\n            int serialNumber = list.get(i);\n\n            if(i <= 2){\n                lord.add(serialNumber);\n                continue;\n            }\n\n            if(i % 3 == 0){\n                player1.add(serialNumber);\n            }else if(i % 3 == 1){\n                player2.add(serialNumber);\n            }else{\n                player3.add(serialNumber);\n            }\n        }\n\n\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n\n    }\n\n    /*\n    * 参数一：玩家的名字\n    * 参数二：牌的序号\n    * */\n    public void lookPoker(String name, TreeSet<Integer> ts){\n        System.out.print(name + ": ");\n        //遍历TreeSet集合得到每一个序号，再拿着序号到Map集合中去找真正的牌\n        for (int serialNumber : ts) {\n            String poker = hm.get(serialNumber);\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n    }\n}','java\npublic class App {\n    public static void main(String[] args) {\n        new PokerGame();\n    }\n}\n\n\npublic class PokerGame {\n    //牌盒\n    static ArrayList<String> list = new ArrayList<>();\n\n    //创建一个集合，用来添加牌的价值\n    static HashMap<String, Integer> hm = new HashMap<>();\n\n    static {\n        //准备牌\n        String[] color = {"♦", "♣", "♥", "♠"};\n        String[] number = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};\n\n        for (String c : color) {\n            for (String n : number) {\n                list.add(c + n);\n            }\n        }\n        list.add(" 小王");\n        list.add(" 大王");\n\n\n        //指定牌的价值\n        //牌上的数字到Map集合中判断是否存在\n        //存在，获取价值\n        //不存在，本身的数字就是价值\n        hm.put("J", 11);\n        hm.put("Q", 12);\n        hm.put("K", 13);\n        hm.put("A", 14);\n        hm.put("2", 15);\n        hm.put("小王", 50);\n        hm.put("大王", 100);\n\n\n    }\n\n    public PokerGame() {\n        //洗牌\n        Collections.shuffle(list);\n\n        //发牌\n        ArrayList<String> lord = new ArrayList<>();\n        ArrayList<String> player1 = new ArrayList<>();\n        ArrayList<String> player2 = new ArrayList<>();\n        ArrayList<String> player3 = new ArrayList<>();\n\n        for (int i = 0; i < list.size(); i++) {\n            String poker = list.get(i);\n            //发底牌\n            if (i <= 2) {\n                lord.add(poker);\n                continue;\n            }\n\n            //给三个玩家轮流发牌\n            if (i % 3 == 0) {\n                player1.add(poker);\n            } else if (i % 3 == 1) {\n                player2.add(poker);\n            } else {\n                player3.add(poker);\n            }\n        }\n\n\n        //排序\n        order(lord);\n        order(player1);\n        order(player2);\n        order(player3);\n\n\n        //看牌\n        lookPoker("底牌",lord);\n        lookPoker("钢脑壳",player1);\n        lookPoker("大帅比",player2);\n        lookPoker("蛋筒",player3);\n    }\n\n\n    /*\n     * 参数一：玩家的名字\n     * 参数二：每位玩家的牌\n     * */\n    public void lookPoker(String name, ArrayList<String> list){\n        System.out.print(name + ": ");\n        for (String poker : list) {\n            System.out.print(poker + " ");\n        }\n        System.out.println();\n\n    }\n\n\n    //利用牌的价值进行排序\n    //参数：集合\n    //♥5 ♥3 ♥6 ♥7 ♥9\n    public void order(ArrayList<String> list){\n        Collections.sort(list, new Comparator<String>() {\n            //Array.sort （插入排序 + 二分查找）\n            @Override\n            public int compare(String o1, String o2) {\n                //o1：表示当前要插入到有序序列中的牌\n                //o2：表示已经在有序序列中存在的牌\n\n                //负数：o1小 插入到前面\n                //正数：o1大 插入到后面\n                //0：o1的数字跟o2的数字是一样的，需要按照花色再次排序\n\n                //1.计算o1的花色和价值   大王\n                String color1 = o1.substring(0, 1);\n                int value1 = getValue(o1);\n\n                //2.计算o2的花色和价值\n                String color2 = o2.substring(0, 1);\n                int value2 = getValue(o2);\n\n                //3.比较o1和o2的价值    ♥3  ♠3\n                int i = value1 - value2;\n                return i == 0 ? color1.compareTo(color2) : i;\n\n            }\n        });\n    }\n\n    //计算牌的价值\n    //参数：牌\n    //返回值：价值\n    public int getValue(String poker){//♥3\n        //获取牌上的数字\n        String number = poker.substring(1);//把这里截取出来的结果，让这个结果再Map集合中存在 “ 大王”\n        //拿着数字到map集合中判断是否存在\n        if(hm.containsKey(number)){\n            //存在，获取价值\n            return hm.get(number);\n        }else{\n            //不存在，类型转换\n            return Integer.parseInt(number);\n        }\n    }\n}']},{title:"stream流和方法引用",headers:[{level:2,title:"1.不可变集合",slug:"_1-不可变集合",link:"#_1-不可变集合",children:[{level:3,title:"1.1 什么是不可变集合",slug:"_1-1-什么是不可变集合",link:"#_1-1-什么是不可变集合",children:[]},{level:3,title:"1.2 使用场景",slug:"_1-2-使用场景",link:"#_1-2-使用场景",children:[]},{level:3,title:"1.3 不可变集合分类",slug:"_1-3-不可变集合分类",link:"#_1-3-不可变集合分类",children:[]},{level:3,title:"1.4 不可变的list集合",slug:"_1-4-不可变的list集合",link:"#_1-4-不可变的list集合",children:[]},{level:3,title:"1.5 不可变的Set集合",slug:"_1-5-不可变的set集合",link:"#_1-5-不可变的set集合",children:[]},{level:3,title:"1.6 不可变的Map集合",slug:"_1-6-不可变的map集合",link:"#_1-6-不可变的map集合",children:[]}]},{level:2,title:"2.Stream流",slug:"_2-stream流",link:"#_2-stream流",children:[{level:3,title:"2.1体验Stream流【理解】",slug:"_2-1体验stream流【理解】",link:"#_2-1体验stream流【理解】",children:[]},{level:3,title:"2.2Stream流的常见生成方式【应用】",slug:"_2-2stream流的常见生成方式【应用】",link:"#_2-2stream流的常见生成方式【应用】",children:[]},{level:3,title:"2.3Stream流中间操作方法【应用】",slug:"_2-3stream流中间操作方法【应用】",link:"#_2-3stream流中间操作方法【应用】",children:[]},{level:3,title:"2.4Stream流终结操作方法【应用】",slug:"_2-4stream流终结操作方法【应用】",link:"#_2-4stream流终结操作方法【应用】",children:[]},{level:3,title:"2.5Stream流的收集操作【应用】",slug:"_2-5stream流的收集操作【应用】",link:"#_2-5stream流的收集操作【应用】",children:[]},{level:3,title:"2.6Stream流综合练习【应用】",slug:"_2-6stream流综合练习【应用】",link:"#_2-6stream流综合练习【应用】",children:[]}]},{level:2,title:"3.方法引用",slug:"_3-方法引用",link:"#_3-方法引用",children:[{level:3,title:"3.1体验方法引用【理解】",slug:"_3-1体验方法引用【理解】",link:"#_3-1体验方法引用【理解】",children:[]},{level:3,title:"3.2方法引用符【理解】",slug:"_3-2方法引用符【理解】",link:"#_3-2方法引用符【理解】",children:[]},{level:3,title:"3.3引用类方法【应用】",slug:"_3-3引用类方法【应用】",link:"#_3-3引用类方法【应用】",children:[]},{level:3,title:"3.4引用对象的实例方法【应用】",slug:"_3-4引用对象的实例方法【应用】",link:"#_3-4引用对象的实例方法【应用】",children:[]},{level:3,title:"3.5引用类的实例方法【应用】",slug:"_3-5引用类的实例方法【应用】",link:"#_3-5引用类的实例方法【应用】",children:[]},{level:3,title:"3.6引用构造器【应用】",slug:"_3-6引用构造器【应用】",link:"#_3-6引用构造器【应用】",children:[]}]}],path:"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html",pathLocale:"/",extraFields:['java\npublic class ImmutableDemo1 {\n    public static void main(String[] args) {\n        /*\n            创建不可变的List集合\n            "张三", "李四", "王五", "赵六"\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        List<String> list = List.of("张三", "李四", "王五", "赵六");\n\n        System.out.println(list.get(0));\n        System.out.println(list.get(1));\n        System.out.println(list.get(2));\n        System.out.println(list.get(3));\n\n        System.out.println("---------------------------");\n\n        for (String s : list) {\n            System.out.println(s);\n        }\n\n        System.out.println("---------------------------");\n\n\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n        System.out.println("---------------------------");\n\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            System.out.println(s);\n        }\n        System.out.println("---------------------------");\n\n        //list.remove("李四");\n        //list.add("aaa");\n        list.set(0,"aaa");\n    }\n}','java\npublic class ImmutableDemo2 {\n    public static void main(String[] args) {\n        /*\n           创建不可变的Set集合\n           "张三", "李四", "王五", "赵六"\n\n\n           细节：\n                当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");\n\n        for (String s : set) {\n            System.out.println(s);\n        }\n\n        System.out.println("-----------------------");\n\n        Iterator<String> it = set.iterator();\n        while(it.hasNext()){\n            String s = it.next();\n            System.out.println(s);\n        }\n\n        System.out.println("-----------------------");\n        //set.remove("王五");\n    }\n}','java\npublic class ImmutableDemo3 {\n    public static void main(String[] args) {\n       /*\n        创建Map的不可变集合\n            细节1：\n                键是不能重复的\n            细节2：\n                Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对\n            细节3：\n                如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法\n        */\n\n        //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作\n        Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",\n                "赵六", "广州", "孙七", "深圳", "周八", "杭州",\n                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",\n                "陈二", "嘉兴");\n\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            String value = map.get(key);\n            System.out.println(key + "=" + value);\n        }\n\n        System.out.println("--------------------------");\n\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            System.out.println(key + "=" + value);\n        }\n        System.out.println("--------------------------");\n    }\n}','java\npublic class ImmutableDemo4 {\n    public static void main(String[] args) {\n\n        /*\n            创建Map的不可变集合,键值对的数量超过10个\n        */\n\n        //1.创建一个普通的Map集合\n        HashMap<String, String> hm = new HashMap<>();\n        hm.put("张三", "南京");\n        hm.put("李四", "北京");\n        hm.put("王五", "上海");\n        hm.put("赵六", "北京");\n        hm.put("孙七", "深圳");\n        hm.put("周八", "杭州");\n        hm.put("吴九", "宁波");\n        hm.put("郑十", "苏州");\n        hm.put("刘一", "无锡");\n        hm.put("陈二", "嘉兴");\n        hm.put("aaa", "111");\n\n        //2.利用上面的数据来获取一个不可变的集合\n/*\n        //获取到所有的键值对对象（Entry对象）\n        Set<Map.Entry<String, String>> entries = hm.entrySet();\n        //把entries变成一个数组\n        Map.Entry[] arr1 = new Map.Entry[0];\n        //toArray方法在底层会比较集合的长度跟数组的长度两者的大小\n        //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组\n        //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用\n        Map.Entry[] arr2 = entries.toArray(arr1);\n        //不可变的map集合\n        Map map = Map.ofEntries(arr2);\n        map.put("bbb","222");*/\n\n\n        //Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));\n\n        Map<String, String> map = Map.copyOf(hm);\n        map.put("bbb","222");\n    }\n}','java\n  public class MyStream1 {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of("张三丰","张无忌","张翠山","王二麻子","张良","谢广坤"));\n          //list.add()\n\n          //遍历list1把以张开头的元素添加到list2中。\n          ArrayList<String> list2 = new ArrayList<>();\n          for (String s : list1) {\n              if(s.startsWith("张")){\n                  list2.add(s);\n              }\n          }\n          //遍历list2集合，把其中长度为3的元素，再添加到list3中。\n          ArrayList<String> list3 = new ArrayList<>();\n          for (String s : list2) {\n              if(s.length() == 3){\n                  list3.add(s);\n              }\n          }\n          for (String s : list3) {\n              System.out.println(s);\n          }      \n      }\n  }','java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //集合的批量添加\n          ArrayList<String> list1 = new ArrayList<>(List.of("张三丰","张无忌","张翠山","王二麻子","张良","谢广坤"));\n\n          //Stream流\n          list1.stream().filter(s->s.startsWith("张"))\n                  .filter(s->s.length() == 3)\n                  .forEach(s-> System.out.println(s));\n      }\n  }','java\n  public class StreamDemo {\n      public static void main(String[] args) {\n          //Collection体系的集合可以使用默认方法stream()生成流\n          List<String> list = new ArrayList<String>();\n          Stream<String> listStream = list.stream();\n  \n          Set<String> set = new HashSet<String>();\n          Stream<String> setStream = set.stream();\n  \n          //Map体系的集合间接的生成流\n          Map<String,Integer> map = new HashMap<String, Integer>();\n          Stream<String> keyStream = map.keySet().stream();\n          Stream<Integer> valueStream = map.values().stream();\n          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n  \n          //数组可以通过Arrays中的静态方法stream生成流\n          String[] strArray = {"hello","world","java"};\n          Stream<String> strArrayStream = Arrays.stream(strArray);\n        \n        \t//同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流\n          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");\n          Stream<Integer> intStream = Stream.of(10, 20, 30);\n      }\n  }','java\n  public class MyStream3 {\n      public static void main(String[] args) {\n  //        Stream<T> filter(Predicate predicate)：过滤\n  //        Predicate接口中的方法\tboolean test(T t)：对给定的参数进行判断，返回一个布尔值\n\n          ArrayList<String> list = new ArrayList<>();\n          list.add("张三丰");\n          list.add("张无忌");\n          list.add("张翠山");\n          list.add("王二麻子");\n          list.add("张良");\n          list.add("谢广坤");\n\n          //filter方法获取流中的 每一个数据.\n          //而test方法中的s,就依次表示流中的每一个数据.\n          //我们只要在test方法中对s进行判断就可以了.\n          //如果判断的结果为true,则当前的数据留下\n          //如果判断的结果为false,则当前数据就不要.\n  //        list.stream().filter(\n  //                new Predicate<String>() {\n  //                    @Override\n  //                    public boolean test(String s) {\n  //                        boolean result = s.startsWith("张");\n  //                        return result;\n  //                    }\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          //因为Predicate接口中只有一个抽象方法test\n          //所以我们可以使用lambda表达式来简化\n  //        list.stream().filter(\n  //                (String s)->{\n  //                    boolean result = s.startsWith("张");\n  //                        return result;\n  //                }\n  //        ).forEach(s-> System.out.println(s));\n\n          list.stream().filter(s ->s.startsWith("张")).forEach(s-> System.out.println(s));\n\n      }\n  }','java\n  public class StreamDemo02 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n\n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n\n          //需求1：取前3个数据在控制台输出\n          list.stream().limit(3).forEach(s-> System.out.println(s));\n          System.out.println("--------");\n\n          //需求2：跳过3个元素，把剩下的元素在控制台输出\n          list.stream().skip(3).forEach(s-> System.out.println(s));\n          System.out.println("--------");\n\n          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n          list.stream().skip(2).limit(2).forEach(s-> System.out.println(s));\n      }\n  }','java\n  public class StreamDemo03 {\n      public static void main(String[] args) {\n          //创建一个集合，存储多个字符串元素\n          ArrayList<String> list = new ArrayList<String>();\n  \n          list.add("林青霞");\n          list.add("张曼玉");\n          list.add("王祖贤");\n          list.add("柳岩");\n          list.add("张敏");\n          list.add("张无忌");\n  \n          //需求1：取前4个数据组成一个流\n          Stream<String> s1 = list.stream().limit(4);\n  \n          //需求2：跳过2个数据组成一个流\n          Stream<String> s2 = list.stream().skip(2);\n  \n          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n  //        Stream.concat(s1,s2).forEach(s-> System.out.println(s));\n  \n          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n          Stream.concat(s1,s2).distinct().forEach(s-> System.out.println(s));\n      }\n  }','java\n  public class MyStream5 {\n      public static void main(String[] args) {\n          ArrayList<String> list = new ArrayList<>();\n          list.add("张三丰");\n          list.add("张无忌");\n          list.add("张翠山");\n          list.add("王二麻子");\n          list.add("张良");\n          list.add("谢广坤");\n  \n          //method1(list);\n          \n  //        long count()：返回此流中的元素数\n          long count = list.stream().count();\n          System.out.println(count);\n      }\n  \n      private static void method1(ArrayList<String> list) {\n          //  void forEach(Consumer action)：对此流的每个元素执行操作\n          //  Consumer接口中的方法void accept(T t)：对给定的参数执行此操作\n          //在forEach方法的底层,会循环获取到流中的每一个数据.\n          //并循环调用accept方法,并把每一个数据传递给accept方法\n          //s就依次表示了流中的每一个数据.\n          //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了.\n          list.stream().forEach(\n                  new Consumer<String>() {\n                      @Override\n                      public void accept(String s) {\n                          System.out.println(s);\n                      }\n                  }\n          );\n        \n          System.out.println("====================");\n          //lambda表达式的简化格式\n          //是因为Consumer接口中,只有一个accept方法\n          list.stream().forEach(\n                  (String s)->{\n                      System.out.println(s);\n                  }\n          );\n          System.out.println("====================");\n          //lambda表达式还是可以进一步简化的.\n          list.stream().forEach(s->System.out.println(s));\n      }\n  }','java\n  // toList和toSet方法演示 \n  public class MyStream7 {\n      public static void main(String[] args) {\n          ArrayList<Integer> list1 = new ArrayList<>();\n          for (int i = 1; i <= 10; i++) {\n              list1.add(i);\n          }\n  \n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n          list1.add(10);\n  \n          //filter负责过滤数据的.\n          //collect负责收集数据.\n                  //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中.\n          //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中.\n          List<Integer> list = list1.stream().filter(number -> number % 2 == 0)\n                  .collect(Collectors.toList());\n  \n          System.out.println(list);\n  \n      Set<Integer> set = list1.stream().filter(number -> number % 2 == 0)\n              .collect(Collectors.toSet());\n      System.out.println(set);\n  }\n  }\n  /**\n  Stream流的收集方法 toMap方法演示\n  创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄\n  "zhangsan,23"\n  "lisi,24"\n  "wangwu,25"\n  保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值\n  */\n  public class MyStream8 {\n  \tpublic static void main(String[] args) {\n        \tArrayList<String> list = new ArrayList<>();\n          list.add("zhangsan,23");\n          list.add("lisi,24");\n          list.add("wangwu,25");\n  \n          Map<String, Integer> map = list.stream().filter(\n                  s -> {\n                      String[] split = s.split(",");\n                      int age = Integer.parseInt(split[1]);\n                      return age >= 24;\n                  }\n  \n           //   collect方法只能获取到流中剩余的每一个数据.\n           //在底层不能创建容器,也不能把数据添加到容器当中\n  \n           //Collectors.toMap 创建一个map集合并将数据添加到集合当中\n  \n            // s 依次表示流中的每一个数据\n  \n            //第一个lambda表达式就是如何获取到Map中的键\n            //第二个lambda表达式就是如何获取Map中的值\n          ).collect(Collectors.toMap(\n                  s -> s.split(",")[0],\n                  s -> Integer.parseInt(s.split(",")[1]) ));\n  \n          System.out.println(map);\n  \t}\n  }',"java\n  public class Actor {\n      private String name;\n  \n      public Actor(String name) {\n          this.name = name;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  }",'java\n  public class StreamTest {\n      public static void main(String[] args) {\n          //创建集合\n          ArrayList<String> manList = new ArrayList<String>();\n          manList.add("周润发");\n          manList.add("成龙");\n          manList.add("刘德华");\n          manList.add("吴京");\n          manList.add("周星驰");\n          manList.add("李连杰");\n    \n          ArrayList<String> womanList = new ArrayList<String>();\n          womanList.add("林心如");\n          womanList.add("张曼玉");\n          womanList.add("林青霞");\n          womanList.add("柳岩");\n          womanList.add("林志玲");\n          womanList.add("王祖贤");\n    \n          //男演员只要名字为3个字的前三人\n          Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3);\n    \n          //女演员只要姓林的，并且不要第一个\n          Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith("林")).skip(1);\n    \n          //把过滤后的男演员姓名和女演员姓名合并到一起\n          Stream<String> stream = Stream.concat(manStream, womanStream);\n    \n        \t// 将流中的数据封装成Actor对象之后打印\n        \tstream.forEach(name -> {\n              Actor actor = new Actor(name);\n              System.out.println(actor);\n          }); \n      }\n  }','java\n  public interface Printable {\n      void printString(String s);\n  }\n  \n  public class PrintableDemo {\n      public static void main(String[] args) {\n          //在主方法中调用usePrintable方法\n  //        usePrintable((String s) -> {\n  //            System.out.println(s);\n  //        });\n  \t    //Lambda简化写法\n          usePrintable(s -> System.out.println(s));\n  \n          //方法引用\n          usePrintable(System.out::println);\n  \n      }\n  \n      private static void usePrintable(Printable p) {\n          p.printString("爱生活爱Java");\n      }\n  }','java\n  public interface Converter {\n      int convert(String s);\n  }\n  \n  public class ConverterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda写法\n          useConverter(s -> Integer.parseInt(s));\n  \n          //引用类方法\n          useConverter(Integer::parseInt);\n  \n      }\n  \n      private static void useConverter(Converter c) {\n          int number = c.convert("666");\n          System.out.println(number);\n      }\n  }','java\n  public class PrintString {\n      //把字符串参数变成大写的数据，然后在控制台输出\n      public void printUpper(String s) {\n          String result = s.toUpperCase();\n          System.out.println(result);\n      }\n  }\n  \n  public interface Printer {\n      void printUpperCase(String s);\n  }\n  \n  public class PrinterDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          usePrinter(s -> System.out.println(s.toUpperCase()));\n  \n          //引用对象的实例方法\n          PrintString ps = new PrintString();\n          usePrinter(ps::printUpper);\n  \n      }\n  \n      private static void usePrinter(Printer p) {\n          p.printUpperCase("HelloWorld");\n      }\n  }','java\n  public interface MyString {\n      String mySubString(String s,int x,int y);\n  }\n  \n  public class MyStringDemo {\n      public static void main(String[] args) {\n  \t\t//Lambda简化写法\n          useMyString((s,x,y) -> s.substring(x,y));\n  \n          //引用类的实例方法\n          useMyString(String::substring);\n  \n      }\n  \n      private static void useMyString(MyString my) {\n          String s = my.mySubString("HelloWorld", 2, 5);\n          System.out.println(s);\n      }\n  }','java\n  public class Student {\n      private String name;\n      private int age;\n  \n      public Student() {\n      }\n  \n      public Student(String name, int age) {\n          this.name = name;\n          this.age = age;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public int getAge() {\n          return age;\n      }\n  \n      public void setAge(int age) {\n          this.age = age;\n      }\n  }\n  \n  public interface StudentBuilder {\n      Student build(String name,int age);\n  }\n  \n  public class StudentDemo {\n      public static void main(String[] args) {\n  \n  \t\t//Lambda简化写法\n          useStudentBuilder((name,age) -> new Student(name,age));\n  \n          //引用构造器\n          useStudentBuilder(Student::new);\n  \n      }\n  \n      private static void useStudentBuilder(StudentBuilder sb) {\n          Student s = sb.build("林青霞", 30);\n          System.out.println(s.getName() + "," + s.getAge());\n      }\n  }']},{title:"IO(异常&File&综合案例）",headers:[{level:2,title:"1.1 异常概念",slug:"_1-1-异常概念",link:"#_1-1-异常概念",children:[]},{level:2,title:"1.2 异常体系",slug:"_1-2-异常体系",link:"#_1-2-异常体系",children:[]},{level:2,title:"1.3 异常分类",slug:"_1-3-异常分类",link:"#_1-3-异常分类",children:[]},{level:2,title:"1.4 异常的产生过程解析",slug:"_1-4-异常的产生过程解析",link:"#_1-4-异常的产生过程解析",children:[]},{level:2,title:"1.5 抛出异常throw",slug:"_1-5-抛出异常throw",link:"#_1-5-抛出异常throw",children:[]},{level:2,title:"1.6 声明异常throws",slug:"_1-6-声明异常throws",link:"#_1-6-声明异常throws",children:[]},{level:2,title:"1.7 捕获异常try…catch",slug:"_1-7-捕获异常try-catch",link:"#_1-7-捕获异常try-catch",children:[]},{level:2,title:"1.8 finally 代码块",slug:"_1-8-finally-代码块",link:"#_1-8-finally-代码块",children:[]},{level:2,title:"1.9 异常注意事项",slug:"_1-9-异常注意事项",link:"#_1-9-异常注意事项",children:[]},{level:2,title:"1.10 概述",slug:"_1-10-概述",link:"#_1-10-概述",children:[]},{level:2,title:"1.11 自定义异常的练习",slug:"_1-11-自定义异常的练习",link:"#_1-11-自定义异常的练习",children:[]},{level:2,title:"2.1 概述",slug:"_2-1-概述",link:"#_2-1-概述",children:[]},{level:2,title:"2.2 构造方法",slug:"_2-2-构造方法",link:"#_2-2-构造方法",children:[]},{level:2,title:"2.3 常用方法",slug:"_2-3-常用方法",link:"#_2-3-常用方法",children:[{level:3,title:"获取功能的方法",slug:"获取功能的方法",link:"#获取功能的方法",children:[]},{level:3,title:"绝对路径和相对路径",slug:"绝对路径和相对路径",link:"#绝对路径和相对路径",children:[]},{level:3,title:"判断功能的方法",slug:"判断功能的方法",link:"#判断功能的方法",children:[]},{level:3,title:"创建删除功能的方法",slug:"创建删除功能的方法",link:"#创建删除功能的方法",children:[]}]},{level:2,title:"2.4 目录的遍历",slug:"_2-4-目录的遍历",link:"#_2-4-目录的遍历",children:[]},{level:2,title:"2.5 综合练习",slug:"_2-5-综合练习",link:"#_2-5-综合练习",children:[{level:3,title:"练习3：（考虑子文件夹）",slug:"练习3-考虑子文件夹",link:"#练习3-考虑子文件夹",children:[]},{level:3,title:"练习4：删除多级文件夹",slug:"练习4-删除多级文件夹",link:"#练习4-删除多级文件夹",children:[]},{level:3,title:"练习5：统计大小",slug:"练习5-统计大小",link:"#练习5-统计大小",children:[]},{level:3,title:"练习6：统计文件个数",slug:"练习6-统计文件个数",link:"#练习6-统计文件个数",children:[]}]}],path:"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html",pathLocale:"/",extraFields:["java\npublic class ArrayTools {\n    // 对给定的数组通过给定的角标获取元素。\n    public static int getElement(int[] arr, int index) {\n        int element = arr[index];\n        return element;\n    }\n}",'java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        int[] arr = { 34, 12, 67 };\n        intnum = ArrayTools.getElement(arr, 4)\n        System.out.println("num=" + num);\n        System.out.println("over");\n    }\n}',"throw new 异常类名(参数);",'java\nthrow new NullPointerException("要访问的arr数组不存在");\n\nthrow new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");','java\npublic class ThrowDemo {\n    public static void main(String[] args) {\n        //创建一个数组 \n        int[] arr = {2,4,52,2};\n        //根据索引找对应的元素 \n        int index = 4;\n        int element = getElement(arr, index);\n\n        System.out.println(element);\n        System.out.println("over");\n    }\n    /*\n     * 根据 索引找到数组中对应的元素\n     */\n    public static int getElement(int[] arr,int index){ \n       \t//判断  索引是否越界\n        if(index<0 || index>arr.length-1){\n             /*\n             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。\n             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 \n              */\n             throw new ArrayIndexOutOfBoundsException("哥们，角标越界了',"> 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。\n>\n> 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。\n\n## 1.6 声明异常throws\n\n**声明异常**：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\n\n关键字**throws**运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\n\n**声明异常格式：**","声明异常的代码演示：","throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。","## 1.7 捕获异常try…catch\n\n如果异常出现的话,会立刻终止程序,所以我们得处理异常:\n\n1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\n2. 在方法中使用try-catch的语句块来处理异常。\n\n**try-catch**的方式就是捕获异常。\n\n* **捕获异常**：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\n\n捕获异常语法如下：","**try：**该代码块中编写可能产生异常的代码。\n\n**catch：**用来进行某种异常的捕获，实现对捕获到的异常进行处理。\n\n> 注意:try和catch都不能单独使用,必须连用。\n\n演示如下：","如何获取异常信息：\n\nThrowable类中定义了一些查看方法:\n\n* `public String getMessage()`:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。\n\n\n* `public String toString()`:获取异常的类型和异常描述信息(不用)。\n* `public void printStackTrace()`:打印异常的跟踪栈信息并输出到控制台。\n\n​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。*\n\n在开发中呢也可以在catch将编译期异常转换成运行期异常处理。\n\n多个异常使用捕获又该如何处理呢？\n\n1. 多个异常分别处理。\n2. 多个异常一次捕获，多次处理。\n3. 多个异常一次捕获一次处理。\n\n一般我们是使用一次捕获多次处理方式，格式如下：","> 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。\n\n## 1.8 finally 代码块\n\n**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。\n\n什么时候的代码必须最终执行？\n\n当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\n\nfinally的语法:\n\n try...catch....finally:自身需要处理异常,最终还得关闭资源。\n\n> 注意:finally不能单独使用。\n\n比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\n\nfinally代码参考如下：","> 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\n\n## 1.9 异常注意事项\n\n* 运行时异常被抛出可以不处理。即不捕获也不声明抛出。\n* 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。\n* 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\n* 当多异常处理时，捕获处理，前边的类不能是后边类的父类\n* 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。\n\n## 1.10 概述\n\n**为什么需要自定义异常类:**\n\n我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。\n\n在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？\n\n**什么是自定义异常类:**\n\n在开发中根据自己业务的异常情况来定义异常类.\n\n自定义一个业务逻辑异常: **LoginException**。一个登陆异常类。\n\n**异常类如何定义:**\n\n1. 自定义一个编译期异常: 自定义类 并继承于`java.lang.Exception`。\n2. 自定义一个运行时期的异常类:自定义类 并继承于`java.lang.RuntimeException`。\n\n## 1.11 自定义异常的练习\n\n要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。\n\n首先定义一个登陆异常类LoginException：","模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。","# 2. File类\n\n## 2.1 概述\n\n`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n## 2.2 构造方法\n\n- `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n- `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n- `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n- 构造举例，代码如下：","> 小贴士：\n>\n> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n## 2.3 常用方法\n\n### 获取功能的方法\n\n- `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。\n\n- ` public String getPath() ` ：将此File转换为路径名字符串。 \n\n- `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n- `public long length()`  ：返回由此File表示的文件的长度。 \n\n  方法演示，代码如下：","> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n### 绝对路径和相对路径\n\n- **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n- **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。","### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n方法演示，代码如下：","### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n方法演示，代码如下：","> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n## 2.4 目录的遍历\n\n- `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n- `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。","> 小贴士：\n>\n> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。\n\n## 2.5 综合练习\n\n#### 练习1：创建文件夹\n\n​\t在当前模块下的aaa文件夹中创建一个a.txt文件\n\n代码实现：","#### 练习2：查找文件（不考虑子文件夹）\n\n​\t定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹）\n\n代码示例：","### 练习3：（考虑子文件夹）\n\n​\t找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）\n\n代码示例：","### 练习4：删除多级文件夹\n\n需求： 如果我们要删除一个有内容的文件夹\n\t   1.先删除文件夹里面所有的内容\n           2.再删除自己\n\n代码示例：","### 练习5：统计大小\n\n​\t需求：统计一个文件夹的总大小\n\n代码示例：","### 练习6：统计文件个数\n\n  需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）\n            打印格式如下：\n            txt:3个\n            doc:4个\n            jpg:6个\n\n代码示例：",""]},{title:"IO流（字节流&字符流）",headers:[{level:2,title:"1.1 什么是IO",slug:"_1-1-什么是io",link:"#_1-1-什么是io",children:[]},{level:2,title:"1.2 IO的分类",slug:"_1-2-io的分类",link:"#_1-2-io的分类",children:[]},{level:2,title:"1.3 IO的流向说明图解",slug:"_1-3-io的流向说明图解",link:"#_1-3-io的流向说明图解",children:[]},{level:2,title:"1.4 顶级父类们",slug:"_1-4-顶级父类们",link:"#_1-4-顶级父类们",children:[]},{level:2,title:"2.1 一切皆为字节",slug:"_2-1-一切皆为字节",link:"#_2-1-一切皆为字节",children:[]},{level:2,title:"2.2 字节输出流【OutputStream】",slug:"_2-2-字节输出流【outputstream】",link:"#_2-2-字节输出流【outputstream】",children:[]},{level:2,title:"2.3 FileOutputStream类",slug:"_2-3-fileoutputstream类",link:"#_2-3-fileoutputstream类",children:[{level:3,title:"构造方法",slug:"构造方法",link:"#构造方法",children:[]},{level:3,title:"写出字节数据",slug:"写出字节数据",link:"#写出字节数据",children:[]},{level:3,title:"数据追加续写",slug:"数据追加续写",link:"#数据追加续写",children:[]},{level:3,title:"写出换行",slug:"写出换行",link:"#写出换行",children:[]}]},{level:2,title:"2.4 字节输入流【InputStream】",slug:"_2-4-字节输入流【inputstream】",link:"#_2-4-字节输入流【inputstream】",children:[]},{level:2,title:"2.5 FileInputStream类",slug:"_2-5-fileinputstream类",link:"#_2-5-fileinputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-1",link:"#构造方法-1",children:[]},{level:3,title:"读取字节数据",slug:"读取字节数据",link:"#读取字节数据",children:[]}]},{level:2,title:"2.6 字节流练习：图片复制",slug:"_2-6-字节流练习-图片复制",link:"#_2-6-字节流练习-图片复制",children:[{level:3,title:"复制原理图解",slug:"复制原理图解",link:"#复制原理图解",children:[]},{level:3,title:"案例实现",slug:"案例实现",link:"#案例实现",children:[]}]},{level:2,title:"3.1 字符输入流【Reader】",slug:"_3-1-字符输入流【reader】",link:"#_3-1-字符输入流【reader】",children:[]},{level:2,title:"3.2 FileReader类",slug:"_3-2-filereader类",link:"#_3-2-filereader类",children:[{level:3,title:"构造方法",slug:"构造方法-2",link:"#构造方法-2",children:[]},{level:3,title:"读取字符数据",slug:"读取字符数据",link:"#读取字符数据",children:[]}]},{level:2,title:"3.3 字符输出流【Writer】",slug:"_3-3-字符输出流【writer】",link:"#_3-3-字符输出流【writer】",children:[]},{level:2,title:"3.4 FileWriter类",slug:"_3-4-filewriter类",link:"#_3-4-filewriter类",children:[{level:3,title:"构造方法",slug:"构造方法-3",link:"#构造方法-3",children:[]},{level:3,title:"基本写出数据",slug:"基本写出数据",link:"#基本写出数据",children:[]},{level:3,title:"关闭和刷新",slug:"关闭和刷新",link:"#关闭和刷新",children:[]},{level:3,title:"写出其他数据",slug:"写出其他数据",link:"#写出其他数据",children:[]},{level:3,title:"JDK7前处理",slug:"jdk7前处理",link:"#jdk7前处理",children:[]},{level:3,title:"JDK7的处理(扩展知识点了解内容)",slug:"jdk7的处理-扩展知识点了解内容",link:"#jdk7的处理-扩展知识点了解内容",children:[]},{level:3,title:"JDK9的改进(扩展知识点了解内容)",slug:"jdk9的改进-扩展知识点了解内容",link:"#jdk9的改进-扩展知识点了解内容",children:[]}]},{level:2,title:"练习1：拷贝文件夹",slug:"练习1-拷贝文件夹",link:"#练习1-拷贝文件夹",children:[]},{level:2,title:"练习2：文件加密",slug:"练习2-文件加密",link:"#练习2-文件加密",children:[]},{level:2,title:"练习3：数字排序",slug:"练习3-数字排序",link:"#练习3-数字排序",children:[]}],path:"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html",pathLocale:"/",extraFields:['java\npublic class FileOutputStreamConstructor throws IOException {\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileOutputStream fos = new FileOutputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("b.txt");\n    }\n}','java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 写出数据\n      \tfos.write(97); // 写出第1个字节\n      \tfos.write(98); // 写出第2个字节\n      \tfos.write(99); // 写出第3个字节\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\nabc','java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "黑马程序员".getBytes();\n      \t// 写出字节数组数据\n      \tfos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\n黑马程序员','java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "abcde".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\ncd','java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt"，true);     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = "abcde".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b);\n      \t// 关闭资源\n        fos.close();\n    }\n}\n文件操作前：cd\n文件操作后：cdabcde','java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream("fos.txt");  \n      \t// 定义字节数组\n      \tbyte[] words = {97,98,99,100,101};\n      \t// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          \t// 写出一个字节\n            fos.write(words[i]);\n          \t// 写出一个换行, 换行符号转成数组写出\n            fos.write("\\r\\n".getBytes());\n        }\n      \t// 关闭资源\n        fos.close();\n    }\n}\n\n输出结果：\na\nb\nc\nd\ne','java\npublic class FileInputStreamConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileInputStream fos = new FileInputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileInputStream fos = new FileInputStream("b.txt");\n    }\n}','java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream("read.txt");\n      \t// 读取数据，返回一个字节\n        int read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n      \t// 读取到末尾,返回-1\n       \tread = fis.read();\n        System.out.println( read);\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n-1','java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象\n       \tFileInputStream fis = new FileInputStream("read.txt");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fis.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne','java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组变成字符串打印\n            System.out.println(new String(b));\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ned','java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne','java\npublic class Copy {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 指定数据源\n        FileInputStream fis = new FileInputStream("D:\\\\test.jpg");\n        // 1.2 指定目的地\n        FileOutputStream fos = new FileOutputStream("test_copy.jpg");\n\n        // 2.读写数据\n        // 2.1 定义数组\n        byte[] b = new byte[1024];\n        // 2.2 定义长度\n        int len;\n        // 2.3 循环读取\n        while ((len = fis.read(b))!=-1) {\n            // 2.4 写出数据\n            fos.write(b, 0 , len);\n        }\n\n        // 3.关闭资源\n        fos.close();\n        fis.close();\n    }\n}','java\npublic class FileReaderConstructor throws IOException{\n    public static void main(String[] args) {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileReader fr = new FileReader(file);\n      \n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader("b.txt");\n    }\n}','java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fr.read())!=-1) {\n            System.out.println((char)b);\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑\n马\n程\n序\n员','java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n         char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf));\n        }\n\t\t// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑马\n程序\n员序','java\npublic class FISRead {\n    public static void main(String[] args) throws IOException {\n      \t// 使用文件名称创建流对象\n       \tFileReader fr = new FileReader("read.txt");\n      \t// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n        char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf,0,len));\n        }\n    \t// 关闭资源\n        fr.close();\n    }\n}\n\n输出结果：\n黑马\n程序\n员','java\npublic class FileWriterConstructor {\n    public static void main(String[] args) throws IOException {\n   \t \t// 使用File对象创建流对象\n        File file = new File("a.txt");\n        FileWriter fw = new FileWriter(file);\n      \n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter("b.txt");\n    }\n}',"java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 写出数据\n      \tfw.write(97); // 写出第1个字符\n      \tfw.write('b'); // 写出第2个字符\n      \tfw.write('C'); // 写出第3个字符\n      \tfw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。\n      \n      \t/*\n        【注意】关闭资源时,与FileOutputStream不同。\n      \t 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n        */\n        // fw.close();\n    }\n}\n输出结果：\nabC田","java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        // 写出数据，通过flush\n        fw.write('刷'); // 写出第1个字符\n        fw.flush();\n        fw.write('新'); // 继续写出第2个字符，写出成功\n        fw.flush();\n      \n      \t// 写出数据，通过close\n        fw.write('关'); // 写出第1个字符\n        fw.close();\n        fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n        fw.close();\n    }\n}","java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串转换为字节数组\n      \tchar[] chars = \"黑马程序员\".toCharArray();\n      \n      \t// 写出字符数组\n      \tfw.write(chars); // 黑马程序员\n        \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(b,2,2); // 程序\n      \n      \t// 关闭资源\n        fos.close();\n    }\n}","java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      \t// 字符串\n      \tString msg = \"黑马程序员\";\n      \n      \t// 写出字符数组\n      \tfw.write(msg); //黑马程序员\n      \n\t\t// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。\n        fw.write(msg,2,2);\t// 程序\n      \t\n        // 关闭资源\n        fos.close();\n    }\n}",'java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter("fw.txt"，true);     \n      \t// 写出字符串\n        fw.write("黑马");\n      \t// 写出换行\n      \tfw.write("\\r\\n");\n      \t// 写出字符串\n  \t\tfw.write("程序员");\n      \t// 关闭资源\n        fw.close();\n    }\n}\n输出结果:\n黑马\n程序员','java  \npublic class HandleException1 {\n    public static void main(String[] args) {\n      \t// 声明变量\n        FileWriter fw = null;\n        try {\n            //创建流对象\n            fw = new FileWriter("fw.txt");\n            // 写出数据\n            fw.write("黑马程序员"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}',"java\ntry (创建流对象语句，如果多个,使用';'隔开) {\n\t// 读写数据\n} catch (IOException e) {\n\te.printStackTrace();\n}",'java\npublic class HandleException2 {\n    public static void main(String[] args) {\n      \t// 创建流对象\n        try ( FileWriter fw = new FileWriter("fw.txt"); ) {\n            // 写出数据\n            fw.write("黑马程序员"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}','java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource("resource1");\n// 普通对象\nResource resource2 = new Resource("resource2");\n// 引入方式：创建新的变量保存\ntry (Resource r1 = resource1;\n     Resource r2 = resource2) {\n     // 使用对象\n}','java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource("resource1");\n// 普通对象\nResource resource2 = new Resource("resource2");\n\n// 引入方式：直接引入\ntry (resource1; resource2) {\n     // 使用对象\n}','java\npublic class TryDemo {\n    public static void main(String[] args) throws IOException {\n       \t// 创建流对象\n        final  FileReader fr  = new FileReader("in.txt");\n        FileWriter fw = new FileWriter("out.txt");\n       \t// 引入到try中\n        try (fr; fw) {\n          \t// 定义变量\n            int b;\n          \t// 读取数据\n          \twhile ((b = fr.read())!=-1) {\n            \t// 写出数据\n            \tfw.write(b);\n          \t}\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}','java\npublic class Test01 {\n    public static void main(String[] args) throws IOException {\n        //拷贝一个文件夹，考虑子文件夹\n\n        //1.创建对象表示数据源\n        File src = new File("D:\\\\aaa\\\\src");\n        //2.创建对象表示目的地\n        File dest = new File("D:\\\\aaa\\\\dest");\n\n        //3.调用方法开始拷贝\n        copydir(src,dest);\n\n\n\n    }\n\n    /*\n    * 作用：拷贝文件夹\n    * 参数一：数据源\n    * 参数二：目的地\n    *\n    * */\n    private static void copydir(File src, File dest) throws IOException {\n        dest.mkdirs();\n        //递归\n        //1.进入数据源\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断文件，拷贝\n                FileInputStream fis = new FileInputStream(file);\n                FileOutputStream fos = new FileOutputStream(new File(dest,file.getName()));\n                byte[] bytes = new byte[1024];\n                int len;\n                while((len = fis.read(bytes)) != -1){\n                    fos.write(bytes,0,len);\n                }\n                fos.close();\n                fis.close();\n            }else {\n                //4.判断文件夹，递归\n                copydir(file, new File(dest,file.getName()));\n            }\n        }\n    }\n}',"java\npublic class Test02 {\n    public static void main(String[] args) throws IOException {\n        /*\n            为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。\n            加密原理：\n                对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。\n            解密原理：\n                读取加密之后的文件，按照加密的规则反向操作，变成原始文件。\n\n             ^ : 异或\n                 两边相同：false\n                 两边不同：true\n\n                 0：false\n                 1：true\n\n               100:1100100\n               10: 1010\n\n               1100100\n             ^ 0001010\n             __________\n               1101110\n             ^ 0001010\n             __________\n               1100100\n\n        */\n    }\n\n    public static void encryptionAndReduction(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while ((b = fis.read()) != -1) {\n            fos.write(b ^ 2);\n        }\n        //4.释放资源\n        fos.close();\n        fis.close();\n    }\n\n\n}",'java\npublic class Test03 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n        */\n\n\n        //1.读取数据\n        FileReader fr = new FileReader("myio\\\\a.txt");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        String str = sb.toString();\n        String[] arrStr = str.split("-");//2-1-9-4-7-8\n\n        ArrayList<Integer> list = new ArrayList<>();\n        for (String s : arrStr) {\n            int i = Integer.parseInt(s);\n            list.add(i);\n        }\n        Collections.sort(list);\n        System.out.println(list);\n        //3.写出\n        FileWriter fw = new FileWriter("myio\\\\a.txt");\n        for (int i = 0; i < list.size(); i++) {\n            if(i == list.size() - 1){\n                fw.write(list.get(i) + "");\n            }else{\n                fw.write(list.get(i) + "-");\n            }\n        }\n        fw.close();\n    }\n}','java\npublic class Test04 {\n    public static void main(String[] args) throws IOException {\n        /*\n            文本文件中有以下的数据：\n                2-1-9-4-7-8\n            将文件中的数据进行排序，变成以下的数据：\n                1-2-4-7-8-9\n\n           细节1：\n                文件中的数据不要换行\n\n            细节2:\n                bom头\n        */\n        //1.读取数据\n        FileReader fr = new FileReader("myio\\\\a.txt");\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while((ch = fr.read()) != -1){\n            sb.append((char)ch);\n        }\n        fr.close();\n        System.out.println(sb);\n        //2.排序\n        Integer[] arr = Arrays.stream(sb.toString()\n                                      .split("-"))\n            .map(Integer::parseInt)\n            .sorted()\n            .toArray(Integer[]::new);\n        //3.写出\n        FileWriter fw = new FileWriter("myio\\\\a.txt");\n        String s = Arrays.toString(arr).replace(", ","-");\n        String result = s.substring(1, s.length() - 1);\n        fw.write(result);\n        fw.close();\n    }\n}']},{title:"IO流（其他流）",headers:[{level:2,title:"1.1 概述",slug:"_1-1-概述",link:"#_1-1-概述",children:[]},{level:2,title:"1.2 字节缓冲流",slug:"_1-2-字节缓冲流",link:"#_1-2-字节缓冲流",children:[{level:3,title:"构造方法",slug:"构造方法",link:"#构造方法",children:[]},{level:3,title:"效率测试",slug:"效率测试",link:"#效率测试",children:[]}]},{level:2,title:"1.3 字符缓冲流",slug:"_1-3-字符缓冲流",link:"#_1-3-字符缓冲流",children:[{level:3,title:"构造方法",slug:"构造方法-1",link:"#构造方法-1",children:[]},{level:3,title:"特有方法",slug:"特有方法",link:"#特有方法",children:[]}]},{level:2,title:"1.4 练习:文本排序",slug:"_1-4-练习-文本排序",link:"#_1-4-练习-文本排序",children:[{level:3,title:"案例分析",slug:"案例分析",link:"#案例分析",children:[]},{level:3,title:"案例实现",slug:"案例实现",link:"#案例实现",children:[]}]},{level:2,title:"2.1 字符编码和字符集",slug:"_2-1-字符编码和字符集",link:"#_2-1-字符编码和字符集",children:[{level:3,title:"字符编码",slug:"字符编码",link:"#字符编码",children:[]},{level:3,title:"字符集",slug:"字符集",link:"#字符集",children:[]}]},{level:2,title:"2.2 编码引出的问题",slug:"_2-2-编码引出的问题",link:"#_2-2-编码引出的问题",children:[]},{level:2,title:"2.3 InputStreamReader类",slug:"_2-3-inputstreamreader类",link:"#_2-3-inputstreamreader类",children:[{level:3,title:"构造方法",slug:"构造方法-2",link:"#构造方法-2",children:[]},{level:3,title:"指定编码读取",slug:"指定编码读取",link:"#指定编码读取",children:[]}]},{level:2,title:"2.4 OutputStreamWriter类",slug:"_2-4-outputstreamwriter类",link:"#_2-4-outputstreamwriter类",children:[{level:3,title:"构造方法",slug:"构造方法-3",link:"#构造方法-3",children:[]},{level:3,title:"指定编码写出",slug:"指定编码写出",link:"#指定编码写出",children:[]},{level:3,title:"转换流理解图解",slug:"转换流理解图解",link:"#转换流理解图解",children:[]}]},{level:2,title:"2.5 练习：转换文件编码",slug:"_2-5-练习-转换文件编码",link:"#_2-5-练习-转换文件编码",children:[{level:3,title:"案例分析",slug:"案例分析-1",link:"#案例分析-1",children:[]},{level:3,title:"案例实现",slug:"案例实现-1",link:"#案例实现-1",children:[]}]},{level:2,title:"3.1 概述",slug:"_3-1-概述",link:"#_3-1-概述",children:[]},{level:2,title:"3.2 ObjectOutputStream类",slug:"_3-2-objectoutputstream类",link:"#_3-2-objectoutputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-4",link:"#构造方法-4",children:[]},{level:3,title:"序列化操作",slug:"序列化操作",link:"#序列化操作",children:[]}]},{level:2,title:"3.3 ObjectInputStream类",slug:"_3-3-objectinputstream类",link:"#_3-3-objectinputstream类",children:[{level:3,title:"构造方法",slug:"构造方法-5",link:"#构造方法-5",children:[]},{level:3,title:"反序列化操作1",slug:"反序列化操作1",link:"#反序列化操作1",children:[]},{level:3,title:"反序列化操作2",slug:"反序列化操作2",link:"#反序列化操作2",children:[]}]},{level:2,title:"3.4 练习：序列化集合",slug:"_3-4-练习-序列化集合",link:"#_3-4-练习-序列化集合",children:[{level:3,title:"案例分析",slug:"案例分析-2",link:"#案例分析-2",children:[]},{level:3,title:"案例实现",slug:"案例实现-2",link:"#案例实现-2",children:[]}]},{level:2,title:"4.1 概述",slug:"_4-1-概述",link:"#_4-1-概述",children:[]},{level:2,title:"4.2 PrintStream类",slug:"_4-2-printstream类",link:"#_4-2-printstream类",children:[{level:3,title:"构造方法",slug:"构造方法-6",link:"#构造方法-6",children:[]},{level:3,title:"改变打印流向",slug:"改变打印流向",link:"#改变打印流向",children:[]}]}],path:"/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89.html",pathLocale:"/",extraFields:['java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt"));','java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tFileInputStream fis = new FileInputStream("jdk9.exe");\n        \tFileOutputStream fos = new FileOutputStream("copy.exe")\n        ){\n        \t// 读写数据\n            int b;\n            while ((b = fis.read()) != -1) {\n                fos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("普通流复制时间:"+(end - start)+" 毫秒");\n    }\n}\n\n十几分钟过去了...','java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      \tlong start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n        \tBufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));\n\t     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));\n        ){\n        // 读写数据\n            int b;\n            while ((b = bis.read()) != -1) {\n                bos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("缓冲流复制时间:"+(end - start)+" 毫秒");\n    }\n}\n\n缓冲流复制时间:8016 毫秒','java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n      \t// 记录开始时间\n        long start = System.currentTimeMillis();\n\t\t// 创建流对象\n        try (\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe"));\n\t\t BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));\n        ){\n          \t// 读写数据\n            int len;\n            byte[] bytes = new byte[8*1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0 , len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\t\t// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println("缓冲流使用数组复制时间:"+(end - start)+" 毫秒");\n    }\n}\n缓冲流使用数组复制时间:666 毫秒','java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader("br.txt"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));','java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      \t // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader("in.txt"));\n\t\t// 定义字符串,保存读取的一行文字\n        String line  = null;\n      \t// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println("------");\n        }\n\t\t// 释放资源\n        br.close();\n    }\n}','java\npublic class BufferedWriterDemo throws IOException {\n    public static void main(String[] args) throws IOException  {\n      \t// 创建流对象\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter("out.txt"));\n      \t// 写出数据\n        bw.write("黑马");\n      \t// 写出换行\n        bw.newLine();\n        bw.write("程序");\n        bw.newLine();\n        bw.write("员");\n        bw.newLine();\n\t\t// 释放资源\n        bw.close();\n    }\n}\n输出效果:\n黑马\n程序\n员',"3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。",'java\npublic class Demo05Test {\n    public static void main(String[] args) throws IOException {\n        //1.创建ArrayList集合,泛型使用String\n        ArrayList<String> list = new ArrayList<>();\n        //2.创建BufferedReader对象,构造方法中传递FileReader对象\n        BufferedReader br = new BufferedReader(new FileReader("10_IO\\\\in.txt"));\n        //3.创建BufferedWriter对象,构造方法中传递FileWriter对象\n        BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\\\out.txt"));\n        //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本\n        String line;\n        while((line = br.readLine())!=null){\n            //5.把读取到的文本存储到ArrayList集合中\n            list.add(line);\n        }\n        //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序\n        Collections.sort(list, new Comparator<String>() {\n            /*\n                o1-o2:升序\n                o2-o1:降序\n             */\n            @Override\n            public int compare(String o1, String o2) {\n                //依次比较集合中两个元素的首字母,升序排序\n                return o1.charAt(0)-o2.charAt(0);\n            }\n        });\n        //7.遍历ArrayList集合,获取每一个元素\n        for (String s : list) {\n            //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中)\n            bw.write(s);\n            //9.写换行\n            bw.newLine();\n        }\n        //10.释放资源\n        bw.close();\n        br.close();\n    }\n}','java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader("E:\\\\File_GBK.txt");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：\n���','java\nInputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");','java\npublic class ReaderDemo2 {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径,文件为gbk编码\n        String FileName = "E:\\\\file_gbk.txt";\n      \t// 创建流对象,默认UTF8编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n      \t// 创建流对象,指定GBK编码\n        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK");\n\t\t// 定义变量,保存字符\n        int read;\n      \t// 使用默认编码字符流读取,乱码\n        while ((read = isr.read()) != -1) {\n            System.out.print((char)read); // ��Һ�\n        }\n        isr.close();\n      \n      \t// 使用指定编码字符流读取,正常解析\n        while ((read = isr2.read()) != -1) {\n            System.out.print((char)read);// 大家好\n        }\n        isr2.close();\n    }\n}','java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK");','java\npublic class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径\n        String FileName = "E:\\\\out.txt";\n      \t// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      \tosw.write("你好"); // 保存为6个字节\n        osw.close();\n      \t\n\t\t// 定义文件路径\n\t\tString FileName2 = "E:\\\\out2.txt";\n     \t// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK");\n        // 写出数据\n      \tosw2.write("你好");// 保存为4个字节\n        osw2.close();\n    }\n}','java\npublic class TransDemo {\n   public static void main(String[] args) {      \n    \t// 1.定义文件路径\n     \tString srcFile = "file_gbk.txt";\n        String destFile = "file_utf8.txt";\n\t\t// 2.创建流对象\n    \t// 2.1 转换输入流,指定GBK编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK");\n    \t// 2.2 转换输出流,默认utf8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));\n\t\t// 3.读写数据\n    \t// 3.1 定义数组\n        char[] cbuf = new char[1024];\n    \t// 3.2 定义长度\n        int len;\n    \t// 3.3 循环读取\n        while ((len = isr.read(cbuf))!=-1) {\n            // 循环写出\n          \tosw.write(cbuf,0,len);\n        }\n    \t// 4.释放资源\n        osw.close();\n        isr.close();\n  \t}\n}','java\nFileOutputStream fileOut = new FileOutputStream("employee.txt");\nObjectOutputStream out = new ObjectOutputStream(fileOut);','java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age; // transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n      \tSystem.out.println("Address  check : " + name + " -- " + address);\n    }\n}','java\npublic class SerializeDemo{\n   \tpublic static void main(String [] args)   {\n    \tEmployee e = new Employee();\n    \te.name = "zhangsan";\n    \te.address = "beiqinglu";\n    \te.age = 20; \n    \ttry {\n      \t\t// 创建序列化流对象\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt"));\n        \t// 写出对象\n        \tout.writeObject(e);\n        \t// 释放资源\n        \tout.close();\n        \tfileOut.close();\n        \tSystem.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。\n        } catch(IOException i)   {\n            i.printStackTrace();\n        }\n   \t}\n}\n输出结果：\nSerialized data is saved','java\npublic class DeserializeDemo {\n   public static void main(String [] args)   {\n        Employee e = null;\n        try {\t\t\n             // 创建反序列化流\n             FileInputStream fileIn = new FileInputStream("employee.txt");\n             ObjectInputStream in = new ObjectInputStream(fileIn);\n             // 读取一个对象\n             e = (Employee) in.readObject();\n             // 释放资源\n             in.close();\n             fileIn.close();\n        }catch(IOException i) {\n             // 捕获其他异常\n             i.printStackTrace();\n             return;\n        }catch(ClassNotFoundException c)  {\n        \t// 捕获类找不到异常\n             System.out.println("Employee class not found");\n             c.printStackTrace();\n             return;\n        }\n        // 无异常,直接打印输出\n        System.out.println("Name: " + e.name);\t// zhangsan\n        System.out.println("Address: " + e.address); // beiqinglu\n        System.out.println("age: " + e.age); // 0\n    }\n}','java\npublic class Employee implements java.io.Serializable {\n     // 加入序列版本号\n     private static final long serialVersionUID = 1L;\n     public String name;\n     public String address;\n     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n     public int eid; \n\n     public void addressCheck() {\n         System.out.println("Address  check : " + name + " -- " + address);\n     }\n}','java\npublic class SerTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 创建 学生对象\n\t\tStudent student = new Student("老王", "laow");\n\t\tStudent student2 = new Student("老张", "laoz");\n\t\tStudent student3 = new Student("老李", "laol");\n\n\t\tArrayList<Student> arrayList = new ArrayList<>();\n\t\tarrayList.add(student);\n\t\tarrayList.add(student2);\n\t\tarrayList.add(student3);\n\t\t// 序列化操作\n\t\t// serializ(arrayList);\n\t\t\n\t\t// 反序列化  \n\t\tObjectInputStream ois  = new ObjectInputStream(new FileInputStream("list.txt"));\n\t\t// 读取对象,强转为ArrayList类型\n\t\tArrayList<Student> list  = (ArrayList<Student>)ois.readObject();\n\t\t\n      \tfor (int i = 0; i < list.size(); i++ ){\n          \tStudent s = list.get(i);\n        \tSystem.out.println(s.getName()+"--"+ s.getPwd());\n      \t}\n\t}\n\n\tprivate static void serializ(ArrayList<Student> arrayList) throws Exception {\n\t\t// 创建 序列化流 \n\t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("list.txt"));\n\t\t// 写出对象\n\t\toos.writeObject(arrayList);\n\t\t// 释放资源\n\t\toos.close();\n\t}\n}','java\nPrintStream ps = new PrintStream("ps.txt")；','java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n\t\t// 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n      \n\t\t// 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream("ps.txt");\n      \t\n      \t// 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n      \t// 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}','java\n/*\n*   解压缩流\n*\n* */\npublic class ZipStreamDemo1 {\n    public static void main(String[] args) throws IOException {\n\n        //1.创建一个File表示要解压的压缩包\n        File src = new File("D:\\\\aaa.zip");\n        //2.创建一个File表示解压的目的地\n        File dest = new File("D:\\\\");\n\n        //调用方法\n        unzip(src,dest);\n\n    }\n\n    //定义一个方法用来解压\n    public static void unzip(File src,File dest) throws IOException {\n        //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中\n        //创建一个解压缩流用来读取压缩包中的数据\n        ZipInputStream zip = new ZipInputStream(new FileInputStream(src));\n        //要先获取到压缩包里面的每一个zipentry对象\n        //表示当前在压缩包中获取到的文件或者文件夹\n        ZipEntry entry;\n        while((entry = zip.getNextEntry()) != null){\n            System.out.println(entry);\n            if(entry.isDirectory()){\n                //文件夹：需要在目的地dest处创建一个同样的文件夹\n                File file = new File(dest,entry.toString());\n                file.mkdirs();\n            }else{\n                //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）\n                FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));\n                int b;\n                while((b = zip.read()) != -1){\n                    //写到目的地\n                    fos.write(b);\n                }\n                fos.close();\n                //表示在压缩包中的一个文件处理完毕了。\n                zip.closeEntry();\n            }\n        }\n        zip.close();\n    }\n}','java\npublic class ZipStreamDemo2 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\a.txt打包成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件\n        File src = new File("D:\\\\a.txt");\n        //2.创建File对象表示压缩包的位置\n        File dest = new File("D:\\\\");\n        //3.调用方法用来压缩\n        toZip(src,dest);\n    }\n\n    /*\n    *   作用：压缩\n    *   参数一：表示要压缩的文件\n    *   参数二：表示压缩包的位置\n    * */\n    public static void toZip(File src,File dest) throws IOException {\n        //1.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,"a.zip")));\n        //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹\n        //参数：压缩包里面的路径\n        ZipEntry entry = new ZipEntry("aaa\\\\bbb\\\\a.txt");\n        //3.把ZipEntry对象放到压缩包当中\n        zos.putNextEntry(entry);\n        //4.把src文件中的数据写到压缩包当中\n        FileInputStream fis = new FileInputStream(src);\n        int b;\n        while((b = fis.read()) != -1){\n            zos.write(b);\n        }\n        zos.closeEntry();\n        zos.close();\n    }\n}','java\npublic class ZipStreamDemo3 {\n    public static void main(String[] args) throws IOException {\n        /*\n         *   压缩流\n         *      需求：\n         *          把D:\\\\aaa文件夹压缩成一个压缩包\n         * */\n        //1.创建File对象表示要压缩的文件夹\n        File src = new File("D:\\\\aaa");\n        //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）\n        File destParent = src.getParentFile();//D:\\\\\n        //3.创建File对象表示压缩包的路径\n        File dest = new File(destParent,src.getName() + ".zip");\n        //4.创建压缩流关联压缩包\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));\n        //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n        toZip(src,zos,src.getName());//aaa\n        //6.释放资源\n        zos.close();\n    }\n\n    /*\n    *   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中\n    *   参数一：数据源\n    *   参数二：压缩流\n    *   参数三：压缩包内部的路径\n    * */\n    public static void toZip(File src,ZipOutputStream zos,String name) throws IOException {\n        //1.进入src文件夹\n        File[] files = src.listFiles();\n        //2.遍历数组\n        for (File file : files) {\n            if(file.isFile()){\n                //3.判断-文件，变成ZipEntry对象，放入到压缩包当中\n                ZipEntry entry = new ZipEntry(name + "\\\\" + file.getName());//aaa\\\\no1\\\\a.txt\n                zos.putNextEntry(entry);\n                //读取文件中的数据，写到压缩包\n                FileInputStream fis = new FileInputStream(file);\n                int b;\n                while((b = fis.read()) != -1){\n                    zos.write(b);\n                }\n                fis.close();\n                zos.closeEntry();\n            }else{\n                //4.判断-文件夹，递归\n                toZip(file,zos,name + "\\\\" + file.getName());\n                //     no1            aaa   \\\\   no1\n            }\n        }\n    }\n}','java\npublic class CommonsIODemo1 {\n    public static void main(String[] args) throws IOException {\n        /*\n          FileUtils类\n                static void copyFile(File srcFile, File destFile)                   复制文件\n                static void copyDirectory(File srcDir, File destDir)                复制文件夹\n                static void copyDirectoryToDirectory(File srcDir, File destDir)     复制文件夹\n                static void deleteDirectory(File directory)                         删除文件夹\n                static void cleanDirectory(File directory)                          清空文件夹\n                static String readFileToString(File file, Charset encoding)         读取文件中的数据变成成字符串\n                static void write(File file, CharSequence data, String encoding)    写出数据\n\n            IOUtils类\n                public static int copy(InputStream input, OutputStream output)      复制文件\n                public static int copyLarge(Reader input, Writer output)            复制大文件\n                public static String readLines(Reader input)                        读取数据\n                public static void write(String data, OutputStream output)          写出数据\n         */\n\n\n        /* File src = new File("myio\\\\a.txt");\n        File dest = new File("myio\\\\copy.txt");\n        FileUtils.copyFile(src,dest);*/\n\n\n        /*File src = new File("D:\\\\aaa");\n        File dest = new File("D:\\\\bbb");\n        FileUtils.copyDirectoryToDirectory(src,dest);*/\n\n        /*File src = new File("D:\\\\bbb");\n        FileUtils.cleanDirectory(src);*/\n\n\n\n    }\n}','java\npublic class Test1 {\n    public static void main(String[] args) {\n    /*\n        FileUtil类:\n                file：根据参数创建一个file对象\n                touch：根据参数创建文件\n\n                writeLines：把集合中的数据写出到文件中，覆盖模式。\n                appendLines：把集合中的数据写出到文件中，续写模式。\n                readLines：指定字符编码，把文件中的数据，读到集合中。\n                readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中\n\n                copy：拷贝文件或者文件夹\n    */\n\n\n       /* File file1 = FileUtil.file("D:\\\\", "aaa", "bbb", "a.txt");\n        System.out.println(file1);//D:\\aaa\\bbb\\a.txt\n\n        File touch = FileUtil.touch(file1);\n        System.out.println(touch);\n\n\n        ArrayList<String> list = new ArrayList<>();\n        list.add("aaa");\n        list.add("aaa");\n        list.add("aaa");\n\n        File file2 = FileUtil.writeLines(list, "D:\\\\a.txt", "UTF-8");\n        System.out.println(file2);*/\n\n      /*  ArrayList<String> list = new ArrayList<>();\n        list.add("aaa");\n        list.add("aaa");\n        list.add("aaa");\n        File file3 = FileUtil.appendLines(list, "D:\\\\a.txt", "UTF-8");\n        System.out.println(file3);*/\n        List<String> list = FileUtil.readLines("D:\\\\a.txt", "UTF-8");\n        System.out.println(list);\n    }\n}']},{title:"实现多线程",headers:[{level:2,title:"1.实现多线程",slug:"_1-实现多线程",link:"#_1-实现多线程",children:[{level:3,title:"1.1简单了解多线程【理解】",slug:"_1-1简单了解多线程【理解】",link:"#_1-1简单了解多线程【理解】",children:[]},{level:3,title:"1.2并发和并行【理解】",slug:"_1-2并发和并行【理解】",link:"#_1-2并发和并行【理解】",children:[]},{level:3,title:"1.3进程和线程【理解】",slug:"_1-3进程和线程【理解】",link:"#_1-3进程和线程【理解】",children:[]},{level:3,title:"1.4实现多线程方式一：继承Thread类【应用】",slug:"_1-4实现多线程方式一-继承thread类【应用】",link:"#_1-4实现多线程方式一-继承thread类【应用】",children:[]},{level:3,title:"1.5实现多线程方式二：实现Runnable接口【应用】",slug:"_1-5实现多线程方式二-实现runnable接口【应用】",link:"#_1-5实现多线程方式二-实现runnable接口【应用】",children:[]},{level:3,title:"1.6实现多线程方式三: 实现Callable接口【应用】",slug:"_1-6实现多线程方式三-实现callable接口【应用】",link:"#_1-6实现多线程方式三-实现callable接口【应用】",children:[]},{level:3,title:"1.7设置和获取线程名称【应用】",slug:"_1-7设置和获取线程名称【应用】",link:"#_1-7设置和获取线程名称【应用】",children:[]},{level:3,title:"1.8线程休眠【应用】",slug:"_1-8线程休眠【应用】",link:"#_1-8线程休眠【应用】",children:[]},{level:3,title:"1.9线程优先级【应用】",slug:"_1-9线程优先级【应用】",link:"#_1-9线程优先级【应用】",children:[]},{level:3,title:"1.10守护线程【应用】",slug:"_1-10守护线程【应用】",link:"#_1-10守护线程【应用】",children:[]}]},{level:2,title:"2.线程同步",slug:"_2-线程同步",link:"#_2-线程同步",children:[{level:3,title:"2.1卖票【应用】",slug:"_2-1卖票【应用】",link:"#_2-1卖票【应用】",children:[]},{level:3,title:"2.2卖票案例的问题【理解】",slug:"_2-2卖票案例的问题【理解】",link:"#_2-2卖票案例的问题【理解】",children:[]},{level:3,title:"2.3同步代码块解决数据安全问题【应用】",slug:"_2-3同步代码块解决数据安全问题【应用】",link:"#_2-3同步代码块解决数据安全问题【应用】",children:[]},{level:3,title:"2.4同步方法解决数据安全问题【应用】",slug:"_2-4同步方法解决数据安全问题【应用】",link:"#_2-4同步方法解决数据安全问题【应用】",children:[]},{level:3,title:"2.5Lock锁【应用】",slug:"_2-5lock锁【应用】",link:"#_2-5lock锁【应用】",children:[]},{level:3,title:"2.6死锁【理解】",slug:"_2-6死锁【理解】",link:"#_2-6死锁【理解】",children:[]}]},{level:2,title:"3.生产者消费者",slug:"_3-生产者消费者",link:"#_3-生产者消费者",children:[{level:3,title:"3.1生产者和消费者模式概述【应用】",slug:"_3-1生产者和消费者模式概述【应用】",link:"#_3-1生产者和消费者模式概述【应用】",children:[]},{level:3,title:"3.2生产者和消费者案例【应用】",slug:"_3-2生产者和消费者案例【应用】",link:"#_3-2生产者和消费者案例【应用】",children:[]},{level:3,title:"3.3生产者和消费者案例优化【应用】",slug:"_3-3生产者和消费者案例优化【应用】",link:"#_3-3生产者和消费者案例优化【应用】",children:[]},{level:3,title:"3.4阻塞队列基本使用【理解】",slug:"_3-4阻塞队列基本使用【理解】",link:"#_3-4阻塞队列基本使用【理解】",children:[]},{level:3,title:"3.5阻塞队列实现等待唤醒机制【理解】",slug:"_3-5阻塞队列实现等待唤醒机制【理解】",link:"#_3-5阻塞队列实现等待唤醒机制【理解】",children:[]}]}],path:"/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html",pathLocale:"/",extraFields:["java\n  public class MyThread extends Thread {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n  //        my1.run();\n  //        my2.run();\n\n          //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n          my1.start();\n          my2.start();\n      }\n  }",'java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for(int i=0; i<100; i++) {\n              System.out.println(Thread.currentThread().getName()+":"+i);\n          }\n      }\n  }\n  public class MyRunnableDemo {\n      public static void main(String[] args) {\n          //创建MyRunnable类的对象\n          MyRunnable my = new MyRunnable();\n\n          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n          //Thread(Runnable target)\n  //        Thread t1 = new Thread(my);\n  //        Thread t2 = new Thread(my);\n          //Thread(Runnable target, String name)\n          Thread t1 = new Thread(my,"坦克");\n          Thread t2 = new Thread(my,"飞机");\n\n          //启动线程\n          t1.start();\n          t2.start();\n      }\n  }','java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println("跟女孩表白" + i);\n          }\n          //返回值就表示线程运行完毕之后的结果\n          return "答应";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws ExecutionException, InterruptedException {\n          //线程开启之后需要执行里面的call方法\n          MyCallable mc = new MyCallable();\n\n          //Thread t1 = new Thread(mc);\n\n          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          //创建线程对象\n          Thread t1 = new Thread(ft);\n\n          String s = ft.get();\n          //开启线程\n          t1.start();\n\n          //String s = ft.get();\n          System.out.println(s);\n      }\n  }','java\n  public class MyThread extends Thread {\n      public MyThread() {}\n      public MyThread(String name) {\n          super(name);\n      }\n\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName()+":"+i);\n          }\n      }\n  }\n  public class MyThreadDemo {\n      public static void main(String[] args) {\n          MyThread my1 = new MyThread();\n          MyThread my2 = new MyThread();\n\n          //void setName(String name)：将此线程的名称更改为等于参数 name\n          my1.setName("高铁");\n          my2.setName("飞机");\n\n          //Thread(String name)\n          MyThread my1 = new MyThread("高铁");\n          MyThread my2 = new MyThread("飞机");\n\n          my1.start();\n          my2.start();\n\n          //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n          System.out.println(Thread.currentThread().getName());\n      }\n  }','java\n  public class MyRunnable implements Runnable {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) throws InterruptedException {\n          /*System.out.println("睡觉前");\n          Thread.sleep(3000);\n          System.out.println("睡醒了");*/\n\n          MyRunnable mr = new MyRunnable();\n\n          Thread t1 = new Thread(mr);\n          Thread t2 = new Thread(mr);\n\n          t1.start();\n          t2.start();\n      }\n  }','java\n  public class MyCallable implements Callable<String> {\n      @Override\n      public String call() throws Exception {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(Thread.currentThread().getName() + "---" + i);\n          }\n          return "线程执行完毕了";\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          //优先级: 1 - 10 默认值:5\n          MyCallable mc = new MyCallable();\n\n          FutureTask<String> ft = new FutureTask<>(mc);\n\n          Thread t1 = new Thread(ft);\n          t1.setName("飞机");\n          t1.setPriority(10);\n          //System.out.println(t1.getPriority());//5\n          t1.start();\n\n          MyCallable mc2 = new MyCallable();\n\n          FutureTask<String> ft2 = new FutureTask<>(mc2);\n\n          Thread t2 = new Thread(ft2);\n          t2.setName("坦克");\n          t2.setPriority(1);\n          //System.out.println(t2.getPriority());//5\n          t2.start();\n      }\n  }','java\n  public class MyThread1 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 10; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class MyThread2 extends Thread {\n      @Override\n      public void run() {\n          for (int i = 0; i < 100; i++) {\n              System.out.println(getName() + "---" + i);\n          }\n      }\n  }\n  public class Demo {\n      public static void main(String[] args) {\n          MyThread1 t1 = new MyThread1();\n          MyThread2 t2 = new MyThread2();\n\n          t1.setName("女神");\n          t2.setName("备胎");\n\n          //把第二个线程设置为守护线程\n          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.\n          t2.setDaemon(true);\n\n          t1.start();\n          t2.start();\n      }\n  }','java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n      @Override\n      public void run() {\n          while (true) {\n              if(ticket <= 0){\n                      //卖完了\n                      break;\n                  }else{\n                      try {\n                          Thread.sleep(100);\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      ticket--;\n                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");\n                  }\n          }\n      }\n  }\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          //创建SellTicket类的对象\n          SellTicket st = new SellTicket();\n\n          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n          Thread t1 = new Thread(st,"窗口1");\n          Thread t2 = new Thread(st,"窗口2");\n          Thread t3 = new Thread(st,"窗口3");\n\n          //启动线程\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }',"java\n  synchronized(任意对象) { \n  \t多条语句操作共享数据的代码 \n  }",'java\n  public class SellTicket implements Runnable {\n      private int tickets = 100;\n      private Object obj = new Object();\n\n      @Override\n      public void run() {\n          while (true) {\n              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁\n                  //t1进来后，就会把这段代码给锁起来\n                  if (tickets > 0) {\n                      try {\n                          Thread.sleep(100);\n                          //t1休息100毫秒\n                      } catch (InterruptedException e) {\n                          e.printStackTrace();\n                      }\n                      //窗口1正在出售第100张票\n                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");\n                      tickets--; //tickets = 99;\n                  }\n              }\n              //t1出来了，这段代码的锁就被释放了\n          }\n      }\n  }\n\n  public class SellTicketDemo {\n      public static void main(String[] args) {\n          SellTicket st = new SellTicket();\n\n          Thread t1 = new Thread(st, "窗口1");\n          Thread t2 = new Thread(st, "窗口2");\n          Thread t3 = new Thread(st, "窗口3");\n\n          t1.start();\n          t2.start();\n          t3.start();\n      }\n  }',"java\n  修饰符 synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }","java\n  修饰符 static synchronized 返回值类型 方法名(方法参数) { \n  \t方法体；\n  }",'java\n  public class MyRunnable implements Runnable {\n      private static int ticketCount = 100;\n  \n      @Override\n      public void run() {\n          while(true){\n              if("窗口一".equals(Thread.currentThread().getName())){\n                  //同步方法\n                  boolean result = synchronizedMthod();\n                  if(result){\n                      break;\n                  }\n              }\n  \n              if("窗口二".equals(Thread.currentThread().getName())){\n                  //同步代码块\n                  synchronized (MyRunnable.class){\n                      if(ticketCount == 0){\n                         break;\n                      }else{\n                          try {\n                              Thread.sleep(10);\n                          } catch (InterruptedException e) {\n                              e.printStackTrace();\n                          }\n                          ticketCount--;\n                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n                      }\n                  }\n              }\n  \n          }\n      }\n  \n      private static synchronized boolean synchronizedMthod() {\n          if(ticketCount == 0){\n              return true;\n          }else{\n              try {\n                  Thread.sleep(10);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              ticketCount--;\n              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");\n              return false;\n          }\n      }\n  }',"### 2.5Lock锁【应用】\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock\n\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化\n\n- ReentrantLock构造方法\n\n  | 方法名             | 说明                   |\n  | --------------- | -------------------- |\n  | ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n- 加锁解锁方法\n\n  | 方法名           | 说明   |\n  | ------------- | ---- |\n  | void lock()   | 获得锁  |\n  | void unlock() | 释放锁  |\n\n- 代码演示","### 2.6死锁【理解】\n\n+ 概述\n\n  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行\n\n+ 什么情况下会产生死锁\n\n  1. 资源有限\n  2. 同步嵌套\n\n+ 代码演示","## 3.生产者消费者\n\n### 3.1生产者和消费者模式概述【应用】\n\n- 概述\n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程：\n\n  ​\t一类是生产者线程用于生产数据\n\n  ​\t一类是消费者线程用于消费数据\n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库\n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为\n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n- Object类的等待和唤醒方法\n\n  | 方法名              | 说明                                       |\n  | ---------------- | ---------------------------------------- |\n  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |\n  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |\n\n### 3.2生产者和消费者案例【应用】\n\n- 案例需求\n\n  + 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子\n\n      3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.判断是否有包子,决定当前线程是否执行\n\n      2.如果没有包子,就进入等待状态,如果有包子,就消费包子\n\n      3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建生产者线程和消费者线程对象\n\n      分别开启两个线程\n\n- 代码实现","### 3.3生产者和消费者案例优化【应用】\n\n+ 需求\n\n  + 将Desk类中的变量,采用面向对象的方式封装起来\n  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用\n  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象\n  + 开启两个线程\n\n+ 代码实现","### 3.4阻塞队列基本使用【理解】\n\n+ 阻塞队列继承结构\n\n  ![06_阻塞队列继承结构](.\\img\\06_阻塞队列继承结构.png)\n\n\n+ 常见BlockingQueue:\n\n   ArrayBlockingQueue: 底层是数组,有界\n\n   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值\n\n+ BlockingQueue的核心方法:\n\n   put(anObject): 将参数放入队列,如果放不进去会阻塞\n\n   take(): 取出第一个数据,取不到会阻塞\n\n+ 代码示例","### 3.5阻塞队列实现等待唤醒机制【理解】\n\n+ 案例需求\n\n  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务\n\n      1.构造方法中接收一个阻塞队列对象\n\n      2.在run方法中循环向阻塞队列中添加包子\n\n      3.打印添加结果\n\n  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务\n\n       1.构造方法中接收一个阻塞队列对象\n\n       2.在run方法中循环获取阻塞队列中的包子\n\n       3.打印获取结果\n\n  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下\n\n      创建阻塞队列对象\n\n      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象\n\n      分别开启两个线程\n\n+ 代码实现",""]},{title:"线程池",headers:[{level:2,title:"1. 线程池",slug:"_1-线程池",link:"#_1-线程池",children:[{level:3,title:"1.1 线程状态介绍",slug:"_1-1-线程状态介绍",link:"#_1-1-线程状态介绍",children:[]},{level:3,title:"1.2 线程池-基本原理",slug:"_1-2-线程池-基本原理",link:"#_1-2-线程池-基本原理",children:[]},{level:3,title:"1.3 线程池-Executors默认线程池",slug:"_1-3-线程池-executors默认线程池",link:"#_1-3-线程池-executors默认线程池",children:[]},{level:3,title:"1.4 线程池-Executors创建指定上限的线程池",slug:"_1-4-线程池-executors创建指定上限的线程池",link:"#_1-4-线程池-executors创建指定上限的线程池",children:[]},{level:3,title:"1.5 线程池-ThreadPoolExecutor",slug:"_1-5-线程池-threadpoolexecutor",link:"#_1-5-线程池-threadpoolexecutor",children:[]},{level:3,title:"1.6 线程池-参数详解",slug:"_1-6-线程池-参数详解",link:"#_1-6-线程池-参数详解",children:[]},{level:3,title:"1.7 线程池-非默认任务拒绝策略",slug:"_1-7-线程池-非默认任务拒绝策略",link:"#_1-7-线程池-非默认任务拒绝策略",children:[]}]},{level:2,title:"2. 多线程综合练习",slug:"_2-多线程综合练习",link:"#_2-多线程综合练习",children:[{level:3,title:"练习一：售票",slug:"练习一-售票",link:"#练习一-售票",children:[]},{level:3,title:"练习二：赠送礼物",slug:"练习二-赠送礼物",link:"#练习二-赠送礼物",children:[]},{level:3,title:"练习三：打印数字",slug:"练习三-打印数字",link:"#练习三-打印数字",children:[]},{level:3,title:"练习四：抢红包",slug:"练习四-抢红包",link:"#练习四-抢红包",children:[]},{level:3,title:"练习五：抽奖箱",slug:"练习五-抽奖箱",link:"#练习五-抽奖箱",children:[]},{level:3,title:"练习六：多线程统计并求最大值",slug:"练习六-多线程统计并求最大值",link:"#练习六-多线程统计并求最大值",children:[]},{level:3,title:"练习七：多线程之间的比较",slug:"练习七-多线程之间的比较",link:"#练习七-多线程之间的比较",children:[]}]},{level:2,title:"2. 原子性",slug:"_2-原子性",link:"#_2-原子性",children:[{level:3,title:"2.1 volatile-问题",slug:"_2-1-volatile-问题",link:"#_2-1-volatile-问题",children:[]},{level:3,title:"2.2 volatile解决",slug:"_2-2-volatile解决",link:"#_2-2-volatile解决",children:[]},{level:3,title:"2.3 synchronized解决",slug:"_2-3-synchronized解决",link:"#_2-3-synchronized解决",children:[]},{level:3,title:"2.4 原子性",slug:"_2-4-原子性",link:"#_2-4-原子性",children:[]},{level:3,title:"2.5 volatile关键字不能保证原子性",slug:"_2-5-volatile关键字不能保证原子性",link:"#_2-5-volatile关键字不能保证原子性",children:[]},{level:3,title:"2.6 原子性_AtomicInteger",slug:"_2-6-原子性-atomicinteger",link:"#_2-6-原子性-atomicinteger",children:[]},{level:3,title:"2.7 AtomicInteger-内存解析",slug:"_2-7-atomicinteger-内存解析",link:"#_2-7-atomicinteger-内存解析",children:[]},{level:3,title:"2.8 AtomicInteger-源码解析",slug:"_2-8-atomicinteger-源码解析",link:"#_2-8-atomicinteger-源码解析",children:[]},{level:3,title:"2.9 悲观锁和乐观锁",slug:"_2-9-悲观锁和乐观锁",link:"#_2-9-悲观锁和乐观锁",children:[]}]},{level:2,title:"3. 并发工具类",slug:"_3-并发工具类",link:"#_3-并发工具类",children:[{level:3,title:"3.1 并发工具类-Hashtable",slug:"_3-1-并发工具类-hashtable",link:"#_3-1-并发工具类-hashtable",children:[]},{level:3,title:"3.2 并发工具类-ConcurrentHashMap基本使用",slug:"_3-2-并发工具类-concurrenthashmap基本使用",link:"#_3-2-并发工具类-concurrenthashmap基本使用",children:[]},{level:3,title:"3.3 并发工具类-ConcurrentHashMap1.7原理",slug:"_3-3-并发工具类-concurrenthashmap1-7原理",link:"#_3-3-并发工具类-concurrenthashmap1-7原理",children:[]},{level:3,title:"3.4 并发工具类-ConcurrentHashMap1.8原理",slug:"_3-4-并发工具类-concurrenthashmap1-8原理",link:"#_3-4-并发工具类-concurrenthashmap1-8原理",children:[]},{level:3,title:"3.5 并发工具类-CountDownLatch",slug:"_3-5-并发工具类-countdownlatch",link:"#_3-5-并发工具类-countdownlatch",children:[]},{level:3,title:"3.6 并发工具类-Semaphore",slug:"_3-6-并发工具类-semaphore",link:"#_3-6-并发工具类-semaphore",children:[]}]}],path:"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html",pathLocale:"/",extraFields:["java\npublic class Thread {\n    \n    public enum State {\n    \n        /* 新建 */\n        NEW , \n\n        /* 可运行状态 */\n        RUNNABLE , \n\n        /* 阻塞状态 */\n        BLOCKED , \n\n        /* 无限等待状态 */\n        WAITING , \n\n        /* 计时等待 */\n        TIMED_WAITING , \n\n        /* 终止 */\n        TERMINATED;\n    \n\t}\n    \n    // 获取当前线程的状态\n    public State getState() {\n        return jdk.internal.misc.VM.toThreadState(threadStatus);\n    }\n    \n}",'java\npackage com.itheima.mythreadpool;\n\n\n//static ExecutorService newCachedThreadPool()   创建一个默认的线程池\n//static newFixedThreadPool(int nThreads)\t    创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MyThreadPoolDemo {\n    public static void main(String[] args) throws InterruptedException {\n\n        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        //Executors --- 可以帮助我们创建线程池对象\n        //ExecutorService --- 可以帮助我们控制线程池\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        //Thread.sleep(2000);\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.shutdown();\n    }\n}','java\npackage com.itheima.mythreadpool;\n\n//static ExecutorService newFixedThreadPool(int nThreads)\n//创建一个指定最多线程数量的线程池\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class MyThreadPoolDemo2 {\n    public static void main(String[] args) {\n        //参数不是初始值而是最大值\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;\n        System.out.println(pool.getPoolSize());//0\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        executorService.submit(()->{\n            System.out.println(Thread.currentThread().getName() + "在执行了");\n        });\n\n        System.out.println(pool.getPoolSize());//2\n//        executorService.shutdown();\n    }\n}',"java\npackage com.itheima.mythreadpool;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyThreadPoolDemo3 {\n//    参数一：核心线程数量\n//    参数二：最大线程数\n//    参数三：空闲线程最大存活时间\n//    参数四：时间单位\n//    参数五：任务队列\n//    参数六：创建线程工厂\n//    参数七：任务的拒绝策略\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());\n        pool.submit(new MyRunnable());\n        pool.submit(new MyRunnable());\n\n        pool.shutdown();\n    }\n}","java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n    \ncorePoolSize：   核心线程的最大值，不能小于0\nmaximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize\nkeepAliveTime：  空闲线程最大存活时间,不能小于0\nunit：           时间单位\nworkQueue：      任务队列，不能为null\nthreadFactory：  创建线程工厂,不能为null      \nhandler：        任务的拒绝策略,不能为null","java\nThreadPoolExecutor.AbortPolicy: \t\t    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。\nThreadPoolExecutor.DiscardPolicy： \t\t   丢弃任务，但是不抛出异常 这是不推荐的做法。\nThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。\nThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。",'java\npublic class ThreadPoolExecutorDemo01 {\n\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}',"java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务",'java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;\n\n        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}',"java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务",'java\npublic class ThreadPoolExecutorDemo02 {\n    public static void main(String[] args) {\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰\n            final int y = x ;\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务" + y);\n            });     \n        }\n    }\n}',"java\npool-1-thread-2----\x3e> 执行了任务2\npool-1-thread-1----\x3e> 执行了任务0\npool-1-thread-3----\x3e> 执行了任务3\npool-1-thread-1----\x3e> 执行了任务4",'java\npublic class ThreadPoolExecutorDemo04 {\n    public static void main(String[] args) {\n\n        /**\n         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s\n         */\n        ThreadPoolExecutor threadPoolExecutor;\n        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,\n                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());\n\n        // 提交5个任务\n        for(int x = 0 ; x < 5 ; x++) {\n            threadPoolExecutor.submit(() -> {\n                System.out.println(Thread.currentThread().getName() + "----\x3e> 执行了任务");\n            });\n        }\n    }\n}',"java\npool-1-thread-1----\x3e> 执行了任务\npool-1-thread-3----\x3e> 执行了任务\npool-1-thread-2----\x3e> 执行了任务\npool-1-thread-1----\x3e> 执行了任务\nmain----\x3e> 执行了任务",'java\npublic class MyThread extends Thread {\n\n    //第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static\n    static int ticket = 1000;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (ticket == 0) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    try {\n                        Thread.sleep(3000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    ticket--;\n                    System.out.println(getName() + "在卖票，还剩下" + ticket + "张票!!!");\n                }\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n       /*\n            一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,\n            要求:请用多线程模拟卖票过程并打印剩余电影票的数量\n        */\n\n        //创建线程对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n\n        //给线程设置名字\n        t1.setName("窗口1");\n        t2.setName("窗口2");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n    }\n}','java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int count = 100;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (count < 10) {\n                    System.out.println("礼物还剩下" + count + "不再赠送");\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + "在赠送礼物，还剩下" + count + "个礼物!!!");\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出，\n            利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.\n        */\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,"窗口1");\n        Thread t2 = new Thread(mr,"窗口2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}','java\npublic class MyRunable implements Runnable {\n\n    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static\n    int number = 1;\n\n    @Override\n    public void run() {\n        //1.循环\n        while (true) {\n            //2.同步代码块\n            synchronized (MyThread.class) {\n                //3.判断共享数据（已经到末尾）\n                if (number > 100) {\n                    break;\n                } else {\n                    //4.判断共享数据（没有到末尾）\n                    if(number % 2 == 1){\n                        System.out.println(Thread.currentThread().getName() + "打印数字" + number);\n                    }\n                    number++;\n                }\n            }\n        }\n    }\n}\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n           同时开启两个线程，共同获取1-100之间的所有数字。\n           要求：将输出所有的奇数。\n        */\n\n\n        //创建参数对象\n        MyRunable mr = new MyRunable();\n\n        //创建线程对象\n        Thread t1 = new Thread(mr,"线程A");\n        Thread t2 = new Thread(mr,"线程B");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}','java\npublic class MyThread extends Thread{\n\n    //共享数据\n    //100块，分成了3个包\n    static double money = 100;\n    static int count = 3;\n\n    //最小的中奖金额\n    static final double MIN = 0.01;\n\n    @Override\n    public void run() {\n        //同步代码块\n        synchronized (MyThread.class){\n            if(count == 0){\n                //判断，共享数据是否到了末尾（已经到末尾）\n                System.out.println(getName() + "没有抢到红包！");\n            }else{\n                //判断，共享数据是否到了末尾（没有到末尾）\n                //定义一个变量，表示中奖的金额\n                double prize = 0;\n                if(count == 1){\n                    //表示此时是最后一个红包\n                    //就无需随机，剩余所有的钱都是中奖金额\n                    prize = money;\n                }else{\n                    //表示第一次，第二次（随机）\n                    Random r = new Random();\n                    //100 元   3个包\n                    //第一个红包：99.98\n                    //100 - (3-1) * 0.01\n                    double bounds = money - (count - 1) * MIN;\n                    prize = r.nextDouble(bounds);\n                    if(prize < MIN){\n                        prize = MIN;\n                    }\n                }\n                //从money当中，去掉当前中奖的金额\n                money = money - prize;\n                //红包的个数-1\n                count--;\n                //本次红包的信息进行打印\n                System.out.println(getName() + "抢到了" + prize + "元");\n            }\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n        //创建线程的对象\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        //给线程设置名字\n        t1.setName("小A");\n        t2.setName("小QQ");\n        t3.setName("小哈哈");\n        t4.setName("小诗诗");\n        t5.setName("小丹丹");\n\n        //启动线程\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}','java\npublic class MyThread extends Thread{\n\n    //总金额\n    static BigDecimal money = BigDecimal.valueOf(100.0);\n    //个数\n    static int count = 3;\n    //最小抽奖金额\n    static final BigDecimal MIN = BigDecimal.valueOf(0.01);\n\n    @Override\n    public void run() {\n        synchronized (MyThread.class){\n            if(count == 0){\n                System.out.println(getName() + "没有抢到红包！");\n            }else{\n                //中奖金额\n                BigDecimal prize;\n                if(count == 1){\n                    prize = money;\n                }else{\n                    //获取抽奖范围\n                    double bounds = money.subtract(BigDecimal.valueOf(count-1).multiply(MIN)).doubleValue();\n                    Random r = new Random();\n                    //抽奖金额\n                    prize = BigDecimal.valueOf(r.nextDouble(bounds));\n                }\n                //设置抽中红包，小数点保留两位，四舍五入\n                prize = prize.setScale(2,RoundingMode.HALF_UP);\n                //在总金额中去掉对应的钱\n                money = money.subtract(prize);\n                //红包少了一个\n                count--;\n                //输出红包信息\n                System.out.println(getName() + "抽中了" + prize + "元");\n            }\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            微信中的抢红包也用到了多线程。\n            假设：100块，分成了3个包，现在有5个人去抢。\n            其中，红包是共享数据。\n            5个人是5条线程。\n            打印结果如下：\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX抢到了XXX元\n            \tXXX没抢到\n            \tXXX没抢到\n        */\n\n\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        MyThread t3 = new MyThread();\n        MyThread t4 = new MyThread();\n        MyThread t5 = new MyThread();\n\n        t1.setName("小A");\n        t2.setName("小QQ");\n        t3.setName("小哈哈");\n        t4.setName("小诗诗");\n        t5.setName("小丹丹");\n\n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n    }\n}','java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        //1.循环\n        //2.同步代码块\n        //3.判断\n        //4.判断\n\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    System.out.println(getName() + "又产生了一个" + prize + "元大奖");\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\n\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n                             每次抽出一个奖项就打印一个(随机)\n            \t抽奖箱1 又产生了一个 10 元大奖\n            \t抽奖箱1 又产生了一个 100 元大奖\n            \t抽奖箱1 又产生了一个 200 元大奖\n            \t抽奖箱1 又产生了一个 800 元大奖\n            \t抽奖箱2 又产生了一个 700 元大奖\n            \t.....\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}','java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    //线程一\n    static ArrayList<Integer> list1 = new ArrayList<>();\n    //线程二\n    static ArrayList<Integer> list2 = new ArrayList<>();\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    if("抽奖箱1".equals(getName())){\n                        System.out.println("抽奖箱1" + list1);\n                    }else {\n                        System.out.println("抽奖箱2" + list2);\n                    }\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    if("抽奖箱1".equals(getName())){\n                        list1.add(prize);\n                    }else {\n                        list2.add(prize);\n                    }\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}','java\npublic class MyThread extends Thread {\n\n    ArrayList<Integer> list;\n\n    public MyThread(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyThread.class) {\n                if (list.size() == 0) {\n                    System.out.println(getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。\n                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。\n                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建线程\n        MyThread t1 = new MyThread(list);\n        MyThread t2 = new MyThread(list);\n\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n\n        //启动线程\n        t1.start();\n        t2.start();\n\n    }\n}','java\npublic class MyCallable implements Callable<Integer> {\n\n    ArrayList<Integer> list;\n\n    public MyCallable(ArrayList<Integer> list) {\n        this.list = list;\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        ArrayList<Integer> boxList = new ArrayList<>();//1 //2\n        while (true) {\n            synchronized (MyCallable.class) {\n                if (list.size() == 0) {\n                    System.out.println(Thread.currentThread().getName() + boxList);\n                    break;\n                } else {\n                    //继续抽奖\n                    Collections.shuffle(list);\n                    int prize = list.remove(0);\n                    boxList.add(prize);\n                }\n            }\n            Thread.sleep(10);\n        }\n        //把集合中的最大值返回\n        if(boxList.size() == 0){\n            return null;\n        }else{\n            return Collections.max(boxList);\n        }\n    }\n}\n\npackage com.itheima.test7;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Test {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        /*\n            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700};\n            创建两个抽奖箱(线程)设置线程名称分别为    "抽奖箱1", "抽奖箱2"\n            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:\n\n            在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300\n        \t    最高奖项为300元，总计额为932元\n\n            在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700\n            \t最高奖项为800元，总计额为1835元\n\n            在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n            核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果）\n\n\n            以上打印效果只是数据模拟,实际代码运行的效果会有差异\n        */\n\n        //创建奖池\n        ArrayList<Integer> list = new ArrayList<>();\n        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);\n\n        //创建多线程要运行的参数对象\n        MyCallable mc = new MyCallable(list);\n\n        //创建多线程运行结果的管理者对象\n        //线程一\n        FutureTask<Integer> ft1 = new FutureTask<>(mc);\n        //线程二\n        FutureTask<Integer> ft2 = new FutureTask<>(mc);\n\n        //创建线程对象\n        Thread t1 = new Thread(ft1);\n        Thread t2 = new Thread(ft2);\n\n        //设置名字\n        t1.setName("抽奖箱1");\n        t2.setName("抽奖箱2");\n\n        //开启线程\n        t1.start();\n        t2.start();\n\n\n        Integer max1 = ft1.get();\n        Integer max2 = ft2.get();\n\n        System.out.println(max1);\n        System.out.println(max2);\n\n        //在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元\n        if(max1 == null){\n            System.out.println("在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为"+max2+"元");\n        }else if(max2 == null){\n            System.out.println("在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为"+max1+"元");\n        }else if(max1 > max2){\n            System.out.println("在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为"+max1+"元");\n        }else if(max1 < max2){\n            System.out.println("在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为"+max2+"元");\n        }else{\n            System.out.println("两者的最大奖项是一样的");\n        }\n    }\n}','java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}',"java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static int money = 100000;\n}",'java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}',"java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}",'java\npackage com.itheima.myvolatile;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}',"java\npackage com.itheima.myvolatile;\n\npublic class Money {\n    public static volatile int money = 100000;\n}",'java\npackage com.itheima.myvolatile;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(Money.money == 100000){\n\n        }\n\n        System.out.println("结婚基金已经不是十万了");\n    }\n}',"java\npackage com.itheima.myvolatile;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        Money.money = 90000;\n    }\n}",'java\npackage com.itheima.myvolatile2;\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyThread1 t1 = new MyThread1();\n        t1.setName("小路同学");\n        t1.start();\n\n        MyThread2 t2 = new MyThread2();\n        t2.setName("小皮同学");\n        t2.start();\n    }\n}',"java\npackage com.itheima.myvolatile2;\n\npublic class Money {\n    public static Object lock = new Object();\n    public static volatile int money = 100000;\n}",'java\npackage com.itheima.myvolatile2;\n\npublic class MyThread1 extends  Thread {\n    @Override\n    public void run() {\n        while(true){\n            synchronized (Money.lock){\n                if(Money.money != 100000){\n                    System.out.println("结婚基金已经不是十万了");\n                    break;\n                }\n            }\n        }\n    }\n}',"java\npackage com.itheima.myvolatile2;\n\npublic class MyThread2 extends Thread {\n    @Override\n    public void run() {\n        synchronized (Money.lock) {\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            Money.money = 90000;\n        }\n    }\n}",'java\npackage com.itheima.threadatom;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            count++;\n            System.out.println("已经送了" + count + "个冰淇淋");\n        }\n    }\n}','java\npackage com.itheima.threadatom2;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}\nclass MyAtomThread implements Runnable {\n    private volatile int count = 0; //送冰淇淋的数量\n    private Object lock = new Object();\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            synchronized (lock) {\n                count++;\n                System.out.println("已经送了" + count + "个冰淇淋");\n            }\n        }\n    }\n}',"java\npublic AtomicInteger()：\t   \t\t\t    初始化一个默认值为0的原子型Integer\npublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer\n\nint get():   \t\t\t \t\t\t\t获取值\nint getAndIncrement():      \t\t\t 以原子方式将当前值加1，注意，这里返回的是自增前的值。\nint incrementAndGet():     \t\t\t\t 以原子方式将当前值加1，注意，这里返回的是自增后的值。\nint addAndGet(int data):\t\t\t\t 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。\nint getAndSet(int value):   \t\t\t 以原子方式设置为newValue的值，并返回旧值。","java\npackage com.itheima.threadatom3;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo1 {\n//    public AtomicInteger()：\t               初始化一个默认值为0的原子型Integer\n//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer\n    public static void main(String[] args) {\n        AtomicInteger ac = new AtomicInteger();\n        System.out.println(ac);\n\n        AtomicInteger ac2 = new AtomicInteger(10);\n        System.out.println(ac2);\n    }\n\n}","java\npackage com.itheima.threadatom3;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomIntergerDemo2 {\n//    int get():   \t\t \t\t获取值\n//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。\n//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。\n//    int addAndGet(int data):\t 以原子方式将参数与对象中的值相加，并返回结果。\n//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。\n    public static void main(String[] args) {\n//        AtomicInteger ac1 = new AtomicInteger(10);\n//        System.out.println(ac1.get());\n\n//        AtomicInteger ac2 = new AtomicInteger(10);\n//        int andIncrement = ac2.getAndIncrement();\n//        System.out.println(andIncrement);\n//        System.out.println(ac2.get());\n\n//        AtomicInteger ac3 = new AtomicInteger(10);\n//        int i = ac3.incrementAndGet();\n//        System.out.println(i);//自增后的值\n//        System.out.println(ac3.get());\n\n//        AtomicInteger ac4 = new AtomicInteger(10);\n//        int i = ac4.addAndGet(20);\n//        System.out.println(i);\n//        System.out.println(ac4.get());\n\n        AtomicInteger ac5 = new AtomicInteger(100);\n        int andSet = ac5.getAndSet(20);\n        System.out.println(andSet);\n        System.out.println(ac5.get());\n    }\n}","java\npackage com.itheima.threadatom4;\n\npublic class AtomDemo {\n    public static void main(String[] args) {\n        MyAtomThread atom = new MyAtomThread();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(atom).start();\n        }\n    }\n}",'java\npackage com.itheima.threadatom4;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyAtomThread implements Runnable {\n    //private volatile int count = 0; //送冰淇淋的数量\n    //private Object lock = new Object();\n    AtomicInteger ac = new AtomicInteger(0);\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            //1,从共享数据中读取数据到本线程栈中.\n            //2,修改本线程栈中变量副本的值\n            //3,会把本线程栈中变量副本的值赋值给共享数据.\n            //synchronized (lock) {\n//                count++;\n//                ac++;\n            int count = ac.incrementAndGet();\n            System.out.println("已经送了" + count + "个冰淇淋");\n           // }\n        }\n    }\n}',"java\n\n//先自增，然后获取自增后的结果\npublic final int incrementAndGet() {\n        //+ 1 自增后的结果\n        //this 就表示当前的atomicInteger（值）\n        //1    自增一次\n        return U.getAndAddInt(this, VALUE, 1) + 1;\n}\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n        //v 旧值\n        int v;\n        //自旋的过程\n        do {\n            //不断的获取旧值\n            v = getIntVolatile(o, offset);\n            //如果这个方法的返回值为false，那么继续自旋\n            //如果这个方法的返回值为true，那么自旋结束\n            //o 表示的就是内存值\n            //v 旧值\n            //v + delta 修改后的值\n        } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。\n            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。\n            //如果修改失败，那么继续自旋。\n        return v;\n}",'java\npackage com.itheima.mymap;\n\nimport java.util.HashMap;\nimport java.util.Hashtable;\n\npublic class MyHashtableDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Hashtable<String, String> hm = new Hashtable<>();\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n\n\n    }\n}','java\npackage com.itheima.mymap;\n\nimport java.util.Hashtable;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MyConcurrentHashMapDemo {\n    public static void main(String[] args) throws InterruptedException {\n        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);\n\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 25; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 25; i < 51; i++) {\n                hm.put(i + "", i + "");\n            }\n        });\n\n        t1.start();\n        t2.start();\n\n        System.out.println("----------------------------");\n        //为了t1和t2能把数据全部添加完毕\n        Thread.sleep(1000);\n\n        //0-0 1-1 ..... 50- 50\n\n        for (int i = 0; i < 51; i++) {\n            System.out.println(hm.get(i + ""));\n        }//0 1 2 3 .... 50\n    }\n}','java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread1 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread1(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}','java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread2 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread2(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}','java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ChileThread3 extends Thread {\n\n    private CountDownLatch countDownLatch;\n    public ChileThread3(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n    @Override\n    public void run() {\n        //1.吃饺子\n        for (int i = 1; i <= 20; i++) {\n            System.out.println(getName() + "在吃第" + i + "个饺子");\n        }\n        //2.吃完说一声\n        //每一次countDown方法的时候，就让计数器-1\n        countDownLatch.countDown();\n    }\n}','java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MotherThread extends Thread {\n    private CountDownLatch countDownLatch;\n    public MotherThread(CountDownLatch countDownLatch) {\n        this.countDownLatch = countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        //1.等待\n        try {\n            //当计数器变成0的时候，会自动唤醒这里等待的线程。\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2.收拾碗筷\n        System.out.println("妈妈在收拾碗筷");\n    }\n}','java\npackage com.itheima.mycountdownlatch;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyCountDownLatchDemo {\n    public static void main(String[] args) {\n        //1.创建CountDownLatch的对象，需要传递给四个线程。\n        //在底层就定义了一个计数器，此时计数器的值就是3\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        //2.创建四个线程对象并开启他们。\n        MotherThread motherThread = new MotherThread(countDownLatch);\n        motherThread.start();\n\n        ChileThread1 t1 = new ChileThread1(countDownLatch);\n        t1.setName("小明");\n\n        ChileThread2 t2 = new ChileThread2(countDownLatch);\n        t2.setName("小红");\n\n        ChileThread3 t3 = new ChileThread3(countDownLatch);\n        t3.setName("小刚");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}','java\npackage com.itheima.mysemaphore;\n\nimport java.util.concurrent.Semaphore;\n\npublic class MyRunnable implements Runnable {\n    //1.获得管理员对象，\n    private Semaphore semaphore = new Semaphore(2);\n    @Override\n    public void run() {\n        //2.获得通行证\n        try {\n            semaphore.acquire();\n            //3.开始行驶\n            System.out.println("获得了通行证开始行驶");\n            Thread.sleep(2000);\n            System.out.println("归还通行证");\n            //4.归还通行证\n            semaphore.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}',"java\npackage com.itheima.mysemaphore;\n\npublic class MySemaphoreDemo {\n    public static void main(String[] args) {\n        MyRunnable mr = new MyRunnable();\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(mr).start();\n        }\n    }\n}"]},{title:"网络编程入门",headers:[{level:2,title:"1. 网络编程入门",slug:"_1-网络编程入门",link:"#_1-网络编程入门",children:[{level:3,title:"1.1 网络编程概述",slug:"_1-1-网络编程概述",link:"#_1-1-网络编程概述",children:[]},{level:3,title:"1.2 网络编程三要素",slug:"_1-2-网络编程三要素",link:"#_1-2-网络编程三要素",children:[]},{level:3,title:"1.3 IP地址",slug:"_1-3-ip地址",link:"#_1-3-ip地址",children:[]},{level:3,title:"1.4 InetAddress",slug:"_1-4-inetaddress",link:"#_1-4-inetaddress",children:[]},{level:3,title:"1.5 端口和协议",slug:"_1-5-端口和协议",link:"#_1-5-端口和协议",children:[]}]},{level:2,title:"2.UDP通信程序",slug:"_2-udp通信程序",link:"#_2-udp通信程序",children:[{level:3,title:"2.1 UDP发送数据",slug:"_2-1-udp发送数据",link:"#_2-1-udp发送数据",children:[]},{level:3,title:"2.2UDP接收数据",slug:"_2-2udp接收数据",link:"#_2-2udp接收数据",children:[]},{level:3,title:"2.3UDP通信程序练习",slug:"_2-3udp通信程序练习",link:"#_2-3udp通信程序练习",children:[]},{level:3,title:"2.4UDP三种通讯方式",slug:"_2-4udp三种通讯方式",link:"#_2-4udp三种通讯方式",children:[]},{level:3,title:"2.5UDP组播实现",slug:"_2-5udp组播实现",link:"#_2-5udp组播实现",children:[]},{level:3,title:"2.6UDP广播实现",slug:"_2-6udp广播实现",link:"#_2-6udp广播实现",children:[]},{level:3,title:"3.1TCP发送数据",slug:"_3-1tcp发送数据",link:"#_3-1tcp发送数据",children:[]},{level:3,title:"3.2TCP接收数据",slug:"_3-2tcp接收数据",link:"#_3-2tcp接收数据",children:[]},{level:3,title:"3.3TCP程序练习（传输中文）",slug:"_3-3tcp程序练习-传输中文",link:"#_3-3tcp程序练习-传输中文",children:[]}]},{level:2,title:"4. 综合练习",slug:"_4-综合练习",link:"#_4-综合练习",children:[{level:3,title:"练习一：多发多收",slug:"练习一-多发多收",link:"#练习一-多发多收",children:[]},{level:3,title:"练习二：接收并反馈",slug:"练习二-接收并反馈",link:"#练习二-接收并反馈",children:[]},{level:3,title:"练习三：上传练习（TCP协议）",slug:"练习三-上传练习-tcp协议",link:"#练习三-上传练习-tcp协议",children:[]},{level:3,title:"练习四：文件名重复",slug:"练习四-文件名重复",link:"#练习四-文件名重复",children:[]},{level:3,title:"练习五：服务器改写为多线程",slug:"练习五-服务器改写为多线程",link:"#练习五-服务器改写为多线程",children:[]},{level:3,title:"练习六：线程池改进",slug:"练习六-线程池改进",link:"#练习六-线程池改进",children:[]}]}],path:"/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html",pathLocale:"/",extraFields:['java\n  public class InetAddressDemo {\n      public static void main(String[] args) throws UnknownHostException {\n  \t\t//InetAddress address = InetAddress.getByName("itheima");\n          InetAddress address = InetAddress.getByName("192.168.1.66");\n  \n          //public String getHostName()：获取此IP地址的主机名\n          String name = address.getHostName();\n          //public String getHostAddress()：返回文本显示中的IP地址字符串\n          String ip = address.getHostAddress();\n  \n          System.out.println("主机名：" + name);\n          System.out.println("IP地址：" + ip);\n      }\n  }','java\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n          DatagramSocket ds = new DatagramSocket();\n  \n          //创建数据，并把数据打包\n          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n          byte[] bys = "hello,udp,我来了".getBytes();\n  \n          DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("127.0.0.1"),10086);\n  \n          //调用DatagramSocket对象的方法发送数据\n          //void send(DatagramPacket p) 从此套接字发送数据报包\n          ds.send(dp);\n  \n          //关闭发送端\n          //void close() 关闭此数据报套接字\n          ds.close();\n      }\n  }','java\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n        \t//创建接收端的Socket对象(DatagramSocket)\n        \tDatagramSocket ds = new DatagramSocket(12345);\n  \n        \t//创建一个数据包，用于接收数据\n        \tbyte[] bys = new byte[1024];\n        \tDatagramPacket dp = new DatagramPacket(bys, bys.length);\n  \n        \t//调用DatagramSocket对象的方法接收数据\n        \tds.receive(dp);\n  \n        \t//解析数据包，并把数据在控制台显示\n        \tSystem.out.println("数据是：" + new String(dp.getData(), 0,                                             dp.getLength()));\n          }\n      }\n  }','java\n  /*\n      UDP发送数据：\n          数据来自于键盘录入，直到输入的数据是886，发送数据结束\n   */\n  public class SendDemo {\n      public static void main(String[] args) throws IOException {\n          //创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          //键盘录入数据\n          Scanner sc = new Scanner(System.in);\n          while (true) {\n            \tString s = sc.nextLine();\n              //输入的数据是886，发送数据结束\n              if ("886".equals(s)) {\n                  break;\n              }\n              //创建数据，并把数据打包\n              byte[] bys = s.getBytes();\n              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);\n  \n              //调用DatagramSocket对象的方法发送数据\n              ds.send(dp);\n          }\n          //关闭发送端\n          ds.close();\n      }\n  }\n  \n  /*\n      UDP接收数据：\n          因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n   */\n  public class ReceiveDemo {\n      public static void main(String[] args) throws IOException {\n          //创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(12345);\n          while (true) {\n              //创建一个数据包，用于接收数据\n              byte[] bys = new byte[1024];\n              DatagramPacket dp = new DatagramPacket(bys, bys.length);\n              //调用DatagramSocket对象的方法接收数据\n              ds.receive(dp);\n              //解析数据包，并把数据在控制台显示\n              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));\n          }\n          //关闭接收端\n  //        ds.close();\n      }\n  }','java\n  // 发送端\n  public class ClinetDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建发送端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n          String s = "hello 组播";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("224.0.1.0");\n          int port = 10000;\n          // 2. 创建数据，并把数据打包(DatagramPacket)\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n          // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)\n          ds.send(dp);\n          // 4. 释放资源\n          ds.close();\n      }\n  }\n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端Socket对象(MulticastSocket)\n          MulticastSocket ms = new MulticastSocket(10000);\n          // 2. 创建一个箱子,用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.\n          ms.joinGroup(InetAddress.getByName("224.0.1.0"));\n          // 4. 将数据接收到箱子中\n          ms.receive(dp);\n          // 5. 解析数据包,并打印数据\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 6. 释放资源\n          ms.close();\n      }\n  }','java\n  // 发送端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n        \t// 1. 创建发送端Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket();\n  \t\t// 2. 创建存储数据的箱子,将广播地址封装进去\n          String s = "广播 hello";\n          byte[] bytes = s.getBytes();\n          InetAddress address = InetAddress.getByName("255.255.255.255");\n          int port = 10000;\n          DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port);\n  \t\t// 3. 发送数据\n          ds.send(dp);\n  \t\t// 4. 释放资源\n          ds.close();\n      }\n  }\n  \n  // 接收端\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          // 1. 创建接收端的Socket对象(DatagramSocket)\n          DatagramSocket ds = new DatagramSocket(10000);\n          // 2. 创建一个数据包，用于接收数据\n          DatagramPacket dp = new DatagramPacket(new byte[1024],1024);\n          // 3. 调用DatagramSocket对象的方法接收数据\n          ds.receive(dp);\n          // 4. 解析数据包，并把数据在控制台显示\n          byte[] data = dp.getData();\n          int length = dp.getLength();\n          System.out.println(new String(data,0,length));\n          // 5. 关闭接收端\n          ds.close();\n      }\n  }','java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，发送数据\n  \n          //1.创建Socket对象\n          //细节：在创建对象的同时会连接服务端\n          //      如果连接不上，代码会报错\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          //2.可以从连接通道中获取输出流\n          OutputStream os = socket.getOutputStream();\n          //写出数据\n          os.write("aaa".getBytes());\n  \n          //3.释放资源\n          os.close();\n          socket.close();\n      }\n  }',"java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //TCP协议，接收数据\n  \n          //1.创建对象ServerSocker\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.监听客户端的链接\n          Socket socket = ss.accept();\n  \n          //3.从连接通道中获取输入流读取数据\n          InputStream is = socket.getInputStream();\n          int b;\n          while ((b = is.read()) != -1){\n              System.out.println((char) b);\n          }\n  \n          //4.释放资源\n          socket.close();\n          ss.close();\n      }\n  }",'java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，发送数据\n\n        //1.创建Socket对象\n        //细节：在创建对象的同时会连接服务端\n        //      如果连接不上，代码会报错\n        Socket socket = new Socket("127.0.0.1",10000);\n\n\n        //2.可以从连接通道中获取输出流\n        OutputStream os = socket.getOutputStream();\n        //写出数据\n        os.write("你好你好".getBytes());//12字节\n\n        //3.释放资源\n        os.close();\n        socket.close();\n\n    }\n}',"java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //TCP协议，接收数据\n\n        //1.创建对象ServerSocker\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.监听客户端的链接\n        Socket socket = ss.accept();\n\n        //3.从连接通道中获取输入流读取数据\n        InputStream is = socket.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is);\n        BufferedReader br = new BufferedReader(isr);\n\n        // BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        int b;\n        while ((b = br.read()) != -1){\n            System.out.print((char) b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n\n    }\n}",'java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1. 创建Socket对象并连接服务端\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.写出数据\n        Scanner sc = new Scanner(System.in);\n        OutputStream os = socket.getOutputStream();\n\n        while (true) {\n            System.out.println("请输入您要发送的信息");\n            String str = sc.nextLine();\n            if("886".equals(str)){\n                break;\n            }\n            os.write(str.getBytes());\n        }\n        //3.释放资源\n        socket.close();\n    }\n}',"java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：多次发送数据\n        //服务器：接收多次接收数据，并打印\n\n        //1.创建对象绑定10000端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据\n        InputStreamReader isr = new InputStreamReader(socket.getInputStream());\n        int b;\n        while ((b = isr.read()) != -1){\n            System.out.print((char)b);\n        }\n\n        //4.释放资源\n        socket.close();\n        ss.close();\n    }\n}",'java\n  // 客户端\n  public class ClientDemo {\n      public static void main(String[] args) throws IOException {\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          OutputStream os = socket.getOutputStream();\n          os.write("hello".getBytes());\n         // os.close();如果在这里关流,会导致整个socket都无法使用\n          socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响\n          \n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line;\n          while((line = br.readLine())!=null){\n              System.out.println(line);\n          }\n          br.close();\n          os.close();\n          socket.close();\n      }\n  }\n  // 服务器\n  public class ServerDemo {\n      public static void main(String[] args) throws IOException {\n          ServerSocket ss = new ServerSocket(10000);\n  \n          Socket accept = ss.accept();\n  \n          InputStream is = accept.getInputStream();\n          int b;\n          while((b = is.read())!=-1){\n              System.out.println((char) b);\n          }\n  \n          System.out.println("看看我执行了吗?");\n  \n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));\n          bw.write("你谁啊?");\n          bw.newLine();\n          bw.flush();\n  \n          bw.close();\n          is.close();\n          accept.close();\n          ss.close();\n      }\n  }','java\n  public class Client {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1. 创建Socket对象，并连接服务器\n          Socket socket = new Socket("127.0.0.1",10000);\n  \n          //2.读取本地文件中的数据，并写到服务器当中\n          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n          BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n          byte[] bytes = new byte[1024];\n          int len;\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n  \n          //往服务器写出结束标记\n          socket.shutdownOutput();\n  \n  \n          //3.接收服务器的回写数据\n          BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n          String line = br.readLine();\n          System.out.println(line);\n  \n  \n          //4.释放资源\n          socket.close();\n  \n      }\n  }','java\n  public class Server {\n      public static void main(String[] args) throws IOException {\n          //客户端：将本地文件上传到服务器。接收服务器的反馈。\n          //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n  \n  \n          //1.创建对象并绑定端口\n          ServerSocket ss = new ServerSocket(10000);\n  \n          //2.等待客户端来连接\n          Socket socket = ss.accept();\n  \n          //3.读取数据并保存到本地文件中\n          BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\a.jpg"));\n          int len;\n          byte[] bytes = new byte[1024];\n          while ((len = bis.read(bytes)) != -1){\n              bos.write(bytes,0,len);\n          }\n          bos.close();\n          //4.回写数据\n          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n          bw.write("上传成功");\n          bw.newLine();\n          bw.flush();\n  \n          //5.释放资源\n          socket.close();\n          ss.close();\n      }\n  }','java\npublic class UUIDTest {\n    public static void main(String[] args) {\n        String str = UUID.randomUUID().toString().replace("-", "");\n        System.out.println(str);//9f15b8c356c54f55bfcb0ee3023fce8a\n    }\n}','java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}','java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        //2.等待客户端来连接\n        Socket socket = ss.accept();\n\n        //3.读取数据并保存到本地文件中\n        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n        String name = UUID.randomUUID().toString().replace("-", "");\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n        int len;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read(bytes)) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        bos.close();\n        //4.回写数据\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        bw.write("上传成功");\n        bw.newLine();\n        bw.flush();\n\n        //5.释放资源\n        socket.close();\n        ss.close();\n    }\n}','java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}','java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            new Thread(new MyRunnable(socket)).start();\n        }\n\n    }\n}\n\n\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace("-", "");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write("上传成功");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}','java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //1. 创建Socket对象，并连接服务器\n        Socket socket = new Socket("127.0.0.1",10000);\n\n        //2.读取本地文件中的数据，并写到服务器当中\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("mysocketnet\\\\clientdir\\\\a.jpg"));\n        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len = bis.read(bytes)) != -1){\n            bos.write(bytes,0,len);\n        }\n\n        //往服务器写出结束标记\n        socket.shutdownOutput();\n\n\n        //3.接收服务器的回写数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String line = br.readLine();\n        System.out.println(line);\n\n\n        //4.释放资源\n        socket.close();\n\n    }\n}',"java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        //客户端：将本地文件上传到服务器。接收服务器的反馈。\n        //服务器：接收客户端上传的文件，上传完毕之后给出反馈。\n\n\n        //创建线程池对象\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(\n                3,//核心线程数量\n                16,//线程池总大小\n                60,//空闲时间\n                TimeUnit.SECONDS,//空闲时间（单位）\n                new ArrayBlockingQueue<>(2),//队列\n                Executors.defaultThreadFactory(),//线程工厂，让线程池如何创建线程对象\n                new ThreadPoolExecutor.AbortPolicy()//阻塞队列\n        );\n\n\n\n        //1.创建对象并绑定端口\n        ServerSocket ss = new ServerSocket(10000);\n\n        while (true) {\n            //2.等待客户端来连接\n            Socket socket = ss.accept();\n\n            //开启一条线程\n            //一个用户就对应服务端的一条线程\n            //new Thread(new MyRunnable(socket)).start();\n            pool.submit(new MyRunnable(socket));\n        }\n\n    }\n}",'java\npublic class MyRunnable implements Runnable{\n\n    Socket socket;\n\n    public MyRunnable(Socket socket){\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //3.读取数据并保存到本地文件中\n            BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());\n            String name = UUID.randomUUID().toString().replace("-", "");\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("mysocketnet\\\\serverdir\\\\" + name + ".jpg"));\n            int len;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n            }\n            bos.close();\n            //4.回写数据\n            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bw.write("上传成功");\n            bw.newLine();\n            bw.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //5.释放资源\n           if(socket != null){\n               try {\n                   socket.close();\n               } catch (IOException e) {\n                   e.printStackTrace();\n               }\n           }\n        }\n    }\n}']},{title:"反射&动态代理",headers:[{level:2,title:"1.1 反射的概述：",slug:"_1-1-反射的概述",link:"#_1-1-反射的概述",children:[]},{level:2,title:"1.2 学习反射到底学什么？",slug:"_1-2-学习反射到底学什么",link:"#_1-2-学习反射到底学什么",children:[]},{level:2,title:"1.3 获取字节码文件对象的三种方式",slug:"_1-3-获取字节码文件对象的三种方式",link:"#_1-3-获取字节码文件对象的三种方式",children:[]},{level:2,title:"1.4 字节码文件和字节码文件对象",slug:"_1-4-字节码文件和字节码文件对象",link:"#_1-4-字节码文件和字节码文件对象",children:[]},{level:2,title:"1.5 获取构造方法",slug:"_1-5-获取构造方法",link:"#_1-5-获取构造方法",children:[]},{level:2,title:"1.6 获取构造方法并创建对象",slug:"_1-6-获取构造方法并创建对象",link:"#_1-6-获取构造方法并创建对象",children:[]},{level:2,title:"1.7 获取成员变量",slug:"_1-7-获取成员变量",link:"#_1-7-获取成员变量",children:[]},{level:2,title:"1.8 获取成员变量并获取值和修改值",slug:"_1-8-获取成员变量并获取值和修改值",link:"#_1-8-获取成员变量并获取值和修改值",children:[]},{level:2,title:"1.9 获取成员方法",slug:"_1-9-获取成员方法",link:"#_1-9-获取成员方法",children:[]},{level:2,title:"1.10 获取成员方法并运行",slug:"_1-10-获取成员方法并运行",link:"#_1-10-获取成员方法并运行",children:[]},{level:2,title:"面试题：",slug:"面试题",link:"#面试题",children:[]},{level:2,title:"1.11 练习泛型擦除（掌握概念，了解代码）",slug:"_1-11-练习泛型擦除-掌握概念-了解代码",link:"#_1-11-练习泛型擦除-掌握概念-了解代码",children:[]},{level:2,title:"1.12 练习：修改字符串的内容（掌握概念，了解代码）",slug:"_1-12-练习-修改字符串的内容-掌握概念-了解代码",link:"#_1-12-练习-修改字符串的内容-掌握概念-了解代码",children:[]},{level:2,title:"1.13 练习，反射和配置文件结合动态获取的练习（重点）",slug:"_1-13-练习-反射和配置文件结合动态获取的练习-重点",link:"#_1-13-练习-反射和配置文件结合动态获取的练习-重点",children:[]},{level:2,title:"1.14 利用发射保存对象中的信息（重点）",slug:"_1-14-利用发射保存对象中的信息-重点",link:"#_1-14-利用发射保存对象中的信息-重点",children:[]},{level:2,title:"2.1 好处：",slug:"_2-1-好处",link:"#_2-1-好处",children:[]},{level:2,title:"2.2 动态代理三要素：",slug:"_2-2-动态代理三要素",link:"#_2-2-动态代理三要素",children:[]},{level:2,title:"2.3 代码实现：",slug:"_2-3-代码实现",link:"#_2-3-代码实现",children:[]},{level:2,title:"2.4 额外扩展",slug:"_2-4-额外扩展",link:"#_2-4-额外扩展",children:[]},{level:2,title:"2.5 动态代理的练习",slug:"_2-5-动态代理的练习",link:"#_2-5-动态代理的练习",children:[]}],path:"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",pathLocale:"/",extraFields:['java\n//1.Class这个类里面的静态方法forName\n//Class.forName("类的全类名")： 全类名 = 包名 + 类名\nClass clazz1 = Class.forName("com.itheima.reflectdemo.Student");\n//源代码阶段获取 --- 先把Student加载到内存中，再获取字节码文件的对象\n//clazz 就表示Student这个类的字节码文件对象。\n//就是当Student.class这个文件加载到内存之后，产生的字节码文件对象\n\n\n//2.通过class属性获取\n//类名.class\nClass clazz2 = Student.class;\n\n//因为class文件在硬盘中是唯一的，所以，当这个文件加载到内存之后产生的对象也是唯一的\nSystem.out.println(clazz1 == clazz2);//true\n\n\n//3.通过Student对象获取字节码文件对象\nStudent s = new Student();\nClass clazz3 = s.getClass();\nSystem.out.println(clazz1 == clazz2);//true\nSystem.out.println(clazz2 == clazz3);//true','java\npublic class ReflectDemo2 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获得整体（class字节码文件对象）\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n\n        //2.获取构造方法对象\n        //获取所有构造方法（public）\n        Constructor[] constructors1 = clazz.getConstructors();\n        for (Constructor constructor : constructors1) {\n            System.out.println(constructor);\n        }\n\n        System.out.println("=======================");\n\n        //获取所有构造（带私有的）\n        Constructor[] constructors2 = clazz.getDeclaredConstructors();\n\n        for (Constructor constructor : constructors2) {\n            System.out.println(constructor);\n        }\n        System.out.println("=======================");\n\n        //获取指定的空参构造\n        Constructor con1 = clazz.getConstructor();\n        System.out.println(con1);\n\n        Constructor con2 = clazz.getConstructor(String.class,int.class);\n        System.out.println(con2);\n\n        System.out.println("=======================");\n        //获取指定的构造(所有构造都可以获取到，包括public包括private)\n        Constructor con3 = clazz.getDeclaredConstructor();\n        System.out.println(con3);\n        //了解 System.out.println(con3 == con1);\n        //每一次获取构造方法对象的时候，都会新new一个。\n\n        Constructor con4 = clazz.getDeclaredConstructor(String.class);\n        System.out.println(con4);\n    }\n}','java\n//首先要有一个javabean类\npublic class Student {\n    private String name;\n\n    private int age;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + "}";\n    }\n}\n\n\n\n//测试类中的代码：\n//需求1：\n//获取空参，并创建对象\n\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n//2.获取空参的构造方法\nConstructor con = clazz.getConstructor();\n//3.利用空参构造方法创建对象\nStudent stu = (Student) con.newInstance();\nSystem.out.println(stu);\n\n\nSystem.out.println("=============================================");\n\n\n//测试类中的代码：\n//需求2：\n//获取带参构造，并创建对象\n//1.获取整体的字节码文件对象\nClass clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n//2.获取有参构造方法\nConstructor con = clazz.getDeclaredConstructor(String.class, int.class);\n//3.临时修改构造方法的访问权限（暴力反射）\ncon.setAccessible(true);\n//4.直接创建对象\nStudent stu = (Student) con.newInstance("zhangsan", 23);\nSystem.out.println(stu);','java\npublic class ReflectDemo4 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        //获取成员变量对象\n\n        //1.获取class对象\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n        //2.获取成员变量的对象（Field对象)只能获取public修饰的\n        Field[] fields1 = clazz.getFields();\n        for (Field field : fields1) {\n            System.out.println(field);\n        }\n\n        System.out.println("===============================");\n\n        //获取成员变量的对象（public + private）\n        Field[] fields2 = clazz.getDeclaredFields();\n        for (Field field : fields2) {\n            System.out.println(field);\n        }\n\n        System.out.println("===============================");\n        //获得单个成员变量对象\n        //如果获取的属性是不存在的，那么会报异常\n        //Field field3 = clazz.getField("aaa");\n        //System.out.println(field3);//NoSuchFieldException\n\n        Field field4 = clazz.getField("gender");\n        System.out.println(field4);\n\n        System.out.println("===============================");\n        //获取单个成员变量（私有）\n        Field field5 = clazz.getDeclaredField("name");\n        System.out.println(field5);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n\n    private int age;\n\n    public String gender;\n\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", address = " + address + "}";\n    }\n}','java\npublic class ReflectDemo5 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        Student s = new Student("zhangsan",23,"广州");\n        Student ss = new Student("lisi",24,"北京");\n\n        //需求：\n        //利用反射获取成员变量并获取值和修改值\n\n        //1.获取class对象\n        Class clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n        //2.获取name成员变量\n        //field就表示name这个属性的对象\n        Field field = clazz.getDeclaredField("name");\n        //临时修饰他的访问权限\n        field.setAccessible(true);\n\n        //3.设置(修改)name的值\n        //参数一：表示要修改哪个对象的name？\n        //参数二：表示要修改为多少？\n        field.set(s,"wangwu");\n\n        //3.获取name的值\n        //表示我要获取这个对象的name的值\n        String result = (String)field.get(s);\n\n        //4.打印结果\n        System.out.println(result);\n\n        System.out.println(s);\n        System.out.println(ss);\n\n    }\n}\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n    }\n\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n\n\n    public Student(String name, int age, String gender, String address) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.address = address;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public String getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return address\n     */\n    public String getAddress() {\n        return address;\n    }\n\n    /**\n     * 设置\n     * @param address\n     */\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", address = " + address + "}";\n    }\n}','java\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //1.获取class对象\n        Class<?> clazz = Class.forName("com.itheima.reflectdemo.Student");\n\n\n        //2.获取方法\n        //getMethods可以获取父类中public修饰的方法\n        Method[] methods1 = clazz.getMethods();\n        for (Method method : methods1) {\n            System.out.println(method);\n        }\n\n        System.out.println("===========================");\n        //获取所有的方法（包含私有）\n        //但是只能获取自己类中的方法\n        Method[] methods2 = clazz.getDeclaredMethods();\n        for (Method method : methods2) {\n            System.out.println(method);\n        }\n\n        System.out.println("===========================");\n        //获取指定的方法（空参）\n        Method method3 = clazz.getMethod("sleep");\n        System.out.println(method3);\n\n        Method method4 = clazz.getMethod("eat",String.class);\n        System.out.println(method4);\n\n        //获取指定的私有方法\n        Method method5 = clazz.getDeclaredMethod("playGame");\n        System.out.println(method5);\n    }\n}','java\npackage com.itheima.a02reflectdemo1;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo6 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.获取字节码文件对象\n        Class clazz = Class.forName("com.itheima.a02reflectdemo1.Student");\n\t\t\n        //2.获取一个对象\n        //需要用这个对象去调用方法\n        Student s = new Student();\n        \n        //3.获取一个指定的方法\n        //参数一：方法名\n        //参数二：参数列表，如果没有可以不写\n        Method eatMethod = clazz.getMethod("eat",String.class);\n        \n        //运行\n        //参数一：表示方法的调用对象\n        //参数二：方法在运行时需要的实际参数\n        //注意点：如果方法有返回值，那么需要接收invoke的结果\n        //如果方法没有返回值，则不需要接收\n        String result = (String) eatMethod.invoke(s, "重庆小面");\n        System.out.println(result);\n\n    }\n}\n\n\n\npublic class Student {\n    private String name;\n    private int age;\n    public String gender;\n    public String address;\n\n\n    public Student() {\n\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    private Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + "}";\n    }\n\n    private void study(){\n        System.out.println("学生在学习");\n    }\n\n    private void sleep(){\n        System.out.println("学生在睡觉");\n    }\n\n    public String eat(String something){\n        System.out.println("学生在吃" + something);\n        return "学生已经吃完了，非常happy";\n    }\n}','java\npackage com.itheima.reflectdemo;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\n\npublic class ReflectDemo8 {\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        //1.创建集合对象\n        ArrayList<Integer> list = new ArrayList<>();\n        list.add(123);\n//        list.add("aaa");\n\n        //2.利用反射运行add方法去添加字符串\n        //因为反射使用的是class字节码文件\n\n        //获取class对象\n        Class clazz = list.getClass();\n\n        //获取add方法对象\n        Method method = clazz.getMethod("add", Object.class);\n\n        //运行方法\n        method.invoke(list,"aaa");\n\n        //打印集合\n        System.out.println(list);\n    }\n}',"java\nprivate final byte[] value;",'java\nString s = "abc";\nString ss = "abc";\n// private final byte[] value= {97,98,99};\n// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值\n// 如果我们利用反射获取了value的地址值。\n// 也是可以修改的，final修饰的value\n// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险\n\n//1.获取class对象\nClass clazz = s.getClass();\n\n//2.获取value成员变量（private）\nField field = clazz.getDeclaredField("value");\n//但是这种操作非常危险\n//JDK高版本已经屏蔽了这种操作，低版本还是可以的\n//临时修改权限\nfield.setAccessible(true);\n\n//3.获取value记录的地址值\nbyte[] bytes = (byte[]) field.get(s);\nbytes[0] = 100;\n\nSystem.out.println(s);//dbc\nSystem.out.println(ss);//dbc','java\npublic class ReflectDemo9 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //1.读取配置文件的信息\n        Properties prop = new Properties();\n        FileInputStream fis = new FileInputStream("day14-code\\\\prop.properties");\n        prop.load(fis);\n        fis.close();\n        System.out.println(prop);\n\n        String classname = prop.get("classname") + "";\n        String methodname = prop.get("methodname") + "";\n\n        //2.获取字节码文件对象\n        Class clazz = Class.forName(classname);\n\n        //3.要先创建这个类的对象\n        Constructor con = clazz.getDeclaredConstructor();\n        con.setAccessible(true);\n        Object o = con.newInstance();\n        System.out.println(o);\n\n        //4.获取方法的对象\n        Method method = clazz.getDeclaredMethod(methodname);\n        method.setAccessible(true);\n\n        //5.运行方法\n        method.invoke(o);\n\n\n    }\n}\n\n配置文件中的信息：\nclassname=com.itheima.a02reflectdemo1.Student\nmethodname=sleep','java\npublic class MyReflectDemo {\n    public static void main(String[] args) throws IllegalAccessException, IOException {\n    /*\n        对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去\n    */\n       Student s = new Student("小A",23,\'女\',167.5,"睡觉");\n       Teacher t = new Teacher("播妞",10000);\n       saveObject(s);\n    }\n\n    //把对象里面所有的成员变量名和值保存到本地文件中\n    public static void saveObject(Object obj) throws IllegalAccessException, IOException {\n        //1.获取字节码文件的对象\n        Class clazz = obj.getClass();\n        //2. 创建IO流\n        BufferedWriter bw = new BufferedWriter(new FileWriter("myreflect\\\\a.txt"));\n        //3. 获取所有的成员变量\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            field.setAccessible(true);\n            //获取成员变量的名字\n            String name = field.getName();\n            //获取成员变量的值\n            Object value = field.get(obj);\n            //写出数据\n            bw.write(name + "=" + value);\n            bw.newLine();\n        }\n\n        bw.close();\n\n    }\n}','java\npublic class Student {\n    private String name;\n    private int age;\n    private char gender;\n    private double height;\n    private String hobby;\n\n    public Student() {\n    }\n\n    public Student(String name, int age, char gender, double height, String hobby) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.height = height;\n        this.hobby = hobby;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return age\n     */\n    public int getAge() {\n        return age;\n    }\n\n    /**\n     * 设置\n     * @param age\n     */\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * 获取\n     * @return gender\n     */\n    public char getGender() {\n        return gender;\n    }\n\n    /**\n     * 设置\n     * @param gender\n     */\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    /**\n     * 获取\n     * @return height\n     */\n    public double getHeight() {\n        return height;\n    }\n\n    /**\n     * 设置\n     * @param height\n     */\n    public void setHeight(double height) {\n        this.height = height;\n    }\n\n    /**\n     * 获取\n     * @return hobby\n     */\n    public String getHobby() {\n        return hobby;\n    }\n\n    /**\n     * 设置\n     * @param hobby\n     */\n    public void setHobby(String hobby) {\n        this.hobby = hobby;\n    }\n\n    public String toString() {\n        return "Student{name = " + name + ", age = " + age + ", gender = " + gender + ", height = " + height + ", hobby = " + hobby + "}";\n    }\n}','java\npublic class Teacher {\n    private String name;\n    private double salary;\n\n    public Teacher() {\n    }\n\n    public Teacher(String name, double salary) {\n        this.name = name;\n        this.salary = salary;\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * 获取\n     * @return salary\n     */\n    public double getSalary() {\n        return salary;\n    }\n\n    /**\n     * 设置\n     * @param salary\n     */\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    public String toString() {\n        return "Teacher{name = " + name + ", salary = " + salary + "}";\n    }\n}','java\npublic class Test {\n    public static void main(String[] args) {\n    /*\n        需求：\n            外面的人想要大明星唱一首歌\n             1. 获取代理的对象\n                代理对象 = ProxyUtil.createProxy(大明星的对象);\n             2. 再调用代理的唱歌方法\n                代理对象.唱歌的方法("只因你太美");\n     */\n        //1. 获取代理的对象\n        BigStar bigStar = new BigStar("鸡哥");\n        Star proxy = ProxyUtil.createProxy(bigStar);\n\n        //2. 调用唱歌的方法\n        String result = proxy.sing("只因你太美");\n        System.out.println(result);\n    }\n}','java\n/*\n*\n* 类的作用：\n*       创建一个代理\n*\n* */\npublic class ProxyUtil {\n    /*\n    *\n    * 方法的作用：\n    *       给一个明星的对象，创建一个代理\n    *\n    *  形参：\n    *       被代理的明星对象\n    *\n    *  返回值：\n    *       给明星创建的代理\n    *\n    *\n    *\n    * 需求：\n    *   外面的人想要大明星唱一首歌\n    *   1. 获取代理的对象\n    *      代理对象 = ProxyUtil.createProxy(大明星的对象);\n    *   2. 再调用代理的唱歌方法\n    *      代理对象.唱歌的方法("只因你太美");\n    * */\n    public static Star createProxy(BigStar bigStar){\n       /* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\n\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        参数一：用于指定用哪个类加载器，去加载生成的代理类\n        参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n        参数三：用来指定生成的代理对象要干什么事情*/\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),//参数一：用于指定用哪个类加载器，去加载生成的代理类\n                new Class[]{Star.class},//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n                //参数三：用来指定生成的代理对象要干什么事情\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        /*\n                        * 参数一：代理的对象\n                        * 参数二：要运行的方法 sing\n                        * 参数三：调用sing方法时，传递的实参\n                        * */\n                        if("sing".equals(method.getName())){\n                            System.out.println("准备话筒，收钱");\n                        }else if("dance".equals(method.getName())){\n                            System.out.println("准备场地，收钱");\n                        }\n                        //去找大明星开始唱歌或者跳舞\n                        //代码的表现形式：调用大明星里面唱歌或者跳舞的方法\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}',"java\npublic interface Star {\n    //我们可以把所有想要被代理的方法定义在接口当中\n    //唱歌\n    public abstract String sing(String name);\n    //跳舞\n    public abstract void dance();\n}",'java\npublic class BigStar implements Star {\n    private String name;\n\n\n    public BigStar() {\n    }\n\n    public BigStar(String name) {\n        this.name = name;\n    }\n\n    //唱歌\n    @Override\n    public String sing(String name){\n        System.out.println(this.name + "正在唱" + name);\n        return "谢谢";\n    }\n\n    //跳舞\n    @Override\n    public void dance(){\n        System.out.println(this.name + "正在跳舞");\n    }\n\n    /**\n     * 获取\n     * @return name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * 设置\n     * @param name\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String toString() {\n        return "BigStar{name = " + name + "}";\n    }\n}','java\n/*\n* 类的作用：\n*       创建一个代理\n* */\npublic class ProxyUtil {\n    public static Star createProxy(BigStar bigStar){\n        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)\n        Star star = (Star) Proxy.newProxyInstance(\n                ProxyUtil.class.getClassLoader(),\n                new Class[]{Star.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        if("cleanWC".equals(method.getName())){\n                            System.out.println("拦截，不调用大明星的方法");\n                            return null;\n                        }\n                        //如果是其他方法，正常执行\n                        return method.invoke(bigStar,args);\n                    }\n                }\n        );\n        return star;\n    }\n}','java\npublic class MyProxyDemo1 {\n    public static void main(String[] args) {\n        //动态代码可以增强也可以拦截\n        //1.创建真正干活的人\n        ArrayList<String> list = new ArrayList<>();\n\n        //2.创建代理对象\n        //参数一：类加载器。当前类名.class.getClassLoader()\n        //                 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存\n\n        //参数二：是一个数组，在数组里面写接口的字节码文件对象。\n        //                  如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截\n        //                  但是，一定要写ArrayList真实实现的接口\n        //                  假设在第二个参数中，写了MyInter接口，那么是错误的。\n        //                  因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截\n        //参数三：用来创建代理对象的匿名内部类\n        List proxyList = (List) Proxy.newProxyInstance(\n                //参数一：类加载器\n                MyProxyDemo1.class.getClassLoader(),\n                //参数二：是一个数组，表示代理对象能代理的方法范围\n                new Class[]{List.class},\n                //参数三：本质就是代理对象\n                new InvocationHandler() {\n                    @Override\n                    //invoke方法参数的意义\n                    //参数一：表示代理对象，一般不用（了解）\n                    //参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截\n                    //参数三：就是下面第三步调用方法时，传递的参数。\n                    //举例1：\n                    //list.add("阿玮好帅");\n                    //此时参数二就是add这个方法名\n                    //此时参数三 args[0] 就是 阿玮好帅\n                    //举例2：\n                    //list.set(1, "aaa");\n                    //此时参数二就是set这个方法名\n                    //此时参数三  args[0] 就是 1  args[1]"aaa"\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        //对add方法做一个增强，统计耗时时间\n                        if (method.getName().equals("add")) {\n                            long start = System.currentTimeMillis();\n                            //调用集合的方法，真正的添加数据\n                            method.invoke(list, args);\n                            long end = System.currentTimeMillis();\n                            System.out.println("耗时时间：" + (end - start));\n                            //需要进行返回，返回值要跟真正增强或者拦截的方法保持一致\n                            return true;\n                        }else if(method.getName().equals("remove") && args[0] instanceof Integer){\n                            System.out.println("拦截了按照索引删除的方法");\n                            return null;\n                        }else if(method.getName().equals("remove")){\n                            System.out.println("拦截了按照对象删除的方法");\n                            return false;\n                        }else{\n                            //如果当前调用的是其他方法,我们既不增强，也不拦截\n                            method.invoke(list,args);\n                            return null;\n                        }\n                    }\n                }\n        );\n\n        //3.调用方法\n        //如果调用者是list，就好比绕过了第二步的代码，直接添加元素\n        //如果调用者是代理对象，此时代理才能帮我们增强或者拦截\n\n        //每次调用方法的时候，都不会直接操作集合\n        //而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截\n        proxyList.add("aaa");\n        proxyList.add("bbb");\n        proxyList.add("ccc");\n        proxyList.add("ddd");\n\n        proxyList.remove(0);\n        proxyList.remove("aaa");\n\n\n        //打印集合\n        System.out.println(list);\n    }\n}']},{title:"Spring Framework 综述",headers:[{level:2,title:"Spring Framework 简介",slug:"spring-framework-简介",link:"#spring-framework-简介",children:[]},{level:2,title:"为什么使用 Spring",slug:"为什么使用-spring",link:"#为什么使用-spring",children:[]},{level:2,title:"核心思想",slug:"核心思想",link:"#核心思想",children:[{level:3,title:"IoC",slug:"ioc",link:"#ioc",children:[]},{level:3,title:"Aop",slug:"aop",link:"#aop",children:[]}]},{level:2,title:"Spring 体系结构",slug:"spring-体系结构",link:"#spring-体系结构",children:[{level:3,title:"Core Container",slug:"core-container",link:"#core-container",children:[]},{level:3,title:"AOP and Instrumentation",slug:"aop-and-instrumentation",link:"#aop-and-instrumentation",children:[]},{level:3,title:"Messaging",slug:"messaging",link:"#messaging",children:[]},{level:3,title:"Data Access / Integaration",slug:"data-access-integaration",link:"#data-access-integaration",children:[]},{level:3,title:"Web",slug:"web",link:"#web",children:[]},{level:3,title:"Test",slug:"test",link:"#test",children:[]}]},{level:2,title:"术语",slug:"术语",link:"#术语",children:[]}],path:"/pages/9d3091/",pathLocale:"/",extraFields:['java\nApplicationContext context = new FileSystemXmlApplicationContext("D:\\Temp\\build.xml");\nApplicationContext context2 = new ClassPathXmlApplicationContext("build.xml");']},{title:"SpringBoot 知识图谱",headers:[{level:2,title:"一、抛砖引玉：探索 Spring IoC 容器",slug:"一、抛砖引玉-探索-spring-ioc-容器",link:"#一、抛砖引玉-探索-spring-ioc-容器",children:[{level:3,title:"1.1、Spring IoC 容器",slug:"_1-1、spring-ioc-容器",link:"#_1-1、spring-ioc-容器",children:[]},{level:3,title:"1.2、Spring 容器扩展机制",slug:"_1-2、spring-容器扩展机制",link:"#_1-2、spring-容器扩展机制",children:[]}]},{level:2,title:"二、夯实基础：JavaConfig 与常见 Annotation",slug:"二、夯实基础-javaconfig-与常见-annotation",link:"#二、夯实基础-javaconfig-与常见-annotation",children:[{level:3,title:"2.1、JavaConfig",slug:"_2-1、javaconfig",link:"#_2-1、javaconfig",children:[]},{level:3,title:"2.2、@ComponentScan",slug:"_2-2、-componentscan",link:"#_2-2、-componentscan",children:[]},{level:3,title:"2.3、@Import",slug:"_2-3、-import",link:"#_2-3、-import",children:[]},{level:3,title:"2.4、@Conditional",slug:"_2-4、-conditional",link:"#_2-4、-conditional",children:[]},{level:3,title:"2.5、@ConfigurationProperties 与@EnableConfigurationProperties",slug:"_2-5、-configurationproperties-与-enableconfigurationproperties",link:"#_2-5、-configurationproperties-与-enableconfigurationproperties",children:[]}]},{level:2,title:"三、削铁如泥：SpringFactoriesLoader 详解",slug:"三、削铁如泥-springfactoriesloader-详解",link:"#三、削铁如泥-springfactoriesloader-详解",children:[]},{level:2,title:"四、另一件武器：Spring 容器的事件监听机制",slug:"四、另一件武器-spring-容器的事件监听机制",link:"#四、另一件武器-spring-容器的事件监听机制",children:[]},{level:2,title:"五、出神入化：揭秘自动配置原理",slug:"五、出神入化-揭秘自动配置原理",link:"#五、出神入化-揭秘自动配置原理",children:[]},{level:2,title:"六、启动引导：Spring Boot 应用启动的秘密",slug:"六、启动引导-spring-boot-应用启动的秘密",link:"#六、启动引导-spring-boot-应用启动的秘密",children:[{level:3,title:"6.1 SpringApplication 初始化",slug:"_6-1-springapplication-初始化",link:"#_6-1-springapplication-初始化",children:[]},{level:3,title:"6.2 Spring Boot 启动流程",slug:"_6-2-spring-boot-启动流程",link:"#_6-2-spring-boot-启动流程",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/430f53/",pathLocale:"/",extraFields:['// 默认容器实现\nDefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();\n// 根据业务对象构造相应的BeanDefinition\nAbstractBeanDefinition definition = new RootBeanDefinition(Business.class,true);\n// 将bean定义注册到容器中\nbeanRegistry.registerBeanDefinition("beanName",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，\n// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");','// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例\nBeanDefinitionRegistry beanRegistry = new DefaultListableBeanFactory();\n// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件\nXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReaderImpl(beanRegistry);\n// 加载配置文件\nbeanDefinitionReader.loadBeanDefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");',"public interface BeanPostProcessor {\n    // 前置处理\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n    // 后置处理\n    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}","// 代码来自：org.springframework.context.support.ApplicationContextAwareProcessor\n// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof EnvironmentAware) {\n        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n    }\n    if (bean instanceof ApplicationContextAware) {\n        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n    }\n    // ......\n}",'<bean id="bookService" class="cn.moondev.service.BookServiceImpl"></bean>',"@Configuration\npublic class MoonBookConfiguration {\n\n    // 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中\n    // 方法名默认成为该bean定义的id\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}",'<bean id="bookService" class="cn.moondev.service.BookServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="otherService" class="cn.moondev.service.OtherServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"/>',"@Configuration\npublic class MoonBookConfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyService()\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public OtherService otherService() {\n        return new OtherServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService() {\n        return new DependencyServiceImpl();\n    }\n}","@Configuration\npublic class MoonBookConfiguration {\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}","@Configuration\n// 可以同时导入多个配置类，比如：@Import({A.class,B.class})\n@Import(MoonBookConfiguration.class)\npublic class MoonUserConfiguration {\n    @Bean\n    public UserService userService(BookService bookService) {\n        return new BookServiceImpl(bookService);\n    }\n}",'public class JdbcTemplateCondition implements Condition {\n\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n        try {\n        conditionContext.getClassLoader().loadClass("org.springframework.jdbc.core.JdbcTemplate");\n            return true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}',"@Conditional(JdbcTemplateCondition.class)\n@Service\npublic MyService service() {\n    ......\n}",'// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @Value("jdbc.mysql.url")\n    public String url;\n    @Value("jdbc.mysql.username")\n    public String user;\n    @Value("jdbc.mysql.password")\n    public String password;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(url);\n        hikariConfig.setUsername(user);\n        hikariConfig.setPassword(password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}','@Component\n//  还可以通过@PropertySource("classpath:jdbc.properties")来指定配置文件\n@ConfigurationProperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class JdbcConfig {\n    public String url;\n    public String username;\n    public String password;\n}\n\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @AutoWired\n    public JdbcConfig config;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(config.url);\n        hikariConfig.setUsername(config.username);\n        hikariConfig.setPassword(config.password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}',"#App\napp.menus[0].title=Home\napp.menus[0].name=Home\napp.menus[0].path=/\napp.menus[1].title=Login\napp.menus[1].name=Login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/",'@Component\n@ConfigurationProperties("app")\npublic class AppProperties {\n\n    public String error;\n    public List<Menu> menus = new ArrayList<>();\n    public Compiler compiler = new Compiler();\n\n    public static class Menu {\n        public String name;\n        public String path;\n        public String title;\n    }\n\n    public static class Compiler {\n        public String timeout;\n        public String outputFolder;\n    }\n}',"protected Class<?> loadClass(String name, boolean resolve) {\n    synchronized (getClassLoadingLock(name)) {\n    // 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回\n    Class<?> c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是BootstrapClassLoader为止\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findClass方法去寻找\n            // findClass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findClass(name);\n        }\n    }\n    if (resolve) {\n        resolveClass(c);\n    }\n    return c;\n    }\n}",'for (String aDriver : driversList) {\n    try {\n        // 直接使用AppClassLoader\n        Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());\n    } catch (Exception ex) {\n        println("DriverManager.Initialize: load failed: " + ex);\n    }\n}',"public Enumeration<URL> getResources(String name) throws IOException {\n    Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getResources(name);\n    } else {\n        tmp[0] = getBootstrapResources(name);\n    }\n    tmp[1] = findResources(name);\n    return new CompoundEnumeration<>(tmp);\n}",'// 寻找Array.class文件\npublic static void main(String[] args) throws Exception{\n    // Array.class的完整路径\n    String name = "java/sql/Array.class";\n    Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(name);\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        System.out.println(url.toString());\n    }\n}',"$JAVA_HOME/jre/lib/rt.jar!/java/sql/Array.class",'public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到META-INF/spring.factories文件\n// 然后从文件中解析出key=factoryClass类名称的所有value值\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    // 取得资源文件的URL\n    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    List<String> result = new ArrayList<String>();\n    // 遍历所有的URL\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // 根据资源文件URL解析properties文件\n        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n        String factoryClassNames = properties.getProperty(factoryClassName);\n        // 组装数据，并返回\n        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n    }\n    return result;\n}',"// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\","public class MethodMonitorEvent extends EventObject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public MethodMonitorEvent(Object source) {\n        super(source);\n    }\n}",'// 1、定义事件监听接口\npublic interface MethodMonitorEventListener extends EventListener {\n    // 处理方法执行之前发布的事件\n    public void onMethodBegin(MethodMonitorEvent event);\n    // 处理方法结束时发布的事件\n    public void onMethodEnd(MethodMonitorEvent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class AbstractMethodMonitorEventListener implements MethodMonitorEventListener {\n\n    @Override\n    public void onMethodBegin(MethodMonitorEvent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void onMethodEnd(MethodMonitorEvent event) {\n        // 计算方法耗时\n        long duration = System.currentTimeMillis() - event.timestamp;\n        System.out.println("耗时：" + duration);\n    }\n}','public class MethodMonitorEventPublisher {\n\n    private List<MethodMonitorEventListener> listeners = new ArrayList<MethodMonitorEventListener>();\n\n    public void methodMonitor() {\n        MethodMonitorEvent eventObject = new MethodMonitorEvent(this);\n        publishEvent("begin",eventObject);\n        // 模拟方法执行：休眠5秒钟\n        TimeUnit.SECONDS.sleep(5);\n        publishEvent("end",eventObject);\n\n    }\n\n    private void publishEvent(String status,MethodMonitorEvent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        List<MethodMonitorEventListener> copyListeners = ➥ new ArrayList<MethodMonitorEventListener>(listeners);\n        for (MethodMonitorEventListener listener : copyListeners) {\n            if ("begin".equals(status)) {\n                listener.onMethodBegin(event);\n            } else {\n                listener.onMethodEnd(event);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MethodMonitorEventPublisher publisher = new MethodMonitorEventPublisher();\n        publisher.addEventListener(new AbstractMethodMonitorEventListener());\n        publisher.methodMonitor();\n    }\n    // 省略实现\n    public void addEventListener(MethodMonitorEventListener listener) {}\n    public void removeEventListener(MethodMonitorEventListener listener) {}\n    public void removeAllListeners() {}',"@SpringBootApplication\npublic class MoonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MoonApplication.class, args);\n    }\n}","@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ......\n}","@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    // ......\n}","public String[] selectImports(AnnotationMetadata annotationMetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中\n    // SpringFactoriesLoader相关知识请参考前文\n    List<String> factories = new ArrayList<String>(new LinkedHashSet<String>(\n        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, this.beanClassLoader)));\n}","// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// 配置的key = EnableAutoConfiguration，与代码中一致\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n.....","@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n}",'// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@ConfigurationProperties(prefix = "spring.datasource")\npublic class DataSourceProperties  {\n    private ClassLoader classLoader;\n    private Environment environment;\n    private String name = "testdb";\n    ......\n}',"@Configuration\npublic class DataSourcePoolMetadataProvidersConfiguration {\n\n    @Configuration\n    @ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)\n    static class TomcatDataSourcePoolMetadataProviderConfiguration {\n        @Bean\n        public DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {\n            .....\n        }\n    }\n  ......\n}","private void initialize(Object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addAll(Arrays.asList(sources));\n     }\n     // 判断是否是Web项目\n     this.webEnvironment = deduceWebEnvironment();\n     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n     // 找到入口类\n     this.mainApplicationClass = deduceMainApplicationClass();\n}","org.springframework.context.ApplicationListener=\\\ncn.moondev.listeners.xxxxListener\\","public ConfigurableApplicationContext run(String... args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        ConfigurableApplicationContext context = null;\n        FailureAnalyzers analyzers = null;\n        configureHeadlessProperty();\n        // ①\n        SpringApplicationRunListeners listeners = getRunListeners(args);\n        listeners.starting();\n        try {\n            // ②\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);\n            // ③\n            Banner printedBanner = printBanner(environment);\n            // ④\n            context = createApplicationContext();\n            // ⑤\n            analyzers = new FailureAnalyzers(context);\n            // ⑥\n            prepareContext(context, environment, listeners, applicationArguments,printedBanner);\n            // ⑦\n            refreshContext(context);\n            // ⑧\n            afterRefresh(context, applicationArguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopWatch.stop();\n            return context;\n        }\n        catch (Throwable ex) {\n            handleRunFailure(context, listeners, analyzers, ex);\n            throw new IllegalStateException(ex);\n        }\n    }","public interface SpringApplicationRunListener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // Environment准备好后，并且ApplicationContext创建之前调用\n    void environmentPrepared(ConfigurableEnvironment environment);\n\n    // ApplicationContext创建好后立即调用\n    void contextPrepared(ConfigurableApplicationContext context);\n\n    // ApplicationContext加载完成，在refresh之前调用\n    void contextLoaded(ConfigurableApplicationContext context);\n\n    // 当run方法结束之前调用\n    void finished(ConfigurableApplicationContext context, Throwable exception);\n\n}","public void starting() {\n    // 发布一个ApplicationStartedEvent\n    this.initialMulticaster.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}",".   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.6.RELEASE)","// 摘自refresh()方法中一句代码\ninvokeBeanFactoryPostProcessors(beanFactory);","protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n    ......\n}","ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor\nSharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor\nConfigFileApplicationListener$PropertySourceOrderingPostProcessor","public void initialize(ConfigurableApplicationContext context) {\n    context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));\n}"]},{title:"SpringBoot 基本原理",headers:[{level:2,title:"SpringBootApplication 背后的秘密",slug:"springbootapplication-背后的秘密",link:"#springbootapplication-背后的秘密",children:[]},{level:2,title:"@Configuration",slug:"configuration",link:"#configuration",children:[]},{level:2,title:"@ComponentScan",slug:"componentscan",link:"#componentscan",children:[]},{level:2,title:"@EnableAutoConfiguration",slug:"enableautoconfiguration",link:"#enableautoconfiguration",children:[{level:3,title:"自动配置幕后英雄：SpringFactoriesLoader 详解",slug:"自动配置幕后英雄-springfactoriesloader-详解",link:"#自动配置幕后英雄-springfactoriesloader-详解",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/dbf521/",pathLocale:"/",extraFields:["java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}","kotlin\n@Target(ElementType.TYPE)            // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明\n@Retention(RetentionPolicy.RUNTIME)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@Documented                          // 表明这个注解应该被javadoc记录\n@Inherited                           // 子类可以继承该注解\n@SpringBootConfiguration             // 继承了Configuration，表示当前是注解类\n@EnableAutoConfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@ComponentScan(excludeFilters = {    // 扫描路径设置（具体使用待确认）\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}","java\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>',"java\n@Configuration\npublic class MockConfiguration{\n    //bean定义\n}",'csharp\n<bean id="mockService" class="..MockServiceImpl">\n    ...\n</bean>',"java\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl();\n    }\n}",'jsx\n<bean id="mockService" class="..MockServiceImpl">\n    <propery name ="dependencyService" ref="dependencyService" />\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"></bean>',"java\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}",'kotlin\n@SuppressWarnings("deprecation")\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    ...\n}',"java\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata metadata,\n                BeanDefinitionRegistry registry) {\n            register(registry, new PackageImport(metadata).getPackageName());\n        }","dart\n@Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) {\n        if (!isEnabled(annotationMetadata)) {\n            return NO_IMPORTS;\n        }\n        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n                .loadMetadata(this.beanClassLoader);\n        AnnotationAttributes attributes = getAttributes(annotationMetadata);\n        List<String> configurations = getCandidateConfigurations(annotationMetadata,\n                attributes);\n        configurations = removeDuplicates(configurations);\n        Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n        checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = filter(configurations, autoConfigurationMetadata);\n        fireAutoConfigurationImportEvents(configurations, exclusions);\n        return StringUtils.toStringArray(configurations);\n    }","php\npublic abstract class SpringFactoriesLoader {\n    //...\n    public static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n        ...\n    }\n\n\n    public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n        ....\n    }\n}"]},{title:"Spring 面试",headers:[{level:2,title:"综合篇",slug:"综合篇",link:"#综合篇",children:[{level:3,title:"不同版本的 Spring Framework 有哪些主要功能？",slug:"不同版本的-spring-framework-有哪些主要功能",link:"#不同版本的-spring-framework-有哪些主要功能",children:[]},{level:3,title:"什么是 Spring Framework？",slug:"什么是-spring-framework",link:"#什么是-spring-framework",children:[]},{level:3,title:"列举 Spring Framework 的优点。",slug:"列举-spring-framework-的优点。",link:"#列举-spring-framework-的优点。",children:[]},{level:3,title:"Spring Framework 有哪些不同的功能？",slug:"spring-framework-有哪些不同的功能",link:"#spring-framework-有哪些不同的功能",children:[]},{level:3,title:"Spring Framework 中有多少个模块，它们分别是什么？",slug:"spring-framework-中有多少个模块-它们分别是什么",link:"#spring-framework-中有多少个模块-它们分别是什么",children:[]},{level:3,title:"什么是 Spring 配置文件？",slug:"什么是-spring-配置文件",link:"#什么是-spring-配置文件",children:[]},{level:3,title:"Spring 应用程序有哪些不同组件？",slug:"spring-应用程序有哪些不同组件",link:"#spring-应用程序有哪些不同组件",children:[]},{level:3,title:"使用 Spring 有哪些方式？",slug:"使用-spring-有哪些方式",link:"#使用-spring-有哪些方式",children:[]}]},{level:2,title:"核心篇",slug:"核心篇",link:"#核心篇",children:[{level:3,title:"IoC",slug:"ioc",link:"#ioc",children:[]},{level:3,title:"Bean",slug:"bean",link:"#bean",children:[]},{level:3,title:"AOP",slug:"aop",link:"#aop",children:[]}]},{level:2,title:"注解",slug:"注解",link:"#注解",children:[{level:3,title:"你用过哪些重要的 Spring 注解？",slug:"你用过哪些重要的-spring-注解",link:"#你用过哪些重要的-spring-注解",children:[]},{level:3,title:"如何在 spring 中启动注解装配？",slug:"如何在-spring-中启动注解装配",link:"#如何在-spring-中启动注解装配",children:[]},{level:3,title:"@Component, @Controller, @Repository, @Service 有何区别？",slug:"component-controller-repository-service-有何区别",link:"#component-controller-repository-service-有何区别",children:[]},{level:3,title:"@Required 注解有什么用？",slug:"required-注解有什么用",link:"#required-注解有什么用",children:[]},{level:3,title:"@Autowired 注解有什么用？",slug:"autowired-注解有什么用",link:"#autowired-注解有什么用",children:[]},{level:3,title:"@Qualifier 注解有什么用？",slug:"qualifier-注解有什么用",link:"#qualifier-注解有什么用",children:[]},{level:3,title:"@RequestMapping 注解有什么用？",slug:"requestmapping-注解有什么用",link:"#requestmapping-注解有什么用",children:[]}]},{level:2,title:"数据篇",slug:"数据篇",link:"#数据篇",children:[{level:3,title:"spring DAO 有什么用？",slug:"spring-dao-有什么用",link:"#spring-dao-有什么用",children:[]},{level:3,title:"列举 Spring DAO 抛出的异常。",slug:"列举-spring-dao-抛出的异常。",link:"#列举-spring-dao-抛出的异常。",children:[]},{level:3,title:"spring JDBC API 中存在哪些类？",slug:"spring-jdbc-api-中存在哪些类",link:"#spring-jdbc-api-中存在哪些类",children:[]},{level:3,title:"使用 Spring 访问 Hibernate 的方法有哪些？",slug:"使用-spring-访问-hibernate-的方法有哪些",link:"#使用-spring-访问-hibernate-的方法有哪些",children:[]},{level:3,title:"列举 spring 支持的事务管理类型",slug:"列举-spring-支持的事务管理类型",link:"#列举-spring-支持的事务管理类型",children:[]},{level:3,title:"spring 支持哪些 ORM 框架",slug:"spring-支持哪些-orm-框架",link:"#spring-支持哪些-orm-框架",children:[]}]},{level:2,title:"MVC",slug:"mvc",link:"#mvc",children:[{level:3,title:"Spring MVC 框架有什么用？",slug:"spring-mvc-框架有什么用",link:"#spring-mvc-框架有什么用",children:[]},{level:3,title:"描述一下 DispatcherServlet 的工作流程",slug:"描述一下-dispatcherservlet-的工作流程",link:"#描述一下-dispatcherservlet-的工作流程",children:[]},{level:3,title:"介绍一下 WebApplicationContext",slug:"介绍一下-webapplicationcontext",link:"#介绍一下-webapplicationcontext",children:[]}]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/db33b0/",pathLocale:"/",extraFields:['java\ninterface Fruit {\n     public abstract void eat();\n}\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println("Apple");\n    }\n}\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println("Orange");\n    }\n}\nclass Factory {\n    public static Fruit getInstance(String ClassName) {\n        Fruit f=null;\n        try {\n            f=(Fruit)Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\nclass Client {\n    public static void main(String[] a) {\n        Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}','xml\n<bean id="studentbean" class="org.edureka.firstSpring.StudentBean">\n <property name="name" value="Edureka"></property>\n</bean>',"xml\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>","java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}","java\npublic class Student {\n    private Person person;\n    //Setters and Getters\n}\npublic class Person {\n    private String name;\n    private String address;\n    //Setters and Getters\n}",'xml\n<bean id=“StudentBean" class="com.edureka.Student">\n    <property name="person">\n        \x3c!--This is inner bean --\x3e\n        <bean class="com.edureka.Person">\n            <property name="name" value=“Scott"></property>\n            <property name="address" value=“Bangalore"></property>\n        </bean>\n    </property>\n</bean>',"Advice + Target Object = Proxy","java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}","java\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}","java\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName() {\n        return name;\n    }\n}","java\npublic class EmpAccount {\n    private Employee emp;\n\n    @Autowired\n    @Qualifier(emp1)\n    public void showName() {\n        System.out.println(“Employee name : ”+emp.getName);\n    }\n}"]},{title:"Spring 综述",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/9e0b67/",pathLocale:"/",extraFields:[]},{title:"Spring Bean",headers:[{level:2,title:"Spring Bean 定义",slug:"spring-bean-定义",link:"#spring-bean-定义",children:[{level:3,title:"BeanDefinition",slug:"beandefinition",link:"#beandefinition",children:[]},{level:3,title:"Spring Bean 命名",slug:"spring-bean-命名",link:"#spring-bean-命名",children:[]}]},{level:2,title:"Spring Bean 生命周期",slug:"spring-bean-生命周期",link:"#spring-bean-生命周期",children:[]},{level:2,title:"Spring Bean 注册",slug:"spring-bean-注册",link:"#spring-bean-注册",children:[{level:3,title:"XML 配置元信息",slug:"xml-配置元信息",link:"#xml-配置元信息",children:[]},{level:3,title:"注解配置元信息",slug:"注解配置元信息",link:"#注解配置元信息",children:[]},{level:3,title:"Java API 配置元信息",slug:"java-api-配置元信息",link:"#java-api-配置元信息",children:[]}]},{level:2,title:"Spring Bean 实例化",slug:"spring-bean-实例化",link:"#spring-bean-实例化",children:[]},{level:2,title:"Spring Bean 初始化和销毁",slug:"spring-bean-初始化和销毁",link:"#spring-bean-初始化和销毁",children:[]},{level:2,title:"Spring Bean 垃圾回收",slug:"spring-bean-垃圾回收",link:"#spring-bean-垃圾回收",children:[]},{level:2,title:"Spring Bean 作用范围",slug:"spring-bean-作用范围",link:"#spring-bean-作用范围",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/68097d/",pathLocale:"/",extraFields:["java\npublic interface BeanNameGenerator {\n   String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);\n}",'xml\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.User">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasUser" />']},{title:"Spring IoC",headers:[{level:2,title:"IoC 简介",slug:"ioc-简介",link:"#ioc-简介",children:[{level:3,title:"IoC 是什么",slug:"ioc-是什么",link:"#ioc-是什么",children:[]},{level:3,title:"IoC 能做什么",slug:"ioc-能做什么",link:"#ioc-能做什么",children:[]},{level:3,title:"IoC 和 DI",slug:"ioc-和-di",link:"#ioc-和-di",children:[]},{level:3,title:"IoC 容器",slug:"ioc-容器",link:"#ioc-容器",children:[]},{level:3,title:"Bean",slug:"bean",link:"#bean",children:[]},{level:3,title:"Spring IoC",slug:"spring-ioc-1",link:"#spring-ioc-1",children:[]}]},{level:2,title:"IoC 容器",slug:"ioc-容器-1",link:"#ioc-容器-1",children:[{level:3,title:"配置元数据",slug:"配置元数据",link:"#配置元数据",children:[]},{level:3,title:"实例化容器",slug:"实例化容器",link:"#实例化容器",children:[]},{level:3,title:"使用容器",slug:"使用容器",link:"#使用容器",children:[]}]},{level:2,title:"IoC 依赖来源",slug:"ioc-依赖来源",link:"#ioc-依赖来源",children:[]},{level:2,title:"IoC 配置元数据",slug:"ioc-配置元数据",link:"#ioc-配置元数据",children:[{level:3,title:"Xml 配置",slug:"xml-配置",link:"#xml-配置",children:[]},{level:3,title:"注解配置",slug:"注解配置",link:"#注解配置",children:[]},{level:3,title:"Java 配置",slug:"java-配置",link:"#java-配置",children:[]}]},{level:2,title:"依赖解决过程",slug:"依赖解决过程",link:"#依赖解决过程",children:[]},{level:2,title:"最佳实践",slug:"最佳实践",link:"#最佳实践",children:[{level:3,title:"singleton 的 Bean 如何注入 prototype 的 Bean",slug:"singleton-的-bean-如何注入-prototype-的-bean",link:"#singleton-的-bean-如何注入-prototype-的-bean",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/915530/",pathLocale:"/",extraFields:['java\nBeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath.xml");','java\nBeanFactory beanFactory = new FileSystemXmlApplicationContext("fileSystemConfig.xml");','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 Bean 定义 --\x3e\n\n</beans>','java\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n        <property name="itemDao" ref="itemDao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountDao"\n        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>','xml\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messageSource.xml"/>\n    <import resource="/resources/themeSource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>','java\n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n\n// use configured instance\nList<String> userList = service.getUsernameList();','java\nGenericApplicationContext context = new GenericApplicationContext();\nnew XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");\ncontext.refresh();','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>','java\nApplicationContext context =\n      new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});','xml\n<import resource="classpath:spring/applicationContext.xml"/>\n<import resource="/WEB-INF/spring/service.xml"/>','java\n// create and configure beans\nApplicationContext context =\nnew ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n// use configured instance\nList<String> userList = service.getUsernameList();',"xml\n<context:annotation-config/>","java\npublic class AnnotationRequired {\n    private String name;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @Required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出BeanInitializationException。\n     */\n    @Required\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}",'java\npublic class AnnotationAutowired {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationRequired.class);\n\n    @Autowired\n    private Apple fieldA;\n\n    private Banana fieldB;\n\n    private Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Autowired\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public void setFieldC(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public AnnotationAutowired() {}\n\n    @Autowired\n    public AnnotationAutowired(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationAutowired annotationAutowired =\n                        (AnnotationAutowired) ctx.getBean("annotationAutowired");\n        log.debug("fieldA: {}, fieldB:{}, fieldC:{}", annotationAutowired.getFieldA().getName(),\n                        annotationAutowired.getFieldB().getName(),\n                        annotationAutowired.getFieldC().getName());\n        ctx.close();\n    }\n}','xml\n\x3c!-- 测试@Autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.Apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.Banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.Orange"/>\n<bean id="annotationAutowired" class="org.zp.notes.spring.beans.annotation.sample.AnnotationAutowired"/>','java\npublic class AnnotationQualifier {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationQualifier.class);\n\n    @Autowired\n    @Qualifier("dog") /** 去除这行，会报异常 */\n    Animal dog;\n\n    Animal cat;\n\n    public Animal getDog() {\n        return dog;\n    }\n\n    public void setDog(Animal dog) {\n        this.dog = dog;\n    }\n\n    public Animal getCat() {\n        return cat;\n    }\n\n    @Autowired\n    public void setCat(@Qualifier("cat") Animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationQualifier annotationQualifier =\n                (AnnotationQualifier) ctx.getBean("annotationQualifier");\n\n        log.debug("Dog name: {}", annotationQualifier.getDog().getName());\n        log.debug("Cat name: {}", annotationQualifier.getCat().getName());\n        ctx.close();\n    }\n}\n\nabstract class Animal {\n    public String getName() {\n        return null;\n    }\n}\n\nclass Dog extends Animal {\n    public String getName() {\n        return "狗";\n    }\n}\n\nclass Cat extends Animal {\n    public String getName() {\n        return "猫";\n    }\n}','xml\n\x3c!-- 测试@Qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.Dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.Cat"/>\n<bean id="annotationQualifier" class="org.zp.notes.spring.beans.annotation.sample.AnnotationQualifier"/>','java\npublic class AnnotationResource {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationResource.class);\n\n    @Resource(name = "flower")\n    Plant flower;\n\n    @Resource(name = "tree")\n    Plant tree;\n\n    public Plant getFlower() {\n        return flower;\n    }\n\n    public void setFlower(Plant flower) {\n        this.flower = flower;\n    }\n\n    public Plant getTree() {\n        return tree;\n    }\n\n    public void setTree(Plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationResource annotationResource =\n                        (AnnotationResource) ctx.getBean("annotationResource");\n        log.debug("type: {}, name: {}", annotationResource.getFlower().getClass(), annotationResource.getFlower().getName());\n        log.debug("type: {}, name: {}", annotationResource.getTree().getClass(), annotationResource.getTree().getName());\n        ctx.close();\n    }\n}','xml\n\x3c!-- 测试@Resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.Flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.Tree"/>\n<bean id="annotationResource" class="org.zp.notes.spring.beans.annotation.sample.AnnotationResource"/>','java\npublic class AnnotationPostConstructAndPreDestroy {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationPostConstructAndPreDestroy.class);\n\n    @PostConstruct\n    public void init() {\n        log.debug("call @PostConstruct method");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug("call @PreDestroy method");\n    }\n}',"xml\n<dependency>\n  <groupId>javax.inject</groupId>\n  <artifactId>javax.inject</artifactId>\n  <version>1</version>\n</dependency>",'java\npublic class AnnotationInject {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationInject.class);\n    @Inject\n    Apple fieldA;\n\n    Banana fieldB;\n\n    Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Inject\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public AnnotationInject() {}\n\n    @Inject\n    public AnnotationInject(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n        AnnotationInject annotationInject = (AnnotationInject) ctx.getBean("annotationInject");\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldA().getClass(),\n                        annotationInject.getFieldA().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldB().getClass(),\n                        annotationInject.getFieldB().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldC().getClass(),\n                        annotationInject.getFieldC().getName());\n\n        ctx.close();\n    }\n}','java\n@Configuration\npublic class AnnotationConfiguration {\n    private static final Logger log = LoggerFactory.getLogger(JavaComponentScan.class);\n\n    @Bean\n    public Job getPolice() {\n        return new Police();\n    }\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AnnotationConfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        Job job = (Job) ctx.getBean("police");\n        log.debug("job: {}, work: {}", job.getClass(), job.work());\n    }\n}\n\npublic interface Job {\n    String work();\n}\n\n@Component("police")\npublic class Police implements Job {\n    @Override\n    public String work() {\n        return "抓罪犯";\n    }\n}','xml\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.Police"/>\n</beans>',"java\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}",'xml\n<beans>\n\t<bean id="myService" class="com.acme.services.MyServiceImpl"/>\n</beans>','java\n/**\n * SayService 是有状态，如果 SayService 是单例的话必然会 OOM\n */\n@Slf4j\npublic abstract class SayService {\n\n   List<String> data = new ArrayList<>();\n\n   public void say() {\n      data.add(IntStream.rangeClosed(1, 1000000)\n         .mapToObj(__ -> "a")\n         .collect(Collectors.joining("")) + UUID.randomUUID().toString());\n      log.info("I\'m {} size:{}", this, data.size());\n   }\n\n}','java\n@Service\n@Slf4j\npublic class SayBye extends SayService {\n\n   @Override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@Service\n@Slf4j\npublic class SayHello extends SayService {\n\n\t@Override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}','java\n@Slf4j\n@RestController\n@RequestMapping("beansingletonandorder")\npublic class BeanSingletonAndOrderController {\n\n   @Autowired\n   List<SayService> sayServiceList;\n   @Autowired\n   private ApplicationContext applicationContext;\n\n   @GetMapping("test")\n   public void test() {\n      log.info("====================");\n      sayServiceList.forEach(SayService::say);\n   }\n\n}',"java\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)","java\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProx)"]},{title:"Spring 依赖查找",headers:[{level:2,title:"单一类型依赖查找",slug:"单一类型依赖查找",link:"#单一类型依赖查找",children:[]},{level:2,title:"集合类型依赖查找",slug:"集合类型依赖查找",link:"#集合类型依赖查找",children:[]},{level:2,title:"层次性依赖查找",slug:"层次性依赖查找",link:"#层次性依赖查找",children:[]},{level:2,title:"延迟依赖查找",slug:"延迟依赖查找",link:"#延迟依赖查找",children:[]},{level:2,title:"安全依赖查找",slug:"安全依赖查找",link:"#安全依赖查找",children:[]},{level:2,title:"内建可查找的依赖",slug:"内建可查找的依赖",link:"#内建可查找的依赖",children:[]},{level:2,title:"依赖查找中的经典异常",slug:"依赖查找中的经典异常",link:"#依赖查找中的经典异常",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/9a6f6b/",pathLocale:"/",extraFields:[]},{title:"Spring 依赖注入",headers:[{level:2,title:"IoC 依赖注入 API",slug:"ioc-依赖注入-api",link:"#ioc-依赖注入-api",children:[]},{level:2,title:"依赖注入模式",slug:"依赖注入模式",link:"#依赖注入模式",children:[{level:3,title:"手动注入模式",slug:"手动注入模式",link:"#手动注入模式",children:[]},{level:3,title:"自动注入模式",slug:"自动注入模式",link:"#自动注入模式",children:[]}]},{level:2,title:"依赖注入方式",slug:"依赖注入方式",link:"#依赖注入方式",children:[{level:3,title:"构造器注入",slug:"构造器注入",link:"#构造器注入",children:[]},{level:3,title:"Setter 方法注入",slug:"setter-方法注入",link:"#setter-方法注入",children:[]},{level:3,title:"字段注入",slug:"字段注入",link:"#字段注入",children:[]},{level:3,title:"方法注入",slug:"方法注入",link:"#方法注入",children:[]},{level:3,title:"接口回调注入",slug:"接口回调注入",link:"#接口回调注入",children:[]},{level:3,title:"依赖注入选型",slug:"依赖注入选型",link:"#依赖注入选型",children:[]}]},{level:2,title:"限定注入和延迟注入",slug:"限定注入和延迟注入",link:"#限定注入和延迟注入",children:[{level:3,title:"限定注入",slug:"限定注入",link:"#限定注入",children:[]},{level:3,title:"延迟注入",slug:"延迟注入",link:"#延迟注入",children:[]}]},{level:2,title:"依赖注入数据类型",slug:"依赖注入数据类型",link:"#依赖注入数据类型",children:[{level:3,title:"基础类型",slug:"基础类型",link:"#基础类型",children:[]},{level:3,title:"集合类型",slug:"集合类型",link:"#集合类型",children:[]}]},{level:2,title:"依赖处理过程",slug:"依赖处理过程",link:"#依赖处理过程",children:[]},{level:2,title:"依赖查找 VS. 依赖注入",slug:"依赖查找-vs-依赖注入",link:"#依赖查找-vs-依赖注入",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/f61a1c/",pathLocale:"/",extraFields:["java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}","package x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}",'xml\n<beans>\n    <bean id="beanOne" class="x.y.ThingOne">\n        <constructor-arg ref="beanTwo"/>\n        <constructor-arg ref="beanThree"/>\n    </bean>\n\n    <bean id="beanTwo" class="x.y.ThingTwo"/>\n\n    <bean id="beanThree" class="x.y.ThingThree"/>\n</beans>',"java\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private final int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private final String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}",'xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.String" value="42"/>\n</bean>','xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>','xml\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateAnswer" value="42"/>\n</bean>','java\npackage examples;\n\npublic class ExampleBean {\n\n    // Fields omitted\n\n    @ConstructorProperties({"years", "ultimateAnswer"})\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}',"java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}"]},{title:"Spring IoC 依赖来源",headers:[{level:2,title:"依赖查找的来源",slug:"依赖查找的来源",link:"#依赖查找的来源",children:[]},{level:2,title:"依赖注入的来源",slug:"依赖注入的来源",link:"#依赖注入的来源",children:[]},{level:2,title:"Spring 容器管理和游离对象",slug:"spring-容器管理和游离对象",link:"#spring-容器管理和游离对象",children:[]},{level:2,title:"Spring BeanDefinition 作为依赖来源",slug:"spring-beandefinition-作为依赖来源",link:"#spring-beandefinition-作为依赖来源",children:[]},{level:2,title:"单例对象作为依赖来源",slug:"单例对象作为依赖来源",link:"#单例对象作为依赖来源",children:[]},{level:2,title:"非 Spring 对象容器管理对象作为依赖来源",slug:"非-spring-对象容器管理对象作为依赖来源",link:"#非-spring-对象容器管理对象作为依赖来源",children:[]},{level:2,title:"外部化配置作为依赖来源",slug:"外部化配置作为依赖来源",link:"#外部化配置作为依赖来源",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a5f257/",pathLocale:"/",extraFields:[]},{title:"Spring Bean 作用域",headers:[{level:2,title:"Spring Bean 作用域",slug:"spring-bean-作用域-1",link:"#spring-bean-作用域-1",children:[]},{level:2,title:'"singleton" Bean 作用域',slug:"singleton-bean-作用域",link:"#singleton-bean-作用域",children:[]},{level:2,title:'"prototype" Bean 作用域',slug:"prototype-bean-作用域",link:"#prototype-bean-作用域",children:[]},{level:2,title:'"request" Bean 作用域',slug:"request-bean-作用域",link:"#request-bean-作用域",children:[]},{level:2,title:'"session" Bean 作用域',slug:"session-bean-作用域",link:"#session-bean-作用域",children:[]},{level:2,title:'"application" Bean 作用域',slug:"application-bean-作用域",link:"#application-bean-作用域",children:[]},{level:2,title:"自定义 Bean 作用域",slug:"自定义-bean-作用域",link:"#自定义-bean-作用域",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/8289f5/",pathLocale:"/",extraFields:['xml\n  <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">\n    <property name="scopes">\n      <map>\n        <entry key="...">\n        </entry>\n      </map>\n    </property>\n  </bean>']},{title:"Spring Bean 生命周期",headers:[{level:2,title:"Spring Bean 元信息配置阶段",slug:"spring-bean-元信息配置阶段",link:"#spring-bean-元信息配置阶段",children:[]},{level:2,title:"Spring Bean 元信息解析阶段",slug:"spring-bean-元信息解析阶段",link:"#spring-bean-元信息解析阶段",children:[]},{level:2,title:"Spring Bean 注册阶段",slug:"spring-bean-注册阶段",link:"#spring-bean-注册阶段",children:[]},{level:2,title:"Spring BeanDefinition 合并阶段",slug:"spring-beandefinition-合并阶段",link:"#spring-beandefinition-合并阶段",children:[]},{level:2,title:"Spring Bean Class 加载阶段",slug:"spring-bean-class-加载阶段",link:"#spring-bean-class-加载阶段",children:[]},{level:2,title:"Spring Bean 实例化前阶段",slug:"spring-bean-实例化前阶段",link:"#spring-bean-实例化前阶段",children:[]},{level:2,title:"Spring Bean 实例化阶段",slug:"spring-bean-实例化阶段",link:"#spring-bean-实例化阶段",children:[]},{level:2,title:"Spring Bean 实例化后阶段",slug:"spring-bean-实例化后阶段",link:"#spring-bean-实例化后阶段",children:[]},{level:2,title:"Spring Bean 属性赋值前阶段",slug:"spring-bean-属性赋值前阶段",link:"#spring-bean-属性赋值前阶段",children:[]},{level:2,title:"Spring Bean Aware 接口回调阶段",slug:"spring-bean-aware-接口回调阶段",link:"#spring-bean-aware-接口回调阶段",children:[]},{level:2,title:"Spring Bean 初始化前阶段",slug:"spring-bean-初始化前阶段",link:"#spring-bean-初始化前阶段",children:[]},{level:2,title:"Spring Bean 初始化阶段",slug:"spring-bean-初始化阶段",link:"#spring-bean-初始化阶段",children:[]},{level:2,title:"Spring Bean 初始化后阶段",slug:"spring-bean-初始化后阶段",link:"#spring-bean-初始化后阶段",children:[]},{level:2,title:"Spring Bean 初始化完成阶段",slug:"spring-bean-初始化完成阶段",link:"#spring-bean-初始化完成阶段",children:[]},{level:2,title:"Spring Bean 销毁前阶段",slug:"spring-bean-销毁前阶段",link:"#spring-bean-销毁前阶段",children:[]},{level:2,title:"Spring Bean 销毁阶段",slug:"spring-bean-销毁阶段",link:"#spring-bean-销毁阶段",children:[]},{level:2,title:"Spring Bean 垃圾收集",slug:"spring-bean-垃圾收集",link:"#spring-bean-垃圾收集",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/4ab176/",pathLocale:"/",extraFields:[]},{title:"Spring 配置元数据",headers:[{level:2,title:"Spring 配置元信息",slug:"spring-配置元信息",link:"#spring-配置元信息",children:[]},{level:2,title:"Spring Bean 配置元信息",slug:"spring-bean-配置元信息",link:"#spring-bean-配置元信息",children:[]},{level:2,title:"Spring Bean 属性元信息",slug:"spring-bean-属性元信息",link:"#spring-bean-属性元信息",children:[]},{level:2,title:"Spring 容器配置元信息",slug:"spring-容器配置元信息",link:"#spring-容器配置元信息",children:[]},{level:2,title:"基于 XML 文件装载 Spring Bean 配置元信息",slug:"基于-xml-文件装载-spring-bean-配置元信息",link:"#基于-xml-文件装载-spring-bean-配置元信息",children:[]},{level:2,title:"基于 Properties 文件装载 Spring Bean 配置元信息",slug:"基于-properties-文件装载-spring-bean-配置元信息",link:"#基于-properties-文件装载-spring-bean-配置元信息",children:[]},{level:2,title:"基于 Java 注解装载 Spring Bean 配置元信息",slug:"基于-java-注解装载-spring-bean-配置元信息",link:"#基于-java-注解装载-spring-bean-配置元信息",children:[]},{level:2,title:"Spring Bean 配置元信息底层实现",slug:"spring-bean-配置元信息底层实现",link:"#spring-bean-配置元信息底层实现",children:[{level:3,title:"Spring XML 资源 BeanDefinition 解析与注册",slug:"spring-xml-资源-beandefinition-解析与注册",link:"#spring-xml-资源-beandefinition-解析与注册",children:[]},{level:3,title:"Spring Properties 资源 BeanDefinition 解析与注册",slug:"spring-properties-资源-beandefinition-解析与注册",link:"#spring-properties-资源-beandefinition-解析与注册",children:[]},{level:3,title:"Spring Java 注册 BeanDefinition 解析与注册",slug:"spring-java-注册-beandefinition-解析与注册",link:"#spring-java-注册-beandefinition-解析与注册",children:[]}]},{level:2,title:"基于 XML 文件装载 Spring IoC 容器配置元信息",slug:"基于-xml-文件装载-spring-ioc-容器配置元信息",link:"#基于-xml-文件装载-spring-ioc-容器配置元信息",children:[]},{level:2,title:"基于 Java 注解装载 Spring IoC 容器配置元信息",slug:"基于-java-注解装载-spring-ioc-容器配置元信息",link:"#基于-java-注解装载-spring-ioc-容器配置元信息",children:[]},{level:2,title:"基于 Extensible XML authoring 扩展 SpringXML 元素",slug:"基于-extensible-xml-authoring-扩展-springxml-元素",link:"#基于-extensible-xml-authoring-扩展-springxml-元素",children:[]},{level:2,title:"Extensible XML authoring 扩展原理",slug:"extensible-xml-authoring-扩展原理",link:"#extensible-xml-authoring-扩展原理",children:[{level:3,title:"触发时机",slug:"触发时机",link:"#触发时机",children:[]},{level:3,title:"核心流程",slug:"核心流程",link:"#核心流程",children:[]}]},{level:2,title:"基于 Properties 文件装载外部化配置",slug:"基于-properties-文件装载外部化配置",link:"#基于-properties-文件装载外部化配置",children:[]},{level:2,title:"基于 YAML 文件装载外部化配置",slug:"基于-yaml-文件装载外部化配置",link:"#基于-yaml-文件装载外部化配置",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/55f315/",pathLocale:"/",extraFields:[]},{title:"Spring 应用上下文生命周期",headers:[{level:2,title:"Spring 应用上下文启动准备阶段",slug:"spring-应用上下文启动准备阶段",link:"#spring-应用上下文启动准备阶段",children:[]},{level:2,title:"BeanFactory 创建阶段",slug:"beanfactory-创建阶段",link:"#beanfactory-创建阶段",children:[]},{level:2,title:"BeanFactory 准备阶段",slug:"beanfactory-准备阶段",link:"#beanfactory-准备阶段",children:[]},{level:2,title:"BeanFactory 后置处理阶段",slug:"beanfactory-后置处理阶段",link:"#beanfactory-后置处理阶段",children:[]},{level:2,title:"BeanFactory 注册 BeanPostProcessor 阶段",slug:"beanfactory-注册-beanpostprocessor-阶段",link:"#beanfactory-注册-beanpostprocessor-阶段",children:[]},{level:2,title:"初始化內建 Bean：MessageSource",slug:"初始化內建-bean-messagesource",link:"#初始化內建-bean-messagesource",children:[]},{level:2,title:"初始化內建 Bean：Spring 事件广播器",slug:"初始化內建-bean-spring-事件广播器",link:"#初始化內建-bean-spring-事件广播器",children:[]},{level:2,title:"Spring 应用上下文刷新阶段",slug:"spring-应用上下文刷新阶段",link:"#spring-应用上下文刷新阶段",children:[]},{level:2,title:"Spring 事件监听器注册阶段",slug:"spring-事件监听器注册阶段",link:"#spring-事件监听器注册阶段",children:[]},{level:2,title:"BeanFactory 初始化完成阶段",slug:"beanfactory-初始化完成阶段",link:"#beanfactory-初始化完成阶段",children:[]},{level:2,title:"Spring 应用上下刷新完成阶段",slug:"spring-应用上下刷新完成阶段",link:"#spring-应用上下刷新完成阶段",children:[]},{level:2,title:"Spring 应用上下文启动阶段",slug:"spring-应用上下文启动阶段",link:"#spring-应用上下文启动阶段",children:[]},{level:2,title:"Spring 应用上下文停止阶段",slug:"spring-应用上下文停止阶段",link:"#spring-应用上下文停止阶段",children:[]},{level:2,title:"Spring 应用上下文关闭阶段",slug:"spring-应用上下文关闭阶段",link:"#spring-应用上下文关闭阶段",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/ad472e/",pathLocale:"/",extraFields:[]},{title:"Spring AOP",headers:[{level:2,title:"AOP 概念",slug:"aop-概念",link:"#aop-概念",children:[{level:3,title:"什么是 AOP",slug:"什么是-aop",link:"#什么是-aop",children:[]},{level:3,title:"术语",slug:"术语",link:"#术语",children:[]},{level:3,title:"advice 的类型",slug:"advice-的类型",link:"#advice-的类型",children:[]},{level:3,title:"关于 AOP Proxy",slug:"关于-aop-proxy",link:"#关于-aop-proxy",children:[]},{level:3,title:"彻底理解 aspect, join point, point cut, advice",slug:"彻底理解-aspect-join-point-point-cut-advice",link:"#彻底理解-aspect-join-point-point-cut-advice",children:[]}]},{level:2,title:"@AspectJ 支持",slug:"aspectj-支持",link:"#aspectj-支持",children:[{level:3,title:"使能 @AspectJ 支持",slug:"使能-aspectj-支持",link:"#使能-aspectj-支持",children:[]},{level:3,title:"定义 aspect(切面)",slug:"定义-aspect-切面",link:"#定义-aspect-切面",children:[]},{level:3,title:"声明 pointcut",slug:"声明-pointcut",link:"#声明-pointcut",children:[]},{level:3,title:"声明 advice",slug:"声明-advice",link:"#声明-advice",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/53aedb/",pathLocale:"/",extraFields:["java\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig {\n}","<aop:aspectj-autoproxy/>","java\n@Component\n@Aspect\npublic class MyTest {\n}",'java\n@Pointcut("execution(* com.xys.service.UserService.*(..))") // 切点表达式\nprivate void dataAccessOperation() {} // 切点前面',"bean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法\nbean(myService) // 匹配名字为 myService 的 bean 下的所有方法",'java\n@Pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@Before(value = "pointcut2()  &&  args(name)")\npublic void doSomething(String name) {\n    logger.info("---page: {}---", name);\n}','java\n@Service\npublic class NormalService {\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    public void someMethod() {\n        logger.info("---NormalService: someMethod invoked---");\n    }\n\n    public String test(String name) {\n        logger.info("---NormalService: test invoked---");\n        return "服务一切正常";\n    }\n}','java\n// 匹配只有一个参数 name 的方法\n@Before(value = "aspectMethod()  &&  args(name)")\npublic void doSomething(String name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@Before(value = "aspectMethod()  &&  args(name, ..)")\npublic void doSomething(String name) {\n}\n\n// 匹配第二个参数为 name 的方法\nBefore(value = "aspectMethod()  &&  args(*, name, ..)")\npublic void doSomething(String name) {\n}','java\n@Pointcut("@annotation(com.xys.demo1.AuthChecker)")\npublic void pointcut() {\n}',"// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* UserService.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(String name, ..))","// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(UserService)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(UserDao+)","// 匹配以指定名字结尾的 Bean 中的所有方法\nbean(*Service)","// 匹配以 Service 或 ServiceImpl 结尾的 bean\nbean(*Service || *ServiceImpl)\n\n// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*Service) && within(com.xys.service.*)",'java\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@Component\n@Aspect\npublic class BeforeAspectTest {\n    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.\n    @Pointcut("execution(* com.xys.service.UserService.*(..))")\n    public void dataAccessOperation() {\n    }\n}','java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Before("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public void doBeforeAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}','java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 将 pointcut 和 advice 同时定义\n    @Before("within(com.xys.service..*)")\n    public void doAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****doAccessCheck, Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}','java\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Around("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 开始\n        Object retVal = pjp.proceed();\n        stopWatch.stop();\n        // 结束\n        System.out.println("invoke method: " + pjp.getSignature().getName() + ", elapsed time: " + stopWatch.getTotalTimeMillis());\n        return retVal;\n    }\n}']},{title:"Spring 资源管理",headers:[{level:2,title:"Resource 接口",slug:"resource-接口",link:"#resource-接口",children:[]},{level:2,title:"内置的 Resource 实现",slug:"内置的-resource-实现",link:"#内置的-resource-实现",children:[]},{level:2,title:"ResourceLoader 接口",slug:"resourceloader-接口",link:"#resourceloader-接口",children:[]},{level:2,title:"ResourcePatternResolver 接口",slug:"resourcepatternresolver-接口",link:"#resourcepatternresolver-接口",children:[]},{level:2,title:"ResourceLoaderAware 接口",slug:"resourceloaderaware-接口",link:"#resourceloaderaware-接口",children:[]},{level:2,title:"资源依赖",slug:"资源依赖",link:"#资源依赖",children:[]},{level:2,title:"应用上下文和资源路径",slug:"应用上下文和资源路径",link:"#应用上下文和资源路径",children:[{level:3,title:"构造应用上下文",slug:"构造应用上下文",link:"#构造应用上下文",children:[]},{level:3,title:"使用通配符构造应用上下文",slug:"使用通配符构造应用上下文",link:"#使用通配符构造应用上下文",children:[]}]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a1549f/",pathLocale:"/",extraFields:["java\npublic interface Resource extends InputStreamSource {\n\n    boolean exists();\n\n    boolean isReadable();\n\n    boolean isOpen();\n\n    boolean isFile();\n\n    URL getURL() throws IOException;\n\n    URI getURI() throws IOException;\n\n    File getFile() throws IOException;\n\n    ReadableByteChannel readableChannel() throws IOException;\n\n    long contentLength() throws IOException;\n\n    long lastModified() throws IOException;\n\n    Resource createRelative(String relativePath) throws IOException;\n\n    String getFilename();\n\n    String getDescription();\n}","java\npublic interface ResourceLoader {\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}",'java\n// 如果没有指定资源前缀，Spring 会尝试返回合适的资源\nResource template = ctx.getResource("some/resource/path/myTemplate.txt");\n// 如果指定 classpath: 前缀，Spring 会强制使用 ClassPathResource\nResource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");\n// 如果指定 file:、http 等 URL 前缀，Spring 会强制使用 UrlResource\nResource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");\nResource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");','java\npublic interface ResourcePatternResolver extends ResourceLoader {\n\n    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}',"java\npublic interface ResourceLoaderAware {\n    void setResourceLoader(ResourceLoader resourceLoader);\n}",'xml\n<bean id="myBean" class="example.MyBean">\n    <property name="template" value="some/resource/path/myTemplate.txt"/>\n</bean>','xml\n<property name="template" value="classpath:some/resource/path/myTemplate.txt">\n<property name="template" value="file:///some/resource/path/myTemplate.txt"/>','java\n@Component\npublic class MyBean {\n\n    private final Resource template;\n\n    public MyBean(@Value("${template.path}") Resource template) {\n        this.template = template;\n    }\n\n    // ...\n}','java\n@Component\npublic class MyBean {\n\n    private final Resource[] templates;\n\n    public MyBean(@Value("${templates.path}") Resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}','java\nApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");\nApplicationContext ctx = new ClassPathXmlApplicationContext(\n                new String[] {"services.xml", "daos.xml"}, MessengerService.class);','java\nApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");']},{title:"Spring 校验",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"校验示例",slug:"校验示例",link:"#校验示例",children:[]},{level:3,title:"统一异常处理",slug:"统一异常处理",link:"#统一异常处理",children:[]}]},{level:2,title:"进阶使用",slug:"进阶使用",link:"#进阶使用",children:[{level:3,title:"分组校验",slug:"分组校验",link:"#分组校验",children:[]},{level:3,title:"嵌套校验",slug:"嵌套校验",link:"#嵌套校验",children:[]},{level:3,title:"自定义校验注解",slug:"自定义校验注解",link:"#自定义校验注解",children:[]},{level:3,title:"自定义校验",slug:"自定义校验",link:"#自定义校验",children:[]},{level:3,title:"快速失败(Fail Fast)",slug:"快速失败-fail-fast",link:"#快速失败-fail-fast",children:[]}]},{level:2,title:"Spring 校验原理",slug:"spring-校验原理",link:"#spring-校验原理",children:[{level:3,title:"Spring 校验使用场景",slug:"spring-校验使用场景",link:"#spring-校验使用场景",children:[]},{level:3,title:"Validator 接口设计",slug:"validator-接口设计",link:"#validator-接口设计",children:[]},{level:3,title:"Errors 接口设计",slug:"errors-接口设计",link:"#errors-接口设计",children:[]},{level:3,title:"Errors 文案来源",slug:"errors-文案来源",link:"#errors-文案来源",children:[]},{level:3,title:"spring web 校验原理",slug:"spring-web-校验原理",link:"#spring-web-校验原理",children:[]}]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/fe6aad/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator-parent</artifactId>\n  <version>6.2.5.Final</version>\n</dependency>","kotlin\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    @NotNull\n    private Long id;\n\n    @NotBlank\n    @Size(min = 2, max = 10)\n    private String name;\n\n    @Min(value = 1)\n    @Max(value = 100)\n    private Integer age;\n\n}",'less\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate1")\npublic class ValidatorController {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "save")\n    public DataResult<Boolean> save(@Valid @RequestBody User entity) {\n        log.info("保存一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestParam} 参数校验\n     */\n    @GetMapping(value = "queryByName")\n    public DataResult<User> queryByName(\n        @RequestParam("username")\n        @NotBlank\n        @Size(min = 2, max = 10)\n        String name\n    ) {\n        User user = new User(1L, name, 18);\n        return DataResult.ok(user);\n    }\n\n    /**\n     * {@link PathVariable} 参数校验\n     */\n    @GetMapping(value = "detail/{id}")\n    public DataResult<User> detail(@PathVariable("id") @Min(1L) Long id) {\n        User user = new User(id, "李四", 18);\n        return DataResult.ok(user);\n    }\n\n}','java\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.OK)\n    @ExceptionHandler(Throwable.class)\n    public Result handleException(Throwable e) {\n        log.error("未知异常", e);\n        return new Result(ResultStatus.HTTP_SERVER_ERROR.getCode(), e.getMessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e ConstraintViolationException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ ConstraintViolationException.class })\n    public Result handleConstraintViolationException(final ConstraintViolationException e) {\n        log.error("ConstraintViolationException", e);\n        List<String> errors = new ArrayList<>();\n        for (ConstraintViolation<?> violation : e.getConstraintViolations()) {\n            Path path = violation.getPropertyPath();\n            List<String> pathArr = StrUtil.split(path.toString(), \',\');\n            errors.add(pathArr.get(0) + " " + violation.getMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e MethodArgumentNotValidException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ MethodArgumentNotValidException.class })\n    private Result handleMethodArgumentNotValidException(final MethodArgumentNotValidException e) {\n        log.error("MethodArgumentNotValidException", e);\n        List<String> errors = new ArrayList<>();\n        for (ObjectError error : e.getBindingResult().getAllErrors()) {\n            errors.add(((FieldError) error).getField() + " " + error.getDefaultMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n}',"java\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AddCheck { }\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface EditCheck { }",'less\n@Data\npublic class User2 {\n\n    @NotNull(groups = EditCheck.class)\n    private Long id;\n\n    @NotNull(groups = { AddCheck.class, EditCheck.class })\n    @Size(min = 2, max = 10, groups = { AddCheck.class, EditCheck.class })\n    private String name;\n\n    @IsMobile(message = "不是有效手机号", groups = { AddCheck.class, EditCheck.class })\n    private String mobile;\n\n}','less\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate2")\npublic class ValidatorController2 {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "add")\n    public DataResult<Boolean> add(@Validated(AddCheck.class) @RequestBody User2 entity) {\n        log.info("添加一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "edit")\n    public DataResult<Boolean> edit(@Validated(EditCheck.class) @RequestBody User2 entity) {\n        log.info("编辑一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n}',"less\n@Data\npublic class UserDTO {\n\n    @Min(value = 10000000000000000L, groups = Update.class)\n    private Long userId;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n    private String userName;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String account;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String password;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Valid\n    private Job job;\n\n    @Data\n    public static class Job {\n\n        @Min(value = 1, groups = Update.class)\n        private Long jobId;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String jobName;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface Save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface Update {\n    }\n}\n复制代码","less\n@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })\n@Retention(RUNTIME)\n@Constraint(validatedBy = MobileValidator.class)\npublic @interface IsMobile {\n\n    String message();\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}","java\nimport cn.hutool.core.util.StrUtil;\nimport io.github.dunwu.spring.core.validation.annotation.IsMobile;\nimport io.github.dunwu.tool.util.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\npublic class MobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    @Override\n    public void initialize(IsMobile isMobile) { }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if (StrUtil.isBlank(s)) {\n            return false;\n        } else {\n            return ValidatorUtil.isMobile(s);\n        }\n    }\n\n}",'less\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.Valid;\nimport io.github.dunwu.spring.core.validation.config.CustomValidatorConfig;\nimport io.github.dunwu.spring.core.validation.entity.Person;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Component\npublic class CustomValidator implements Validator {\n\n    private final CustomValidatorConfig validatorConfig;\n\n    public CustomValidator(CustomValidatorConfig validatorConfig) {\n        this.validatorConfig = validatorConfig;\n    }\n\n    /**\n     * 本校验器只针对 Person 对象进行校验\n     */\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Person.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, "name", "name.empty");\n\n        List<Field> fields = getFields(target.getClass());\n        for (Field field : fields) {\n            Annotation[] annotations = field.getAnnotations();\n            for (Annotation annotation : annotations) {\n                if (annotation.annotationType().getAnnotation(Valid.class) != null) {\n                    try {\n                        ValidatorRule validatorRule = validatorConfig.findRule(annotation);\n                        if (validatorRule != null) {\n                            validatorRule.valid(annotation, target, field, errors);\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private List<Field> getFields(Class<?> clazz) {\n        // 声明Field数组\n        List<Field> fields = new ArrayList<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            Collections.addAll(fields, clazz.getDeclaredFields());\n            clazz = clazz.getSuperclass();\n        }\n        return fields;\n    }\n\n}',"scss\n@Bean\npublic Validator validator() {\n    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)\n            .configure()\n            // 快速失败模式\n            .failFast(true)\n            .buildValidatorFactory();\n    return validatorFactory.getValidator();\n}","java\n@Override\npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n    parameter = parameter.nestedIfOptional();\n    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n    String name = Conventions.getVariableNameForParameter(parameter);\n\n    if (binderFactory != null) {\n        WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateIfApplicable(binder, parameter);\n            if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 MethodArgumentNotValidException\n                throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n            }\n        }\n        if (mavContainer != null) {\n            mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n        }\n    }\n\n    return adaptArgumentIfNecessary(arg, parameter);\n}",'java\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n    // 获取参数注解，如 @RequestBody、@Valid、@Validated\n    Annotation[] annotations = parameter.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        // 先尝试获取 @Validated 注解\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        // 如果标注了 @Validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 Valid 开头的注解。\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            // 执行校验\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}',"typescript\n@Override\npublic void validate(Object target, Errors errors, Object... validationHints) {\n    if (this.targetValidator != null) {\n        processConstraintViolations(\n            // 此处调用 Hibernate Validator 执行真正的校验\n            this.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n    }\n}","java\npublic class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean {\n    @Override\n    public void afterPropertiesSet() {\n        // 为所有 @Validated 标注的 Bean 创建切面\n        Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true);\n        // 创建 Advisor 进行增强\n        this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator));\n    }\n\n    // 创建 Advice，本质就是一个方法拦截器\n    protected Advice createMethodValidationAdvice(@Nullable Validator validator) {\n        return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor());\n    }\n}","scss\npublic class MethodValidationInterceptor implements MethodInterceptor {\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        // 无需增强的方法，直接跳过\n        if (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        Class<?>[] groups = determineValidationGroups(invocation);\n        ExecutableValidator execVal = this.validator.forExecutables();\n        Method methodToValidate = invocation.getMethod();\n        Set<ConstraintViolation<Object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 Hibernate Validator 来校验\n            result = execVal.validateParameters(\n                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n        }\n        catch (IllegalArgumentException ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        // 真正的方法调用\n        Object returnValue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给Hibernate Validator来校验\n        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        return returnValue;\n    }\n}"]},{title:"Spring 数据绑定",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"Spring 数据绑定使用场景",slug:"spring-数据绑定使用场景",link:"#spring-数据绑定使用场景",children:[]},{level:2,title:"DataBinder",slug:"databinder",link:"#databinder",children:[]},{level:2,title:"Spring 数据绑定元数据",slug:"spring-数据绑定元数据",link:"#spring-数据绑定元数据",children:[]},{level:2,title:"Spring 数据绑定控制参数",slug:"spring-数据绑定控制参数",link:"#spring-数据绑定控制参数",children:[{level:3,title:"DataBinder 绑定控制参数",slug:"databinder-绑定控制参数",link:"#databinder-绑定控制参数",children:[]}]},{level:2,title:"BeanWrapper 的使用场景",slug:"beanwrapper-的使用场景",link:"#beanwrapper-的使用场景",children:[]},{level:2,title:"Spring 底层 Java Beans 替换实现",slug:"spring-底层-java-beans-替换实现",link:"#spring-底层-java-beans-替换实现",children:[]},{level:2,title:"DataBinder 数据校验",slug:"databinder-数据校验",link:"#databinder-数据校验",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/267b4c/",pathLocale:"/",extraFields:['java\npublic class TestBean {\n\n    private int num;\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return "TestBean{" + "num=" + num + \'}\';\n    }\n\n}','java\npublic class DataBindingDemo {\n\n    public static void main(String[] args) {\n\n        MutablePropertyValues mpv = new MutablePropertyValues();\n        mpv.add("num", "10");\n\n        TestBean testBean = new TestBean();\n        DataBinder db = new DataBinder(testBean);\n\n        db.bind(mpv);\n        System.out.println(testBean);\n    }\n\n}']},{title:"Spring 类型转换",headers:[{level:2,title:"Spring 类型转换的实现",slug:"spring-类型转换的实现",link:"#spring-类型转换的实现",children:[]},{level:2,title:"使用场景",slug:"使用场景",link:"#使用场景",children:[]},{level:2,title:"基于 JavaBeans 接口的类型转换",slug:"基于-javabeans-接口的类型转换",link:"#基于-javabeans-接口的类型转换",children:[]},{level:2,title:"Spring 內建 PropertyEditor 扩展",slug:"spring-內建-propertyeditor-扩展",link:"#spring-內建-propertyeditor-扩展",children:[]},{level:2,title:"自定义 PropertyEditor 扩展",slug:"自定义-propertyeditor-扩展",link:"#自定义-propertyeditor-扩展",children:[]},{level:2,title:"Spring PropertyEditor 的设计缺陷",slug:"spring-propertyeditor-的设计缺陷",link:"#spring-propertyeditor-的设计缺陷",children:[]},{level:2,title:"Spring 3 通用类型转换接口",slug:"spring-3-通用类型转换接口",link:"#spring-3-通用类型转换接口",children:[]},{level:2,title:"Spring 內建类型转换器",slug:"spring-內建类型转换器",link:"#spring-內建类型转换器",children:[]},{level:2,title:"Converter 接口的局限性",slug:"converter-接口的局限性",link:"#converter-接口的局限性",children:[]},{level:2,title:"GenericConverter 接口",slug:"genericconverter-接口",link:"#genericconverter-接口",children:[]},{level:2,title:"优化 GenericConverter 接口",slug:"优化-genericconverter-接口",link:"#优化-genericconverter-接口",children:[]},{level:2,title:"扩展 Spring 类型转换器",slug:"扩展-spring-类型转换器",link:"#扩展-spring-类型转换器",children:[]},{level:2,title:"统一类型转换服务",slug:"统一类型转换服务",link:"#统一类型转换服务",children:[]},{level:2,title:"ConversionService 作为依赖",slug:"conversionservice-作为依赖",link:"#conversionservice-作为依赖",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/6662dc/",pathLocale:"/",extraFields:[]},{title:"Spring EL 表达式",headers:[{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1f743f/",pathLocale:"/",extraFields:[]},{title:"Spring 事件",headers:[{level:2,title:"Java 事件/监听器编程模型",slug:"java-事件-监听器编程模型",link:"#java-事件-监听器编程模型",children:[]},{level:2,title:"面向接口的事件/监听器设计模式",slug:"面向接口的事件-监听器设计模式",link:"#面向接口的事件-监听器设计模式",children:[]},{level:2,title:"面向注解的事件/监听器设计模式",slug:"面向注解的事件-监听器设计模式",link:"#面向注解的事件-监听器设计模式",children:[]},{level:2,title:"Spring 标准事件 - ApplicationEvent",slug:"spring-标准事件-applicationevent",link:"#spring-标准事件-applicationevent",children:[]},{level:2,title:"基于接口的 Spring 事件监听器",slug:"基于接口的-spring-事件监听器",link:"#基于接口的-spring-事件监听器",children:[]},{level:2,title:"基于注解的 Spring 事件监听器",slug:"基于注解的-spring-事件监听器",link:"#基于注解的-spring-事件监听器",children:[]},{level:2,title:"注册 Spring ApplicationListener",slug:"注册-spring-applicationlistener",link:"#注册-spring-applicationlistener",children:[]},{level:2,title:"Spring 事件发布器",slug:"spring-事件发布器",link:"#spring-事件发布器",children:[]},{level:2,title:"Spring 层次性上下文事件传播",slug:"spring-层次性上下文事件传播",link:"#spring-层次性上下文事件传播",children:[]},{level:2,title:"Spring 内建事件",slug:"spring-内建事件",link:"#spring-内建事件",children:[]},{level:2,title:"Spring 4.2 Payload 事件",slug:"spring-4-2-payload-事件",link:"#spring-4-2-payload-事件",children:[]},{level:2,title:"自定义 Spring 事件",slug:"自定义-spring-事件",link:"#自定义-spring-事件",children:[]},{level:2,title:"依赖注入 ApplicationEventPublisher",slug:"依赖注入-applicationeventpublisher",link:"#依赖注入-applicationeventpublisher",children:[]},{level:2,title:"依赖查找 ApplicationEventMulticaster",slug:"依赖查找-applicationeventmulticaster",link:"#依赖查找-applicationeventmulticaster",children:[]},{level:2,title:"ApplicationEventPublisher 底层实现",slug:"applicationeventpublisher-底层实现",link:"#applicationeventpublisher-底层实现",children:[]},{level:2,title:"同步和异步 Spring 事件广播",slug:"同步和异步-spring-事件广播",link:"#同步和异步-spring-事件广播",children:[]},{level:2,title:"Spring 4.1 事件异常处理",slug:"spring-4-1-事件异常处理",link:"#spring-4-1-事件异常处理",children:[]},{level:2,title:"Spring 事件/监听器实现原理",slug:"spring-事件-监听器实现原理",link:"#spring-事件-监听器实现原理",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cca414/",pathLocale:"/",extraFields:[]},{title:"Spring 国际化",headers:[{level:2,title:"Spring 国际化使用场景",slug:"spring-国际化使用场景",link:"#spring-国际化使用场景",children:[]},{level:2,title:"Spring 国际化接口",slug:"spring-国际化接口",link:"#spring-国际化接口",children:[]},{level:2,title:"层次性 MessageSource",slug:"层次性-messagesource",link:"#层次性-messagesource",children:[]},{level:2,title:"Java 国际化标准实现",slug:"java-国际化标准实现",link:"#java-国际化标准实现",children:[]},{level:2,title:"Java 文本格式化",slug:"java-文本格式化",link:"#java-文本格式化",children:[]},{level:2,title:"MessageSource 开箱即用实现",slug:"messagesource-开箱即用实现",link:"#messagesource-开箱即用实现",children:[]},{level:2,title:"MessageSource 內建依赖",slug:"messagesource-內建依赖",link:"#messagesource-內建依赖",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/b5b8ad/",pathLocale:"/",extraFields:[]},{title:"Spring 泛型处理",headers:[{level:2,title:"Java 泛型基础",slug:"java-泛型基础",link:"#java-泛型基础",children:[]},{level:2,title:"Java 5 类型接口",slug:"java-5-类型接口",link:"#java-5-类型接口",children:[]},{level:2,title:"Spring 泛型类型辅助类",slug:"spring-泛型类型辅助类",link:"#spring-泛型类型辅助类",children:[]},{level:2,title:"Spring 泛型集合类型辅助类",slug:"spring-泛型集合类型辅助类",link:"#spring-泛型集合类型辅助类",children:[]},{level:2,title:"Spring 方法参数封装 - MethodParameter",slug:"spring-方法参数封装-methodparameter",link:"#spring-方法参数封装-methodparameter",children:[]},{level:2,title:"Spring 4.0 泛型优化实现 - ResolvableType",slug:"spring-4-0-泛型优化实现-resolvabletype",link:"#spring-4-0-泛型优化实现-resolvabletype",children:[]},{level:2,title:"ResolvableType 的局限性",slug:"resolvabletype-的局限性",link:"#resolvabletype-的局限性",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/175cbd/",pathLocale:"/",extraFields:[]},{title:"Spring 注解",headers:[{level:2,title:"Spring 注解驱动编程发展历程",slug:"spring-注解驱动编程发展历程",link:"#spring-注解驱动编程发展历程",children:[]},{level:2,title:"Spring 核心注解场景分类",slug:"spring-核心注解场景分类",link:"#spring-核心注解场景分类",children:[]},{level:2,title:"Spring 注解编程模型",slug:"spring-注解编程模型",link:"#spring-注解编程模型",children:[]},{level:2,title:"Spring 元注解（Meta-Annotations）",slug:"spring-元注解-meta-annotations",link:"#spring-元注解-meta-annotations",children:[]},{level:2,title:"Spring 模式注解（Stereotype Annotations）",slug:"spring-模式注解-stereotype-annotations",link:"#spring-模式注解-stereotype-annotations",children:[]},{level:2,title:"Spring 组合注解（Composed Annotations）",slug:"spring-组合注解-composed-annotations",link:"#spring-组合注解-composed-annotations",children:[]},{level:2,title:"Spring 注解属性别名（Attribute Aliases）",slug:"spring-注解属性别名-attribute-aliases",link:"#spring-注解属性别名-attribute-aliases",children:[]},{level:2,title:"Spring 注解属性覆盖（Attribute Overrides）",slug:"spring-注解属性覆盖-attribute-overrides",link:"#spring-注解属性覆盖-attribute-overrides",children:[]},{level:2,title:"Spring @Enable 模块驱动",slug:"spring-enable-模块驱动",link:"#spring-enable-模块驱动",children:[]},{level:2,title:"Spring 条件注解",slug:"spring-条件注解",link:"#spring-条件注解",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/b6556f/",pathLocale:"/",extraFields:[]},{title:"Spring Environment 抽象",headers:[{level:2,title:"理解 Spring Environment 抽象",slug:"理解-spring-environment-抽象",link:"#理解-spring-environment-抽象",children:[]},{level:2,title:"Spring Environment 接口使用场景",slug:"spring-environment-接口使用场景",link:"#spring-environment-接口使用场景",children:[]},{level:2,title:"Environment 占位符处理",slug:"environment-占位符处理",link:"#environment-占位符处理",children:[]},{level:2,title:"理解条件配置 Spring Profiles",slug:"理解条件配置-spring-profiles",link:"#理解条件配置-spring-profiles",children:[]},{level:2,title:"Spring 4 重构 @Profile",slug:"spring-4-重构-profile",link:"#spring-4-重构-profile",children:[]},{level:2,title:"依赖注入 Environment",slug:"依赖注入-environment",link:"#依赖注入-environment",children:[]},{level:2,title:"依赖查找 Environment",slug:"依赖查找-environment",link:"#依赖查找-environment",children:[]},{level:2,title:"依赖注入 @Value",slug:"依赖注入-value",link:"#依赖注入-value",children:[]},{level:2,title:"Spring 类型转换在 Environment 中的运用",slug:"spring-类型转换在-environment-中的运用",link:"#spring-类型转换在-environment-中的运用",children:[]},{level:2,title:"Spring 类型转换在 @Value 中的运用",slug:"spring-类型转换在-value-中的运用",link:"#spring-类型转换在-value-中的运用",children:[]},{level:2,title:"Spring 配置属性源 PropertySource",slug:"spring-配置属性源-propertysource",link:"#spring-配置属性源-propertysource",children:[]},{level:2,title:"Spring 內建的配置属性源",slug:"spring-內建的配置属性源",link:"#spring-內建的配置属性源",children:[]},{level:2,title:"基于注解扩展 Spring 配置属性源",slug:"基于注解扩展-spring-配置属性源",link:"#基于注解扩展-spring-配置属性源",children:[]},{level:2,title:"基于 API 扩展 Spring 配置属性源",slug:"基于-api-扩展-spring-配置属性源",link:"#基于-api-扩展-spring-配置属性源",children:[]},{level:2,title:"问题",slug:"问题",link:"#问题",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/03d838/",pathLocale:"/",extraFields:[]},{title:"SpringBoot 之快速入门",headers:[{level:2,title:"Spring Boot 简介",slug:"spring-boot-简介",link:"#spring-boot-简介",children:[]},{level:2,title:"Spring Boot 系统要求",slug:"spring-boot-系统要求",link:"#spring-boot-系统要求",children:[]},{level:2,title:"部署第一个 Spring Boot 项目",slug:"部署第一个-spring-boot-项目",link:"#部署第一个-spring-boot-项目",children:[{level:3,title:"环境检查",slug:"环境检查",link:"#环境检查",children:[]},{level:3,title:"创建 pom",slug:"创建-pom",link:"#创建-pom",children:[]},{level:3,title:"添加依赖",slug:"添加依赖",link:"#添加依赖",children:[]},{level:3,title:"编写代码",slug:"编写代码",link:"#编写代码",children:[]},{level:3,title:"运行示例",slug:"运行示例",link:"#运行示例",children:[]},{level:3,title:"创建可执行 jar",slug:"创建可执行-jar",link:"#创建可执行-jar",children:[]}]},{level:2,title:"通过 SPRING INITIALIZR 创建 Spring Boot 项目",slug:"通过-spring-initializr-创建-spring-boot-项目",link:"#通过-spring-initializr-创建-spring-boot-项目",children:[{level:3,title:"创建项目",slug:"创建项目",link:"#创建项目",children:[]},{level:3,title:"项目说明",slug:"项目说明",link:"#项目说明",children:[]},{level:3,title:"编写 REST 服务",slug:"编写-rest-服务",link:"#编写-rest-服务",children:[]},{level:3,title:"编写单元测试用例",slug:"编写单元测试用例",link:"#编写单元测试用例",children:[]},{level:3,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/950e4d/",pathLocale:"/",extraFields:['shell\n$ java -version\njava version "1.8.0_102"\nJava(TM) SE Runtime Environment (build 1.8.0_102-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)',"java\n$ mvn -v\nApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)\nMaven home: /usr/local/Cellar/maven/3.3.9/libexec\nJava version: 1.8.0_102, vendor: Oracle Corporation",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>myproject</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- Additional lines to be added here... --\x3e\n\n</project>',"shell\n$ mvn dependency:tree\n\n[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT","xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>",'java\n@RestController\n@EnableAutoConfiguration\npublic class MyApplication {\n\n    @RequestMapping("/")\n    String home() {\n        return "Hello World!";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n\n}',"shell\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.222 seconds (JVM running for 6.514)","Hello World!","xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>","shell\n$ mvn package\n\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building myproject 0.0.1-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] .... ..\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar\n[INFO]\n[INFO] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------","shell\n$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar","$ java -jar target/myproject-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.536 seconds (JVM running for 2.864)","xml\n<parent>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-parent</artifactId>\n <version>1.5.10.RELEASE</version>\n <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>","xml\n<dependencies>\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n </dependency>\n\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-maven-plugin</artifactId>\n  </plugin>\n </plugins>\n</build>",'java\n@RestController\npublic class HelloController {\n\n    @RequestMapping("/hello")\n    public String index() {\n        return "Hello World";\n    }\n\n}','java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = MockServletContext.class)\n@WebAppConfiguration\npublic class SpringBootHelloWorldApplicationTest {\n\n\tprivate MockMvc mvc;\n\n\t@Before\n\tpublic void setUp() {\n\t\tmvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n\t}\n\n\t@Test\n\tpublic void getHello() throws Exception {\n\t\tmvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(equalTo("Hello World")));\n\t}\n\n}',"java\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;"]},{title:"SpringBoot 之属性加载详解",headers:[{level:2,title:"加载 property 顺序",slug:"加载-property-顺序",link:"#加载-property-顺序",children:[]},{level:2,title:"随机属性",slug:"随机属性",link:"#随机属性",children:[]},{level:2,title:"命令行属性",slug:"命令行属性",link:"#命令行属性",children:[]},{level:2,title:"Application 属性文件",slug:"application-属性文件",link:"#application-属性文件",children:[]},{level:2,title:"Profile 特定属性",slug:"profile-特定属性",link:"#profile-特定属性",children:[]},{level:2,title:"属性中的占位符",slug:"属性中的占位符",link:"#属性中的占位符",children:[]},{level:2,title:"YAML 属性",slug:"yaml-属性",link:"#yaml-属性",children:[{level:3,title:"访问属性",slug:"访问属性",link:"#访问属性",children:[]},{level:3,title:"多 profile 配置",slug:"多-profile-配置",link:"#多-profile-配置",children:[]},{level:3,title:"YAML 的缺点",slug:"yaml-的缺点",link:"#yaml-的缺点",children:[]}]},{level:2,title:"属性前缀",slug:"属性前缀",link:"#属性前缀",children:[]},{level:2,title:"属性松散绑定规则",slug:"属性松散绑定规则",link:"#属性松散绑定规则",children:[]},{level:2,title:"属性转换",slug:"属性转换",link:"#属性转换",children:[{level:3,title:"时间单位转换",slug:"时间单位转换",link:"#时间单位转换",children:[]},{level:3,title:"数据大小转换",slug:"数据大小转换",link:"#数据大小转换",children:[]}]},{level:2,title:"校验属性",slug:"校验属性",link:"#校验属性",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/0fb992/",pathLocale:"/",extraFields:["properties\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}","$ java -jar myproject.jar --spring.config.name=myproject","properties\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties","app.name=MyApp\napp.description=${app.name} is a Spring Boot application","yaml\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: Developer Setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: My Cool App","properties\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=My Cool App","yaml\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com","properties\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com","yaml\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120",'java\npackage com.example;\n\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix="acme")\npublic class AcmeProperties {\n\n\tprivate boolean enabled;\n\n\tprivate InetAddress remoteAddress;\n\n\tprivate final Security security = new Security();\n\n\tpublic boolean isEnabled() { ... }\n\n\tpublic void setEnabled(boolean enabled) { ... }\n\n\tpublic InetAddress getRemoteAddress() { ... }\n\n\tpublic void setRemoteAddress(InetAddress remoteAddress) { ... }\n\n\tpublic Security getSecurity() { ... }\n\n\tpublic static class Security {\n\n\t\tprivate String username;\n\n\t\tprivate String password;\n\n\t\tprivate List<String> roles = new ArrayList<>(Collections.singleton("USER"));\n\n\t\tpublic String getUsername() { ... }\n\n\t\tpublic void setUsername(String username) { ... }\n\n\t\tpublic String getPassword() { ... }\n\n\t\tpublic void setPassword(String password) { ... }\n\n\t\tpublic List<String> getRoles() { ... }\n\n\t\tpublic void setRoles(List<String> roles) { ... }\n\n\t}\n}',"java\n@Configuration\n@EnableConfigurationProperties(AcmeProperties.class)\npublic class MyConfiguration {\n}",'java\n@ConfigurationProperties("app.system")\npublic class AppSystemProperties {\n\n\t@DurationUnit(ChronoUnit.SECONDS)\n\tprivate Duration sessionTimeout = Duration.ofSeconds(30);\n\n\tprivate Duration readTimeout = Duration.ofMillis(1000);\n\n\tpublic Duration getSessionTimeout() {\n\t\treturn this.sessionTimeout;\n\t}\n\n\tpublic void setSessionTimeout(Duration sessionTimeout) {\n\t\tthis.sessionTimeout = sessionTimeout;\n\t}\n\n\tpublic Duration getReadTimeout() {\n\t\treturn this.readTimeout;\n\t}\n\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n}','java\n@ConfigurationProperties("app.io")\npublic class AppIoProperties {\n\n\t@DataSizeUnit(DataUnit.MEGABYTES)\n\tprivate DataSize bufferSize = DataSize.ofMegabytes(2);\n\n\tprivate DataSize sizeThreshold = DataSize.ofBytes(512);\n\n\tpublic DataSize getBufferSize() {\n\t\treturn this.bufferSize;\n\t}\n\n\tpublic void setBufferSize(DataSize bufferSize) {\n\t\tthis.bufferSize = bufferSize;\n\t}\n\n\tpublic DataSize getSizeThreshold() {\n\t\treturn this.sizeThreshold;\n\t}\n\n\tpublic void setSizeThreshold(DataSize sizeThreshold) {\n\t\tthis.sizeThreshold = sizeThreshold;\n\t}\n\n}','java\n@ConfigurationProperties(prefix="acme")\n@Validated\npublic class AcmeProperties {\n\n\t@NotNull\n\tprivate InetAddress remoteAddress;\n\n\t@Valid\n\tprivate final Security security = new Security();\n\n\t// ... getters and setters\n\n\tpublic static class Security {\n\n\t\t@NotEmpty\n\t\tpublic String username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}']},{title:"SpringBoot 之 Profile",headers:[{level:2,title:"区分环境的配置",slug:"区分环境的配置",link:"#区分环境的配置",children:[{level:3,title:"properties 配置",slug:"properties-配置",link:"#properties-配置",children:[]},{level:3,title:"yml 配置",slug:"yml-配置",link:"#yml-配置",children:[]}]},{level:2,title:"区分环境的代码",slug:"区分环境的代码",link:"#区分环境的代码",children:[{level:3,title:"修饰类",slug:"修饰类",link:"#修饰类",children:[]},{level:3,title:"修饰注解",slug:"修饰注解",link:"#修饰注解",children:[]},{level:3,title:"修饰方法",slug:"修饰方法",link:"#修饰方法",children:[]}]},{level:2,title:"激活 profile",slug:"激活-profile",link:"#激活-profile",children:[{level:3,title:"插件激活 profile",slug:"插件激活-profile",link:"#插件激活-profile",children:[]},{level:3,title:"main 方法激活 profile",slug:"main-方法激活-profile",link:"#main-方法激活-profile",children:[]},{level:3,title:"jar 激活 profile",slug:"jar-激活-profile",link:"#jar-激活-profile",children:[]},{level:3,title:"在 Java 代码中激活 profile",slug:"在-java-代码中激活-profile",link:"#在-java-代码中激活-profile",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cb598e/",pathLocale:"/",extraFields:["properties\nspring.profiles.active = test","yml\nspring:\n  profiles:\n    active: prod","yml\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置",'java\n@Configuration\n@Profile("production")\npublic class JndiDataConfig {\n\n    @Bean(destroyMethod="")\n    public DataSource dataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}','java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Profile("production")\npublic @interface Production {\n}','java\n@Configuration\npublic class AppConfig {\n\n    @Bean("dataSource")\n    @Profile("development")\n    public DataSource standaloneDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript("classpath:com/bank/config/sql/schema.sql")\n            .addScript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @Bean("dataSource")\n    @Profile("production")\n    public DataSource jndiDataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}',"spring-boot:run -Drun.profiles=prod","--spring.profiles.active=prod","java -jar -Dspring.profiles.active=prod *.jar",'java\nSystem.setProperty("spring.profiles.active", "test");','java\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles("development");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh();']},{title:"Spring 核心",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/5e7c20/",pathLocale:"/",extraFields:[]},{title:"Spring 之数据源",headers:[{level:2,title:"Spring Boot 数据源基本配置",slug:"spring-boot-数据源基本配置",link:"#spring-boot-数据源基本配置",children:[]},{level:2,title:"Spring Boot 连接嵌入式数据源",slug:"spring-boot-连接嵌入式数据源",link:"#spring-boot-连接嵌入式数据源",children:[]},{level:2,title:"Spring Boot 连接池化数据源",slug:"spring-boot-连接池化数据源",link:"#spring-boot-连接池化数据源",children:[{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",link:"#引入-spring-boot-依赖",children:[]},{level:3,title:"测试单数据源连接",slug:"测试单数据源连接",link:"#测试单数据源连接",children:[]}]},{level:2,title:"Spring Boot 连接多数据源",slug:"spring-boot-连接多数据源",link:"#spring-boot-连接多数据源",children:[{level:3,title:"多数据源配置",slug:"多数据源配置",link:"#多数据源配置",children:[]},{level:3,title:"测试多数据源连接",slug:"测试多数据源连接",link:"#测试多数据源连接",children:[]}]},{level:2,title:"Spring 之数据源",slug:"spring-之数据源-1",link:"#spring-之数据源-1",children:[{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",link:"#引入-spring-依赖",children:[]},{level:3,title:"Spring 配置数据源",slug:"spring-配置数据源",link:"#spring-配置数据源",children:[]}]},{level:2,title:"SpringBoot 数据源配置",slug:"springboot-数据源配置",link:"#springboot-数据源配置",children:[]},{level:2,title:"DataSourceAutoConfiguration 类",slug:"datasourceautoconfiguration-类",link:"#datasourceautoconfiguration-类",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1b774c/",pathLocale:"/",extraFields:["properties\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root","xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>com.h2database</groupId>\n  <artifactId>h2</artifactId>\n</dependency>","properties\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.Driver\nspring.datasource.username = sa\nspring.datasource.password =","properties\n# 连接池名称\nspring.datasource.hikari.pool-name = SpringTutorialHikariPool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000","xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>",'java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}',"20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8",'java\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\n@Configuration\npublic class DataSourceConfig {\n\n    @Primary\n    @Bean("mysqlDataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.mysql")\n    public DataSource mysqlDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Primary\n    @Bean("mysqlJdbcTemplate")\n    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n    @Bean("h2DataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.h2")\n    public DataSource h2DataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = "h2JdbcTemplate")\n    public JdbcTemplate h2JdbcTemplate(@Qualifier("h2DataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n}',"properties\n# 数据源一：Mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：H2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.Driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =",'java\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.sql.DataSource;\n\n@SpringBootApplication\npublic class SpringBootDataJdbcMultiDataSourceApplication implements CommandLineRunner {\n\n    private static final Logger log = LoggerFactory.getLogger(SpringBootDataJdbcMultiDataSourceApplication.class);\n\n    private final UserDao mysqlUserDao;\n\n    private final UserDao h2UserDao;\n\n    public SpringBootDataJdbcMultiDataSourceApplication(@Qualifier("mysqlUserDao") UserDao mysqlUserDao,\n        @Qualifier("h2UserDao") UserDao h2UserDao) {\n        this.mysqlUserDao = mysqlUserDao;\n        this.h2UserDao = h2UserDao;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcMultiDataSourceApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n\n        if (mysqlUserDao != null && mysqlUserDao.getJdbcTemplate() != null) {\n            printDataSourceInfo(mysqlUserDao.getJdbcTemplate());\n            log.info("Connect to mysql datasource success.");\n        } else {\n            log.error("Connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2UserDao != null) {\n            printDataSourceInfo(h2UserDao.getJdbcTemplate());\n            log.info("Connect to h2 datasource success.");\n        } else {\n            log.error("Connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 JDBC SQL\n        mysqlUserDao.recreateTable();\n\n        // 次数据源执行 JDBC SQL\n        h2UserDao.recreateTable();\n    }\n\n    private void printDataSourceInfo(JdbcTemplate jdbcTemplate) throws SQLException {\n\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("Get dataSource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("DataSource Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("Connect to datasource failed!");\n        }\n    }\n\n}',"21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to mysql datasource success.\n\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:h2:mem:test\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to h2 datasource success.","xml\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">\n    <property name="jndiName" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>','xml\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"\n        init-method="init" destroy-method="close">\n    <property name="driverClassName" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialSize" value="1"/>\n    <property name="minIdle" value="1"/>\n    <property name="maxActive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxWait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timeBetweenEvictionRunsMillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minEvictableIdleTimeMillis" value="300000"/>\n\n    <property name="testWhileIdle" value="true"/>\n\n    \x3c!-- 这里建议配置为TRUE，防止取到的连接不可用 --\x3e\n    <property name="testOnBorrow" value="true"/>\n    <property name="testOnReturn" value="false"/>\n\n    \x3c!-- 打开PSCache，并且指定每个连接上PSCache的大小 --\x3e\n    <property name="poolPreparedStatements" value="true"/>\n    <property name="maxPoolPreparedStatementPerConnectionSize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --\x3e\n\n    <property name="defaultAutoCommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的SQL，不同的数据配置不同 --\x3e\n    <property name="validationQuery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>','xml\n<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n  <property name="driverClassName" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>',"properties\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass","properties\nspring.datasource.jndi-name=java:jboss/datasources/customers",'java\n@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import(DataSourcePoolMetadataProvidersConfiguration.class)\npublic class DataSourceAutoConfiguration {\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedDatabaseConfiguration {\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(PooledDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })\n\tprotected static class PooledDataSourceConfiguration {\n  }\n\n\tstatic class PooledDataSourceCondition extends AnyNestedCondition {\n    // 略\n\t}\n\n\tstatic class PooledDataSourceAvailableCondition extends SpringBootCondition {\n    // 略\n\t}\n\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n    // 略\n\t}\n}']},{title:"Spring 之 JDBC",headers:[{level:2,title:"JDBC 入门示例",slug:"jdbc-入门示例",link:"#jdbc-入门示例",children:[{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"定义 DAO 接口",slug:"定义-dao-接口",link:"#定义-dao-接口",children:[]},{level:3,title:"定义 DAO 实现类",slug:"定义-dao-实现类",link:"#定义-dao-实现类",children:[]},{level:3,title:"测试类",slug:"测试类",link:"#测试类",children:[]}]},{level:2,title:"Spring Boot JDBC",slug:"spring-boot-jdbc",link:"#spring-boot-jdbc",children:[{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",link:"#引入-spring-boot-依赖",children:[]},{level:3,title:"配置数据源",slug:"配置数据源",link:"#配置数据源",children:[]},{level:3,title:"测试",slug:"测试",link:"#测试",children:[]}]},{level:2,title:"Spring JDBC",slug:"spring-jdbc",link:"#spring-jdbc",children:[{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",link:"#引入-spring-依赖",children:[]},{level:3,title:"基于 JDBC 驱动的数据源配置",slug:"基于-jdbc-驱动的数据源配置",link:"#基于-jdbc-驱动的数据源配置",children:[]},{level:3,title:"测试",slug:"测试-1",link:"#测试-1",children:[]}]},{level:2,title:"JdbcTemplate API",slug:"jdbctemplate-api",link:"#jdbctemplate-api",children:[{level:3,title:"execute 方法",slug:"execute-方法",link:"#execute-方法",children:[]},{level:3,title:"update 方法",slug:"update-方法",link:"#update-方法",children:[]},{level:3,title:"query 方法",slug:"query-方法",link:"#query-方法",children:[]}]},{level:2,title:"SpringBoot JDBC 配置",slug:"springboot-jdbc-配置",link:"#springboot-jdbc-配置",children:[{level:3,title:"JdbcTemplateAutoConfiguration 类",slug:"jdbctemplateautoconfiguration-类",link:"#jdbctemplateautoconfiguration-类",children:[]},{level:3,title:"JdbcTemplateConfiguration 类",slug:"jdbctemplateconfiguration-类",link:"#jdbctemplateconfiguration-类",children:[]},{level:3,title:"NamedParameterJdbcTemplateConfiguration 类",slug:"namedparameterjdbctemplateconfiguration-类",link:"#namedparameterjdbctemplateconfiguration-类",children:[]}]},{level:2,title:"spring-data-jdbc",slug:"spring-data-jdbc",link:"#spring-data-jdbc",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/cf19fd/",pathLocale:"/",extraFields:["sql\n-- 创建用户表\nCREATE TABLE `user` (\n    `id`      BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'ID',\n    `name`    VARCHAR(255)        NOT NULL DEFAULT '' COMMENT '用户名',\n    `age`     INT(3)              NOT NULL DEFAULT 0 COMMENT '年龄',\n    `address` VARCHAR(255)        NOT NULL DEFAULT '' COMMENT '地址',\n    `email`   VARCHAR(255)        NOT NULL DEFAULT '' COMMENT '邮件',\n    PRIMARY KEY (`id`),\n    UNIQUE (`name`)\n) COMMENT = '用户表';\n\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES ('张三', 18, '北京', 'xxx@163.com');\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES ('李四', 19, '上海', 'xxx@163.com');","java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n}",'java\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * user 表 Dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\npublic interface UserDao {\n\n    // DML\n    // -------------------------------------------------------------------\n    void insert(User user);\n\n    void batchInsert(List<User> users);\n\n    void deleteByName(String name);\n\n    void deleteAll();\n\n    void update(User user);\n\n    Integer count();\n\n    List<User> list();\n\n    User queryByName(String name);\n\n    JdbcTemplate getJdbcTemplate();\n\n    // DDL\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreateTable();\n\n}','java\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * user 表 Dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\n@Repository\npublic class UserDaoImpl implements UserDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public UserDaoImpl(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public void insert(User user) {\n        jdbcTemplate.update("INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail());\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void batchInsert(List<User> users) {\n        String sql = "INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)";\n\n        List<Object[]> params = new ArrayList<>();\n\n        users.forEach(user -> {\n            params.add(new Object[] { user.getName(), user.getAge(), user.getAddress(), user.getEmail() });\n        });\n        jdbcTemplate.batchUpdate(sql, params);\n    }\n\n    @Override\n    public void deleteByName(String name) {\n        jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void deleteAll() {\n        jdbcTemplate.execute("DELETE FROM user");\n    }\n\n    @Override\n    public void update(User user) {\n        jdbcTemplate.update("UPDATE user SET name=?, age=?, address=?, email=? WHERE id=?",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail(), user.getId());\n    }\n\n    @Override\n    public Integer count() {\n        try {\n            return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public List<User> list() {\n        return jdbcTemplate.query("SELECT * FROM user", new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @Override\n    public User queryByName(String name) {\n        try {\n            return jdbcTemplate.queryForObject("SELECT * FROM user WHERE name = ?",\n                new BeanPropertyRowMapper<>(User.class), name);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    @Override\n    public void truncate() {\n        jdbcTemplate.execute("TRUNCATE TABLE user");\n    }\n\n    @Override\n    public void recreateTable() {\n        jdbcTemplate.execute("DROP TABLE IF EXISTS user");\n\n        String sqlStatement =\n            "CREATE TABLE IF NOT EXISTS user (\\n"\n                + "    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\\n"\n                + "    name    VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\\n"\n                + "    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\\n"\n                + "    address VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\\n"\n                + "    email   VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\\n"\n                + "    PRIMARY KEY (id)\\n"\n                + ") COMMENT = \'用户表\';";\n        jdbcTemplate.execute(sqlStatement);\n    }\n\n}','java\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.Rollback;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Slf4j\n@Rollback\n@SpringBootTest(classes = { SpringBootDataJdbcApplication.class })\npublic class DataJdbcMysqlDataSourceTest {\n\n    @Autowired\n    private UserDao userDAO;\n\n    @BeforeEach\n    public void before() {\n        userDAO.truncate();\n    }\n\n    @Test\n    public void insert() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User linda = userDAO.queryByName("张三");\n        assertThat(linda).isNotNull();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n\n        userDAO.batchInsert(users);\n        int count = userDAO.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = userDAO.list();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(user -> {\n            log.info(user.toString());\n        });\n    }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        userDAO.batchInsert(users);\n\n        userDAO.deleteByName("张三");\n        User user = userDAO.queryByName("张三");\n        assertThat(user).isNull();\n\n        userDAO.deleteAll();\n        List<User> list = userDAO.list();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void update() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User oldUser = userDAO.queryByName("张三");\n        oldUser.setName("张三丰");\n        userDAO.update(oldUser);\n        User newUser = userDAO.queryByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}',"xml\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n  </dependencies>","properties\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root",'java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}',"20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8","xml\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用JDBC驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="dataSource2" class="org.springframework.jdbc.datasource.SingleConnectionDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- JDBC模板 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <constructor-arg ref="dataSource1" />\n    </bean>\n    <bean id="userDao" class="io.github.dunwu.springboot.data.jdbc.UserDaoImpl">\n        <constructor-arg ref="jdbcTemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="dataSource1" ignore-failures="ALL">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>','java\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n@SuppressWarnings("all")\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class MysqlJdbcTest {\n\n    @Autowired\n    private ApplicationContext ctx;\n\n    @Before\n    public void before() {\n        ctx = JdbcDemo.getMysqlApplicationContext();\n    }\n\n    @Test\n    public void testExecJdbcOper() throws SQLException, IOException {\n        UserDao userDao = (UserDaoImpl) ctx.getBean("userDao");\n        JdbcDemo.execJdbcOper(userDao);\n    }\n\n    @After\n    public void after() {\n        ((ClassPathXmlApplicationContext) ctx).close();\n    }\n\n}',"java\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    // 省略 getter/setter\n}",'java\npublic void recreateTable() {\n    jdbcTemplate.execute("DROP DATABASE IF EXISTS test");\n    jdbcTemplate.execute("CREATE DATABASE test");\n    jdbcTemplate.execute("USE test");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    // @formatter:off\n    StringBuilder sb = new StringBuilder();\n    sb.append("CREATE TABLE user (id int (10) unsigned NOT NULL AUTO_INCREMENT,\\n")\n        .append("name varchar (64) NOT NULL DEFAULT \'\',\\n")\n        .append("age tinyint (3) NOT NULL DEFAULT 0,\\n")\n        .append("PRIMARY KEY (ID));\\n");\n    // @formatter:on\n    jdbcTemplate.execute(sb.toString());\n}','java\npublic void insert(String name, Integer age) {\n    jdbcTemplate.update("INSERT INTO user(name, age) VALUES(?, ?)", name, age);\n}','java\npublic void delete(String name) {\n    jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n}','java\npublic void update(User user) {\n    jdbcTemplate.update("UPDATE USER SET name=?, age=? WHERE id=?", user.getName(), user.getAge(), user.getId());\n}','java\npublic void batchInsert(List<User> users) {\n    String sql = "INSERT INTO user(name, age) VALUES(?, ?)";\n\n    List<Object[]> params = new ArrayList<>();\n\n    users.forEach(item -> {\n        params.add(new Object[] {item.getName(), item.getAge()});\n    });\n    jdbcTemplate.batchUpdate(sql, params);\n}','java\npublic User queryByName(String name) {\n    try {\n        return jdbcTemplate\n            .queryForObject("SELECT * FROM user WHERE name = ?", new BeanPropertyRowMapper<>(User.class), name);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}','java\npublic List<User> list() {\n    return jdbcTemplate.query("select * from USER", new BeanPropertyRowMapper(User.class));\n}','java\npublic Integer count() {\n    try {\n        return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}',"java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {\n\n}","java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n\n}","java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnSingleCandidate(JdbcTemplate.class)\n@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\nclass NamedParameterJdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tNamedParameterJdbcTemplate namedParameterJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\treturn new NamedParameterJdbcTemplate(jdbcTemplate);\n\t}\n\n}"]},{title:"Spring 之事务",headers:[{level:2,title:"理解事务",slug:"理解事务",link:"#理解事务",children:[{level:3,title:"事务的特性",slug:"事务的特性",link:"#事务的特性",children:[]},{level:3,title:"全局事务",slug:"全局事务",link:"#全局事务",children:[]},{level:3,title:"本地事务",slug:"本地事务",link:"#本地事务",children:[]},{level:3,title:"Spring 对事务的支持",slug:"spring-对事务的支持",link:"#spring-对事务的支持",children:[]},{level:3,title:"Spring 事务的优点",slug:"spring-事务的优点",link:"#spring-事务的优点",children:[]}]},{level:2,title:"核心 API",slug:"核心-api",link:"#核心-api",children:[{level:3,title:"TransactionManager",slug:"transactionmanager",link:"#transactionmanager",children:[]},{level:3,title:"TransactionDefinition",slug:"transactiondefinition",link:"#transactiondefinition",children:[]},{level:3,title:"TransactionStatus",slug:"transactionstatus",link:"#transactionstatus",children:[]},{level:3,title:"TransactionTemplate",slug:"transactiontemplate",link:"#transactiontemplate",children:[]}]},{level:2,title:"声明式事务管理",slug:"声明式事务管理",link:"#声明式事务管理",children:[{level:3,title:"Spring 声明式事务管理的实现",slug:"spring-声明式事务管理的实现",link:"#spring-声明式事务管理的实现",children:[]},{level:3,title:"声明式事务示例",slug:"声明式事务示例",link:"#声明式事务示例",children:[]},{level:3,title:"回滚一个声明性事务",slug:"回滚一个声明性事务",link:"#回滚一个声明性事务",children:[]},{level:3,title:"为不同的 Bean 配置不同的事务语义",slug:"为不同的-bean-配置不同的事务语义",link:"#为不同的-bean-配置不同的事务语义",children:[]},{level:3,title:"<tx:advice/> 配置",slug:"tx-advice-配置",link:"#tx-advice-配置",children:[]},{level:3,title:"使用 @Transactional 注解",slug:"使用-transactional-注解",link:"#使用-transactional-注解",children:[]}]},{level:2,title:"JDBC 异常抽象",slug:"jdbc-异常抽象",link:"#jdbc-异常抽象",children:[]},{level:2,title:"Spring 事务最佳实践",slug:"spring-事务最佳实践",link:"#spring-事务最佳实践",children:[{level:3,title:"Spring 事务未生效",slug:"spring-事务未生效",link:"#spring-事务未生效",children:[]},{level:3,title:"事务虽然生效但未回滚",slug:"事务虽然生效但未回滚",link:"#事务虽然生效但未回滚",children:[]},{level:3,title:"细化事务传播方式",slug:"细化事务传播方式",link:"#细化事务传播方式",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/128c54/",pathLocale:"/",extraFields:["java\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}",'xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource" ref="dataSource" />\n</bean>','xml\n<bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>','xml\n<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>','xml\n<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">\n  <property name="transactionManagerName" value="java:/TransactionManager" />\n</bean>',"java\npublic interface ReactiveTransactionManager extends TransactionManager {\n\n    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n\n    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n\n    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\n}","java\npublic interface TransactionDefinition {\n    int getPropagationBehavior(); // 返回事务的传播行为\n    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int getTimeout();  // 返回事务必须在多少秒内完成\n    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}","java\n// 事务属性 PROPAGATION_REQUIRED\nmethodA {\n    ……\n    methodB();\n    ……\n}","java\n// 事务属性 PROPAGATION_REQUIRED\nmethodB {\n   ……\n}","java\nmain {\n    metodB();\n}","java\nMain {\n    Connection con=null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n\n        //方法调用\n        methodB();\n\n        //提交事务\n        con.commit();\n    } Catch(RuntimeException ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closeCon();\n    }\n}","java\nmain{\n    Connection con = null;\n    try{\n        con = getConnection();\n        methodA();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        closeCon();\n    }\n}","java\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n  methodB();\n}\n\n//事务属性 PROPAGATION_SUPPORTS\nmethodB(){\n  ……\n}","//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    methodB();\n}\n\n//事务属性 PROPAGATION_MANDATORY\n    methodB(){\n    ……\n}","//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_REQUIRES_NEW\nmethodB(){\n    ……\n}","main(){\n    methodA();\n}","main(){\n    TransactionManager tm = null;\n    try{\n        //获得一个JTA事务管理器\n        tm = getTransactionManager();\n        tm.begin();//开启一个新的事务\n        Transaction ts1 = tm.getTransaction();\n        doSomeThing();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            Transaction ts2 = tm.getTransaction();\n            methodB();\n            ts2.commit();//提交第二个事务\n        } Catch(RunTimeException ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodB执行完后，恢复第一个事务\n        tm.resume(ts1);\n        doSomeThingB();\n        ts1.commit();//提交第一个事务\n    } catch(RunTimeException ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}","//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_NESTED\nmethodB(){\n    ……\n}","main(){\n    Connection con = null;\n    Savepoint savepoint = null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n        doSomeThingA();\n        savepoint = con2.setSavepoint();\n        try{\n            methodB();\n        } catch(RuntimeException ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        doSomeThingB();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}",'con1 = getConnection();\n    select salary from employee empId ="Mary";',"con2 = getConnection();\n    update employee set salary = 2000;\n    con2.commit();",'//con1\n    select salary from employee empId ="Mary";',"con1 = getConnection();\n    Select * from employee where salary =1000;",'con2 = getConnection();\n    Insert into employee(empId,salary) values("Lili",1000);\n    con2.commit();',"//con1\n    select * from employee where salary =1000;","java\npublic interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n\n    @Override\n    boolean isNewTransaction();\n\n    boolean hasSavepoint();\n\n    @Override\n    void setRollbackOnly();\n\n    @Override\n    boolean isRollbackOnly();\n\n    void flush();\n\n    @Override\n    boolean isCompleted();\n}","java\n    TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate\n    Object result = tt.execute(\n        new TransactionCallback(){\n            public Object doTransaction(TransactionStatus status){\n                updateOperation();\n                return resultOfUpdateOperation();\n            }\n    }); // 执行execute方法进行事务管理","java\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface FooService {\n\n    Foo getFoo(String fooName);\n\n    Foo getFoo(String fooName, String barName);\n\n    void insertFoo(Foo foo);\n\n    void updateFoo(Foo foo);\n\n}","java\npackage x.y.service;\n\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}",'xml\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txAdvice" transaction-manager="txManager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>\n        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the DataSource --\x3e\n    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">\n        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the TransactionManager --\x3e\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>','xml\n<aop:config>\n    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>\n</aop:config>','java\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");\n        FooService fooService = ctx.getBean(FooService.class);\n        fooService.insertFoo(new Foo());\n    }\n}','xml\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>','xml\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>','xml\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>\n    </tx:attributes>\n</tx:advice>',"java\npublic void resolvePosition() {\n    try {\n        // some business logic...\n    } catch (NoProductInStockException ex) {\n        // trigger rollback programmatically\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceOperation"\n                expression="execution(* x.y.service..*Service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherService" class="org.xyz.SomeService"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barManager" class="x.y.service.SimpleBarManager"/> \x3c!-- (doesn\'t end in \'Service\') --\x3e\n\n    <tx:advice id="txAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultServiceOperation"\n                expression="execution(* x.y.service.*Service.*(..))"/>\n\n        <aop:pointcut id="noTxServiceOperation"\n                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>\n\n        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultServiceOperation\' pointcut) --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>\n\n    <tx:advice id="defaultTxAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="noTxAdvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="NEVER"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>',"java\n@Transactional\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}",'xml\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a TransactionManager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txManager"/>\n\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>','java\npublic class TransactionalService {\n\n    @Transactional("order")\n    public void setSomething(String name) { ... }\n\n    @Transactional("account")\n    public void doSomething() { ... }\n\n    @Transactional("reactive-account")\n    public Mono<Void> doSomethingReactive() { ... }\n}','xml\n<tx:annotation-driven/>\n\n    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>','java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "order", label = "causal-consistency")\npublic @interface OrderTx {\n}\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "account", label = "retryable")\npublic @interface AccountTx {\n}',"java\npublic class TransactionalService {\n\n    @OrderTx\n    public void setSomething(String name) {\n        // ...\n    }\n\n    @AccountTx\n    public void doSomething() {\n        // ...\n    }\n}",'java\n\t@Transactional\n\tvoid createUserPrivate(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createUserWrong1(String name) {\n\t\ttry {\n\t\t\tthis.createUserPrivate(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}','java\n\t//自调用\n\tpublic int createUserWrong2(String name) {\n\t\ttry {\n\t\t\tthis.createUserPublic(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\t//可以传播出异常\n\t@Transactional\n\tpublic void createUserPublic(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}','java\n@Service\n@Slf4j\npublic class UserService {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@Transactional\n\tpublic void createUserWrong1(String name) {\n\t\ttry {\n\t\t\tuserRepository.save(new UserEntity(name));\n\t\t\tthrow new RuntimeException("error");\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@Transactional\n\tpublic void createUserWrong2(String name) throws IOException {\n\t\tuserRepository.save(new UserEntity(name));\n\t\totherTask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个IOException\n\tprivate void otherTask() throws IOException {\n\t\tFiles.readAllLines(Paths.get("file-that-not-exist"));\n\t}\n\n}','java\n@Transactional\npublic void createUserRight1(String name) {\n   try {\n      userRepository.save(new UserEntity(name));\n      throw new RuntimeException("error");\n   } catch (Exception ex) {\n      log.error("create user failed", ex);\n      TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n   }\n}',"java\n@Transactional(rollbackFor = Exception.class)\npublic void createUserRight2(String name) throws IOException {\n   userRepository.save(new UserEntity(name));\n   otherTask();\n}",'java\n/**\n * {@link Propagation#REQUIRES_NEW} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void createSubUserWithExceptionRight(UserEntity entity) {\n   log.info("createSubUserWithExceptionRight start");\n   userRepository.save(entity);\n   throw new RuntimeException("invalid status");\n}']},{title:"Spring 之 JPA",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"常用 JPA 注解",slug:"常用-jpa-注解",link:"#常用-jpa-注解",children:[{level:3,title:"实体",slug:"实体",link:"#实体",children:[]},{level:3,title:"主键",slug:"主键",link:"#主键",children:[]},{level:3,title:"映射",slug:"映射",link:"#映射",children:[]},{level:3,title:"关系",slug:"关系",link:"#关系",children:[]}]},{level:2,title:"查询",slug:"查询",link:"#查询",children:[{level:3,title:"方法名字方式查询方式",slug:"方法名字方式查询方式",link:"#方法名字方式查询方式",children:[]},{level:3,title:"@Query 注解方式查询",slug:"query-注解方式查询",link:"#query-注解方式查询",children:[]},{level:3,title:"动态 SQL 方式查询",slug:"动态-sql-方式查询",link:"#动态-sql-方式查询",children:[]},{level:3,title:"Example 方式查询",slug:"example-方式查询",link:"#example-方式查询",children:[]},{level:3,title:"排序 Sort",slug:"排序-sort",link:"#排序-sort",children:[]},{level:3,title:"分页 Page 和 Pageable",slug:"分页-page-和-pageable",link:"#分页-page-和-pageable",children:[]}]},{level:2,title:"核心 API",slug:"核心-api",link:"#核心-api",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a03d7b/",pathLocale:"/",extraFields:["xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>",'java\n// 【可选】指定扫描的 Entity 目录，如果不指定，会扫描全部目录\n@EntityScan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 Repository 目录，如果不指定，会扫描全部目录\n@EnableJpaRepositories(basePackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 JPA auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}',"properties\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 JPA SQL 日志\nspring.jpa.show-sql = true\n# Hibernate的DDL策略\nspring.jpa.hibernate.ddl-auto = create-drop","java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\nimport javax.persistence.*;\n\n@Entity\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(unique = true)\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n    public User(String name, Integer age, String address, String email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof User)) {\n            return false;\n        }\n\n        User user = (User) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}",'java\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.bind.annotation.PathVariable;\n\nimport java.util.List;\n\n@RepositoryRestResource(collectionResourceRel = "user", path = "user")\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findUserById(@PathVariable("id") Long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByName?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link User}\n     */\n    User findUserByName(@Param("name") String name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByEmail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link User}\n     */\n    @Query("from User u where u.email=:email")\n    List<User> findByEmail(@Param("email") String email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @Transactional(rollbackFor = Exception.class)\n    void deleteByName(@Param("name") String name);\n\n}','java\n@Slf4j\n@SpringBootTest(classes = { DataJpaApplication.class })\npublic class DataJpaTests {\n\n    @Autowired\n    private UserRepository repository;\n\n    @BeforeEach\n    public void before() {\n        repository.deleteAll();\n    }\n\n    @Test\n    public void insert() {\n        User user = new User("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        Optional<User> optional = repository.findById(user.getId());\n        assertThat(optional).isNotNull();\n        assertThat(optional.isPresent()).isTrue();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        long count = repository.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = repository.findAll();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(this::accept);\n    }\n\n    private void accept(User user) { log.info(user.toString()); }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        repository.deleteByName("张三");\n        assertThat(repository.findUserByName("张三")).isNull();\n\n        repository.deleteAll();\n        List<User> list = repository.findAll();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void findAllInPage() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        PageRequest pageRequest = PageRequest.of(1, 2);\n        Page<User> page = repository.findAll(pageRequest);\n        assertThat(page).isNotNull();\n        assertThat(page.isEmpty()).isFalse();\n        assertThat(page.getTotalElements()).isEqualTo(4);\n        assertThat(page.getTotalPages()).isEqualTo(2);\n\n        List<User> list = page.get().collect(Collectors.toList());\n        System.out.println("user list: ");\n        list.forEach(System.out::println);\n    }\n\n    @Test\n    public void update() {\n        User oldUser = new User("张三", 18, "北京", "user1@163.com");\n        oldUser.setName("张三丰");\n        repository.save(oldUser);\n\n        User newUser = repository.findUserByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}',"java\npublic enum GenerationType {\n    TABLE,\n    SEQUENCE,\n    IDENTITY,\n    AUTO\n}","java\n@Column(length = 10, nullable = false, unique = true)",'java\n@Column(columnDefinition = "INT(3)")\nprivate int age;',"java\npublic interface UserRepository extends JpaRepository<User, Integer> {\n    public User findByName(String name);\n}","java\n// 根据名字查询，且按照名字升序\nList<Person> findByLastnameOrderByFirstnameAsc(String name);\n\n// 根据名字查询，且使用翻页查询\nPage<User> findByLastname(String lastname, Pageable pageable);\n\n// 查询满足条件的前10个用户\nList<User> findFirst10ByLastname(String lastname, Sort sort);\n\n// 使用And联合查询\nList<Person> findByFirstnameAndLastname(String firstname, String lastname);\n\n// 使用Or查询\nList<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic User findByNameLike(String name);",'java\n@Query("select u form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);','java\n@Query("form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);','java\n@Query(value="select * from user where name=?1 and department_id=?2", nativeQuery=true)\npublic User nativeQuery(String name, Integer departmentId);','java\n@Query(value="select * from user where name=:name and department_id=:departmentId", nativeQuery=true)\npublic User nativeQuery2(String name, Integer departmentId);','java\n@Query(value="select department_id,count(*) from user group by department_id", nativeQuery=true)\npublic List<Object[]> queryUserCount()','java\n@Query("select u from User u where department.id=?1")\npublic Page<User> QueryUsers(Integer departmentId, Pageable page);','java\n@Modifying\n@Query("update User u set u.name= ?1 where u.id= ?2")\nint updateName(String name, Integer id);',"java\n<S extends T> List<S> findAll(Example<S> var1);\n<S extends T> List<S> findAll(Example<S> var1, Sort var2);","java\npublic List<User> getByExample(String name) {\n    Department dept = new Department();\n    dept.setId(1);\n\n    User user = new User();\n    user.setName(name);\n    user.setDepartment(dept);\n    Example<User> example = Example.of(user);\n    List<User> list = userDao.findAll(example);\n    return list\n}",'java\nExampleMatcher matcher = ExampleMatcher.matching().withMatcher("xxx",\n    GenericPropertyMatchers.startsWith().ignoreCase());\nExample<User> example = Example.of(user, matcher);','java\nSort sort = new Sort("id");\n//Sort sort = new Sort(Direction.DESC, "id");\nreturn userDao.findAll(sort);']},{title:"Spring 集成 Mybatis",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[{level:3,title:"从 XML 中构建 SqlSessionFactory",slug:"从-xml-中构建-sqlsessionfactory",link:"#从-xml-中构建-sqlsessionfactory",children:[]},{level:3,title:"不使用 XML 构建 SqlSessionFactory",slug:"不使用-xml-构建-sqlsessionfactory",link:"#不使用-xml-构建-sqlsessionfactory",children:[]},{level:3,title:"从 SqlSessionFactory 中获取 SqlSession",slug:"从-sqlsessionfactory-中获取-sqlsession",link:"#从-sqlsessionfactory-中获取-sqlsession",children:[]},{level:3,title:"探究已映射的 SQL 语句",slug:"探究已映射的-sql-语句",link:"#探究已映射的-sql-语句",children:[]},{level:3,title:"作用域（Scope）和生命周期",slug:"作用域-scope-和生命周期",link:"#作用域-scope-和生命周期",children:[]}]},{level:2,title:"Mybatis 扩展工具",slug:"mybatis-扩展工具",link:"#mybatis-扩展工具",children:[{level:3,title:"Mybatis Plus",slug:"mybatis-plus",link:"#mybatis-plus",children:[]},{level:3,title:"Mapper",slug:"mapper",link:"#mapper",children:[]},{level:3,title:"PageHelper",slug:"pagehelper",link:"#pagehelper",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/88219e/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>",'java\nString resource = "org/mybatis/example/mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);','xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC"/>\n      <dataSource type="POOLED">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/BlogMapper.xml"/>\n  </mappers>\n</configuration>','java\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment("development", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);','java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n}',"java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n}",'xml\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.BlogMapper">\n  <select id="selectBlog" resultType="Blog">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>','java\nBlog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);',"java\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);",'java\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select("SELECT * FROM blog WHERE id = #{id}")\n  Blog selectBlog(int id);\n}',"java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}","java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}"]},{title:"Spring Data 综合",headers:[{level:2,title:"核心概念",slug:"核心概念",link:"#核心概念",children:[]},{level:2,title:"查询方法",slug:"查询方法",link:"#查询方法",children:[]},{level:2,title:"定义 Repository",slug:"定义-repository",link:"#定义-repository",children:[{level:3,title:"微调 Repository 定义",slug:"微调-repository-定义",link:"#微调-repository-定义",children:[]},{level:3,title:"使用多个 Spring 数据模块",slug:"使用多个-spring-数据模块",link:"#使用多个-spring-数据模块",children:[]}]},{level:2,title:"定义查询方法",slug:"定义查询方法",link:"#定义查询方法",children:[{level:3,title:"查询策略",slug:"查询策略",link:"#查询策略",children:[]},{level:3,title:"查询创建",slug:"查询创建",link:"#查询创建",children:[]}]},{level:2,title:"创建 Repository 实例",slug:"创建-repository-实例",link:"#创建-repository-实例",children:[]},{level:2,title:"自定义 Repository 实现",slug:"自定义-repository-实现",link:"#自定义-repository-实现",children:[]},{level:2,title:"Spring Data 扩展",slug:"spring-data-扩展",link:"#spring-data-扩展",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/191cdb/",pathLocale:"/",extraFields:["java\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n\n  <S extends T> S save(S entity);\n\n  Optional<T> findById(ID primaryKey);\n\n  Iterable<T> findAll();\n\n  long count();\n\n  void delete(T entity);\n\n  boolean existsById(ID primaryKey);\n\n  // … more functionality omitted.\n}","java\npublic interface PagingAndSortingRepository<T, ID>  {\n\n  Iterable<T> findAll(Sort sort);\n\n  Page<T> findAll(Pageable pageable);\n}","java\nPagingAndSortingRepository<User, Long> repository = // … get access to a bean\nPage<User> users = repository.findAll(PageRequest.of(1, 20));","java\ninterface UserRepository extends CrudRepository<User, Long> {\n  long countByLastname(String lastname);\n}","java\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long deleteByLastname(String lastname);\n\n  List<User> removeByLastname(String lastname);\n}","java\n   interface PersonRepository extends Repository<Person, Long> { … }","java\n   interface PersonRepository extends Repository<Person, Long> {\n     List<Person> findByLastname(String lastname);\n   }","java\n   @EnableJpaRepositories\n   class Config { … }",'java\n   class SomeClient {\n\n     private final PersonRepository repository;\n\n     SomeClient(PersonRepository repository) {\n       this.repository = repository;\n     }\n\n     void doSomething() {\n       List<Person> persons = repository.findByLastname("Matthews");\n     }\n   }',"java\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends Repository<T, ID> {\n\n  Optional<T> findById(ID id);\n\n  <S extends T> S save(S entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}","java\ninterface MyRepository extends JpaRepository<User, Long> { }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends JpaRepository<T, ID> { … }\n\ninterface UserRepository extends MyBaseRepository<User, Long> { … }","java\ninterface AmbiguousRepository extends Repository<User, Long> { … }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends CrudRepository<T, ID> { … }\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> { … }","java\ninterface PersonRepository extends Repository<Person, Long> { … }\n\n@Entity\nclass Person { … }\n\ninterface UserRepository extends Repository<User, Long> { … }\n\n@Document\nclass User { … }","java\ninterface JpaPersonRepository extends Repository<Person, Long> { … }\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> { … }\n\n@Entity\n@Document\nclass Person { … }",'java\n@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")\n@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")\nclass Configuration { … }',"java\ninterface PersonRepository extends Repository<Person, Long> {\n\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}"]},{title:"Spring 访问 Redis",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",link:"#spring-boot-快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"数据源配置",slug:"数据源配置",link:"#数据源配置",children:[]},{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"定义 CRUD 接口",slug:"定义-crud-接口",link:"#定义-crud-接口",children:[]},{level:3,title:"创建 CRUD 接口实现",slug:"创建-crud-接口实现",link:"#创建-crud-接口实现",children:[]},{level:3,title:"创建 Application",slug:"创建-application",link:"#创建-application",children:[]},{level:3,title:"测试",slug:"测试",link:"#测试",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/65e4a2/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>","properties\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =","java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.io.Serializable;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 4142994984277644695L;\n\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n\n}","java\nimport java.util.Map;\n\npublic interface UserService {\n\n    void batchSetUsers(Map<String, User> users);\n\n    long count();\n\n    User getUser(Long id);\n\n    void setUser(User user);\n\n}",'java\n\nimport cn.hutool.core.bean.BeanUtil;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Map;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    public static final String DEFAULT_KEY = "spring:tutorial:user";\n\n    private final RedisTemplate<String, Object> redisTemplate;\n\n    public UserServiceImpl(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    public void batchSetUsers(Map<String, User> users) {\n        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);\n    }\n\n    @Override\n    public long count() {\n        return redisTemplate.opsForHash().size(DEFAULT_KEY);\n    }\n\n    @Override\n    public User getUser(Long id) {\n        Object obj = redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());\n        return BeanUtil.toBean(obj, User.class);\n    }\n\n    @Override\n    public void setUser(User user) {\n        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);\n    }\n\n}',"java\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Slf4j\n@SpringBootApplication\npublic class RedisQuickstartApplication {\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Bean\n    @Primary\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常\n        // objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),\n        //     ObjectMapper.DefaultTyping.NON_FINAL);\n\n        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）\n        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        serializer.setObjectMapper(objectMapper);\n\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 配置连接工厂\n        template.setConnectionFactory(factory);\n        // 值采用json序列化\n        template.setValueSerializer(serializer);\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        // 设置hash key 和value序列化模式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n        template.afterPropertiesSet();\n\n        return template;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(RedisQuickstartApplication.class, args);\n    }\n\n}",'java\n@Slf4j\n@SpringBootTest(classes = { RedisQuickstartApplication.class })\npublic class RedisQuickstartTests {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void test() {\n        final long SIZE = 1000L;\n        Map<String, User> map = new HashMap<>();\n        for (long i = 0; i < SIZE; i++) {\n            User user = new User(i, RandomUtil.randomChineseName(),\n                RandomUtil.randomInt(1, 100),\n                RandomUtil.randomEnum(Location.class).name(),\n                RandomUtil.randomEmail());\n            map.put(String.valueOf(i), user);\n        }\n        userService.batchSetUsers(map);\n        long count = userService.count();\n        Assertions.assertThat(count).isEqualTo(SIZE);\n\n        for (int i = 0; i < 100; i++) {\n            long id = RandomUtil.randomLong(0, 1000);\n            User user = userService.getUser(id);\n            log.info("user-{}: {}", id, user.toString());\n        }\n    }\n\n}']},{title:"Spring 访问 MongoDB",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",link:"#spring-boot-快速入门",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"数据源配置",slug:"数据源配置",link:"#数据源配置",children:[]},{level:3,title:"定义实体",slug:"定义实体",link:"#定义实体",children:[]},{level:3,title:"创建 Repository",slug:"创建-repository",link:"#创建-repository",children:[]},{level:3,title:"创建 Application",slug:"创建-application",link:"#创建-application",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/db2a41/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>","properties\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root","java\nimport org.springframework.data.annotation.Id;\n\npublic class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n\n    public String lastName;\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n            \"Customer[id=%s, firstName='%s', lastName='%s']\",\n            id, firstName, lastName);\n    }\n\n}","java\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\npublic interface CustomerRepository extends MongoRepository<Customer, String> {\n\n    Customer findByFirstName(String firstName);\n    List<Customer> findByLastName(String lastName);\n\n}",'java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DataMongodbApplication implements CommandLineRunner {\n\n    @Autowired\n    private CustomerRepository repository;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DataMongodbApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) {\n\n        repository.deleteAll();\n\n        // save a couple of customers\n        repository.save(new Customer("Alice", "Smith"));\n        repository.save(new Customer("Bob", "Smith"));\n\n        // fetch all customers\n        System.out.println("Customers found with findAll():");\n        System.out.println("-------------------------------");\n        for (Customer customer : repository.findAll()) {\n            System.out.println(customer);\n        }\n        System.out.println();\n\n        // fetch an individual customer\n        System.out.println("Customer found with findByFirstName(\'Alice\'):");\n        System.out.println("--------------------------------");\n        System.out.println(repository.findByFirstName("Alice"));\n\n        System.out.println("Customers found with findByLastName(\'Smith\'):");\n        System.out.println("--------------------------------");\n        for (Customer customer : repository.findByLastName("Smith")) {\n            System.out.println(customer);\n        }\n    }\n\n}',"Customers found with findAll():\n-------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\nCustomer found with findByFirstName('Alice'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomers found with findByLastName('Smith'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)"]},{title:"Spring 访问 Elasticsearch",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"通过 REST 客户端连接 Elasticsearch",slug:"通过-rest-客户端连接-elasticsearch",link:"#通过-rest-客户端连接-elasticsearch",children:[]},{level:3,title:"通过 Jest 连接 Elasticsearch",slug:"通过-jest-连接-elasticsearch",link:"#通过-jest-连接-elasticsearch",children:[]},{level:3,title:"通过 Spring Data 访问 Elasticsearch",slug:"通过-spring-data-访问-elasticsearch",link:"#通过-spring-data-访问-elasticsearch",children:[]},{level:3,title:"Elasticsearch Repositories",slug:"elasticsearch-repositories",link:"#elasticsearch-repositories",children:[]}]},{level:2,title:"源码",slug:"源码",link:"#源码",children:[]},{level:2,title:"版本",slug:"版本",link:"#版本",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/fac14c/",pathLocale:"/",extraFields:["properties\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret","properties\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret","java\nstatic class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {\n\n\t@Override\n\tpublic void customize(HttpClientConfig.Builder builder) {\n\t\tbuilder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);\n\t}\n\n}","java\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@Component\npublic class MyBean {\n\n\tprivate final ElasticsearchTemplate template;\n\n\tpublic MyBean(ElasticsearchTemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}","bash\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar"]},{title:"Spring 数据篇",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"💻 示例",slug:"💻-示例",link:"#💻-示例",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/b912d1/",pathLocale:"/",extraFields:[]},{title:"Spring Web 综述",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"SpringMVC 工作流程",slug:"springmvc-工作流程",link:"#springmvc-工作流程",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/65351b/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>",'java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}',"java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}","json\nHello, World!","Hello, dunwu!"]},{title:"Spring Web 应用",headers:[{level:2,title:"快速入门",slug:"快速入门",link:"#快速入门",children:[]},{level:2,title:"Spring Web 组件",slug:"spring-web-组件",link:"#spring-web-组件",children:[{level:3,title:"组件扫描",slug:"组件扫描",link:"#组件扫描",children:[]},{level:3,title:"AOP 代理",slug:"aop-代理",link:"#aop-代理",children:[]},{level:3,title:"@Controller",slug:"controller",link:"#controller",children:[]},{level:3,title:"@RequestMapping",slug:"requestmapping",link:"#requestmapping",children:[]}]},{level:2,title:"处理方法",slug:"处理方法",link:"#处理方法",children:[{level:3,title:"请求数据",slug:"请求数据",link:"#请求数据",children:[]},{level:3,title:"响应数据",slug:"响应数据",link:"#响应数据",children:[]}]},{level:2,title:"@ModelAttribute",slug:"modelattribute",link:"#modelattribute",children:[]},{level:2,title:"@InitBinder",slug:"initbinder",link:"#initbinder",children:[]},{level:2,title:"表单处理",slug:"表单处理",link:"#表单处理",children:[{level:3,title:"创建处理表单的 Controller",slug:"创建处理表单的-controller",link:"#创建处理表单的-controller",children:[]},{level:3,title:"定义需要提交的表单实体",slug:"定义需要提交的表单实体",link:"#定义需要提交的表单实体",children:[]},{level:3,title:"提交表单前端代码",slug:"提交表单前端代码",link:"#提交表单前端代码",children:[]}]},{level:2,title:"文件上传",slug:"文件上传",link:"#文件上传",children:[{level:3,title:"创建文件上传处理 Controller",slug:"创建文件上传处理-controller",link:"#创建文件上传处理-controller",children:[]},{level:3,title:"定义存储文件的 Service",slug:"定义存储文件的-service",link:"#定义存储文件的-service",children:[]},{level:3,title:"创建文件上传表单",slug:"创建文件上传表单",link:"#创建文件上传表单",children:[]},{level:3,title:"文件上传限制",slug:"文件上传限制",link:"#文件上传限制",children:[]}]},{level:2,title:"异常处理",slug:"异常处理",link:"#异常处理",children:[{level:3,title:"@ExceptionHandler",slug:"exceptionhandler",link:"#exceptionhandler",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/5d002f/",pathLocale:"/",extraFields:['java\n@Controller\npublic class HelloController {\n\n    @GetMapping("/hello")\n    public String handle(Model model) {\n        model.addAttribute("message", "Hello World!");\n        return "index";\n    }\n}',"xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>",'java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}',"java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}","json\nHello, World!","Hello, dunwu!",'java\n@Configuration\n@ComponentScan("org.example.web")\npublic class WebConfig {\n\n    // ...\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:p="http://www.springframework.org/schema/p"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="org.example.web"/>\n\n    \x3c!-- ... --\x3e\n\n</beans>','java\n@RestController\n@RequestMapping("/persons")\nclass PersonController {\n\n    @GetMapping("/{id}")\n    public Person getPerson(@PathVariable Long id) {\n        // ...\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public void add(@RequestBody Person person) {\n        // ...\n    }\n}','java\n@GetMapping("/owners/{ownerId}/pets/{petId}")\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}','java\n@Controller\n@RequestMapping("/owners/{ownerId}")\npublic class OwnerController {\n\n    @GetMapping("/pets/{petId}")\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n        // ...\n    }\n}','java\n@GetMapping("/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}")\npublic void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {\n    // ...\n}','java\n@PostMapping(path = "/pets", consumes = "application/json")\npublic void addPet(@RequestBody Pet pet) {\n    // ...\n}','java\n@GetMapping(path = "/pets/{petId}", produces = "application/json")\n@ResponseBody\npublic Pet getPet(@PathVariable String petId) {\n    // ...\n}','java\n@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}','java\n@GetMapping(path = "/pets", headers = "myHeader=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}','java\n@Configuration\npublic class MyConfig {\n\n    @Autowired\n    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)\n            throws NoSuchMethodException {\n\n        RequestMappingInfo info = RequestMappingInfo\n                .paths("/user/{id}").methods(RequestMethod.GET).build();\n\n        Method method = UserHandler.class.getMethod("getUser", Long.class);\n\n        mapping.registerMapping(info, handler, method);\n    }\n}',"java\n@ModelAttribute\npublic void populateModel(@RequestParam String number, Model model) {\n    model.addAttribute(accountRepository.findAccount(number));\n    // add more ...\n}","java\n@ModelAttribute\npublic Account addAccount(@RequestParam String number) {\n    return accountRepository.findAccount(number);\n}",'java\n@GetMapping("/accounts/{id}")\n@ModelAttribute("myAccount")\npublic Account handle() {\n    // ...\n    return account;\n}','java\n@Controller\npublic class FormController {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");\n        dateFormat.setLenient(false);\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n    }\n\n    // ...\n}','java\n@Controller\npublic class FormController {\n\n    @InitBinder\n    protected void initBinder(WebDataBinder binder) {\n        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));\n    }\n\n    // ...\n}',"java\npublic class ChangeEmailForm {\n\n    private String oldEmailAddress;\n    private String newEmailAddress;\n\n    public void setOldEmailAddress(String oldEmailAddress) {\n        this.oldEmailAddress = oldEmailAddress;\n    }\n\n    public String getOldEmailAddress() {\n        return this.oldEmailAddress;\n    }\n\n    public void setNewEmailAddress(String newEmailAddress) {\n        this.newEmailAddress = newEmailAddress;\n    }\n\n    public String getNewEmailAddress() {\n        return this.newEmailAddress;\n    }\n\n}",'java\n@Controller\npublic class ChangeEmailController {\n\n    @InitBinder\n    void initBinder(WebDataBinder binder) {\n        binder.setAllowedFields("oldEmailAddress", "newEmailAddress");\n    }\n\n    // @RequestMapping methods, etc.\n\n}','java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PostMapping;\n\n@Controller\npublic class GreetingController {\n\n  @GetMapping("/greeting")\n  public String greetingForm(Model model) {\n    model.addAttribute("greeting", new Greeting());\n    return "greeting";\n  }\n\n  @PostMapping("/greeting")\n  public String greetingSubmit(@ModelAttribute Greeting greeting, Model model) {\n    model.addAttribute("greeting", greeting);\n    return "result";\n  }\n\n}',"java\nimport lombok.Data;\n\n@Data\npublic class Greeting {\n\n    private long id;\n\n    private String content;\n\n}",'html\n<!DOCTYPE html>\n<html xmlns:th="https://www.thymeleaf.org">\n  <head>\n    <title>Getting Started: Handling Form Submission</title>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n  </head>\n  <body>\n    <h1>Form</h1>\n    <form action="#" th:action="@{/greeting}" th:object="${greeting}" method="post">\n      <p>Id: <input type="text" th:field="*{id}" /></p>\n      <p>Message: <input type="text" th:field="*{content}" /></p>\n      <p><input type="submit" value="Submit" /> <input type="reset" value="Reset" /></p>\n    </form>\n  </body>\n</html>','java\nimport java.io.IOException;\nimport java.util.stream.Collectors;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport com.example.uploadingfiles.storage.StorageFileNotFoundException;\nimport com.example.uploadingfiles.storage.StorageService;\n\n@Controller\npublic class FileUploadController {\n\n\tprivate final StorageService storageService;\n\n\t@Autowired\n\tpublic FileUploadController(StorageService storageService) {\n\t\tthis.storageService = storageService;\n\t}\n\n\t@GetMapping("/")\n\tpublic String listUploadedFiles(Model model) throws IOException {\n\n\t\tmodel.addAttribute("files", storageService.loadAll().map(\n\t\t\t\tpath -> MvcUriComponentsBuilder.fromMethodName(FileUploadController.class,\n\t\t\t\t\t\t"serveFile", path.getFileName().toString()).build().toUri().toString())\n\t\t\t\t.collect(Collectors.toList()));\n\n\t\treturn "uploadForm";\n\t}\n\n\t@GetMapping("/files/{filename:.+}")\n\t@ResponseBody\n\tpublic ResponseEntity<Resource> serveFile(@PathVariable String filename) {\n\n\t\tResource file = storageService.loadAsResource(filename);\n\t\treturn ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,\n\t\t\t\t"attachment; filename=\\"" + file.getFilename() + "\\"").body(file);\n\t}\n\n\t@PostMapping("/")\n\tpublic String handleFileUpload(@RequestParam("file") MultipartFile file,\n\t\t\tRedirectAttributes redirectAttributes) {\n\n\t\tstorageService.store(file);\n\t\tredirectAttributes.addFlashAttribute("message",\n\t\t\t\t"You successfully uploaded " + file.getOriginalFilename() + "!");\n\n\t\treturn "redirect:/";\n\t}\n\n\t@ExceptionHandler(StorageFileNotFoundException.class)\n\tpublic ResponseEntity<?> handleStorageFileNotFound(StorageFileNotFoundException exc) {\n\t\treturn ResponseEntity.notFound().build();\n\t}\n\n}',"java\nimport org.springframework.core.io.Resource;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\npublic interface StorageService {\n\n\tvoid init();\n\n\tvoid store(MultipartFile file);\n\n\tStream<Path> loadAll();\n\n\tPath load(String filename);\n\n\tResource loadAsResource(String filename);\n\n\tvoid deleteAll();\n\n}",'java\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.FileSystemUtils;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.stream.Stream;\n\n@Service\npublic class FileSystemStorageServiceImpl implements StorageService {\n\n    private final Path rootLocation;\n\n    @Autowired\n    public FileSystemStorageServiceImpl(StorageProperties properties) {\n        this.rootLocation = Paths.get(properties.getLocation());\n    }\n\n    @Override\n    public void deleteAll() {\n        FileSystemUtils.deleteRecursively(rootLocation.toFile());\n    }\n\n    @Override\n    public void init() {\n        try {\n            Files.createDirectories(rootLocation);\n        } catch (IOException e) {\n            throw new StorageException("Could not initialize storage", e);\n        }\n    }\n\n    @Override\n    public Path load(String filename) {\n        return rootLocation.resolve(filename);\n    }\n\n    @Override\n    public Stream<Path> loadAll() {\n        try {\n            return Files.walk(this.rootLocation, 1).filter(path -> !path.equals(this.rootLocation))\n                .map(this.rootLocation::relativize);\n        } catch (IOException e) {\n            throw new StorageException("Failed to read stored files", e);\n        }\n    }\n\n    @Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path file = load(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                throw new StorageFileNotFoundException("Could not read file: " + filename);\n            }\n        } catch (MalformedURLException e) {\n            throw new StorageFileNotFoundException("Could not read file: " + filename, e);\n        }\n    }\n\n    @Override\n    public void store(MultipartFile file) {\n        String filename = StringUtils.cleanPath(file.getOriginalFilename());\n        try {\n            if (file.isEmpty()) {\n                throw new StorageException("Failed to store empty file " + filename);\n            }\n            if (filename.contains("..")) {\n                // This is a security check\n                throw new StorageException(\n                    "Cannot store file with relative path outside current directory " + filename);\n            }\n            try (InputStream inputStream = file.getInputStream()) {\n                Files.copy(inputStream, this.rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n            }\n        } catch (IOException e) {\n            throw new StorageException("Failed to store file " + filename, e);\n        }\n    }\n\n}','html\n<html xmlns:th="https://www.thymeleaf.org">\n<body>\n\n\t<div th:if="${message}">\n\t\t<h2 th:text="${message}"/>\n\t</div>\n\n\t<div>\n\t\t<form method="POST" enctype="multipart/form-data" action="/">\n\t\t\t<table>\n\t\t\t\t<tr><td>File to upload:</td><td><input type="file" name="file" /></td></tr>\n\t\t\t\t<tr><td></td><td><input type="submit" value="Upload" /></td></tr>\n\t\t\t</table>\n\t\t</form>\n\t</div>\n\n\t<div>\n\t\t<ul>\n\t\t\t<li th:each="file : ${files}">\n\t\t\t\t<a th:href="${file}" th:text="${file}" />\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\n</body>\n</html>',"properties\nspring.servlet.multipart.max-file-size=128KB\nspring.servlet.multipart.max-request-size=128KB","java\n@Controller\npublic class SimpleController {\n\n    // ...\n\n    @ExceptionHandler\n    public ResponseEntity<String> handle(IOException ex) {\n        // ...\n    }\n}","java\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(IOException ex) {\n    // ...\n}","java\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(Exception ex) {\n    // ...\n}"]},{title:"Spring MVC 之 DispatcherServlet",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"DispatcherServlet 工作原理",slug:"dispatcherservlet-工作原理",link:"#dispatcherservlet-工作原理",children:[]}]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"路径匹配",slug:"路径匹配",link:"#路径匹配",children:[]},{level:2,title:"拦截器",slug:"拦截器",link:"#拦截器",children:[]},{level:2,title:"解析器",slug:"解析器",link:"#解析器",children:[{level:3,title:"HandlerExceptionResolver",slug:"handlerexceptionresolver",link:"#handlerexceptionresolver",children:[]},{level:3,title:"ViewResolver",slug:"viewresolver",link:"#viewresolver",children:[]},{level:3,title:"LocaleResolver",slug:"localeresolver",link:"#localeresolver",children:[]},{level:3,title:"ThemeResolver",slug:"themeresolver",link:"#themeresolver",children:[]},{level:3,title:"MultipartResolver",slug:"multipartresolver",link:"#multipartresolver",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/20287b/",pathLocale:"/",extraFields:["java\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * 初始化此 servlet 使用的策略对象\n\t * 可以在子类中重写以初始化更多策略对象\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}","java\n\t@Override\n\tprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tlogRequest(request);\n\n\t\t// 在包含的情况下保留请求属性的快照，以便能够在包含后恢复原始属性\n\t\tMap<String, Object> attributesSnapshot = null;\n\t\tif (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = new HashMap<>();\n\t\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 设置请求属性（绑定各种 Resolver），使框架对象可用于处理程序和视图对象\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\tif (this.flashMapManager != null) {\n\t\t\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\tif (inputFlashMap != null) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\t\t}\n\n\t\tRequestPath previousRequestPath = null;\n\t\tif (this.parseRequestPath) {\n\t\t\tpreviousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t}\n\n\t\ttry {\n            // 请求分发\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t// 恢复原始属性快照，以防包含\n\t\t\t\tif (attributesSnapshot != null) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parseRequestPath) {\n\t\t\t\tServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n\t\t\t}\n\t\t}\n\t}",'java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   HttpServletRequest processedRequest = request;\n   HandlerExecutionChain mappedHandler = null;\n   boolean multipartRequestParsed = false;\n\n   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n   try {\n      ModelAndView mv = null;\n      Exception dispatchException = null;\n\n      try {\n         // 检查是否为multipart请求，如果是，则解析参数\n         processedRequest = checkMultipart(request);\n         multipartRequestParsed = (processedRequest != request);\n\n         // 确定适配当前请求的 Handler\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n         }\n\n         // 确定适配当前请求的 HandlerAdapter\n         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n         // 如果 Handler 支持，则处理 last-modified 头\n         String method = request.getMethod();\n         boolean isGet = HttpMethod.GET.matches(method);\n         if (isGet || HttpMethod.HEAD.matches(method)) {\n            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n            if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n               return;\n            }\n         }\n\n         // 请求的前置处理\n         if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n            return;\n         }\n\n         // 调用实际的 Handler 处理请求并返回 ModelAndView（有可能为 null）\n         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n         if (asyncManager.isConcurrentHandlingStarted()) {\n            return;\n         }\n\n         applyDefaultViewName(processedRequest, mv);\n         // 请求的后置处理\n         mappedHandler.applyPostHandle(processedRequest, response, mv);\n      }\n      catch (Exception ex) {\n         dispatchException = ex;\n      }\n      catch (Throwable err) {\n         // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n         // making them available for @ExceptionHandler methods and other scenarios.\n         dispatchException = new NestedServletException("Handler dispatch failed", err);\n      }\n       // 处理响应结果\n      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n   }\n   catch (Exception ex) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n   }\n   catch (Throwable err) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler,\n            new NestedServletException("Handler processing failed", err));\n   }\n   finally {\n      if (asyncManager.isConcurrentHandlingStarted()) {\n         // 替代 postHandle 和 afterCompletion\n         if (mappedHandler != null) {\n            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n         }\n      }\n      else {\n         // 清理 multipart 请求所使用的资源\n         if (multipartRequestParsed) {\n            cleanupMultipart(processedRequest);\n         }\n      }\n   }\n}','java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/app1/*" };\n    }\n}',"xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>",'java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n\n        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/");\n    }\n}','java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return null;\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { MyWebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}','java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        return null;\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n        return cxt;\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}',"java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected Filter[] getServletFilters() {\n        return new Filter[] {\n            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n    }\n}",'java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext servletContext) {\n\n        // Load Spring web application configuration\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(AppConfig.class);\n\n        // Create and register the DispatcherServlet\n        DispatcherServlet servlet = new DispatcherServlet(context);\n        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/app/*");\n    }\n}',"xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/app-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value></param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>","xml\n<error-page>\n    <location>/error</location>\n</error-page>",'java\n@RestController\npublic class ErrorController {\n\n    @RequestMapping(path = "/error")\n    public Map<String, Object> handle(HttpServletRequest request) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put("status", request.getAttribute("jakarta.servlet.error.status_code"));\n        map.put("reason", request.getAttribute("jakarta.servlet.error.message"));\n        return map;\n    }\n}','xml\n<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">\n\n    <property name="cookieName" value="clientlanguage"/>\n\n    \x3c!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --\x3e\n    <property name="cookieMaxAge" value="100000"/>\n\n</bean>','xml\n<bean id="localeChangeInterceptor"\n        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">\n    <property name="paramName" value="siteLanguage"/>\n</bean>\n\n<bean id="localeResolver"\n        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>\n\n<bean id="urlMapping"\n        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">\n    <property name="interceptors">\n        <list>\n            <ref bean="localeChangeInterceptor"/>\n        </list>\n    </property>\n    <property name="mappings">\n        <value>/**/*.view=someController</value>\n    </property>\n</bean>',"properties\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg",'xml\n<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>\n<html>\n    <head>\n        <link rel="stylesheet" href="<spring:theme code=\'styleSheet\'/>" type="text/css"/>\n    </head>\n    <body style="background=<spring:theme code=\'background\'/>">\n        ...\n    </body>\n</html>','java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n        registration.setMultipartConfig(new MultipartConfigElement("/tmp"));\n    }\n\n}']},{title:"Spring MVC 之过滤器",headers:[{level:2,title:"表单内容过滤器",slug:"表单内容过滤器",link:"#表单内容过滤器",children:[]},{level:2,title:"转发过滤器",slug:"转发过滤器",link:"#转发过滤器",children:[]},{level:2,title:"ETag 过滤器",slug:"etag-过滤器",link:"#etag-过滤器",children:[]},{level:2,title:"跨域过滤器",slug:"跨域过滤器",link:"#跨域过滤器",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/4a164d/",pathLocale:"/",extraFields:[]},{title:"Spring MVC 之跨域",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"处理",slug:"处理",link:"#处理",children:[]},{level:2,title:"@CrossOrigin",slug:"crossorigin",link:"#crossorigin",children:[]},{level:2,title:"全局配置",slug:"全局配置",link:"#全局配置",children:[{level:3,title:"Java 配置",slug:"java-配置",link:"#java-配置",children:[]},{level:3,title:"XML 配置",slug:"xml-配置",link:"#xml-配置",children:[]}]},{level:2,title:"CORS 过滤器",slug:"cors-过滤器",link:"#cors-过滤器",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/1d2954/",pathLocale:"/",extraFields:['java\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}','java\n@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}','java\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin("https://domain2.com")\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}','java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n\n        registry.addMapping("/api/**")\n            .allowedOrigins("https://domain2.com")\n            .allowedMethods("PUT", "DELETE")\n            .allowedHeaders("header1", "header2", "header3")\n            .exposedHeaders("header1", "header2")\n            .allowCredentials(true).maxAge(3600);\n\n        // Add more mappings...\n    }\n}','xml\n<mvc:cors>\n\n    <mvc:mapping path="/api/**"\n        allowed-origins="https://domain1.com, https://domain2.com"\n        allowed-methods="GET, PUT"\n        allowed-headers="header1, header2, header3"\n        exposed-headers="header1, header2" allow-credentials="true"\n        max-age="123" />\n\n    <mvc:mapping path="/resources/**"\n        allowed-origins="https://domain1.com" />\n\n</mvc:cors>','java\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin("https://domain1.com");\nconfig.addAllowedHeader("*");\nconfig.addAllowedMethod("*");\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration("/**", config);\n\nCorsFilter filter = new CorsFilter(source);']},{title:"Spring MVC 之视图技术",headers:[{level:2,title:"Thymeleaf",slug:"thymeleaf",link:"#thymeleaf",children:[]},{level:2,title:"FreeMarker",slug:"freemarker",link:"#freemarker",children:[{level:3,title:"视图配置",slug:"视图配置",link:"#视图配置",children:[]},{level:3,title:"FreeMarker 配置",slug:"freemarker-配置",link:"#freemarker-配置",children:[]},{level:3,title:"表单处理",slug:"表单处理",link:"#表单处理",children:[]}]},{level:2,title:"Groovy",slug:"groovy",link:"#groovy",children:[{level:3,title:"配置",slug:"配置",link:"#配置",children:[]},{level:3,title:"示例",slug:"示例",link:"#示例",children:[]}]},{level:2,title:"脚本视图",slug:"脚本视图",link:"#脚本视图",children:[{level:3,title:"要求",slug:"要求",link:"#要求",children:[]},{level:3,title:"脚本模板",slug:"脚本模板",link:"#脚本模板",children:[]}]},{level:2,title:"JSP 和 JSTL",slug:"jsp-和-jstl",link:"#jsp-和-jstl",children:[]},{level:2,title:"RSS and Atom",slug:"rss-and-atom",link:"#rss-and-atom",children:[]},{level:2,title:"PDF and Excel",slug:"pdf-and-excel",link:"#pdf-and-excel",children:[{level:3,title:"文档视图简介",slug:"文档视图简介",link:"#文档视图简介",children:[]},{level:3,title:"PDF 视图",slug:"pdf-视图",link:"#pdf-视图",children:[]},{level:3,title:"Excel 视图",slug:"excel-视图",link:"#excel-视图",children:[]}]},{level:2,title:"Jackson",slug:"jackson",link:"#jackson",children:[{level:3,title:"基于 Jackson 的 JSON MVC 视图",slug:"基于-jackson-的-json-mvc-视图",link:"#基于-jackson-的-json-mvc-视图",children:[]},{level:3,title:"基于 Jackson 的 XML 视图",slug:"基于-jackson-的-xml-视图",link:"#基于-jackson-的-xml-视图",children:[]}]},{level:2,title:"XML",slug:"xml",link:"#xml",children:[]},{level:2,title:"XSLT",slug:"xslt",link:"#xslt",children:[{level:3,title:"Beans",slug:"beans",link:"#beans",children:[]},{level:3,title:"Controller",slug:"controller",link:"#controller",children:[]},{level:3,title:"Transformation",slug:"transformation",link:"#transformation",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/251e31/",pathLocale:"/",extraFields:['java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.freeMarker();\n    }\n\n    // Configure FreeMarker...\n\n    @Bean\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPath("/WEB-INF/freemarker");\n        return configurer;\n    }\n}','xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:freemarker/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure FreeMarker... --\x3e\n<mvc:freemarker-configurer>\n    <mvc:template-loader-path location="/WEB-INF/freemarker"/>\n</mvc:freemarker-configurer>','xml\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n</bean>','xml\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n    <property name="freemarkerVariables">\n        <map>\n            <entry key="xml_escape" value-ref="fmXmlEscape"/>\n        </map>\n    </property>\n</bean>\n\n<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>','xml\n\x3c!-- FreeMarker macros have to be imported into a namespace.\n    We strongly recommend sticking to \'spring\'. --\x3e\n<#import "/spring.ftl" as spring/>\n<html>\n    ...\n    <form action="" method="POST">\n        Name:\n        <@spring.bind "personForm.name"/>\n        <input type="text"\n            name="${spring.status.expression}"\n            value="${spring.status.value?html}"/><br />\n        <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>\n        <br />\n        ...\n        <input type="submit" value="submit"/>\n    </form>\n    ...\n</html>','xml\n<@spring.formInput "command.name"/>\n<@spring.showErrors "<br>"/>','html\nName:\n<input type="text" name="name" value="">\n<br>\n    <b>required</b>\n<br>\n<br>','html\n...\nTown:\n<@spring.formRadioButtons "command.address.town", cityMap, ""/><br><br>','html\nTown:\n<input type="radio" name="address.town" value="London">London</input>\n<input type="radio" name="address.town" value="Paris" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="New York">New York</input>','java\nprotected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {\n    Map<String, String> cityMap = new LinkedHashMap<>();\n    cityMap.put("LDN", "London");\n    cityMap.put("PRS", "Paris");\n    cityMap.put("NYC", "New York");\n\n    Map<String, Object> model = new HashMap<>();\n    model.put("cityMap", cityMap);\n    return model;\n}','html\nTown:\n<input type="radio" name="address.town" value="LDN">London</input>\n<input type="radio" name="address.town" value="PRS" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="NYC">New York</input>',"html\n<#-- for FreeMarker --\x3e\n<#assign xhtmlCompliant = true>",'html\n<#-- until this point, default HTML escaping is used --\x3e\n\n<#assign htmlEscape = true>\n<#-- next field will use HTML escaping --\x3e\n<@spring.formInput "command.name"/>\n\n<#assign htmlEscape = false in spring>\n<#-- all future fields will be bound with HTML escaping off --\x3e','java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.groovy();\n    }\n\n    // Configure the Groovy Markup Template Engine...\n\n    @Bean\n    public GroovyMarkupConfigurer groovyMarkupConfigurer() {\n        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();\n        configurer.setResourceLoaderPath("/WEB-INF/");\n        return configurer;\n    }\n}','xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:groovy/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure the Groovy Markup Template Engine... --\x3e\n<mvc:groovy-configurer resource-loader-path="/WEB-INF/"/>',"groovy\nyieldUnescaped '<!DOCTYPE html>'\nhtml(lang:'en') {\n    head {\n        meta('http-equiv':'\"Content-Type\" content=\"text/html; charset=utf-8\"')\n        title('My page')\n    }\n    body {\n        p('This is an example of HTML contents')\n    }\n}",'java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("mustache.js");\n        configurer.setRenderObject("Mustache");\n        configurer.setRenderFunction("render");\n        return configurer;\n    }\n}','xml\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:script-template/>\n</mvc:view-resolvers>\n\n<mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render">\n    <mvc:script location="mustache.js"/>\n</mvc:script-template-configurer>','java\n@Controller\npublic class SampleController {\n\n    @GetMapping("/sample")\n    public String test(Model model) {\n        model.addAttribute("title", "Sample title");\n        model.addAttribute("body", "Sample body");\n        return "template";\n    }\n}',"html\n<html>\n  <head>\n    <title>{{title}}</title>\n  </head>\n  <body>\n    <p>{{body}}</p>\n  </body>\n</html>",'java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");\n        configurer.setRenderFunction("render");\n        configurer.setSharedEngine(false);\n        return configurer;\n    }\n}',"javascript\nvar window = {}","javascript\nfunction render(template, model) {\n  var compiledTemplate = Handlebars.compile(template)\n  return compiledTemplate(model)\n}","java\npublic class SampleContentAtomView extends AbstractAtomFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Feed feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Entry> buildFeedEntries(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}","java\npublic class SampleContentRssView extends AbstractRssFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Channel feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Item> buildFeedItems(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}",'java\npublic class PdfWordList extends AbstractPdfView {\n\n    protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        List<String> words = (List<String>) model.get("wordList");\n        for (String word : words) {\n            doc.add(new Paragraph(word));\n        }\n    }\n}','java\n@EnableWebMvc\n@ComponentScan\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Bean\n    public XsltViewResolver xsltViewResolver() {\n        XsltViewResolver viewResolver = new XsltViewResolver();\n        viewResolver.setPrefix("/WEB-INF/xsl/");\n        viewResolver.setSuffix(".xslt");\n        return viewResolver;\n    }\n}','java\n@Controller\npublic class XsltController {\n\n    @RequestMapping("/")\n    public String home(Model model) throws Exception {\n        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        Element root = document.createElement("wordList");\n\n        List<String> words = Arrays.asList("Hello", "Spring", "Framework");\n        for (String word : words) {\n            Element wordNode = document.createElement("word");\n            Text textNode = document.createTextNode(word);\n            wordNode.appendChild(textNode);\n            root.appendChild(wordNode);\n        }\n\n        model.addAttribute("wordList", root);\n        return "home";\n    }\n}','xml\n<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\n\n    <xsl:output method="html" omit-xml-declaration="yes"/>\n\n    <xsl:template match="/">\n        <html>\n            <head><title>Hello!</title></head>\n            <body>\n                <h1>My First Words</h1>\n                <ul>\n                    <xsl:apply-templates/>\n                </ul>\n            </body>\n        </html>\n    </xsl:template>\n\n    <xsl:template match="word">\n        <li><xsl:value-of select="."/></li>\n    </xsl:template>\n\n</xsl:stylesheet>','html\n<html>\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>My First Words</h1>\n    <ul>\n      <li>Hello</li>\n      <li>Spring</li>\n      <li>Framework</li>\n    </ul>\n  </body>\n</html>']},{title:"SpringBoot 之应用 EasyUI",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"什么是 EasyUI？",slug:"什么是-easyui",link:"#什么是-easyui",children:[]}]},{level:2,title:"Spring Boot 整合 EasyUI",slug:"spring-boot-整合-easyui",link:"#spring-boot-整合-easyui",children:[{level:3,title:"配置",slug:"配置",link:"#配置",children:[]},{level:3,title:"引入 easyui",slug:"引入-easyui",link:"#引入-easyui",children:[]}]},{level:2,title:"实战",slug:"实战",link:"#实战",children:[{level:3,title:"引入 maven 依赖",slug:"引入-maven-依赖",link:"#引入-maven-依赖",children:[]},{level:3,title:"使用 JPA",slug:"使用-jpa",link:"#使用-jpa",children:[]},{level:3,title:"使用 Web",slug:"使用-web",link:"#使用-web",children:[]},{level:3,title:"使用 EasyUI",slug:"使用-easyui",link:"#使用-easyui",children:[]}]},{level:2,title:"完整示例",slug:"完整示例",link:"#完整示例",children:[]},{level:2,title:"引用和引申",slug:"引用和引申",link:"#引用和引申",children:[]}],path:"/pages/ad0516/",pathLocale:"/",extraFields:["properties\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html",'html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>',"xml\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>com.h2database</groupId>\n      <artifactId>h2</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>","java\n@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    private String phone;\n    private String email;\n\n    protected User() {}\n\n    public User(String firstName, String lastName, String phone, String email) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}","public interface UserRepository extends CrudRepository<User, Long> {\n\n    List<User> findByLastName(String lastName);\n}",'java\n@Controller\npublic class IndexController {\n\n    @RequestMapping(value = {"", "/", "index"})\n    public String index() {\n        return "index";\n    }\n\n}','java\n@Controller\npublic class UserController {\n\n    @Autowired\n    private UserRepository customerRepository;\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String user() {\n        return "user";\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/list")\n    public ResponseDTO<User> list() {\n        Iterable<User> all = customerRepository.findAll();\n        List<User> list = IteratorUtils.toList(all.iterator());\n        return new ResponseDTO<>(true, list.size(), list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/add")\n    public ResponseDTO<User> add(User user) {\n        User result = customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(result);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/save")\n    public ResponseDTO<User> save(@RequestParam("id") Long id, User user) {\n        user.setId(id);\n        customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(user);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/delete")\n    public ResponseDTO delete(@RequestParam("id") Long id) {\n        customerRepository.deleteById(id);\n        return new ResponseDTO<>(true, null, null);\n    }\n\n}','html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Complex Layout - jQuery EasyUI Demo</title>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 CRUD 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="Custom List"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitColumns="true"\n        singleSelect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">ID</th>\n            <th field="firstName" width="50">First Name</th>\n            <th field="lastName" width="50">Last Name</th>\n            <th field="phone" width="50">Phone</th>\n            <th field="email" width="50">Email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-add"\n          plain="true"\n          onclick="newUser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-edit"\n          plain="true"\n          onclick="editUser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-remove"\n          plain="true"\n          onclick="destroyUser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>User Information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstName"\n              class="easyui-textbox"\n              required="true"\n              label="First Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastName"\n              class="easyui-textbox"\n              required="true"\n              label="Last Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="Phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validType="email"\n              label="Email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconCls="icon-ok"\n          onclick="saveUser()"\n          style="width:90px"\n          >Save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >Cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newUser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'setTitle\', \'New User\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function editUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'setTitle\', \'Edit User\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveUser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onSubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errorMsg) {\n              $.messager.show({\n                title: \'Error\',\n                msg: result.errorMsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $.messager.confirm(\n            \'Confirm\',\n            \'Are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'Error\',\n                        msg: result.errorMsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>',"mvn clean package -DskipTests=true\njava -jar target/"]},{title:"Spring Web",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/e2586a/",pathLocale:"/",extraFields:[]},{title:"spring-boot-async",headers:[{level:2,title:"@EnableAsync 注解",slug:"enableasync-注解",link:"#enableasync-注解",children:[]},{level:2,title:"@Async 注解",slug:"async-注解",link:"#async-注解",children:[{level:3,title:"支持的用法",slug:"支持的用法",link:"#支持的用法",children:[]},{level:3,title:"不支持的用法",slug:"不支持的用法",link:"#不支持的用法",children:[]}]},{level:2,title:"明确指定执行器",slug:"明确指定执行器",link:"#明确指定执行器",children:[]},{level:2,title:"管理 @Async 的异常",slug:"管理-async-的异常",link:"#管理-async-的异常",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/92add2/",pathLocale:"/",extraFields:["java\n@Configuration\n@EnableAsync\npublic class AppConfig {\n}","java\n@Async\nvoid doSomething() {\n    // this will be executed asynchronously\n}","java\n@Async\nvoid doSomething(String s) {\n    // this will be executed asynchronously\n}","java\n@Async\nFuture<String> returnSomething(int i) {\n    // this will be executed asynchronously\n}","java\npublic class SampleBeanImpl implements SampleBean {\n\n    @Async\n    void doSomething() {\n        // ...\n    }\n\n}\n\npublic class SampleBeanInitializer {\n\n    private final SampleBean bean;\n\n    public SampleBeanInitializer(SampleBean bean) {\n        this.bean = bean;\n    }\n\n    @PostConstruct\n    public void initialize() {\n        bean.doSomething();\n    }\n\n}",'java\n@Async("otherExecutor")\nvoid doSomething(String s) {\n    // this will be executed asynchronously by "otherExecutor"\n}',"java\npublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\n\n    @Override\n    public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n        // handle exception\n    }\n}"]},{title:"SpringBoot 之集成 Json",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[{level:3,title:"Spring Boot 支持的 Json 库",slug:"spring-boot-支持的-json-库",link:"#spring-boot-支持的-json-库",children:[]},{level:3,title:"Spring Web 中的序列化、反序列化",slug:"spring-web-中的序列化、反序列化",link:"#spring-web-中的序列化、反序列化",children:[]}]},{level:2,title:"指定类的 Json 序列化、反序列化",slug:"指定类的-json-序列化、反序列化",link:"#指定类的-json-序列化、反序列化",children:[]},{level:2,title:"@JsonTest",slug:"jsontest",link:"#jsontest",children:[]},{level:2,title:"Spring Boot 中的 json 配置",slug:"spring-boot-中的-json-配置",link:"#spring-boot-中的-json-配置",children:[{level:3,title:"Jackson 配置",slug:"jackson-配置",link:"#jackson-配置",children:[]},{level:3,title:"GSON 配置",slug:"gson-配置",link:"#gson-配置",children:[]}]},{level:2,title:"Spring Boot 中使用 Fastjson",slug:"spring-boot-中使用-fastjson",link:"#spring-boot-中使用-fastjson",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"引申和引用",slug:"引申和引用",link:"#引申和引用",children:[]}],path:"/pages/676725/",pathLocale:"/",extraFields:['java\n@ResponseBody\n@RequestMapping(name = "/getInfo", method = RequestMethod.GET)\npublic InfoDTO getInfo() {\n\treturn new InfoDTO();\n}','java\n@RequestMapping(name = "/postInfo", method = RequestMethod.POST)\npublic void postInfo(@RequestBody InfoDTO infoDTO) {\n    // ...\n}',"java\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@JsonComponent\npublic class Example {\n\n\tpublic static class Serializer extends JsonSerializer<SomeObject> {\n\t\t// ...\n\t}\n\n\tpublic static class Deserializer extends JsonDeserializer<SomeObject> {\n\t\t// ...\n\t}\n\n}","org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration",'java\n@JsonTest\n@RunWith(SpringRunner.class)\npublic class SimpleJsonTest {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private JacksonTester<InfoDTO> json;\n\n    @Test\n    public void testSerialize() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n        InfoDTO infoDTO = new InfoDTO("JSON测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        JsonContent<InfoDTO> jsonContent = json.write(infoDTO);\n        log.info("json content: {}", jsonContent.getJson());\n        // 或者使用基于JSON path的校验\n        assertThat(jsonContent).hasJsonPathStringValue("@.appName");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.appName").isEqualTo("JSON测试应用");\n        assertThat(jsonContent).hasJsonPathStringValue("@.version");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.version").isEqualTo("1.0.0");\n        assertThat(jsonContent).hasJsonPathStringValue("@.date");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.date").isEqualTo("2019-01-01 12:00:00");\n    }\n\n    @Test\n    public void testDeserialize() throws Exception {\n        String content = "{\\"appName\\":\\"JSON测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        InfoDTO actual = json.parseObject(content);\n        assertThat(actual.getAppName()).isEqualTo("JSON测试应用");\n        assertThat(actual.getVersion()).isEqualTo("1.0.0");\n    }\n}','properties\nspring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.\nspring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson\'s JsonInclude.Include enumeration.\nspring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.\nspring.jackson.generator.*= # Jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # Locale used for formatting.\nspring.jackson.mapper.*= # Jackson general purpose on/off features.\nspring.jackson.parser.*= # Jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # One of the constants on Jackson\'s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.\nspring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.\nspring.jackson.time-zone= #  Time zone used when formatting dates. For instance, "America/Los_Angeles" or "GMT+10".\nspring.jackson.visibility.*= # Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.',"properties\nspring.gson.date-format= # Format to use when serializing Date objects.\nspring.gson.disable-html-escaping= # Whether to disable the escaping of HTML characters such as '<', '>', etc.\nspring.gson.disable-inner-class-serialization= # Whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # Whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # Whether to exclude all fields from consideration for serialization or deserialization that do not have the \"Expose\" annotation.\nspring.gson.field-naming-policy= # Naming policy that should be applied to an object's field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # Whether to generate non executable JSON by prefixing the output with some special text.\nspring.gson.lenient= # Whether to be lenient about parsing JSON that doesn't conform to RFC 4627.\nspring.gson.long-serialization-policy= # Serialization policy for Long and long types.\nspring.gson.pretty-printing= # Whether to output serialized JSON that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # Whether to serialize null fields.","xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.54</version>\n</dependency>",'java\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        // 清除默认 Json 转换器\n        converters.removeIf(converter -> converter instanceof MappingJackson2HttpMessageConverter);\n\n        // 配置 FastJson\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.QuoteFieldNames, SerializerFeature.WriteEnumUsingToString,\n            SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat,\n            SerializerFeature.DisableCircularReferenceDetect);\n\n        // 添加 FastJsonHttpMessageConverter\n        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();\n        fastJsonHttpMessageConverter.setFastJsonConfig(config);\n        List<MediaType> fastMediaTypes = new ArrayList<>();\n        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);\n        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);\n        converters.add(fastJsonHttpMessageConverter);\n\n        // 添加 StringHttpMessageConverter，解决中文乱码问题\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));\n        converters.add(stringHttpMessageConverter);\n    }\n\n    // ...\n}']},{title:"SpringBoot 之发送邮件",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"API",slug:"api",link:"#api",children:[]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"实战",slug:"实战",link:"#实战",children:[{level:3,title:"引入依赖",slug:"引入依赖",link:"#引入依赖",children:[]},{level:3,title:"配置邮件属性",slug:"配置邮件属性",link:"#配置邮件属性",children:[]},{level:3,title:"Java 代码",slug:"java-代码",link:"#java-代码",children:[]}]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/2586f1/",pathLocale:"/",extraFields:["xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>","properties\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000","spring.mail.jndi-name=mail/Session","properties\n# Email (MailProperties)\nspring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.\nspring.mail.host= # SMTP server host. For instance, `smtp.example.com`.\nspring.mail.jndi-name= # Session JNDI name. When set, takes precedence over other Session settings.\nspring.mail.password= # Login password of the SMTP server.\nspring.mail.port= # SMTP server port.\nspring.mail.properties.*= # Additional JavaMail Session properties.\nspring.mail.protocol=smtp # Protocol used by the SMTP server.\nspring.mail.test-connection=false # Whether to test that the mail server is available on startup.\nspring.mail.username= # Login user of the SMTP server.","xml\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>com.github.dozermapper</groupId>\n    <artifactId>dozer-spring-boot-starter</artifactId>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>","properties\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = UTF-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}","properties\nspring.profiles.active = 163",'java\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.annotation.Validated;\n\n@Validated\n@Component\n@ConfigurationProperties(prefix = "mail")\npublic class MailProperties {\n    private String domain;\n    private String from;\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n}',"java\nimport lombok.Data;\nimport java.util.Date;\n\n@Data\npublic class MailDTO {\n    private String from;\n    private String replyTo;\n    private String[] to;\n    private String[] cc;\n    private String[] bcc;\n    private Date sentDate;\n    private String subject;\n    private String text;\n    private String[] filenames;\n}",'java\nimport com.github.dozermapper.core.Mapper;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.stereotype.Service;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.io.IOException;\n\n@Service\npublic class MailService {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private Mapper mapper;\n\n    public void sendSimpleMailMessage(MailDTO mailDTO) {\n        SimpleMailMessage simpleMailMessage = mapper.map(mailDTO, SimpleMailMessage.class);\n        if (StringUtils.isEmpty(mailDTO.getFrom())) {\n            mailDTO.setFrom(mailProperties.getFrom());\n        }\n        javaMailSender.send(simpleMailMessage);\n    }\n\n    public void sendMimeMessage(MailDTO mailDTO) {\n\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        MimeMessageHelper messageHelper;\n        try {\n            messageHelper = new MimeMessageHelper(mimeMessage, true);\n\n            if (StringUtils.isEmpty(mailDTO.getFrom())) {\n                messageHelper.setFrom(mailProperties.getFrom());\n            }\n            messageHelper.setTo(mailDTO.getTo());\n            messageHelper.setSubject(mailDTO.getSubject());\n\n            mimeMessage = messageHelper.getMimeMessage();\n            MimeBodyPart mimeBodyPart = new MimeBodyPart();\n            mimeBodyPart.setContent(mailDTO.getText(), "text/html;charset=UTF-8");\n\n            // 描述数据关系\n            MimeMultipart mm = new MimeMultipart();\n            mm.setSubType("related");\n            mm.addBodyPart(mimeBodyPart);\n\n            // 添加邮件附件\n            for (String filename : mailDTO.getFilenames()) {\n                MimeBodyPart attachPart = new MimeBodyPart();\n                try {\n                    attachPart.attachFile(filename);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                mm.addBodyPart(attachPart);\n            }\n            mimeMessage.setContent(mm);\n            mimeMessage.saveChanges();\n\n        } catch (MessagingException e) {\n            e.printStackTrace();\n        }\n\n        javaMailSender.send(mimeMessage);\n    }\n}']},{title:"Spring IO",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/56581b/",pathLocale:"/",extraFields:[]},{title:"Spring集成缓存",headers:[{level:2,title:"缓存接口",slug:"缓存接口",link:"#缓存接口",children:[{level:3,title:"开启注解",slug:"开启注解",link:"#开启注解",children:[]},{level:3,title:"缓存注解使用",slug:"缓存注解使用",link:"#缓存注解使用",children:[]}]},{level:2,title:"缓存存储",slug:"缓存存储",link:"#缓存存储",children:[{level:3,title:"使用 ConcurrentHashMap 作为缓存",slug:"使用-concurrenthashmap-作为缓存",link:"#使用-concurrenthashmap-作为缓存",children:[]},{level:3,title:"使用 Ehcache 作为缓存",slug:"使用-ehcache-作为缓存",link:"#使用-ehcache-作为缓存",children:[]},{level:3,title:"使用 Caffeine 作为缓存",slug:"使用-caffeine-作为缓存",link:"#使用-caffeine-作为缓存",children:[]}]},{level:2,title:"示例代码",slug:"示例代码",link:"#示例代码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/a311cb/",pathLocale:"/",extraFields:['xml\n<cache:annotation-driven cache-manager="cacheManager"/>',"java\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}",'java\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}','java\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)','java\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n\t@Cacheable\n\tpublic Book findBook(ISBN isbn) {...}\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ConcurrentHashMap 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simpleCacheManager" class="org.springframework.cache.support.SimpleCacheManager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simpleCacheManager"/>\n</beans>','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 EhCache 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">\n    <property name="configLocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcacheCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">\n    <property name="cacheManager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcacheCacheManager"/>\n</beans>','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 Caffeine 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeineCacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"/>\n\n  <cache:annotation-driven cache-manager="caffeineCacheManager"/>\n</beans>']},{title:"Spring 集成调度器",headers:[{level:2,title:"概述",slug:"概述",link:"#概述",children:[]},{level:2,title:"实时触发调度任务",slug:"实时触发调度任务",link:"#实时触发调度任务",children:[{level:3,title:"TaskScheduler 接口",slug:"taskscheduler-接口",link:"#taskscheduler-接口",children:[]},{level:3,title:"@Scheduler 的使用方法",slug:"scheduler-的使用方法",link:"#scheduler-的使用方法",children:[]}]},{level:2,title:"参考",slug:"参考",link:"#参考",children:[]}],path:"/pages/a187f0/",pathLocale:"/",extraFields:["java\npublic interface TaskScheduler {\n\n    ScheduledFuture schedule(Runnable task, Trigger trigger);\n\n    ScheduledFuture schedule(Runnable task, Date startTime);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);\n\n}","public interface Trigger {\n    Date nextExecutionTime(TriggerContext triggerContext);\n}",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>',"xml\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd",'import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DemoTask implements Runnable {\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void run() {\n        logger.info("call DemoTask.run");\n    }\n}','java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.TaskScheduler;\nimport org.springframework.scheduling.support.CronTrigger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping("/scheduler")\npublic class SchedulerController {\n    @Autowired\n    TaskScheduler scheduler;\n\n    @RequestMapping(value = "/start", method = RequestMethod.POST)\n    public void start() {\n        scheduler.schedule(new DemoTask(), new CronTrigger("0/5 * * * * *"));\n    }\n}',"13:53:15.010 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:20.003 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:25.004 myScheduler-2 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:30.005 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>',"java\n@Scheduled(fixedDelay=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}","java\n@Scheduled(fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}","java\n@Scheduled(initialDelay=1000, fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}",'java\n@Scheduled(cron="*/5 * * * * MON-FRI")\npublic void doSomething() {\n    // something that should execute on weekdays only\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>','java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @description 使用@Scheduler注解调度任务范例\n * @author Vicotr Zhang\n * @date 2016年8月31日\n */\n@Component\npublic class ScheduledMgr {\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public ScheduledMgr() {\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedDelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @Scheduled(fixedDelay = 5000)\n    public void testFixedDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedRate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @Scheduled(fixedRate = 5000)\n    public void testFixedRate() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * initialDelay属性定义初始化后的启动延迟时间\n     */\n    @Scheduled(initialDelay = 1000, fixedRate = 5000)\n    public void testInitialDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void testCron() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n}',"10:58:46.479 localhost-startStop-1 o.z.n.s.scheduler.ScheduledTasks.<init> - Current time: 2016-08-31 10:58:46\n10:58:52.523 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:52\n10:58:52.523 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:58:52\n10:58:53.524 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:53\n10:58:55.993 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:58:55\n10:58:58.507 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:58\n10:58:59.525 myScheduler-5 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:59\n10:59:03.536 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:03\n10:59:04.527 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:04\n10:59:05.527 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:05\n10:59:06.032 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:06\n10:59:10.534 myScheduler-9 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:10\n10:59:11.527 myScheduler-10 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:11\n10:59:14.524 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:14\n10:59:15.987 myScheduler-6 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:15"]},{title:"Spring集成Dubbo",headers:[{level:2,title:"ZooKeeper",slug:"zookeeper",link:"#zookeeper",children:[]},{level:2,title:"Dubbo",slug:"dubbo",link:"#dubbo",children:[]},{level:2,title:"服务提供者",slug:"服务提供者",link:"#服务提供者",children:[{level:3,title:"定义服务接口",slug:"定义服务接口",link:"#定义服务接口",children:[]},{level:3,title:"在服务提供方实现接口",slug:"在服务提供方实现接口",link:"#在服务提供方实现接口",children:[]},{level:3,title:"用 Spring 配置声明暴露服务",slug:"用-spring-配置声明暴露服务",link:"#用-spring-配置声明暴露服务",children:[]},{level:3,title:"加载 Spring 配置",slug:"加载-spring-配置",link:"#加载-spring-配置",children:[]}]},{level:2,title:"服务消费者",slug:"服务消费者",link:"#服务消费者",children:[{level:3,title:"通过 Spring 配置引用远程服务",slug:"通过-spring-配置引用远程服务",link:"#通过-spring-配置引用远程服务",children:[]},{level:3,title:"加载 Spring 配置，并调用远程服务",slug:"加载-spring-配置-并调用远程服务",link:"#加载-spring-配置-并调用远程服务",children:[]}]},{level:2,title:"FAQ",slug:"faq",link:"#faq",children:[]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/274fd7/",pathLocale:"/",extraFields:["vi conf/zoo.cfg","tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181","tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555","mkdir data\nvi myid","1","telnet 127.0.0.1 2181\ndump","echo dump | nc 127.0.0.1 2181","dubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181",'<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />',"java\npackage com.alibaba.dubbo.demo;\n\npublic interface DemoService {\n    String sayHello(String name);\n}",'java\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class DemoServiceImpl implements DemoService {\n    public String sayHello(String name) {\n        return "Hello " + name;\n    }\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />\n</beans>','java\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Provider {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        System.in.read(); // 按任意键退出\n    }\n}','xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\x3e\n    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" />\n</beans>','import org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class Consumer {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理\n        String hello = demoService.sayHello("world"); // 执行远程方法\n        System.out.println( hello ); // 显示调用结果\n    }\n}']},{title:"Spring 集成",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/d6025b/",pathLocale:"/",extraFields:[]},{title:"SpringBoot 之安全快速入门",headers:[{level:2,title:"QuickStart",slug:"quickstart",link:"#quickstart",children:[]}],path:"/pages/568352/",pathLocale:"/",extraFields:["xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>","properties\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = USER"]},{title:"Spring 4 升级踩雷指南",headers:[{level:2,title:"前言",slug:"前言",link:"#前言",children:[]},{level:2,title:"为什么升级 spring4",slug:"为什么升级-spring4",link:"#为什么升级-spring4",children:[]},{level:2,title:"spring 4 重要新特性",slug:"spring-4-重要新特性",link:"#spring-4-重要新特性",children:[]},{level:2,title:"升级 spring 4 步骤",slug:"升级-spring-4-步骤",link:"#升级-spring-4-步骤",children:[{level:3,title:"修改 spring 版本",slug:"修改-spring-版本",link:"#修改-spring-版本",children:[]},{level:3,title:"修改 spring xml 文件的 xsd",slug:"修改-spring-xml-文件的-xsd",link:"#修改-spring-xml-文件的-xsd",children:[]},{level:3,title:"修改 spring xml 文件",slug:"修改-spring-xml-文件",link:"#修改-spring-xml-文件",children:[]},{level:3,title:"加入 spring support",slug:"加入-spring-support",link:"#加入-spring-support",children:[]},{level:3,title:"更换 spring-mvc jackson",slug:"更换-spring-mvc-jackson",link:"#更换-spring-mvc-jackson",children:[]},{level:3,title:"解决 ibatis 兼容问题",slug:"解决-ibatis-兼容问题",link:"#解决-ibatis-兼容问题",children:[]},{level:3,title:"升级 Dubbo",slug:"升级-dubbo",link:"#升级-dubbo",children:[]},{level:3,title:"升级 Jedis",slug:"升级-jedis",link:"#升级-jedis",children:[]}]},{level:2,title:"资料",slug:"资料",link:"#资料",children:[]}],path:"/pages/752c6a/",pathLocale:"/",extraFields:["xml\n<properties>\n  <spring.version>4.3.13.RELEASE</spring.version>\n</properties>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>${spring.version}</version>\n</dependency>",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">','>   xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>   ..."\n>','xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref local="dataSource" />\n  </property>\n</bean>','xml\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref bean="dataSource" />\n  </property>\n</bean>',"Caused by: org.xml.sax.SAXParseException: cvc-complex-type.3.2.2: Attribute 'local' is not allowed to appear in element 'ref'.","xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.2.3.RELEASE</version>\n</dependency>","xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.7.0</version>\n</dependency>",'xml\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">\n\t<property name="messageConverters">\n\t\t<list>\n\t\t\t <ref bean="stringHttpMessageConverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringHttpMessageConverter"\n\tclass="org.springframework.http.converter.StringHttpMessageConverter">\n\t<property name="supportedMediaTypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=UTF-8</value>\n\t\t</list>\n\t</property>\n</bean>',"xml\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-2-spring</artifactId>\n    <version>1.0.1</version>\n</dependency>","xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>dubbo</artifactId>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.javassist</groupId>\n      <artifactId>javassist</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>","Caused by: java.lang.ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig","xml\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>",'xml\n<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">\n  <property name="maxTotal" value="200" />\n  <property name="maxIdle" value="10" />\n  <property name="maxWaitMillis" value="1000" />\n  <property name="testOnBorrow" value="true" />\n</bean>',"InvalidURIException: Cannot open Redis connection due invalid URI",'xml\n<bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="destroy" depends-on="jedisPoolConfig">\n  <constructor-arg ref="jedisPoolConfig" />\n  <constructor-arg type="java.lang.String" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>']},{title:"SpringBoot 之 banner 定制",headers:[{level:2,title:"简介",slug:"简介",link:"#简介",children:[]},{level:2,title:"变量",slug:"变量",link:"#变量",children:[]},{level:2,title:"配置",slug:"配置",link:"#配置",children:[]},{level:2,title:"编程",slug:"编程",link:"#编程",children:[]},{level:2,title:"示例源码",slug:"示例源码",link:"#示例源码",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/bac2ce/",pathLocale:"/",extraFields:[".   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.1.1.RELEASE)","${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}\n:: Spring Boot ::             (v${spring-boot.version})\n:: Spring Boot Tutorial ::    (v1.0.0)","properties\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 System.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = UTF-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false","yml\nspring:\n  main:\n    banner-mode: off"]},{title:"SpringBoot Actuator 快速入门",headers:[{level:2,title:"端点（Endpoint）",slug:"端点-endpoint",link:"#端点-endpoint",children:[{level:3,title:"启用端点",slug:"启用端点",link:"#启用端点",children:[]},{level:3,title:"暴露端点",slug:"暴露端点",link:"#暴露端点",children:[]},{level:3,title:"安全",slug:"安全",link:"#安全",children:[]},{level:3,title:"配置端点",slug:"配置端点",link:"#配置端点",children:[]},{level:3,title:"Actuator Web 端点的超媒体",slug:"actuator-web-端点的超媒体",link:"#actuator-web-端点的超媒体",children:[]},{level:3,title:"跨域支持",slug:"跨域支持",link:"#跨域支持",children:[]},{level:3,title:"自定义端点",slug:"自定义端点",link:"#自定义端点",children:[]}]},{level:2,title:"通过 HTTP 进行监控和管理",slug:"通过-http-进行监控和管理",link:"#通过-http-进行监控和管理",children:[{level:3,title:"自定义管理端点路径",slug:"自定义管理端点路径",link:"#自定义管理端点路径",children:[]},{level:3,title:"自定义管理服务器端口",slug:"自定义管理服务器端口",link:"#自定义管理服务器端口",children:[]},{level:3,title:"配置 SSL",slug:"配置-ssl",link:"#配置-ssl",children:[]},{level:3,title:"自定义管理服务器地址",slug:"自定义管理服务器地址",link:"#自定义管理服务器地址",children:[]},{level:3,title:"禁用 HTTP 端点",slug:"禁用-http-端点",link:"#禁用-http-端点",children:[]}]},{level:2,title:"通过 JMX 进行监控和管理",slug:"通过-jmx-进行监控和管理",link:"#通过-jmx-进行监控和管理",children:[{level:3,title:"定制化 MBean Names",slug:"定制化-mbean-names",link:"#定制化-mbean-names",children:[]},{level:3,title:"禁用 JMX 端点",slug:"禁用-jmx-端点",link:"#禁用-jmx-端点",children:[]},{level:3,title:"将 Jolokia 用于基于 HTTP 的 JMX",slug:"将-jolokia-用于基于-http-的-jmx",link:"#将-jolokia-用于基于-http-的-jmx",children:[]}]},{level:2,title:"日志",slug:"日志",link:"#日志",children:[]},{level:2,title:"指标",slug:"指标",link:"#指标",children:[]},{level:2,title:"审计",slug:"审计",link:"#审计",children:[]},{level:2,title:"HTTP 追踪",slug:"http-追踪",link:"#http-追踪",children:[]},{level:2,title:"处理监控",slug:"处理监控",link:"#处理监控",children:[]},{level:2,title:"参考资料",slug:"参考资料",link:"#参考资料",children:[]}],path:"/pages/c013cc/",pathLocale:"/",extraFields:["xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>","groovy\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-actuator'\n}","properties\nmanagement.endpoint.shutdown.enabled=true","properties\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true","properties\nmanagement.endpoints.jmx.exposure.include=health,info",'java\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));\n        http.httpBasic();\n        return http.build();\n    }\n\n}',"properties\nmanagement.endpoints.web.exposure.include=*","java\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().permitAll());\n        return http.build();\n    }\n\n}","properties\nmanagement.endpoint.beans.cache.time-to-live=10s","properties\nmanagement.endpoints.web.discovery.enabled=false","properties\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=GET,POST",'java\n@ReadOperation\npublic CustomData getData() {\n    return new CustomData("test", 5);\n}',"properties\nmanagement.endpoints.web.base-path=/manage","properties\nmanagement.server.port=8081","properties\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false","properties\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret","properties\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1","properties\nmanagement.server.port=-1","properties\nmanagement.endpoints.web.exposure.exclude=*","properties\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp","management.endpoints.jmx.exposure.exclude=*","xml\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency"]},{title:"Spring 其他",headers:[{level:2,title:"📖 内容",slug:"📖-内容",link:"#📖-内容",children:[]},{level:2,title:"📚 资料",slug:"📚-资料",link:"#📚-资料",children:[]},{level:2,title:"🚪 传送",slug:"🚪-传送",link:"#🚪-传送",children:[]}],path:"/pages/6bb8c1/",pathLocale:"/",extraFields:[]},{title:"日志",headers:[{level:2,title:"1.1 作用：",slug:"_1-1-作用",link:"#_1-1-作用",children:[]},{level:2,title:"1.2 使用步骤：",slug:"_1-2-使用步骤",link:"#_1-2-使用步骤",children:[]},{level:2,title:"1.3 日志级别",slug:"_1-3-日志级别",link:"#_1-3-日志级别",children:[]},{level:2,title:"1.4 配置文件",slug:"_1-4-配置文件",link:"#_1-4-配置文件",children:[]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/log%E6%97%A5%E5%BF%97.html",pathLocale:"/",extraFields:["TRACE, DEBUG, INFO, WARN, ERROR",'xml\n<?xml version="1.0" encoding="UTF-8"?>\n<configuration>\n    \x3c!--\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\n    --\x3e\n    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">\n        \x3c!--输出流对象 默认 System.out 改为 System.err--\x3e\n        <target>System.out</target>\n        <encoder>\n            \x3c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度\n                %msg：日志消息，%n是换行符--\x3e\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    \x3c!-- File是输出的方向通向文件的 --\x3e\n    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n            <charset>utf-8</charset>\n        </encoder>\n        \x3c!--日志输出路径--\x3e\n        <file>C:/code/itheima-data.log</file>\n        \x3c!--指定日志文件拆分和压缩规则--\x3e\n        <rollingPolicy\n                       class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">\n            \x3c!--通过指定压缩文件名称，来确定分割文件方式--\x3e\n            <fileNamePattern>C:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz</fileNamePattern>\n            \x3c!--文件拆分大小--\x3e\n            <maxFileSize>1MB</maxFileSize>\n        </rollingPolicy>\n    </appender>\n\n    \x3c!--\n\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\n   ， 默认debug\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\n    --\x3e\n    <root level="info">\n        <appender-ref ref="CONSOLE"/>\n        <appender-ref ref="FILE" />\n    </root>\n</configuration>']},{title:"类加载器",headers:[{level:2,title:"1.类加载器",slug:"_1-类加载器",link:"#_1-类加载器",children:[{level:3,title:"1.1类加载器",slug:"_1-1类加载器",link:"#_1-1类加载器",children:[]},{level:3,title:"1.2类加载的完整过程",slug:"_1-2类加载的完整过程",link:"#_1-2类加载的完整过程",children:[]},{level:3,title:"1.3类加载的分类【理解】",slug:"_1-3类加载的分类【理解】",link:"#_1-3类加载的分类【理解】",children:[]},{level:3,title:"1.4双亲委派模型【理解】",slug:"_1-4双亲委派模型【理解】",link:"#_1-4双亲委派模型【理解】",children:[]},{level:3,title:"1.5ClassLoader 中的两个方法【应用】",slug:"_1-5classloader-中的两个方法【应用】",link:"#_1-5classloader-中的两个方法【应用】",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",pathLocale:"/",extraFields:['java\n  public class ClassLoaderDemo1 {\n      public static void main(String[] args) {\n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n\n          //获取系统类加载器的父加载器 --- 平台类加载器\n          ClassLoader classLoader1 = systemClassLoader.getParent();\n\n          //获取平台类加载器的父加载器 --- 启动类加载器\n          ClassLoader classLoader2 = classLoader1.getParent();\n\n          System.out.println("系统类加载器" + systemClassLoader);\n          System.out.println("平台类加载器" + classLoader1);\n          System.out.println("启动类加载器" + classLoader2);\n\n      }\n  }','java\n  public class ClassLoaderDemo2 {\n      public static void main(String[] args) throws IOException {\n          //static ClassLoader getSystemClassLoader() 获取系统类加载器\n          //InputStream getResourceAsStream(String name)  加载某一个资源文件\n\n          //获取系统类加载器\n          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n\n          //利用加载器去加载一个指定的文件\n          //参数：文件的路径（放在src的根目录下，默认去那里加载）\n          //返回值：字节流。\n          InputStream is = systemClassLoader.getResourceAsStream("prop.properties");\n\n          Properties prop = new Properties();\n          prop.load(is);\n\n          System.out.println(prop);\n\n          is.close();\n      }\n  }']},{title:"xml",headers:[{level:2,title:"1.xml",slug:"_1-xml",link:"#_1-xml",children:[{level:3,title:"1.1概述【理解】",slug:"_1-1概述【理解】",link:"#_1-1概述【理解】",children:[]},{level:3,title:"1.2标签的规则【应用】",slug:"_1-2标签的规则【应用】",link:"#_1-2标签的规则【应用】",children:[]},{level:3,title:"1.3语法规则【应用】",slug:"_1-3语法规则【应用】",link:"#_1-3语法规则【应用】",children:[]},{level:3,title:"1.4xml解析【应用】",slug:"_1-4xml解析【应用】",link:"#_1-4xml解析【应用】",children:[]},{level:3,title:"1.5DTD约束【理解】",slug:"_1-5dtd约束【理解】",link:"#_1-5dtd约束【理解】",children:[]},{level:3,title:"1.6schema约束【理解】",slug:"_1-6schema约束【理解】",link:"#_1-6schema约束【理解】",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/xml.html",pathLocale:"/",extraFields:["java\n  <student>","java\n  <student> </student>\n  前边的是开始标签，后边的是结束标签","java\n  <address/>",'java\n  <student id="1"> </student>','java\n  这是正确的: <student id="1"> <name>张三</name> </student>\n  这是错误的: <student id="1"><name>张三</student></name>',"java\n    &lt; < 小于\n    &gt; > 大于\n    &amp; & 和号\n    &apos; ' 单引号\n    &quot; \" 引号",'xml\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n          <info>学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息</info>\n          <message> <![CDATA[内容 <<<<<< >>>>>> ]]]></message>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>','java\n  <?xml version="1.0" encoding="UTF-8" ?>\n  \x3c!--注释的内容--\x3e\n  \x3c!--本xml文件用来描述多个学生信息--\x3e\n  <students>\n\n      \x3c!--第一个学生信息--\x3e\n      <student id="1">\n          <name>张三</name>\n          <age>23</age>\n      </student>\n\n      \x3c!--第二个学生信息--\x3e\n      <student id="2">\n          <name>李四</name>\n          <age>24</age>\n      </student>\n\n  </students>\n\n  // 上边是已经准备好的student.xml文件\n  public class Student {\n      private String id;\n      private String name;\n      private int age;\n\n      public Student() {\n      }\n\n      public Student(String id, String name, int age) {\n          this.id = id;\n          this.name = name;\n          this.age = age;\n      }\n\n      public String getId() {\n          return id;\n      }\n\n      public void setId(String id) {\n          this.id = id;\n      }\n\n      public String getName() {\n          return name;\n      }\n\n      public void setName(String name) {\n          this.name = name;\n      }\n\n      public int getAge() {\n          return age;\n      }\n\n      public void setAge(int age) {\n          this.age = age;\n      }\n\n      @Override\n      public String toString() {\n          return "Student{" +\n                  "id=\'" + id + \'\\\'\' +\n                  ", name=\'" + name + \'\\\'\' +\n                  ", age=" + age +\n                  \'}\';\n      }\n  }\n\n  /**\n   * 利用dom4j解析xml文件\n   */\n  public class XmlParse {\n      public static void main(String[] args) throws DocumentException {\n          //1.获取一个解析器对象\n          SAXReader saxReader = new SAXReader();\n          //2.利用解析器把xml文件加载到内存中,并返回一个文档对象\n          Document document = saxReader.read(new File("myxml\\\\xml\\\\student.xml"));\n          //3.获取到根标签\n          Element rootElement = document.getRootElement();\n          //4.通过根标签来获取student标签\n          //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.\n          //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回\n          //List list = rootElement.elements();\n          List<Element> studentElements = rootElement.elements("student");\n          //System.out.println(list.size());\n\n          //用来装学生对象\n          ArrayList<Student> list = new ArrayList<>();\n\n          //5.遍历集合,得到每一个student标签\n          for (Element element : studentElements) {\n              //element依次表示每一个student标签\n    \n              //获取id这个属性\n              Attribute attribute = element.attribute("id");\n              //获取id的属性值\n              String id = attribute.getValue();\n\n              //获取name标签\n              //element("标签名"):获取调用者指定的子标签\n              Element nameElement = element.element("name");\n              //获取这个标签的标签体内容\n              String name = nameElement.getText();\n\n              //获取age标签\n              Element ageElement = element.element("age");\n              //获取age标签的标签体内容\n              String age = ageElement.getText();\n\n  //            System.out.println(id);\n  //            System.out.println(name);\n  //            System.out.println(age);\n\n              Student s = new Student(id,name,Integer.parseInt(age));\n              list.add(s);\n          }\n          //遍历操作\n          for (Student student : list) {\n              System.out.println(student);\n          }\n      }\n  }',"java\n    <!ELEMENT persons (person)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>","",'xml\n      // 这是persondtd.dtd文件中的内容,已经提前写好\n      <!ELEMENT persons (person)>\n      <!ELEMENT person (name,age)>\n      <!ELEMENT name (#PCDATA)>\n      <!ELEMENT age (#PCDATA)>\n\n      // 在person1.xml文件中引入persondtd.dtd约束\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>','xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons [\n              <!ELEMENT persons (person)>\n              <!ELEMENT person (name,age)>\n              <!ELEMENT name (#PCDATA)>\n              <!ELEMENT age (#PCDATA)>\n              ]>\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>','xml\n      <?xml version="1.0" encoding="UTF-8" ?>\n      <!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL">\n\n      <persons>\n          <person>\n              <name>张三</name>\n              <age>23</age>\n          </person>\n\n      </persons>','java\n    <!ELEMENT persons (person+)>\n    <!ELEMENT person (name,age)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ATTLIST person id CDATA #REQUIRED>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE persons SYSTEM \'persondtd.dtd\'>\n\n    <persons>\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n        <person id = "002">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​','### 1.6schema约束【理解】\n\n+ schema和dtd的区别\n\n  1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd\n  2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）\n  3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型\n  4. schema 语法更加的复杂\n\n  ![04_schema约束介绍](.\\img\\04_schema约束介绍.png)\n\n+ 编写schema约束\n\n  + 步骤\n\n    1，创建一个文件，这个文件的后缀名为.xsd。\n    2，定义文档声明\n    3，schema文件的根标签为： `<schema>`\n    4，在`<schema>`中定义属性：\n    ​\txmlns=http://www.w3.org/2001/XMLSchema\n    5，在`<schema>`中定义属性 ：\n    ​\ttargetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。\n    6，在`<schema>`中定义属性 ：\n    ​\t`elementFormDefault="qualified“`，表示当前schema文件是一个质量良好的文件。\n    7，通过element定义元素\n    8，判断当前元素是简单元素还是复杂元素\n\n    ![05_schema约束编写](.\\img\\05_schema约束编写.png)\n\n  + 代码实现','+ 引入schema约束\n\n  + 步骤\n\n    1，在根标签上定义属性xmlns="http://www.w3.org/2001/XMLSchema-instance"\n    2，通过xmlns引入约束文件的名称空间\n    3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间\n    ​\t格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi\n    4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径\n    ​\t格式为：xsi:schemaLocation = "名称空间url 文件路径“\n\n  + 代码实现',"",'java\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <schema\n        xmlns="http://www.w3.org/2001/XMLSchema"\n        targetNamespace="http://www.itheima.cn/javase"\n        elementFormDefault="qualified"\n    >\n\n        \x3c!--定义persons复杂元素--\x3e\n        <element name="persons">\n            <complexType>\n                <sequence>\n                    \x3c!--定义person复杂元素--\x3e\n                    <element name = "person">\n                        <complexType>\n                            <sequence>\n                                \x3c!--定义name和age简单元素--\x3e\n                                <element name = "name" type = "string"></element>\n                                <element name = "age" type = "string"></element>\n                            </sequence>\n                            \n                            \x3c!--定义属性，required( 必须的)/optional( 可选的)--\x3e\n                            <attribute name="id" type="string" use="required"></attribute>\n                        </complexType>\n                        \n                    </element>\n                </sequence>\n            </complexType>\n        </element>\n        \n    </schema>\n\n    <?xml version="1.0" encoding="UTF-8" ?>\n    <persons\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xmlns="http://www.itheima.cn/javase"\n        xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"\n    >\n        <person id="001">\n            <name>张三</name>\n            <age>23</age>\n        </person>\n\n    </persons>\n    ​',""]},{title:"单元测试Junit",headers:[{level:2,title:"1.1 什么是单元测试？（掌握）",slug:"_1-1-什么是单元测试-掌握",link:"#_1-1-什么是单元测试-掌握",children:[]},{level:2,title:"1.2 Junit的特点？（掌握）",slug:"_1-2-junit的特点-掌握",link:"#_1-2-junit的特点-掌握",children:[]},{level:2,title:"1.3 基本用法：（掌握）",slug:"_1-3-基本用法-掌握",link:"#_1-3-基本用法-掌握",children:[{level:3,title:"手动导包（掌握）",slug:"手动导包-掌握",link:"#手动导包-掌握",children:[]},{level:3,title:"运行测试代码（掌握）",slug:"运行测试代码-掌握",link:"#运行测试代码-掌握",children:[]},{level:3,title:"Junit正确的打开方式（正确的使用方式）（掌握）",slug:"junit正确的打开方式-正确的使用方式-掌握",link:"#junit正确的打开方式-正确的使用方式-掌握",children:[]},{level:3,title:"正确的使用方式：（掌握）",slug:"正确的使用方式-掌握",link:"#正确的使用方式-掌握",children:[]},{level:3,title:"实际开发中单元测试的使用方式（掌握）",slug:"实际开发中单元测试的使用方式-掌握",link:"#实际开发中单元测试的使用方式-掌握",children:[]},{level:3,title:"扩展点：",slug:"扩展点",link:"#扩展点",children:[]}]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",pathLocale:"/",extraFields:["java\n//真正用来测试的类\n//测试用例（测试类）\npublic class JunitTest {\n\n    //在这个类里面再写无参无返回值的非静态方法\n    //在方法中调用想要测试的方法\n\n    @Test\n    public void method2Test(){\n        //调用要测试的方法\n        JunitDemo1 jd = new JunitDemo1();\n        jd.method2(10);\n    }\n}",'java\npublic class JunitDemo3 {\n    //在实际开发中，真正完整的单元测试该怎么写？\n    //前提：\n    //以后在工作的时候，测试代码不能污染原数据。（修改，篡改）\n    //1.利用Before去对数据做一个初始化的动作\n    //2.利用Test真正的去测试方法\n    //3.利用After去还原数据\n    \n    //需求：测试File类中的delete方法是否书写正确？？？\n    @Before\n    public void beforemethod() throws IOException {\n        //先备份\n        File src = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n        File dest = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n    }\n\n    //作为一个标准的测试人员，运行完单元测试之后，不能污染原数据\n    //需要达到下面两个要求：\n    //1.得到结果\n    //2.a.txt还在而且其他的备份文件消失\n    @Test\n    public void method(){\n        File file = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n        boolean delete = file.delete();\n\n        //检查a.txt是否存在\n        boolean exists = file.exists();\n\n        //只有同时满足了下面所有的断言，才表示delete方法编写正确\n        Assert.assertEquals("delete方法出错了",delete,true);\n        Assert.assertEquals("delete方法出错了",exists,false);\n    }\n\n\n    @After\n    public void aftermethod() throws IOException {\n        //还要对a.txt做一个还原\n        File src = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\copy.txt");\n        File dest = new File("C:\\\\Users\\\\moon\\\\Desktop\\\\a.txt");\n\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        int b;\n        while((b = fis.read()) != -1){\n            fos.write(b);\n        }\n        fos.close();\n        fis.close();\n\n        //备份数据要删除\n        src.delete();\n\n    }\n}',"java\n准备数据\n1.创建Properties的对象\n2.put数据到集合当中\n//只不过在下面的方法中，我们也需要用到Properties的对象，所以写完之后要挪到成员位置","java\n调用store方法，保存数据到本地文件\n\n断言1：\n\t判断当前文件是否存在\n断言2：\n\t文件的大小一定是大于0\n断言3：\n\t再次读取文件中的数据，判断是否跟集合中一致\n\n结论：\n\t如果所有的断言都通过了，表示store方法是正确的","java\n把本地文件给删除",'java\nFile file = new File("aweihaoshuai.txt");\nfile.createNewFile();\n//此时是把aweihaoshuai.txt这个文件新建到模块中了。']},{title:"注解",headers:[{level:2,title:"1.1 注释和注解的区别？（掌握）",slug:"_1-1-注释和注解的区别-掌握",link:"#_1-1-注释和注解的区别-掌握",children:[]},{level:2,title:"1.3 Java中已经存在的注解（掌握）",slug:"_1-3-java中已经存在的注解-掌握",link:"#_1-3-java中已经存在的注解-掌握",children:[]},{level:2,title:"1.4 自定义注解（了解）",slug:"_1-4-自定义注解-了解",link:"#_1-4-自定义注解-了解",children:[]},{level:2,title:"1.5 特殊属性（掌握）",slug:"_1-5-特殊属性-掌握",link:"#_1-5-特殊属性-掌握",children:[]},{level:2,title:"1.6 元注解（了解）",slug:"_1-6-元注解-了解",link:"#_1-6-元注解-了解",children:[]},{level:2,title:"1.7 模拟JUnit自带的@Test注解（了解）",slug:"_1-7-模拟junit自带的-test注解-了解",link:"#_1-7-模拟junit自带的-test注解-了解",children:[]},{level:2,title:"1.8 注解小结：",slug:"_1-8-注解小结",link:"#_1-8-注解小结",children:[]}],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3.html",pathLocale:"/",extraFields:['java\n//注解的定义\npublic @interface Anno2 {\n    public String value();\n\n    public int age() default 23;\n}\n\n//注解的使用\n@Anno2("123")\npublic class AnnoDemo2 {\n\n    @Anno2("123")\n    public void method(){\n\n    }\n}','java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyTest {\n}\n\npublic class MyTestMethod {\n\n    @MyTest\n    public void method1(){\n        System.out.println("method1");\n    }\n\n    public void method2(){\n        System.out.println("method2");\n    }\n\n    @MyTest\n    public void method3(){\n        System.out.println("method3");\n    }\n}\n\npublic class MyTestDemo {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        //1,获取class对象\n        Class clazz = Class.forName("com.itheima.test2.MyTestMethod");\n\n        //获取对象\n        Object o = clazz.newInstance();\n\n        //2.获取所有方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            //method依次表示类里面的每一个方法\n            method.setAccessible(true);\n            //判断当前方法有没有MyTest注解\n            if(method.isAnnotationPresent(MyTest.class)){\n                method.invoke(o);\n            }\n        }\n    }\n}']},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[]},{title:"Posts",headers:[],path:"/posts/",pathLocale:"/",extraFields:[]},{title:"Linux",headers:[],path:"/posts/linux/",pathLocale:"/",extraFields:[]},{title:"Idea",headers:[],path:"/posts/idea/",pathLocale:"/",extraFields:[]},{title:"Mysql",headers:[],path:"/posts/mysql/",pathLocale:"/",extraFields:[]},{title:"Network",headers:[],path:"/posts/network/",pathLocale:"/",extraFields:[]},{title:"Redis",headers:[],path:"/posts/redis/",pathLocale:"/",extraFields:[]},{title:"Shell",headers:[],path:"/posts/shell/",pathLocale:"/",extraFields:[]},{title:"Windows",headers:[],path:"/posts/windows/",pathLocale:"/",extraFields:[]},{title:"Basic",headers:[],path:"/posts/java/basic/",pathLocale:"/",extraFields:[]},{title:"Java",headers:[],path:"/posts/java/",pathLocale:"/",extraFields:[]},{title:"Bug",headers:[],path:"/posts/java/bug/",pathLocale:"/",extraFields:[]},{title:"Dependence",headers:[],path:"/posts/java/dependence/",pathLocale:"/",extraFields:[]},{title:"Netty",headers:[],path:"/posts/java/netty/",pathLocale:"/",extraFields:[]},{title:"Spring",headers:[],path:"/posts/java/spring/",pathLocale:"/",extraFields:[]},{title:"Springboot",headers:[],path:"/posts/java/springboot/",pathLocale:"/",extraFields:[]},{title:"Web",headers:[],path:"/posts/java/web/",pathLocale:"/",extraFields:[]},{title:"Django",headers:[],path:"/posts/python/django/",pathLocale:"/",extraFields:[]},{title:"Python",headers:[],path:"/posts/python/",pathLocale:"/",extraFields:[]},{title:"01 Java入门",headers:[],path:"/posts/java/basic/01-Java%E5%85%A5%E9%97%A8/",pathLocale:"/",extraFields:[]},{title:"02 Java基础概念",headers:[],path:"/posts/java/basic/02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/",pathLocale:"/",extraFields:[]},{title:"03 Java运算符",headers:[],path:"/posts/java/basic/03-Java%E8%BF%90%E7%AE%97%E7%AC%A6/",pathLocale:"/",extraFields:[]},{title:"04 判断和循环",headers:[],path:"/posts/java/basic/04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/",pathLocale:"/",extraFields:[]},{title:"05 循环高级和数组",headers:[],path:"/posts/java/basic/05-%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7%E5%92%8C%E6%95%B0%E7%BB%84/",pathLocale:"/",extraFields:[]},{title:"06 方法",headers:[],path:"/posts/java/basic/06-%E6%96%B9%E6%B3%95/",pathLocale:"/",extraFields:[]},{title:"07 综合练习",headers:[],path:"/posts/java/basic/07-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/",pathLocale:"/",extraFields:[]},{title:"08 面向对象",headers:[],path:"/posts/java/basic/08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/",pathLocale:"/",extraFields:[]},{title:"09 面向对象综合训练",headers:[],path:"/posts/java/basic/09-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/",pathLocale:"/",extraFields:[]},{title:"10 字符串",headers:[],path:"/posts/java/basic/10-%E5%AD%97%E7%AC%A6%E4%B8%B2/",pathLocale:"/",extraFields:[]},{title:"11 集合 学生管理系统",headers:[],path:"/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/",pathLocale:"/",extraFields:[]},{title:"13 面向对象进阶（static 继承）",headers:[],path:"/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"14 面向对象进阶（多态 包 Final 权限修饰符 代码块）",headers:[],path:"/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"15 面向对象进阶（抽象类 接口 内部类）",headers:[],path:"/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"16 面向对象综合练习（上）",headers:[],path:"/posts/java/basic/16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"17 面向对象综合练习（下）",headers:[],path:"/posts/java/basic/17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"18 API（常见 API，对象克隆）",headers:[],path:"/posts/java/basic/18-API%EF%BC%88%E5%B8%B8%E8%A7%81API%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"19 API（正则表达式）",headers:[],path:"/posts/java/basic/19-API%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"20 API（时间，包装类，练习）",headers:[],path:"/posts/java/basic/20-API%EF%BC%88%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"21 API（算法，lambda，练习）",headers:[],path:"/posts/java/basic/21-API%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%8Clambda%EF%BC%8C%E7%BB%83%E4%B9%A0%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"22 集合（ List集合）",headers:[],path:"/posts/java/basic/22-%E9%9B%86%E5%90%88%EF%BC%88List%E9%9B%86%E5%90%88%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"23 集合（泛型 Set 数据结构）",headers:[],path:"/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"24 集合（ Map 可变参数 集合工具类）",headers:[],path:"/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"25 阶段项目（综合练习 Doudizhu游戏）",headers:[],path:"/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"26 集合（ Stream流 方法引用）",headers:[],path:"/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"27 IO(异常 File 综合案例）",headers:[],path:"/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"28 IO（字节流 字符流）",headers:[],path:"/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"29 IO（其他流）",headers:[],path:"/posts/java/basic/29-IO%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"30 多线程",headers:[],path:"/posts/java/basic/30-%E5%A4%9A%E7%BA%BF%E7%A8%8B/",pathLocale:"/",extraFields:[]},{title:"31 多线程 Juc",headers:[],path:"/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/",pathLocale:"/",extraFields:[]},{title:"32 网络编程",headers:[],path:"/posts/java/basic/32-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",pathLocale:"/",extraFields:[]},{title:"33 基础加强（反射，动态代理）",headers:[],path:"/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"Pages",headers:[],path:"/pages/",pathLocale:"/",extraFields:[]},{title:"01 Log日志",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/01-log%E6%97%A5%E5%BF%97/",pathLocale:"/",extraFields:[]},{title:"34 基础加强（日志，类加载器，单元测试，xml，注解）",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/",pathLocale:"/",extraFields:[]},{title:"02 类加载器",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",pathLocale:"/",extraFields:[]},{title:"03 Xml",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/03-xml/",pathLocale:"/",extraFields:[]},{title:"04 单元测试",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/04-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",pathLocale:"/",extraFields:[]},{title:"05 注解",headers:[],path:"/posts/java/basic/34-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8Cxml%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%89/05-%E6%B3%A8%E8%A7%A3/",pathLocale:"/",extraFields:[]},{title:"分类",headers:[],path:"/category/",pathLocale:"/",extraFields:[]},{title:"使用指南 分类",headers:[],path:"/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",pathLocale:"/",extraFields:[]},{title:"linux 分类",headers:[],path:"/category/linux/",pathLocale:"/",extraFields:[]},{title:"idea 分类",headers:[],path:"/category/idea/",pathLocale:"/",extraFields:[]},{title:"mysql 分类",headers:[],path:"/category/mysql/",pathLocale:"/",extraFields:[]},{title:"java 分类",headers:[],path:"/category/java/",pathLocale:"/",extraFields:[]},{title:"network 分类",headers:[],path:"/category/network/",pathLocale:"/",extraFields:[]},{title:"redis 分类",headers:[],path:"/category/redis/",pathLocale:"/",extraFields:[]},{title:"windows 分类",headers:[],path:"/category/windows/",pathLocale:"/",extraFields:[]},{title:"dependence 分类",headers:[],path:"/category/dependence/",pathLocale:"/",extraFields:[]},{title:"spring 分类",headers:[],path:"/category/spring/",pathLocale:"/",extraFields:[]},{title:"python 分类",headers:[],path:"/category/python/",pathLocale:"/",extraFields:[]},{title:"Java 分类",headers:[],path:"/category/java/",pathLocale:"/",extraFields:[]},{title:"框架 分类",headers:[],path:"/category/%E6%A1%86%E6%9E%B6/",pathLocale:"/",extraFields:[]},{title:"Spring 分类",headers:[],path:"/category/spring/",pathLocale:"/",extraFields:[]},{title:"Spring综合 分类",headers:[],path:"/category/spring%E7%BB%BC%E5%90%88/",pathLocale:"/",extraFields:[]},{title:"Spring核心 分类",headers:[],path:"/category/spring%E6%A0%B8%E5%BF%83/",pathLocale:"/",extraFields:[]},{title:"Spring数据 分类",headers:[],path:"/category/spring%E6%95%B0%E6%8D%AE/",pathLocale:"/",extraFields:[]},{title:"SpringWeb 分类",headers:[],path:"/category/springweb/",pathLocale:"/",extraFields:[]},{title:"SpringIO 分类",headers:[],path:"/category/springio/",pathLocale:"/",extraFields:[]},{title:"Spring集成 分类",headers:[],path:"/category/spring%E9%9B%86%E6%88%90/",pathLocale:"/",extraFields:[]},{title:"Spring安全 分类",headers:[],path:"/category/spring%E5%AE%89%E5%85%A8/",pathLocale:"/",extraFields:[]},{title:"Spring其他 分类",headers:[],path:"/category/spring%E5%85%B6%E4%BB%96/",pathLocale:"/",extraFields:[]},{title:"标签",headers:[],path:"/tag/",pathLocale:"/",extraFields:[]},{title:"标签: 页面配置",headers:[],path:"/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",pathLocale:"/",extraFields:[]},{title:"标签: 使用指南",headers:[],path:"/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",pathLocale:"/",extraFields:[]},{title:"标签: linux",headers:[],path:"/tag/linux/",pathLocale:"/",extraFields:[]},{title:"标签: tomcat",headers:[],path:"/tag/tomcat/",pathLocale:"/",extraFields:[]},{title:"标签: shell",headers:[],path:"/tag/shell/",pathLocale:"/",extraFields:[]},{title:"标签: sql",headers:[],path:"/tag/sql/",pathLocale:"/",extraFields:[]},{title:"标签: bug",headers:[],path:"/tag/bug/",pathLocale:"/",extraFields:[]},{title:"标签: internet",headers:[],path:"/tag/internet/",pathLocale:"/",extraFields:[]},{title:"标签: java",headers:[],path:"/tag/java/",pathLocale:"/",extraFields:[]},{title:"标签: spring",headers:[],path:"/tag/spring/",pathLocale:"/",extraFields:[]},{title:"标签: springboot",headers:[],path:"/tag/springboot/",pathLocale:"/",extraFields:[]},{title:"标签: redis",headers:[],path:"/tag/redis/",pathLocale:"/",extraFields:[]},{title:"标签: script",headers:[],path:"/tag/script/",pathLocale:"/",extraFields:[]},{title:"标签: java-basic",headers:[],path:"/tag/java-basic/",pathLocale:"/",extraFields:[]},{title:"标签: logback",headers:[],path:"/tag/logback/",pathLocale:"/",extraFields:[]},{title:"标签: maven",headers:[],path:"/tag/maven/",pathLocale:"/",extraFields:[]},{title:"标签: mybatis",headers:[],path:"/tag/mybatis/",pathLocale:"/",extraFields:[]},{title:"标签: netty",headers:[],path:"/tag/netty/",pathLocale:"/",extraFields:[]},{title:"标签: nio",headers:[],path:"/tag/nio/",pathLocale:"/",extraFields:[]},{title:"标签: javaweb",headers:[],path:"/tag/javaweb/",pathLocale:"/",extraFields:[]},{title:"标签: http",headers:[],path:"/tag/http/",pathLocale:"/",extraFields:[]},{title:"标签: servlet",headers:[],path:"/tag/servlet/",pathLocale:"/",extraFields:[]},{title:"标签: Request",headers:[],path:"/tag/request/",pathLocale:"/",extraFields:[]},{title:"标签: Response",headers:[],path:"/tag/response/",pathLocale:"/",extraFields:[]},{title:"标签: jdbc",headers:[],path:"/tag/jdbc/",pathLocale:"/",extraFields:[]},{title:"标签: djgango",headers:[],path:"/tag/djgango/",pathLocale:"/",extraFields:[]},{title:"标签: Java",headers:[],path:"/tag/java/",pathLocale:"/",extraFields:[]},{title:"标签: 框架",headers:[],path:"/tag/%E6%A1%86%E6%9E%B6/",pathLocale:"/",extraFields:[]},{title:"标签: Spring",headers:[],path:"/tag/spring/",pathLocale:"/",extraFields:[]},{title:"标签: SpringBoot",headers:[],path:"/tag/springboot/",pathLocale:"/",extraFields:[]},{title:"标签: 面试",headers:[],path:"/tag/%E9%9D%A2%E8%AF%95/",pathLocale:"/",extraFields:[]},{title:"标签: Bean",headers:[],path:"/tag/bean/",pathLocale:"/",extraFields:[]},{title:"标签: BeanDefinition",headers:[],path:"/tag/beandefinition/",pathLocale:"/",extraFields:[]},{title:"标签: IOC",headers:[],path:"/tag/ioc/",pathLocale:"/",extraFields:[]},{title:"标签: 依赖查找",headers:[],path:"/tag/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/",pathLocale:"/",extraFields:[]},{title:"标签: 依赖注入",headers:[],path:"/tag/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/",pathLocale:"/",extraFields:[]},{title:"标签: AOP",headers:[],path:"/tag/aop/",pathLocale:"/",extraFields:[]},{title:"标签: Resource",headers:[],path:"/tag/resource/",pathLocale:"/",extraFields:[]},{title:"标签: 数据绑定",headers:[],path:"/tag/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/",pathLocale:"/",extraFields:[]},{title:"标签: 数据库",headers:[],path:"/tag/%E6%95%B0%E6%8D%AE%E5%BA%93/",pathLocale:"/",extraFields:[]},{title:"标签: DataSource",headers:[],path:"/tag/datasource/",pathLocale:"/",extraFields:[]},{title:"标签: JDBC",headers:[],path:"/tag/jdbc/",pathLocale:"/",extraFields:[]},{title:"标签: JdbcTemplate",headers:[],path:"/tag/jdbctemplate/",pathLocale:"/",extraFields:[]},{title:"标签: 事务",headers:[],path:"/tag/%E4%BA%8B%E5%8A%A1/",pathLocale:"/",extraFields:[]},{title:"标签: JPA",headers:[],path:"/tag/jpa/",pathLocale:"/",extraFields:[]},{title:"标签: MyBatis",headers:[],path:"/tag/mybatis/",pathLocale:"/",extraFields:[]},{title:"标签: PageHelper",headers:[],path:"/tag/pagehelper/",pathLocale:"/",extraFields:[]},{title:"标签: Mapper",headers:[],path:"/tag/mapper/",pathLocale:"/",extraFields:[]},{title:"标签: Redis",headers:[],path:"/tag/redis/",pathLocale:"/",extraFields:[]},{title:"标签: MongoDB",headers:[],path:"/tag/mongodb/",pathLocale:"/",extraFields:[]},{title:"标签: Elasticsearch",headers:[],path:"/tag/elasticsearch/",pathLocale:"/",extraFields:[]},{title:"标签: Web",headers:[],path:"/tag/web/",pathLocale:"/",extraFields:[]},{title:"标签: Controller",headers:[],path:"/tag/controller/",pathLocale:"/",extraFields:[]},{title:"标签: DispatcherServlet",headers:[],path:"/tag/dispatcherservlet/",pathLocale:"/",extraFields:[]},{title:"标签: Filter",headers:[],path:"/tag/filter/",pathLocale:"/",extraFields:[]},{title:"标签: CORS",headers:[],path:"/tag/cors/",pathLocale:"/",extraFields:[]},{title:"标签: View",headers:[],path:"/tag/view/",pathLocale:"/",extraFields:[]},{title:"标签: 异步",headers:[],path:"/tag/%E5%BC%82%E6%AD%A5/",pathLocale:"/",extraFields:[]},{title:"标签: JSON",headers:[],path:"/tag/json/",pathLocale:"/",extraFields:[]},{title:"标签: 邮件",headers:[],path:"/tag/%E9%82%AE%E4%BB%B6/",pathLocale:"/",extraFields:[]},{title:"标签: IO",headers:[],path:"/tag/io/",pathLocale:"/",extraFields:[]},{title:"标签: 集成",headers:[],path:"/tag/%E9%9B%86%E6%88%90/",pathLocale:"/",extraFields:[]},{title:"标签: 缓存",headers:[],path:"/tag/%E7%BC%93%E5%AD%98/",pathLocale:"/",extraFields:[]},{title:"标签: 调度器",headers:[],path:"/tag/%E8%B0%83%E5%BA%A6%E5%99%A8/",pathLocale:"/",extraFields:[]},{title:"标签: Dubbo",headers:[],path:"/tag/dubbo/",pathLocale:"/",extraFields:[]},{title:"标签: 安全",headers:[],path:"/tag/%E5%AE%89%E5%85%A8/",pathLocale:"/",extraFields:[]},{title:"文章",headers:[],path:"/article/",pathLocale:"/",extraFields:[]},{title:"星标",headers:[],path:"/star/",pathLocale:"/",extraFields:[]},{title:"时间轴",headers:[],path:"/timeline/",pathLocale:"/",extraFields:[]}]},58761:(n,e,t)=>{t.d(e,{U:()=>i});const i=JSON.parse('{"base":"/blog/","lang":"zh-CN","title":"coder-xuyong","description":"以 vuepress-theme-hope 为模板的博客","head":[["script",{},"\\n      // console.log(666)\\n      "],["link",{"rel":"icon","href":"logo.png"}]],"locales":{}}')},26653:(n,e,t)=>{t.d(e,{K:()=>i});const i=JSON.parse('{"encrypt":{"config":{"/demo/encrypt.html":["$2a$10$X0.kXBHMFyF7e/tZA/Xef.NrL1Bi33DwCuAgTF5MaLNdvv3tyjyPS"]}},"author":{"name":"xuyong","url":"https://github.com/coder-xuyong"},"logo":"/logo.svg","repo":"coder-xuyong/blog","docsDir":"src","focus":false,"pure":false,"print":false,"footer":"我虽无意逐鹿 却知苍生苦楚","displayFooter":true,"navbarLayout":{"start":["Brand"],"end":["Links","Repo","Outlook","Search"]},"blog":{"description":"重生之我在提瓦特大陆当牛做马","intro":"/intro.html","medias":{"Baidu":"https://www.baidu.com","BiliBili":"https://www.bilibili.com","GitHub":"https://github.com","Overflow":{"icon":"https://stackoverflow.co/favicon.ico","link":"https://stackoverflow.co"},"Tongyi":{"icon":"https://img.alicdn.com/imgextra/i1/O1CN01asLYeX1WhbsyEZn5u_!!6000000002820-55-tps-56-56.svg","link":"https://tongyi.aliyun.com"},"Vuepress":{"icon":"https://theme-hope-assets.vuejs.press/logo.svg","link":"https://vuepress.vuejs.org/zh/"},"Yuanshen":{"icon":"https://ys.mihoyo.com/main/favicon.ico","link":"https://ys.mihoyo.com/main/"},"fontawesome":{"icon":"https://fontawesome.com/favicon.ico","link":"https://fontawesome.com/search?o=r&m=free"},"Doubao":{"icon":"https://img-s.msn.cn/tenant/amp/entityid/BB1qZI2R.img","link":"https://www.doubao.com/"},"ChatGPT":{"icon":"https://cdn.oaistatic.com/assets/favicon-o20kmmos.svg","link":"https://chatgpt.com/"}}},"locales":{"/":{"lang":"zh-CN","navbarLocales":{"langName":"简体中文","selectLangAriaLabel":"选择语言"},"metaLocales":{"author":"作者","date":"写作日期","origin":"原创","views":"访问量","category":"分类","tag":"标签","readingTime":"阅读时间","words":"字数","toc":"此页内容","prev":"上一页","next":"下一页","lastUpdated":"上次编辑于","contributors":"贡献者","editLink":"在 GitHub 上编辑此页","print":"打印"},"blogLocales":{"article":"文章","articleList":"文章列表","category":"分类","tag":"标签","timeline":"时间轴","timelineTitle":"昨日不在","all":"全部","intro":"个人介绍","star":"星标","empty":"$text 为空"},"paginationLocales":{"prev":"上一页","next":"下一页","navigate":"跳转到","action":"前往","errorText":"请输入 1 到 $page 之前的页码！"},"outlookLocales":{"themeColor":"主题色","darkmode":"外观","fullscreen":"全屏"},"encryptLocales":{"iconLabel":"文章已加密","placeholder":"输入密码","remember":"记住密码","errorHint":"请输入正确的密码"},"routeLocales":{"skipToContent":"跳至主要內容","notFoundTitle":"页面不存在","notFoundMsg":["这里什么也没有","我们是怎么来到这儿的？","这 是 四 零 四 !","看起来你访问了一个失效的链接"],"back":"返回上一页","home":"带我回家"},"navbar":["/",{"text":"java 基础","icon":"fa-brands fa-java","link":"/posts/java/basic/"},{"text":"spring","icon":"fa-solid fa-glasses","link":"/posts/java/spring/"},{"text":"框架","icon":"fa-solid fa-book","prefix":"/posts/java/","children":[{"text":"netty","prefix":"netty/","children":["Netty01-nio","Netty02-入门","Netty03-进阶","Netty04-优化与源码"]},{"text":"spring","prefix":"spring/","children":["spring"]},{"text":"spring","icon":"fa-solid fa-glasses","link":"/posts/java/spring/"}]},{"text":"V2 文档","icon":"book","link":"https://theme-hope.vuejs.press/zh/"}],"sidebar":{"/":["","intro",{"text":"文章","icon":"book","prefix":"posts/","children":"structure"}]}}}}')},74923:(n,e,t)=>{},38123:(n,e,t)=>{t.d(e,{v:()=>i});const i={"/posts/":["markdown",{text:"Idea",prefix:"idea/",collapsible:!0,children:["idea"]},{text:"Java",prefix:"java/",collapsible:!0,children:[{text:"Basic",prefix:"basic/",collapsible:!0,children:[{text:"01 Java入门",prefix:"01-Java入门/",collapsible:!0,children:["01-Java基础语法"]},{text:"02 Java基础概念",prefix:"02-Java基础概念/",collapsible:!0,children:["02-Java基础语法"]},{text:"03 Java运算符",prefix:"03-Java运算符/",collapsible:!0,children:["03笔记"]},{text:"04 判断和循环",prefix:"04-判断和循环/",collapsible:!0,children:["day04-流程控制语句"]},{text:"05 循环高级和数组",prefix:"05-循环高级和数组/",collapsible:!0,children:["循环高级","数组"]},{text:"06 方法",prefix:"06-方法/",collapsible:!0,children:["方法"]},{text:"07 综合练习",prefix:"07-综合练习/",collapsible:!0,children:["综合练习"]},{text:"08 面向对象",prefix:"08-面向对象/",collapsible:!0,children:["day08-面向对象"]},{text:"09 面向对象综合训练",prefix:"09-面向对象综合训练/",collapsible:!0,children:["扩展：键盘录入笔记","面向对象综合训练综合练习"]},{text:"10 字符串",prefix:"10-字符串/",collapsible:!0,children:["常用API"]},{text:"11 集合&学生管理系统",prefix:"11-集合_学生管理系统/",collapsible:!0,children:["/posts/java/basic/11-%E9%9B%86%E5%90%88_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/ArrayList_%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html"]},{text:"13 面向对象进阶（static&继承）",prefix:"13-面向对象进阶（static_继承）/",collapsible:!0,children:["/posts/java/basic/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88static_%E7%BB%A7%E6%89%BF%EF%BC%89/day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html"]},{text:"14 面向对象进阶（多态&包&final&权限修饰符&代码块）",prefix:"14-面向对象进阶（多态_包_final_权限修饰符_代码块）/",collapsible:!0,children:["/posts/java/basic/14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E5%A4%9A%E6%80%81_%E5%8C%85_final_%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89/day14%E7%AC%94%E8%AE%B0.html"]},{text:"15 面向对象进阶（抽象类&接口&内部类）",prefix:"15-面向对象进阶（抽象类_接口_内部类）/",collapsible:!0,children:["/posts/java/basic/15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/day15%E7%AC%94%E8%AE%B0.html"]},{text:"16 面向对象综合练习（上）",prefix:"16-面向对象综合练习（上）/",collapsible:!0,children:["day16-面向对象综合练习（上）"]},{text:"17 面向对象综合练习（下）",prefix:"17-面向对象综合练习（下）/",collapsible:!0,children:["day17-面向对象综合练习（下）"]},{text:"18 API（常见 API，对象克隆）",prefix:"18-API（常见API，对象克隆）/",collapsible:!0,children:["API"]},{text:"19 API（正则表达式）",prefix:"19-API（正则表达式）/",collapsible:!0,children:["正则表达式"]},{text:"20 API（时间，包装类，练习）",prefix:"20-API（时间，包装类，练习）/",collapsible:!0,children:["API"]},{text:"21 API（算法，lambda，练习）",prefix:"21-API（算法，lambda，练习）/",collapsible:!0,children:["算法"]},{text:"22 集合（ List集合）",prefix:"22-集合（List集合）/",collapsible:!0,children:["集合01"]},{text:"23 集合（泛型& Set&数据结构）",prefix:"23-集合（泛型_Set_数据结构）/",collapsible:!0,children:["/posts/java/basic/23-%E9%9B%86%E5%90%88%EF%BC%88%E6%B3%9B%E5%9E%8B_Set_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/%E9%9B%86%E5%90%8802.html"]},{text:"24 集合（ Map&可变参数&集合工具类）",prefix:"24-集合（Map_可变参数_集合工具类）/",collapsible:!0,children:["/posts/java/basic/24-%E9%9B%86%E5%90%88%EF%BC%88Map_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/%E9%9B%86%E5%90%8803.html"]},{text:"25 阶段项目（综合练习&doudizhu游戏）",prefix:"25-阶段项目（综合练习_doudizhu游戏）/",collapsible:!0,children:["/posts/java/basic/25-%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0_doudizhu%E6%B8%B8%E6%88%8F%EF%BC%89/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0.html"]},{text:"26 集合（ Stream流&方法引用）",prefix:"26-集合（Stream流_方法引用）/",collapsible:!0,children:["/posts/java/basic/26-%E9%9B%86%E5%90%88%EF%BC%88Stream%E6%B5%81_%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89/stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html"]},{text:"27 IO(异常& File&综合案例）",prefix:"27-IO(异常_File_综合案例）/",collapsible:!0,children:["/posts/java/basic/27-IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89/IO(%E5%BC%82%E5%B8%B8_File_%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html"]},{text:"28 IO（字节流&字符流）",prefix:"28-IO（字节流_字符流）/",collapsible:!0,children:["/posts/java/basic/28-IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81_%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89.html"]},{text:"29 IO（其他流）",prefix:"29-IO（其他流）/",collapsible:!0,children:["IO流（其他流）"]},{text:"30 多线程",prefix:"30-多线程/",collapsible:!0,children:["多线程01"]},{text:"31 多线程&juc",prefix:"31-多线程_juc/",collapsible:!0,children:["/posts/java/basic/31-%E5%A4%9A%E7%BA%BF%E7%A8%8B_juc/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html"]},{text:"32 网络编程",prefix:"32-网络编程/",collapsible:!0,children:["网络编程"]},{text:"33 基础加强（反射，动态代理）",prefix:"33-基础加强（反射，动态代理）/",collapsible:!0,children:["/posts/java/basic/33-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89/%E5%8F%8D%E5%B0%84_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"]},{text:"34 基础加强（日志，类加载器，单元测试，xml，注解）",prefix:"34-基础加强（日志，类加载器，单元测试，xml，注解）/",collapsible:!0,children:[{text:"01 Log日志",prefix:"01-log日志/",collapsible:!0,children:["log日志"]},{text:"02 类加载器",prefix:"02-类加载器/",collapsible:!0,children:["类加载器"]},{text:"03 Xml",prefix:"03-xml/",collapsible:!0,children:["xml"]},{text:"04 单元测试",prefix:"04-单元测试/",collapsible:!0,children:["单元测试"]},{text:"05 注解",prefix:"05-注解/",collapsible:!0,children:["注解"]}]},"ioStream","regularExpression","3.java-basic","4.collection","jottings","java8Stream","comparator","1.object-oriented-programming","multithreading","2.three-features"]},{text:"Bug",prefix:"bug/",collapsible:!0,children:["bug"]},{text:"Dependence",prefix:"dependence/",collapsible:!0,children:["docx4j","log","mybatis","netty","maven"]},{text:"Netty",prefix:"netty/",collapsible:!0,children:["Netty01-nio","Netty02-入门","Netty03-进阶","Netty04-优化与源码"]},{text:"Spring",prefix:"spring/",collapsible:!0,children:[{text:"10 Spring安全",prefix:"10-Spring安全/",collapsible:!0,children:["/pages/568352/"]},{text:"Spring IO",prefix:"04-SpringIO/",collapsible:!0,children:["/pages/92add2/","/pages/676725/","/pages/2586f1/"]},{text:"Spring Web",prefix:"03-SpringWeb/",collapsible:!0,children:["/pages/ad0516/","/pages/20287b/","/pages/251e31/","/pages/1d2954/","/pages/4a164d/","/pages/5d002f/","/pages/65351b/"]},{text:"Spring 其他",prefix:"99-Spring其他/",collapsible:!0,children:["/pages/752c6a/","/pages/bac2ce/","/pages/c013cc/"]},"spring",{text:"Spring 数据篇",prefix:"02-Spring数据/",collapsible:!0,children:["/pages/1b774c/","/pages/cf19fd/","/pages/128c54/","/pages/a03d7b/","/pages/88219e/","/pages/191cdb/","/pages/65e4a2/","/pages/db2a41/","/pages/fac14c/"]},{text:"Spring 核心",prefix:"01-Spring核心/",collapsible:!0,children:["/pages/68097d/","/pages/915530/","/pages/9a6f6b/","/pages/f61a1c/","/pages/a5f257/","/pages/8289f5/","/pages/4ab176/","/pages/55f315/","/pages/ad472e/","/pages/53aedb/","/pages/a1549f/","/pages/fe6aad/","/pages/267b4c/","/pages/6662dc/","/pages/1f743f/","/pages/cca414/","/pages/b5b8ad/","/pages/175cbd/","/pages/b6556f/","/pages/03d838/","/pages/950e4d/","/pages/0fb992/","/pages/cb598e/"]},{text:"Spring 综述",prefix:"00-Spring综合/",collapsible:!0,children:["/pages/9d3091/","/pages/db33b0/","/pages/dbf521/","/pages/430f53/"]},{text:"Spring 集成",prefix:"05-Spring集成/",collapsible:!0,children:["/pages/a311cb/","/pages/a187f0/","/pages/274fd7/"]},"spring面试题"]},{text:"Springboot",prefix:"springboot/",collapsible:!0,children:["workcondition"]},{text:"Web",prefix:"web/",collapsible:!0,children:["/posts/java/web/HTTP_Tomcat_Servlet.html","jdbc","/posts/java/web/Request_Response.html"]}]},{text:"Linux",prefix:"linux/",collapsible:!0,children:["linux","linuxWork"]},{text:"Mysql",prefix:"mysql/",collapsible:!0,children:["DDL","/posts/mysql/DML_DQL.html","mysql存储过程","mysql安装","mysql数据格式","mysqlBug","mysql约束","mysql自定义函数","mysql触发器"]},{text:"Network",prefix:"network/",collapsible:!0,children:["ftp","internet"]},{text:"Python",prefix:"python/",collapsible:!0,children:[{text:"Django",prefix:"django/",collapsible:!0,children:["djangoWork"]}]},{text:"Redis",prefix:"redis/",collapsible:!0,children:["redisBUG","redis 学习笔记之实战篇","redis 学习笔记之快速入门"]},{text:"Shell",prefix:"shell/",collapsible:!0,children:["shell","shellWork"]},{text:"Windows",prefix:"windows/",collapsible:!0,children:["workcondition"]}]}},32878:(n,e,t)=>{t.d(e,{P:()=>i});const i={Baidu:'<svg xmlns="http://www.w3.org/2000/svg" class="icon baidu-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#2319DC"/><path fill="#FFF" d="M320 528c65-14 56-92 54-109-3-26-34-72-76-68-52 4-60 81-60 81-7 35 17 110 82 96m121-131c36 0 65-41 65-92 0-52-29-93-65-93s-65 41-65 93c0 51 29 92 65 92m155 7c48 6 79-46 86-85 6-38-25-84-59-91-35-8-77 46-81 82-5 44 6 87 54 94m191 65c0-19-15-75-73-75-57 0-65 53-65 91 0 35 3 85 75 84 71-2 63-81 63-100m-73 163s-74-57-118-119c-59-92-142-55-170-8s-72 76-78 84-90 53-71 135c18 83 83 81 83 81s49 5 104-7c56-13 104 3 104 3s131 43 166-41c36-84-20-128-20-128"/><path fill="#2319DC" d="M453 552v56h-45s-46 3-61 54c-6 35 4 55 6 59s17 29 53 37h85V553zm-1 172h-34s-24-1-31-29c-4-12 0-26 2-31 2-6 10-19 26-23h37zm60-111v107s2 27 39 37h98V613h-42v108h-40s-13-2-16-12v-97z"/></svg>',BiliBili:'<svg xmlns="http://www.w3.org/2000/svg" class="icon bilibili-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#1296db"/><path fill="#fff" d="M745.363 177.725a47 47 0 0 1 0 66.3L702.5 286.85h44A141 141 0 0 1 887 427.512v281.25a141 141 0 0 1-141 140.626H277.25A141 141 0 0 1 137 708.763v-281.25a141 141 0 0 1 141-141h43.725l-42.788-42.825a47 47 0 1 1 66.263-66.3l99.45 99.45c2.963 2.962 5.438 6.187 7.425 9.637h120.487c1.988-3.45 4.5-6.75 7.463-9.675l99.413-99.45a47 47 0 0 1 66.3 0zm1.012 203.25h-468.75a47 47 0 0 0-46.763 43.388l-.112 3.525v281.25c0 24.712 19.125 44.962 43.387 46.724l3.488.15h468.75a47 47 0 0 0 46.763-43.387l.112-3.487v-281.25c0-26-21-47-47-46.876zm-375 93.75c26 0 47 21 47 47v47a47 47 0 1 1-93.75 0V521.6c0-26 21-47 47-47zm281.25 0c26 0 47 21 47 47v47a47 47 0 1 1-93.75 0V521.6c0-26 21-47 47-47z"/></svg>',GitHub:'<svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="512" fill="#171515"/><path fill="#fff" d="M509.423 146.442c-200.317 0-362.756 162.42-362.756 362.8 0 160.266 103.936 296.24 248.109 344.217 18.139 3.327 24.76-7.872 24.76-17.486 0-8.613-.313-31.427-.49-61.702-100.912 21.923-122.205-48.63-122.205-48.63-16.495-41.91-40.28-53.067-40.28-53.067-32.937-22.51 2.492-22.053 2.492-22.053 36.407 2.566 55.568 37.386 55.568 37.386 32.362 55.438 84.907 39.43 105.58 30.143 3.296-23.444 12.667-39.43 23.032-48.498-80.557-9.156-165.246-40.28-165.246-179.297 0-39.604 14.135-71.988 37.342-97.348-3.731-9.178-16.18-46.063 3.556-96.009 0 0 30.46-9.754 99.76 37.19 28.937-8.048 59.97-12.071 90.823-12.211 30.807.14 61.843 4.165 90.822 12.21 69.26-46.944 99.663-37.189 99.663-37.189 19.792 49.946 7.34 86.831 3.61 96.01 23.25 25.359 37.29 57.742 37.29 97.347 0 139.366-84.82 170.033-165.637 179.013 13.026 11.2 24.628 33.342 24.628 67.182 0 48.498-.445 87.627-.445 99.521 0 9.702 6.535 20.988 24.945 17.444 144.03-48.067 247.881-183.95 247.881-344.175 0-200.378-162.442-362.798-362.802-362.798z"/></svg>'}}},n=>{n.O(0,[815,7059],(()=>n(n.s=38731))),n.O()}]);