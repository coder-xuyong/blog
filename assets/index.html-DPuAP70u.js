import{_ as t,c as n,b as i,o as a}from"./app-C89rw2WO.js";const r={};function l(p,e){return a(),n("div",null,e[0]||(e[0]=[i('<h1 id="面向对象设计六大原则" tabindex="-1"><a class="header-anchor" href="#面向对象设计六大原则"><span>面向对象设计六大原则</span></a></h1><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h2><p>单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。</p><p>简单点说，<strong>一个类，最好只负责一件事。</strong></p><h2 id="开放-封闭原则" tabindex="-1"><a class="header-anchor" href="#开放-封闭原则"><span>开放-封闭原则</span></a></h2><p>开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。</p><p>对于扩展是开放的；对于更改是封闭的。</p><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h2><p>里氏替换原则（Liskov Substitution Principle），子类可以替换父类。</p><h2 id="依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则"><span>依赖倒置原则</span></a></h2><p>依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p>关键点：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h2><p>接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><ul><li>客户端不应依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul><h2 id="迪米特原则" tabindex="-1"><a class="header-anchor" href="#迪米特原则"><span>迪米特原则</span></a></h2><p>迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener noreferrer">《Head First 设计模式》</a></li><li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener noreferrer">《大话设计模式》</a></li></ul>',21)]))}const s=t(r,[["render",l],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/pages/9703b1/","title":"面向对象原则","lang":"zh-CN","frontmatter":{"title":"面向对象原则","date":"2021-05-19T09:49:05.000Z","order":25,"categories":["设计","设计模式"],"tags":["设计","设计模式"],"permalink":"/pages/9703b1/","description":"面向对象设计六大原则 单一职责原则 单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。 简单点说，一个类，最好只负责一件事。 开放-封闭原则 开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。 对于扩展是开放的；对于更改是封...","head":[["meta",{"property":"og:url","content":"https://coder-xuyong.github.io/blog/pages/9703b1/"}],["meta",{"property":"og:site_name","content":"coder-xuyong"}],["meta",{"property":"og:title","content":"面向对象原则"}],["meta",{"property":"og:description","content":"面向对象设计六大原则 单一职责原则 单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。 简单点说，一个类，最好只负责一件事。 开放-封闭原则 开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。 对于扩展是开放的；对于更改是封..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-06T08:40:02.000Z"}],["meta",{"property":"article:tag","content":"设计"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2021-05-19T09:49:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-06T08:40:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-05-19T09:49:05.000Z\\",\\"dateModified\\":\\"2025-05-06T08:40:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuyong\\",\\"url\\":\\"https://github.com/coder-xuyong\\"}]}"]]},"headers":[{"level":2,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":2,"title":"开放-封闭原则","slug":"开放-封闭原则","link":"#开放-封闭原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"依赖倒置原则","slug":"依赖倒置原则","link":"#依赖倒置原则","children":[]},{"level":2,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[]},{"level":2,"title":"迪米特原则","slug":"迪米特原则","link":"#迪米特原则","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1746520802000,"updatedTime":1746520802000,"contributors":[{"name":"XuYong","username":"XuYong","email":"1299461580@qq.com","commits":1,"url":"https://github.com/XuYong"}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"posts/03.设计/02.设计模式/25.面向对象原则.md","localizedDate":"2021年5月19日","excerpt":"\\n<h2>单一职责原则</h2>\\n<p>单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。</p>\\n<p>简单点说，<strong>一个类，最好只负责一件事。</strong></p>\\n<h2>开放-封闭原则</h2>\\n<p>开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。</p>\\n<p>对于扩展是开放的；对于更改是封闭的。</p>\\n<h2>里氏替换原则</h2>\\n<p>里氏替换原则（Liskov Substitution Principle），子类可以替换父类。</p>","autoDesc":true}');export{s as comp,c as data};
