import{_ as i,c as n,b as a,o as e}from"./app-thRMtbH9.js";const l={};function t(r,s){return e(),n("div",null,s[0]||(s[0]=[a(`<h1 id="设计模式之原型模式" tabindex="-1"><a class="header-anchor" href="#设计模式之原型模式"><span>设计模式之原型模式</span></a></h1><h2 id="意图" tabindex="-1"><a class="header-anchor" href="#意图"><span>意图</span></a></h2><p><strong>原型模式</strong>（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p>原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件：</p><ul><li>实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 CloneNotSupportedException 异常。</li><li>重写 Object 类中的 clone 方法。Java 中，所有类的父类都是 Object 类，Object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，Prototype 类需要将 clone 方法的作用域修改为 public 类型。</li></ul><h3 id="浅拷贝与深拷贝" tabindex="-1"><a class="header-anchor" href="#浅拷贝与深拷贝"><span>浅拷贝与深拷贝</span></a></h3><p>浅拷贝是指当对象的字段值被复制时，字段引用的对象不会被复制。</p><p>例如：如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那麽两个对象将引用同一个字符串。</p><p>深拷贝是指当一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝。</p><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h2><ul><li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li><li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li></ul><h2 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h2><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506094301.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ol><li><strong>原型</strong> （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 <code>clone</code>克隆的方法。</li><li><strong>具体原型</strong> （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</li></ol><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><p>在本例中， <strong>原型</strong>模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210506095002.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 基础原型。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Shape</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field X: int</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field Y: int</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field color: string</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 常规构造函数。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    constructor Shape() is</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    constructor Shape(source: Shape) is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this()</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.X = source.X</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.Y = source.Y</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.color = source.color</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // clone（克隆）操作会返回一个形状子类。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    abstract</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> method clone():Shape</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 成的克隆对象。这可以保持克隆结果的一致。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Rectangle</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Shape</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field width: int</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field height: int</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    constructor </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Rectangle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">(source: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Rectangle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">) is</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        super(source)</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.width = source.width</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.height = source.height</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    method clone():</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Shape</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        return new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Rectangle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">(this)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">class </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> extends </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Shape</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field radius: int</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    constructor </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">(source: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">) is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        super(source)</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        this.radius = source.radius</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    method clone():</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Shape</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        return new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">(this)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 客户端代码中的某个位置。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">class </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Application</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    field shapes: array of </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Shape</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    constructor </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Application</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">() is</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> circle = new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">()</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        circle.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">X</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> = 10</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        circle.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Y</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> = 10</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        circle.radius = 20</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        shapes.add(circle)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Circle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> anotherCircle = circle.clone()</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        shapes.add(anotherCircle)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 变量 \`anotherCircle（另一个圆）\`与 \`circle（圆）\`对象的内</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 容完全一样。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Rectangle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> rectangle = new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Rectangle</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">()</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        rectangle.width = 10</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        rectangle.height = 20</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        shapes.add(rectangle)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">    method businessLogic() is</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 其完全相同的复制品。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Array</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> shapesCopy = new </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Array</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;"> of </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Shapes</span><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 但在多态机制的帮助下，当我们在某个形状上调用 \`clone（克隆）\`</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">        foreach (s in shapes) do</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E06C75;">            shapesCopy.add(s.clone())</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // \`shapesCopy（形状副本）\`数组中包含 \`shape（形状）\`数组所有</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 子元素的复制品。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例"><span>案例</span></a></h2><p><strong>使用示例：</strong> Java 的 <code>Cloneable</code> （可克隆） 接口就是立即可用的原型模式。</p><p>任何类都可通过实现该接口来实现可被克隆的性质。</p><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--" target="_blank" rel="noopener noreferrer"><code>java.lang.Object#clone()</code></a> （类必须实现 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html" target="_blank" rel="noopener noreferrer"><code>java.lang.Cloneable</code></a> 接口）</li></ul><p><strong>识别方法</strong>： 原型可以简单地通过 <code>clone</code>或 <code>copy</code>等方法来识别。</p><h2 id="与其他模式的关系" tabindex="-1"><a class="header-anchor" href="#与其他模式的关系"><span>与其他模式的关系</span></a></h2><ul><li>在许多设计工作的初期都会使用<a href="https://refactoringguru.cn/design-patterns/factory-method" target="_blank" rel="noopener noreferrer">工厂方法模式</a> （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener noreferrer">抽象工厂模式</a>、 <a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型模式</a>或<a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener noreferrer">生成器模式</a> （更灵活但更加复杂）。</li><li><a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener noreferrer">抽象工厂模式</a>通常基于一组<a href="https://refactoringguru.cn/design-patterns/factory-method" target="_blank" rel="noopener noreferrer">工厂方法</a>， 但你也可以使用<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型模式</a>来生成这些类的方法。</li><li><a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型</a>可用于保存<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener noreferrer">命令模式</a>的历史记录。</li><li>大量使用<a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener noreferrer">组合模式</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener noreferrer">装饰模式</a>的设计通常可从对于<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型</a>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li><li><a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型</a>并不基于继承， 因此没有继承的缺点。 另一方面， <em>原型</em>需要对被复制对象进行复杂的初始化。 <a href="https://refactoringguru.cn/design-patterns/factory-method" target="_blank" rel="noopener noreferrer">工厂方法</a>基于继承， 但是它不需要初始化步骤。</li><li>有时候<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型</a>可以作为<a href="https://refactoringguru.cn/design-patterns/memento" target="_blank" rel="noopener noreferrer">备忘录模式</a>的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li><li><a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener noreferrer">抽象工厂</a>、 <a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener noreferrer">生成器</a>和<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener noreferrer">原型</a>都可以用<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener noreferrer">单例模式</a>来实现。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener noreferrer">《Head First 设计模式》</a></li><li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener noreferrer">《大话设计模式》</a></li><li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener noreferrer">设计模式教程</a></li></ul>`,28)]))}const h=i(l,[["render",t],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/pages/1af8ee/","title":"设计模式之原型模式","lang":"zh-CN","frontmatter":{"title":"设计模式之原型模式","date":"2015-06-03T15:00:00.000Z","order":5,"categories":["设计","设计模式"],"tags":["设计","设计模式"],"permalink":"/pages/1af8ee/","description":"设计模式之原型模式 意图 原型模式（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件： 实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用...","head":[["meta",{"property":"og:url","content":"https://coder-xuyong.github.io/blog/pages/1af8ee/"}],["meta",{"property":"og:site_name","content":"coder-xuyong"}],["meta",{"property":"og:title","content":"设计模式之原型模式"}],["meta",{"property":"og:description","content":"设计模式之原型模式 意图 原型模式（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件： 实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dunwu/images/master/snap/20210506094301.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-10T02:14:26.000Z"}],["meta",{"property":"article:tag","content":"设计"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2015-06-03T15:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-10T02:14:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式之原型模式\\",\\"image\\":[\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20210506094301.png\\",\\"https://raw.githubusercontent.com/dunwu/images/master/snap/20210506095002.png\\"],\\"datePublished\\":\\"2015-06-03T15:00:00.000Z\\",\\"dateModified\\":\\"2025-06-10T02:14:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuyong\\",\\"url\\":\\"https://github.com/coder-xuyong\\"}]}"]]},"headers":[{"level":2,"title":"意图","slug":"意图","link":"#意图","children":[{"level":3,"title":"浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","link":"#浅拷贝与深拷贝","children":[]}]},{"level":2,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[]},{"level":2,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":2,"title":"伪代码","slug":"伪代码","link":"#伪代码","children":[]},{"level":2,"title":"案例","slug":"案例","link":"#案例","children":[]},{"level":2,"title":"与其他模式的关系","slug":"与其他模式的关系","link":"#与其他模式的关系","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1746520802000,"updatedTime":1749521666000,"contributors":[{"name":"XuYong","username":"XuYong","email":"1299461580@qq.com","commits":3,"url":"https://github.com/XuYong"}]},"readingTime":{"minutes":5.95,"words":1784},"filePathRelative":"posts/03.design/02.设计模式/05.原型模式.md","localizedDate":"2015年6月3日","excerpt":"\\n<h2>意图</h2>\\n<p><strong>原型模式</strong>（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>\\n<p>原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件：</p>\\n<ul>\\n<li>实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 CloneNotSupportedException 异常。</li>\\n<li>重写 Object 类中的 clone 方法。Java 中，所有类的父类都是 Object 类，Object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，Prototype 类需要将 clone 方法的作用域修改为 public 类型。</li>\\n</ul>","autoDesc":true}');export{h as comp,c as data};
