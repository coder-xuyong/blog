---
title: java 基础知识
icon: pen-to-square
cover: https://webstatic.mihoyo.com/upload/contentweb/2022/06/30/96297a7f2679bf0dce4fb9d11120b882_7601596078607350699.png
date: 2024-12-27
lastUpdated: true
order: 1
category:
  - java
tag:
  - java-basic
---

java 基本类型、String、关键字等内容介绍

<!-- more -->

## 1. Java基本数据类型
### 1.1 数据类型分类
Java基本数据类型分为四类：整数类型、浮点类型、字符类型和布尔类型。

#### 1.1.1 整数类型
 - **byte**：占用 1 个字节（8 位），取值范围是 -128 到 127，常用于处理底层字节流数据、节省内存空间的场景，例如在一些小型嵌入式设备程序中对传感器数据的初步存储。
 - **short**：占 2 个字节（16 位），范围为 -32768 到 32767，在特定的对内存要求稍高但数值范围有限的运算场景使用，如早期一些简单游戏的计分系统。
 - **int**：整型是最常用的，占 4 个字节（32 位），取值范围 -2147483648 到 2147483647，广泛应用于日常编程中的整数运算，像循环计数器、数组下标等。
 - **long**：长整型，占 8 个字节（64 位），范围为 -9223372036854775808 到 9223372036854775807，当需要处理较大整数，比如系统时间戳（以毫秒为单位）、大数据量统计中的计数时会用到，定义长整型字面量时要在数字后加 `L` 或 `l`，建议用 `L` 以避免混淆。

#### 1.1.2 浮点类型
 - 重要提醒：浮点数由于二进制存储机制，存在精度问题，绝对不能直接用于精确的金额计算，金融领域通常采用 `BigDecimal` 类来确保金额的精准。
 - **float**：单精度浮点型，占 4 个字节（32 位），能表示大约 7 位有效数字，常用于科学计算中对精度要求不特别高的近似值场景，定义字面量时需在数字后加 `F` 或 `f`，因为 Java 默认小数是 `double` 型。
 - **double**：双精度浮点型，占 8 个字节（64 位），约有 15 位有效数字，在高精度科学实验数据存储、图形图像渲染等对精度要求较高的场景常用，是 Java 默认的浮点数据类型。

#### 1.1.3 字符类型
 - **char**：字符型，占 2 个字节（16 位），用于存储单个字符，字符在 Java 中用单引号括起来，如 `'A'`、`'9'`、`'$'` 等，本质上存储的是字符对应的 Unicode 编码值，这使得 Java 能够处理世界上大部分的字符。

#### 1.1.4 布尔类型
 - **boolean**：布尔型，占 1 位（实际编译后占用空间因虚拟机实现而异，一般至少 1 字节），只有两个取值 `true` 和 `false`，主要用于条件判断、逻辑控制，是 `if` 语句、`while` 循环等条件表达式的基础。

### 1.2 自动拆装箱机制
#### 1.2.1 装箱（Boxing）
自动将基本数据类型转换为对应的包装类对象。例如，`Integer numObj = 10;`，这里编译器自动把 `int` 值 10 包装成 `Integer` 对象，以便在需要对象的场景（如集合存储）使用。但需要注意，装箱过程会创建新的对象，如果频繁进行装箱操作，会带来一定的性能开销。

#### 1.2.2 拆箱（Unboxing）
与装箱相反，是自动把包装类对象还原为基本数据类型。比如，`Integer numObj = new Integer(20); int num = numObj;`，在赋值时编译器将 `Integer` 对象拆解获取 `int` 值，用于数值运算等操作。同样，过度拆箱也可能影响性能，尤其是在循环等频繁操作场景。

## 2. String类型
### 2.1 常用方法
#### 2.1.1 连接操作
可以使用 `+` 运算符实现字符串连接。例如，`String firstName = "John"; String lastName = "Doe"; String fullName = firstName + " " + lastName;`，不过在编译器内部，对于较长的连接链，会优化为使用 `StringBuilder` 来避免频繁创建新的 `String` 对象，以提高性能。

#### 2.1.2 获取长度
调用 `length()` 方法来获取字符串的长度，这与数组的 `length` 属性有所不同。例如，`String message = "Hello"; int len = message.length();`，通过该方法可以得到字符串中字符的个数。

#### 2.1.3 字符索引访问
使用 `charAt(int index)` 方法按索引获取字符，索引从 0 开始。如 `String word = "Java"; char c = word.charAt(1);`，这里可以取到字符 `a`，需要注意的是，如果索引越界，会抛出 `IndexOutOfBoundsException`。

#### 2.1.4 子串截取
依靠 `substring(int start, int end)` 方法，其中 `start` 索引对应的字符包含在内，`end` 索引对应的字符不包含在内。例如，`String text = "Hello Java"; String sub = text.substring(0, 5);`，可以得到子串 “Hello”。

### 2.2 技巧
#### 2.2.1 字符串比较
要避免使用 `==` 来判断字符串内容是否相等，而应该使用 `equals()` 方法。因为 `==` 比较的是引用地址，而 `equals` 方法在 `String` 类中被重写，能够比较字符序列是否一致。例如，`String s1 = "hello"; String s2 = new String("hello"); s1.equals(s2)` 的结果为 `true`，但 `s1 == s2` 的结果为 `false`。

#### 2.2.3 空字符串判断
可以结合使用 `isEmpty()` 和 `length() == 0` 方法来判断空字符串。`isEmpty()` 方法简洁直观，`length() == 0` 方法通用性强。例如，`String str = ""; str.isEmpty();` 和 `str.length() == 0` 都能确认字符串为空。

### 2.3 字符串池、Class常量池、运行时常量池概念
#### 2.3.1 字符串池
字符串池是堆内存的一部分，它存放 Java 程序中直接使用双引号括起的字符串字面量。当创建相同字面量的字符串时，会直接从池中获取引用，这样可以节省内存。例如，`String s1 = "hello"; String s2 = "hello"; s1 == s2` 的结果为 `true`，因为它们指向的是字符串池中的同一个对象。

#### 2.3.2 Class常量池
位于方法区，是类文件结构的一部分，它存放编译期生成的各种常量，包括字符串常量、基本类型常量等，为类的加载和运行提供基础数据支持。

#### 2.3.3 运行时常量池
是方法区的动态扩展，在类加载后，运行期间可以将新的常量放入其中。它包含从 Class常量池解析来的常量以及通过动态生成的，如 `String.intern()` 处理后的字符串，用于高效访问常量。

### 2.4 intern方法
调用 `intern()` 方法能够将字符串对象添加到字符串池（如果池中没有相同的字符串），并返回池内对应字符串的引用。例如，`String s1 = new String("hello").intern(); String s2 = "hello"; s1 == s2` 的结果为 `true`，这是通过 `intern()` 方法强制实现了字符串实例的共享。

### 2.5 String长度限制
在 Java 中，`String` 理论上长度受限于内存大小，但在实际操作中有一些约束。在编译期，常量字符串的长度受到编译器的限制（通常为几千字节）；在运行时，创建 `String` 对象受到堆内存分配以及虚拟机实现的限制，对于超长字符串的处理需要谨慎规划内存。

## 3. Java关键字
### 3.1 访问控制关键字
#### 3.1.1 public
赋予最宽泛的访问权限，修饰的类、成员可以被任何其他类访问，无论是同包还是跨包，这有助于代码的复用和模块之间的协同工作，促进大型项目的开发。

#### 3.1.2 private
实施最严格的保密措施，修饰的成员（变量、方法）只能在所属类的内部可见，外部类无法直接访问，这是实现类封装的关键，能够有效地保护类的内部实现细节，防止外部的非法篡改。

#### 3.1.3 protected
介于 public 和 private 之间，修饰的成员在同包内的类以及子类中可以访问，这种访问权限搭建了继承的桥梁，既允许子类继承和拓展父类的功能，又适度地隔离了外界对父类的直接访问，维护了类层次结构的稳定性。

#### 3.1.4 default（无显式关键字）
当类、成员没有显式地使用访问控制关键字时，默认采用包访问权限，即同包内的类可以相互访问，这种默认设置有助于维持包内的代码凝聚性，同时对外保持一定的封闭性。

### 3.2 类、接口、抽象相关关键字
#### 3.1.1 class
是定义类的标志性关键字，通过它可以勾勒出对象的蓝图，在类中定义属性和方法，类是 Java 编程世界的基石，承载着程序的主要逻辑和数据结构。

#### 3.1.2 interface
用于绘制规范的蓝图，它规定了一组方法签名以及常量，但不包含具体的实现细节。接口使得不同的类可以遵循相同的规范，实现多态性，在松耦合的模块关联中发挥着重要作用。

#### 3.1.3 abstract
可以用来定义抽象类和抽象方法。抽象类为子类提供了一个框架，它可以包含抽象方法，这些抽象方法需要子类去具体实现，通过这种方式规划了继承体系的发展方向，引导子类按照预定的设计进行拓展。

### 3.3 修饰符关键字
#### 3.3.1 final
具有“最终确定”的含义，当修饰类时，该类不可被继承；修饰方法时，方法不可被重写；修饰变量时，变量成为常量，其值不能再被改变。使用 final 关键字可以保障代码的稳定性，确保数据在特定阶段后保持恒定。

#### 3.3.2 static
赋予成员静态的特性，当 static 修饰变量或方法时，它们归属于类本身，而不是类的某个实例，因此可以直接通过类名进行访问，无需创建实例对象。静态成员常用于工具类、共享资源等场景，需要注意的是，静态方法不能直接访问非静态成员，因为非静态成员依赖于具体的实例。

#### 3.3.3 synchronized
在多线程编程中充当“保镖”的角色，当修饰方法或代码块时，它能够确保在同一时刻只有一个线程能够进入被修饰的区域，从而保护共享资源，防止多个线程并发访问时产生冲突，保证程序的正确性和稳定性。

### 3.4 流程控制关键字
#### 3.4.1 if、else
是最基础的条件分支语句，if 语句用于根据给定的条件判断程序的走向，如果条件成立，则执行相应的代码块；else 语句则在 if 条件不成立时提供备用的执行路径，它们可以灵活组合，应对各种各样复杂的程序逻辑。

#### 3.4.2 switch、case、default
是多分支的快捷方式，switch 语句根据一个表达式的值来选择执行多个分支中的一个，case 用来标记每个可能的分支情况，当表达式的值与某个 case 后的常量匹配时，就执行对应的代码块；如果没有匹配的 case，则执行 default 分支，这种结构在处理定值的多分支情况时非常高效。

#### 3.4.3 while、do - while
都是循环语句，while 循环先判断条件是否成立，成立则执行循环体，然后再次判断条件，如此反复，直到条件不成立；do - while 循环则先执行一次循环体，然后再判断条件，若条件成立则继续循环，它们适用于不同的循环场景，根据具体需求选择使用。

#### 3.4.4 for
是一种功能强大的万能循环语句，它将循环的初始化、条件判断、循环体执行以及迭代操作集成在一起，在遍历数组、集合等数据结构以及进行简单的计数循环时都非常方便，能够大大提高编程效率。

### 3.5 异常处理关键字
#### 3.5.1 try、catch、finally
构成了异常处理的铁三角，try 语句块用于包围可能出现异常的代码；catch 语句块紧跟其后，用于捕获并处理特定类型的异常，多个 catch 块可以针对不同类型的异常进行分类处理；finally 语句块无论是否发生异常，都会被执行，它通常用于保证资源的释放和清理工作，确保程序的稳健性。

#### 3.5.2 throw
用于手动抛出异常，当程序在运行过程中遇到某些不符合预期的情况时，可以使用 throw 语句抛出一个异常对象，将错误信息传递给调用者，促使调用者采取相应的措施来处理问题。

#### 3.5.2 throws
是在方法声明中使用的关键字，用于声明该方法可能抛出的异常类型，这样做可以提醒调用者在调用该方法时需要注意防范相应的异常，实现异常处理的协同。

### 3.6 其他重要关键字
#### 3.6.1 this
在类内部充当“自我指代”的角色，用于区分同名的成员变量和局部变量，还可以在构造函数中调用其他构造函数，实现构造函数的复用，它聚焦于当前对象的操作，使代码更加清晰。

#### 3.6.2 super
在子类中用于“追溯祖先”，可以访问父类的成员变量和方法，还可以调用父类的构造函数，这对于维护继承体系的正统性非常重要，确保子类在拓展功能的同时，不会丢失父类的核心特性。

#### 3.6.3 new
是创建对象的“魔法棒”，使用 new 关键字可以在堆内存中开辟空间，调用对象的构造函数进行初始化，赋予对象生命，使其能够参与到程序的运行中。

#### 3.6.4 null
代表空引用，它在 Java 中是一个特殊的值，就像一把双刃剑，如果使用不当，很容易引发空指针异常，所以在编程过程中，对于可能为 null 的引用要格外小心，谨慎处理。

